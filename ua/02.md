# Філософія PowerShell.
## Частина 2: Конвеєр (Pipeline), змінні, Get-Member, файл *.ps1* та експорт результатів
**❗ Важливо:**
Я пишу про PS7 (PowerShell 7). Він відрізняється від PS5 (PowerShell 5). Починаючи з сьомої версії, PS став кросплатформним. Через це
змінилася поведінка деяких команд.

У першій частині ми встановили ключовий принцип: PowerShell працює з **об'єктами**, а не з текстом.
Цей пост присвячений деяким важливим інструментам PowerShell:
навчимося передавати об'єкти по **конвеєру**, аналізувати їх за допомогою **`Get-Member`**,
зберігати результати у **змінні** та автоматизувати все це у **файлах скриптів (`.ps1`)** з **експортом**
результатів у зручні формати.

### 1. Що таке конвеєр (`|`)?
Конвеєр у PowerShell — це механізм передачі повноцінних .NET об'єктів (а не просто тексту) від однієї команди
до іншої, де кожен наступний командлет отримує структуровані об'єкти з усіма їхніми властивостями та методами.

Символ `|` (вертикальна риска) — це оператор конвеєра. Його завдання — взяти результат (вивід) команди, що стоїть ліворуч від нього, і передати його на вхід команді, що стоїть праворуч.

`Команда 1 (створює об'єкти)` → `|` → `Команда 2 (отримує та обробляє об'єкти)` → `|` → `Команда 3 (отримує оброблені об'єкти)` → | ...

#### Класичний UNIX-конвеєр: Потік тексту

У `bash` по конвеєру передається **потік байтів**, який зазвичай інтерпретується як текст.

```bash
# Знайти всі процеси 'nginx' та порахувати їх кількість
ps -ef | grep 'nginx' | wc -l
```
Тут `ps` виводить текст, `grep` фільтрує цей текст, а `wc` рахує рядки. Кожна утиліта нічого не знає про "процеси", вона працює тільки з рядками.

#### PowerShell-конвеєр: Потік об'єктів
**Приклад:** Давайте отримаємо всі процеси, відсортуємо їх за використанням CPU та виберемо 5 найбільш "ненажерливих".

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
!(assets/02/1.png)

Тут `Get-Process` створює **об'єкти** процесів. `Sort-Object` отримує ці **об'єкти** та сортує їх за властивістю `CPU`. `Select-Object` отримує відсортовані **об'єкти** та вибирає перші 5.

Ви напевно помітили в команді слова, що починаються з дефіса (-): -Property, -Descending, -First. Це параметри.
Параметри — це налаштування, перемикачі та інструкції для командлета. Вони дозволяють керувати тим, **ЯК** команда виконуватиме свою роботу.
Без параметрів команда працює в режимі за замовчуванням, а з параметрами ви даєте їй конкретні вказівки.

Основні типи параметрів:

- Параметр зі значенням: вимагає додаткової інформації.

    `-Property CPU`: Ми говоримо Sort-Object, за якою властивістю сортувати. CPU — це значення параметра.

    `-First 5`: Ми говоримо Select-Object, скільки об'єктів вибрати. 5 — це значення параметра.

- Параметр-перемикач (прапор): Не вимагає значення. Сама його наявність у команді вмикає або вимикає певну поведінку.

   `-Descending`: Цей прапор говорить Sort-Object змінити порядок сортування на зворотний (від більшого до меншого). Йому не потрібне додаткове значення — він сам по собі інструкція.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
!(assets/02/2.png)
Ця команда відповідає на дуже просте питання:
**"Скільки саме процесів з ім'ям `svchost.exe` зараз запущено в моїй системі?"**

#### Розбір по кроках

##### **Крок 1: `Get-Process -Name 'svchost'`**

Ця частина команди звертається до операційної системи та просить знайти **всі без винятку** запущені процеси, у яких ім'я виконуваного файлу — `svchost.exe`.
На відміну від процесів типу `notepad` (яких зазвичай один або два), процесів `svchost` у системі завжди **багато**. Команда поверне **масив (колекцію) об'єктів**,
де кожен об'єкт — це окремий, повноцінний процес `svchost` зі своїм унікальним ID, використанням пам'яті тощо.
PowerShell знайшов у системі, наприклад, 90 процесів `svchost` і тепер тримає в руках колекцію з 90 об'єктів.

##### **Крок 2: `|` (Оператор конвеєра)**

Цей символ бере колекцію з 90 об'єктів `svchost`, отриману на першому кроці, і починає передавати їх **по одному** на вхід наступній команді.

##### **Крок 3: `Measure-Object`**

Оскільки ми викликали `Measure-Object` без параметрів (таких як `-Property`, `-Sum` тощо), він виконує свою операцію **за замовчуванням** — просто рахує кількість "предметів", які йому передали.
Раз, два, три ... Після того, як усі об'єкти пораховані, `Measure-Object` створює **свій власний об'єкт-результат**, у якому є властивість `Count`, що дорівнює підсумковому числу.

**`Count: 90`** — це і є відповідь на наше питання. Запущено 90 процесів `svchost`.
Решта полів порожні, тому що ми не просили `Measure-Object` виконувати складніші обчислення.

#### Приклад з `svchost` та параметрами

Давайте змінимо наше завдання. Тепер ми хочемо не просто порахувати процеси `svchost`,
а дізнатися, **скільки всього оперативної пам'яті (у мегабайтах) вони споживають разом**.

Для цього нам знадобляться параметри:
*   `-Property WorkingSet64`: Ця інструкція говорить `Measure-Object`: "З кожного об'єкта `svchost`, який до тебе прийде, візьми числове значення з властивості `WorkingSet64` (це використання пам'яті в байтах)".
*   `-Sum`: Ця інструкція-прапор говорить: "Додай усі ці значення, які ти взяв з властивості `WorkingSet64`".

Наша нова команда виглядатиме так:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
!(assets/02/3.png)

1.  `Get-Process` знайде кількість об'єктів `svchost`.
2.  Конвеєр `|` передасть їх у `Measure-Object`.
3.  Але тепер `Measure-Object` працює по-новому:
    *   Він бере перший об'єкт `svchost`, дивиться його властивість `.WorkingSet64` (наприклад, `25000000` байт) і запам'ятовує це число.
    *   Бере другий об'єкт, дивиться його `.WorkingSet64` (наприклад, `15000000` байт) і додає до попереднього.
    *   ...і так далі для всіх об'єктів.
4.  У підсумку `Measure-Object` створить об'єкт-результат, але тепер він буде іншим.

*   **`Count: 92`**: Кількість об'єктів.
*   **`Sum: 1661890560`**: Це загальна сума всіх значень `WorkingSet64` у байтах.
*   **`Property: WorkingSet64`**: Це поле тепер теж заповнене, воно інформує нас, яка саме властивість була використана для обчислень.

### 2. Змінні (Звичайні та спеціальна `$_`)

Змінна — це іменоване сховище в пам'яті, яке містить якесь значення.

Цим значенням може бути що завгодно: текст, число, дата або, що найважливіше для PowerShell,
цілий об'єкт або навіть колекція об'єктів. Ім'я змінної в PowerShell завжди починається зі знака долара ($).
Приклади: $name, $counter, $processList.

Спеціальна змінна $_?

$_ — це скорочення для "поточний об'єкт" або "ось ця штука".
Уявіть собі конвеєр на заводі. По ньому їдуть різні деталі (об'єкти).

$_ — це та сама деталь, яка знаходиться прямо зараз перед вами (або перед роботом-обробником).

Джерело (Get-Process) — висипає на конвеєр цілу коробку з деталями (усіма процесами).

Конвеєр (|) — змушує ці деталі рухатися по стрічці по одній.

Обробник (Where-Object або ForEach-Object) — це робот, який дивиться на кожну деталь.

Змінна $_ — це та сама деталь, яка зараз знаходиться в "руках" у робота.

Коли робот закінчить з однією деталлю, конвеєр подає йому наступну, і $_ тепер вказуватиме вже на неї.

Давайте порахуємо, скільки всього пам'яті використовують процеси `svchost`, і виведемо результат на монітор.
```powershell
# 1. Виконуємо команду та зберігаємо її складний об'єкт-результат у змінну $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Тепер ми можемо працювати зі збереженим об'єктом. Дістаємо з нього властивість Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Виводимо результат на екран, використовуючи нову змінну
Write-Host "Усі процеси svchost використовують $memoryInMB МБ пам'яті."
```
!(assets/02/4.png)

*   `Write-Host` — це спеціалізований командлет, чиє єдине завдання — **показати текст безпосередньо користувачеві в консолі**.

*   Рядок у подвійних лапках: `"..."` - текстовий рядок, який ми передаємо командлету `Write-Host` як аргумент. Чому подвійні, а не одинарні лапки?

    У PowerShell є два типи лапок:

    *   **Одинарні (`'...'`):** Створюють **буквальний рядок**. Усе, що всередині них, сприймається як звичайний текст, без винятків.
    *   **Подвійні (`"..."`):** Створюють **розширюваний (або підстановочний) рядок**. PowerShell "сканує" такий рядок на предмет змінних (що починаються з `$`) і підставляє на їхнє місце їхні значення.

* `$memoryInMB`. Це змінна, в яку ми **на попередньому кроці** нашого скрипта поклали результат обчислень. Коли `Write-Host` отримує рядок у подвійних лапках,
відбувається процес, що називається **"підстановка змінних" (String Expansion)**:
    1.  PowerShell бачить текст `"Усі процеси svchost використовують "`.
    2.  Потім він натрапляє на конструкцію `$memoryInMB`. Він розуміє, що це не просто текст, а змінна.
    3.  Він заглядає в пам'ять, знаходить значення, що зберігається в `$memoryInMB` (наприклад, `1585.52`).
    4.  Він **підставляє це значення** прямо в рядок.
    5.  Потім він додає решту тексту: `" МБ пам'яті."`.
    6.  У підсумку, в `Write-Host` передається вже готовий, зібраний рядок: `"Усі процеси svchost використовують 1585.52 МБ пам'яті."`.

Запустіть блокнот:
 1. Знаходимо процес Блокнота та зберігаємо його у змінну $notepadProcess
 ```powershell
$notepadProcess = Get-Process -Name notepad
```

 2. Звертаємося до властивості 'Id' цього об'єкта через крапку та виводимо його
 ```powershell
Write-Host "ID процесу 'Блокнот' дорівнює: $($notepadProcess.Id)"
```
!(assets/02/5.png)

**❗ Важливо:**
    Write-Host "ламає" конвеєр. Текст, виведений ним, не можна передати далі по конвеєру для обробки. Він призначений тільки для відображення.

### 3. Get-Member (Інспектор об'єктів)

Ми знаємо, що по конвеєру "течуть" об'єкти. Але як дізнатися, з чого вони складаються? Які у них є властивості та які дії (методи) з ними можна здійснювати?

Командлет **`Get-Member`** (псевдонім: `gm`) — головний інструмент для дослідження.
Перш ніж працювати з об'єктом, пропустіть його через `Get-Member`, щоб побачити всі його можливості.

Давайте проаналізуємо об'єкти, які створює `Get-Process`:
```powershell
Get-Process | Get-Member
```
!(assets/02/6.png)

*Розберемо кожну частину виводу Get-Member.*

`TypeName: System.Diagnostics.Process` - Це повне, офіційне "ім'я типу" об'єкта з бібліотеки .NET. Це його "паспорт".
Цей рядок говорить вам, що всі об'єкти, які повертає Get-Process, є об'єктами типу System.Diagnostics.Process.
Це гарантує, що у них у всіх буде однаковий набір властивостей та методів.
Ви можете [загуглити](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process", щоб знайти офіційну документацію Microsoft з ще більш детальною інформацією.

- Колонка 1: `Name`

Це просте, людиночитабельне **ім'я** властивості, методу або іншого "члена" об'єкта. Саме це ім'я ви будете використовувати у своєму коді для доступу до даних або виконання дій.

- Колонка 2: `MemberType` (Тип об'єкта)

Це найважливіша для розуміння колонка. Вона класифікує, **чим є** кожен об'єкт. Це його "посада", яка говорить вам, **ЯК** його використовувати.

*   **`Property` (Властивість):** **характеристика** або **порція даних**, що зберігається всередині об'єкта. Ви можете "прочитати" її значення.
    *   *Приклади на скріншоті:* `BasePriority`, `HandleCount`, `ExitCode`. Це просто дані, які можна подивитися.

*   **`Method` (Метод):** **ДІЯ**, яку можна здійснити з об'єктом. Методи завжди викликаються з круглими дужками `()`.
    *   *Приклади на скріншоті:* `Kill`, `Refresh`, `WaitForExit`. Ви б написали `$process.Kill()` або `$process.Refresh()`.

*   **`AliasProperty` (Псевдонім властивості):** **дружній псевдонім** для іншої, довшої властивості. PowerShell додає їх для зручності та стислості.
    *   *Приклади на скріншоті:* `WS` — це короткий псевдонім для `WorkingSet64`. `Name` — для `ProcessName`. `VM` — для `VirtualMemorySize64`.

*   **`Event` (Подія):** **ПОВІДОМЛЕННЯ** про те, що щось сталося, на яке можна "підписатися".
    *   *Приклад на скріншоті:* `Exited`. Ваш скрипт може "слухати" цю подію, щоб виконати якусь дію відразу після того, як процес завершиться.

*   **`CodeProperty` та `NoteProperty`:** спеціальні типи властивостей, часто додані самим PowerShell для зручності. `CodeProperty` обчислює своє значення "на льоту", а `NoteProperty` — це проста властивість-примітка, додана до об'єкта.

- Колонка 3: `Definition` (Визначення)

Це **технічне визначення** або "підпис" члена. Вона дає вам точні деталі для його використання. Її вміст залежить від `MemberType`:

*   **Для `AliasProperty`:** Показує, **чому дорівнює псевдонім**. Це неймовірно корисно!
    *   *Приклад на скріншоті:* `WS = WorkingSet64`. Ви відразу бачите, що `WS` — це просто короткий запис для `WorkingSet64`.

*   **Для `Property`:** Показує **тип даних**, який зберігається у властивості (наприклад, `int` для цілого числа, `string` для тексту, `datetime` для дати та часу), і що можна з ним робити (`{get;}` — тільки читати, `{get;set;}` — читати та змінювати).
    *   *Приклад на скріншоті:* `int BasePriority {get;}`. Це цілочисельна властивість, яку можна тільки прочитати.

*   **Для `Method`:** Показує, що метод повертає (наприклад, `void` — нічого, `bool` — true/false) і які **параметри** (вхідні дані) він приймає в дужках.
    *   *Приклад на скріншоті:* `void Kill()`. Це означає, що метод `Kill` нічого не повертає і може бути викликаний без параметрів. Також є друга версія `void Kill(bool entireProcessTree)`, яка приймає логічне значення (true/false).

#### У вигляді таблиці

| Колонка      | Що це?                             | Приклад зі скріншота                  | Для чого?                                                                   |
|--------------|--------------------------------------|--------------------------------------------|-----------------------------------------------------------------------------------------|
| **Name**     | Ім'я, яке ви використовуєте в коді.  | `Kill`, `WS`, `Name`                       | звернутися до властивості або методу (`$process.WS`, `$process.Kill()`).    |
| **MemberType**| Тип члена (дані, дія тощо). | `Method`, `Property`, `AliasProperty`      | **як** його використовувати (читати значення або викликати з `()`).              |
| **Definition** | Технічні деталі.                  | `WS = WorkingSet64`, `void Kill()`           | що приховується за псевдонімом і які параметри потрібні методу.                |

#### Приклад: Робота з вікнами процесів

##### 1. Проблема:
"Я відкрив багато вікон Блокнота. Як мені програмно згорнути всі, крім головного, а потім закрити тільки те, у якого в заголовку є слово 'Untitled'?"

##### 2. Дослідження з `Get-Member`:
Нам потрібно знайти властивості, пов'язані з вікном та його заголовком.

```powershell
Get-Process -Name notepad | Get-Member
```
**Аналіз результату `Get-Member`:**
*   Гортаючи властивості, ми знаходимо `MainWindowTitle`. Тип `string`. Чудово, це заголовок головного вікна!
*   У методах ми бачимо `CloseMainWindow()`. Це більш "м'який" спосіб закрити вікно, ніж `Kill()`.
*   Також у методах є `WaitForInputIdle()`. Звучить цікаво, можливо, це допоможе дочекатися, поки процес буде готовий до взаємодії.

!(assets/02/7.png)

`Get-Member` показав нам властивість `MainWindowTitle`, яка є ключем до вирішення завдання та дозволяє взаємодіяти з процесами на основі стану їхніх вікон, а не просто за ім'ям.

##### 3. Рішення:
Тепер ми можемо побудувати логіку, засновану на заголовку вікна.

```powershell
# 1. Знаходимо всі процеси Блокнота
$notepads = Get-Process -Name notepad

# 2. Проходимося по кожному та перевіряємо заголовок
foreach ($pad in $notepads) {
    # Для кожного процесу ($pad) перевіряємо його властивість MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Знайдено незбережений Блокнот (ID: $($pad.Id)). Закриваємо його вікно..."
        # $pad.CloseMainWindow() # Розкоментуйте, щоб дійсно закрити
        Write-Host "Вікно '$($pad.MainWindowTitle)' було б закрито." -ForegroundColor Yellow
    } else {
        Write-Host "Пропускаємо Блокнот із заголовком: $($pad.MainWindowTitle)"
    }
}
```

!(assets/02/8.png)

!(assets/02/9.png)

---

#### Приклад: Знайти батьківський процес

##### 1. Проблема:
"Іноді я бачу в системі багато дочірніх процесів `chrome.exe`. Як мені дізнатися, який з них є головним, "батьківським" процесом, який їх усіх запустив?"

##### 2. Дослідження з `Get-Member`:
Нам потрібно знайти щось, що пов'язує один процес з іншим.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
!(assets/02/10.png)

**Аналіз результату `Get-Member`:**
*   Уважно переглядаючи список, ми знаходимо властивість типу `CodeProperty` з ім'ям `Parent`.
*   Його визначення (`Definition`) — `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
Це обчислювана властивість, яка при зверненні до неї повертає **об'єкт батьківського процесу**.

##### 3. Рішення:
Тепер ми можемо написати скрипт, який для кожного процесу `chrome` виводитиме інформацію про його батька.

```powershell
# 1. Отримуємо всі процеси chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Для кожного з них виводимо інформацію про нього та його батька
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Отримуємо батьківський процес
    $parent = $_.Parent

    # Формуємо красивий вивід
    Write-Host "Процес:" -ForegroundColor Green
    Write-Host "  - Ім'я: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Його батько:" -ForegroundColor Yellow
    Write-Host "  - Ім'я: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
```
!(assets/02/11.png)

!(assets/02/12.png)

Ми відразу бачимо, що процеси з ID 4756, 7936, 8268 та 9752 були запущені процесом з ID 14908. Також можна помітити цікавий випадок з процесом ID: 7252, у якого батьківський процес не визначився (можливо, батько вже встиг завершитися до моменту перевірки). Модифікація скрипта з перевіркою if ($parent) акуратно обробляє цей випадок, не викликаючи помилки.
Get-Member допоміг нам виявити "приховану" властивість Parent, яка надає потужні можливості для аналізу ієрархії процесів.

#### 4. Файл *.ps1* (Створення скриптів)

Коли ваш ланцюжок команд стає корисним, ви захочете зберегти його для багаторазового використання. Для цього і потрібні **скрипти** — текстові файли з розширенням **`.ps1`**.

##### Дозвіл на запуск скриптів
За замовчуванням у Windows заборонено запуск локальних скриптів. Щоб це виправити **для поточного користувача**, виконайте один раз у PowerShell **від імені адміністратора**:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
Це безпечне налаштування, яке дозволяє запускати ваші власні скрипти та скрипти, підписані довіреним видавцем.

##### Приклад скрипта `system_monitor.ps1`
Створіть файл з таким ім'ям і вставте в нього код нижче. Цей скрипт збирає інформацію про систему та генерує звіти.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Скрипт для створення звіту про стан системи.
.DESCRIPTION
    Збирає інформацію про процеси, служби та дисковий простір і генерує звіти.
.PARAMETER OutputPath
    Шлях для збереження звітів. За замовчуванням 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Блок 1: Підготовка ---
Write-Host "Підготовка до створення звіту..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Блок 2: Збір даних ---
Write-Host "Збір інформації..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Блок 3: Виклик функції для експорту (див. наступний розділ) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Звіти успішно збережено в папці $OutputPath" -ForegroundColor Magenta
```
*Примітка: функція `Export-Results` буде визначена в наступному розділі як приклад хорошої практики.*

#### 5. Експорт результатів

Чисті дані — це добре, але часто їх потрібно представити у зручному для людини або іншої програми вигляді. PowerShell пропонує безліч командлетів для експорту.

| Метод                               | Команда                                            | Опис                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Простий текст**                   | `... \| Out-File C:\Temp\data.txt`                 | Перенаправляє текстове представлення у файл.                                      |
| **CSV (для Excel)**                 | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | Експортує об'єкти в CSV. `-NoTypeInfo` прибирає службовий перший рядок.     |
| **HTML-звіт**                      | `... \| ConvertTo-Html -Title "Звіт"`             | Створює HTML-код з об'єктів.                                                       |
| **JSON (для API, веб)**             | `... \| ConvertTo-Json`                            | Перетворює об'єкти у формат JSON.                                                  |
| **XML (рідний формат PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml`            | Зберігає об'єкти з усіма типами даних. Їх можна ідеально відновити через `Import-Clixml`. |

##### Доповнення до скрипта: функція експорту
Давайте додамо в наш скрипт `system_monitor.ps1` функцію, яка займатиметься експортом. Помістіть цей код **перед** викликом `Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Експорт у CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Створення красивого HTML-звіту
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Топ-10 процесів за CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Статистика служб</h2>"

    ConvertTo-Html -Head "<title>Звіт про систему</title>" -Body "<h1>Звіт про систему від $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
Тепер наш скрипт не просто збирає дані, а й акуратно зберігає їх у двох форматах: CSV для аналізу та HTML для швидкого перегляду.

#### Висновок

1.  **Конвеєр (`|`)** — головний інструмент для об'єднання команд та обробки об'єктів.
2.  **`Get-Member`** — аналіз об'єктів, який показує, з чого вони складаються.
3.  **Змінні (`$var`, `$_`)** дозволяють зберігати дані та звертатися до поточного об'єкта в конвеєрі.
4.  **Файли `.ps1`** перетворюють команди на інструменти автоматизації, що можуть бути використані повторно.
5.  **Командлети експорту** (`Export-Csv`, `ConvertTo-Html`) Експортують дані у відповідному форматі.

**У наступній частині ми застосуємо ці знання для навігації та керування файловою системою, досліджуючи об'єкти `System.IO.DirectoryInfo` та `System.IO.FileInfo`.**