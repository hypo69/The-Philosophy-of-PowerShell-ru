# Філософія PowerShell.

### **Частина 3: Навігація та керування файловою системою. Оператори логіки. Вступ до функцій.**

У [попередній частині](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md) ми досліджували конвеєри та абстрактні об'єкти процесів.
Тепер давайте застосуємо наші знання про конвеєр та об'єкти до одного з частих завдань користувача або адміністратора — роботи з файловою системою.
У PowerShell ця робота побудована на тих самих принципах: команди повертають об'єкти, які можна передавати конвеєром для подальшої обробки.

***

### **1. Концепція PowerShell Drives (PSDrives)**

Перш ніж почати працювати з файлами, важливо зрозуміти концепцію **PowerShell-дисків (PSDrives)**. На відміну від `cmd.exe`, де диски — це лише літери `C:`, `D:` і так далі, у PowerShell "диск" — це абстракція для доступу до будь-якого ієрархічного сховища даних.

```powershell
Get-PSDrive
```
Результат покаже не тільки фізичні диски, а й псевдо-диски:

| Name | Provider | Root | Опис |
|------|----------|------|----------|
| Alias | Alias | Alias:\ | Псевдоніми команд |
| C | FileSystem | C:\ | Локальний диск C |
| Cert | Certificate | Cert:\ | Сховище сертифікатів |
| Env | Environment | Env:\ | Змінні середовища |
| Function | Function | Function:\ | Завантажені функції |
| HKCU | Registry | HKEY_CURRENT_USER | Гілка реєстру |
| HKLM | Registry | HKEY_LOCAL_MACHINE | Гілка реєстру |
| Variable | Variable | Variable:\ | Змінні сесії |
| WSMan | WSMan | WSMan:\ | Конфігурація WinRM |

Ця уніфікація означає, що ви можете "зайти" в реєстр (`Set-Location HKLM:`) і отримати список його ключів тією ж командою `Get-ChildItem`, якою отримуєте список файлів на диску C:. Це неймовірно потужна концепція.

#### **Приклади роботи з різними провайдерами**

*   **Сховище сертифікатів (Cert:)**
    Дозволяє працювати з цифровими сертифікатами так, ніби це файли в папках.

    **Завдання:** Знайти всі SSL-сертифікати на локальній машині, термін дії яких закінчується протягом найближчих 30 днів.
    ```powershell
    # Переходимо до сховища сертифікатів локального комп'ютера
    Set-Location Cert:\LocalMachine\My

    # Знаходимо сертифікати, де дата закінчення менша, ніж сьогодні + 30 днів
    Get-ChildItem | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) } | Select-Object Subject, NotAfter, Thumbprint
    ```

*   **Змінні середовища (Env:)**
    Надає доступ до змінних середовища Windows (`%PATH%`, `%windir%` тощо) як до файлів.

    **Завдання:** Отримати шлях до системної папки Windows і додати до нього шлях до `System32`.
    ```powershell
    # Отримуємо значення змінної windir
    $windowsPath = (Get-Item Env:windir).Value
    # Або простіше: $windowsPath = $env:windir

    # Безпечно збираємо повний шлях
    $system32Path = Join-Path -Path $windowsPath -ChildPath "System32"
    Write-Host $system32Path
    # Результат: C:\WINDOWS\System32
    ```

*   **Реєстр Windows (HKCU: та HKLM:)**
    Уявіть, що реєстр — це просто ще одна файлова система. Гілки — це папки, а параметри — властивості цих папок.

    **Завдання:** Дізнатися повну назву встановленої версії Windows з реєстру.
    ```powershell
    # Переходимо до потрібної гілки реєстру
    Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

    # Отримуємо властивість (параметр реєстру) з ім'ям "ProductName"
    Get-ItemProperty -Path . -Name "ProductName"
    # Результат: ProductName : Windows 11 Pro
    ```

*   **Завантажені функції (Function:)**
    Показує всі функції, доступні в поточній сесії PowerShell, ніби це були файли.

    **Завдання:** Знайти всі завантажені функції, у назві яких є слово "Help", і подивитися код однієї з них.
    ```powershell
    # Шукаємо функції за маскою
    Get-ChildItem Function: | Where-Object { $_.Name -like "*Help*" }

    # Отримуємо повний код (визначення) функції Get-Help
    (Get-Item Function:Get-Help).Definition
    ```

*   **Змінні сесії (Variable:)**
    Дозволяє керувати всіма змінними (`$myVar`, `$PROFILE`, `$Error` тощо), визначеними в поточній сесії.

    **Завдання:** Знайти всі змінні, пов'язані з версією PowerShell (`$PSVersionTable`, `$PSHOME` та ін.).
    ```powershell
    # Знаходимо всі змінні, що починаються з "PS"
    Get-ChildItem Variable:PS*

    # Отримуємо значення конкретної змінної
    Get-Variable -Name "PSVersionTable"
    ```
---

### 2. **Навігація та аналіз**

#### **Основи навігації**

```powershell
# Дізнатися, де ми знаходимося (повертає об'єкт PathInfo)
Get-Location          # Псевдоніми: gl, pwd

# Перехід до кореня диска C:
Set-Location C:\      # Псевдоніми: sl, cd

# Перехід до домашньої папки поточного користувача
Set-Location ~

# Показати вміст поточної папки (повертає колекцію об'єктів)
Get-ChildItem         # Псевдоніми: gci, ls, dir
```

```powershell
# **Рекурсивний пошук**
# Знайти файл hosts у системі, ігноруючи помилки "Доступ заборонено"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
```
**Ключ `-Recurse` (Рекурсивно):** Змушує командлет працювати не тільки з вказаним елементом, а й з усім його вмістом.

**Ключ `-ErrorAction SilentlyContinue`:** Інструкція ігнорувати помилки та продовжувати роботу мовчки.

##### **Аналіз дискового простору**
Класичний приклад потужності конвеєра: знайти, відсортувати, відформатувати та вибрати.
```powershell
Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue |
    Sort-Object Length -Descending |
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} |
    Select-Object -First 20
```

###### **Підказка як вводити довгі команди.**
> PowerShell дозволяє розбивати їх на кілька рядків для зручності читання.
> 
> *   **Після оператора конвеєра (`|`):** Це найчастіший і найзручніший спосіб. Просто натисніть `Enter` після символу `|`. PowerShell побачить, що команда не завершена, і чекатиме продовження на наступному рядку.
> *   **У будь-якому іншому місці:** Використовуйте символ зворотного апострофа (backtick) `` ` `` בסוף השורה, а потім натисніть `Enter`. Цей символ говорить PowerShell: "Команда продовжиться на наступному рядку".
> *   **У редакторах (ISE, VS Code):** Поєднання клавіш `Shift+Enter` зазвичай автоматично вставляє перенесення рядка, не запускаючи команду.

#### **Фільтрація вмісту та оператори логіки**

```powershell
# Знайти всі .exe файли. Параметр -Filter працює дуже швидко.
Get-ChildItem C:\Windows | Where-Object { $_.Extension -eq ".exe" }
```

`Get-ChildItem` повертає колекцію об'єктів. Ми можемо передати її конвеєром до `Where-Object` для подальшої фільтрації.

```powershell
# Показати тільки файли
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
```
Ця команда знайомить нас з одним із фундаментальних понять у скриптах PowerShell: **операторами порівняння**.

#### **Оператори порівняння та логіки**

Це спеціальні ключі для порівняння значень. Вони завжди починаються з дефіса (`-`) і є основою для фільтрації даних у `Where-Object` та побудови логіки в `if`.

| Оператор | Опис | Приклад у конвеєрі |
| :--- | :--- | :--- |
| `-eq` | Дорівнює (EQual) | `$_.Name -eq "svchost.exe"` |
| `-ne` | Не дорівнює (Not Equal) | `$_.Status -ne "Running"` |
| `-gt` | Більше ніж (Greater Than) | `$_.Length -gt 1MB` |
| `-ge` | Більше або дорівнює (Greater or Equal) | `$_.Handles -ge 500` |
| `-lt` | Менше ніж (Less Than) | `$_.LastWriteTime -lt (Get-Date).AddDays(-30)`|
| `-le` | Менше або дорівнює (Less or Equal) | `$_.Count -le 1` |
| `-like` | Схоже на (з підстановочними знаками `*`, `?`)| `$_.Name -like "win*"` |
| `-notlike`| Не схоже на | `$_.Name -notlike "*.tmp"` |
| `-in` | Значення міститься в колекції | `$_.Extension -in ".log", ".txt"` |
| `-and` | Логічне І (обидві умови істинні) | |
| `-or` | Логічне АБО (хоча б одна умова істинна) | |
| `-not` | Логічне НЕ (інвертує умову) | |

Тема операторів логіки - дуже обширна і я їй присвячу окрему частину (або навіть дві). А поки озброївшись цими операторами,
ми можемо **фільтрувати, сортувати та вибирати потрібні нам файли та папки**, використовуючи всю міць об'єктного конвеєра.

#### **Приклади використання у файловій системі**

**Знайти файл за точним ім'ям (з урахуванням регістру):**
```powershell
Get-ChildItem C:\Windows\System32 -Recurse | Where-Object { $_.Name -eq "kernel32.dll" }
```

**Знайти всі файли, що починаються з "host", але не є папками:**
```powershell
Get-ChildItem C:\Windows\System32\drivers\etc | Where-Object { ($_.Name -like "host*") -and (-not $_.PSIsContainer) }
```

**Знайти всі файли журналів (.log), розмір яких перевищує 50 мегабайт:**
```powershell
Get-ChildItem C:\Windows\Logs -Filter "*.log" -Recurse | Where-Object { $_.Length -gt 50MB }
```

**Знайти всі тимчасові файли (.tmp) та файли резервних копій (.bak) для очищення:**
Оператор `-in` тут набагато елегантніший, ніж кілька умов з `-or`.
```powershell
$extensionsToDelete = ".tmp", ".bak", ".old"
Get-ChildItem C:\Temp -Recurse | Where-Object { $_.Extension -in $extensionsToDelete }
```

**Знайти всі файли Word (.docx), створені за останній тиждень:**
```powershell
$oneWeekAgo = (Get-Date).AddDays(-7)
Get-ChildItem C:\Users\MyUser\Documents -Filter "*.docx" -Recurse | Where-Object { $_.CreationTime -ge $oneWeekAgo }
```

**Знайти порожні файли (розміром 0 байт), які не є папками:**
```powershell
Get-ChildItem C:\Downloads -Recurse | Where-Object { ($_.Length -eq 0) -and (-not $_.PSIsContainer) }
```

**Знайти всі виконувані файли (.exe), які були змінені цього року, але НЕ цього місяця:**
Цей складний приклад демонструє міць комбінування операторів.
```powershell
Get-ChildItem "C:\Program Files" -Filter "*.exe" -Recurse | Where-Object {
    ($_.LastWriteTime.Year -eq (Get-Date).Year) -and ($_.LastWriteTime.Month -ne (Get-Date).Month)
}
```

*(Примітка: дужки `()` навколо кожної умови використовуються для групування та покращення читабельності, особливо у складних випадках).*

Будьте уважні з рекурсією:
Дуже багато файлів/тіки — `-Recurse` може рекурсивно заходити в десятки тисяч елементів.
Символічні посилання / циклічні посилання — можуть викликати нескінченну рекурсію.
Файли без прав доступу — можуть блокувати виконання.

### 4. **Створення, керування та безпечне видалення**

#### **Створення, копіювання та переміщення**

```powershell
New-Item -Path "C:\Temp\MyFolder" -ItemType Directory
Add-Content -Path "C:\Temp\MyFolder\MyFile.txt" -Value "Перший рядок"
Copy-Item -Path "C:\Temp\MyFolder" -Destination "C:\Temp\MyFolder_Copy" -Recurse
```

#### **Безпечне видалення**
`Remove-Item` — потенційно небезпечний командлет, тому в PowerShell є вбудовані механізми захисту.
> **Ключ `-WhatIf` (Що якщо?):** Ваш найкращий друг. Він **не виконує** команду, а лише виводить у консоль повідомлення про те, **що б сталося**.

```powershell
# Безпечна ПЕРЕВІРКА перед видаленням
Remove-Item C:\Temp\MyFolder -Recurse -Force -WhatIf
# Результат: What if: Performing the operation "Remove Directory" on target "C:\Temp\MyFolder".

# Тільки переконавшись, що все вірно, прибираємо -WhatIf і ВИКОНУЄМО команду
Remove-Item C:\Temp\MyFolder -Recurse -Force
```
---

### **Вступ до функцій**

Коли один рядок коду перетворюється на складний набір команд, який ви хочете використовувати знову і знову, настає час для створення **функцій**.

#### **Як використовувати та зберігати функції**

Існує три основні способи зробити ваші функції доступними:

**Спосіб 1: Тимчасовий (для тестів)**
Ви можете набрати в консолі або просто скопіювати та вставити весь код функції в консоль PowerShell. Функція буде доступна до закриття цього вікна.

**Спосіб 2: Постійний, але ручний (через `.ps1` файл)**
Це найпоширеніший спосіб для організації та обміну інструментами. Ви зберігаєте функцію у файл `.ps1` і завантажуєте її в сесію, коли вона вам потрібна.
> **Dot Sourcing (`. .\сript.ps1`):** Ця спеціальна команда виконує скрипт у *поточному* контексті, роблячи всі його функції та змінні доступними у вашій консолі.

**Спосіб 3: Автоматичний (через профіль PowerShell)**
Це найпотужніший спосіб для ваших особистих, часто використовуваних інструментів.
> **Що таке профіль PowerShell?** Це спеціальний скрипт `.ps1`, який PowerShell автоматично запускає щоразу при старті. Все, що ви помістите в цей файл — псевдоніми, змінні і, звичайно, функції — буде доступно в кожній вашій сесії за замовчуванням.

##### **Приклад 1: Пошук дублікатів файлів**

Давайте пройдемо всі кроки на прикладі функції `Find-DuplicateFiles`.

**Крок 1: Визначаємо код функції**
```powershell
$functionCode = @'
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )

    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue |
        Group-Object Name, Length |
        Where-Object { $_.Count -gt 1 } |
        ForEach-Object {
            # זו השורה המתוקנת:
            # בתוך אופרטור $() משתני לא מקבלים אסקייפ.
            Write-Host "Знайдено дублікати: $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
        }
}
'@
```

**Крок 2 (Варіант А): Зберігаємо в окремий файл для ручного завантаження**
```powershell
# Зберігаємо
Set-Content -Path ".\Find-DuplicateFiles.ps1" -Value $functionCode
# Завантажуємо
. .\Find-DuplicateFiles.ps1
```
> Dot Sourcing (. .\Find-DuplicateFiles.ps1): Ця спеціальна команда виконує скрипт у поточному контексті, роблячи всі його функції та змінні доступними у вашій консолі.
```powershell
# Викликаємо
Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Downloads"
```

**Крок 2 (Варіант Б): Додаємо до профілю для автоматичного завантаження**
Зробимо цю функцію доступною завжди.
>Що таке профіль PowerShell? Це спеціальний скрипт .ps1, який PowerShell автоматично запускає щоразу при старті. Все, що ви помістите в цей файл — псевдоніми, змінні і, звичайно, функції — буде доступно в кожній вашій сесії за замовчуванням.
1.  **Знаходимо шлях до файлу профілю.** PowerShell зберігає його в змінній `$PROFILE`.
    ```powershell
    $PROFILE
    ```
2.  **Створюємо файл профілю, якщо він не існує.**
    ```powershell
    if (-not (Test-Path $PROFILE)) {
        New-Item -Path $PROFILE -Type File -Force
    }
    ```
3.  **Додаємо код нашої функції в кінець файлу профілю.**
    ```powershell
    Add-Content -Path $PROFILE -Value $functionCode
    ```
4.  **Перезапустіть PowerShell** (або виконайте `. $PROFILE`), і тепер ваша команда `Find-DuplicateFiles` буде доступна завжди, як і `Get-ChildItem`.

##### **Приклад 2: Створення ZIP-архіву з резервною копією**

**Код для файлу `Backup-FolderToZip.ps1`:**
```powershell
function Backup-FolderToZip {
    param([string]$SourcePath, [string]$DestinationPath)
    if (-not (Test-Path $SourcePath)) { Write-Error "Вихідна папка не знайдена."; return }
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName
    if (-not (Test-Path $DestinationPath)) { New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null }
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force
    Write-Host "Резервне копіювання завершено: $fullArchivePath" -ForegroundColor Green
}
```

Детальний розбір функцій я зроблю в наступних частинах.

---

### **Довідник командлетів для роботи з файловою системою**

#### **1. Основні командлети**
Цей список включає 12 найнеобхідніших командлетів, які покривають 90% повсякденних завдань.

| Командлет | Основне призначення | Приклад використання |
| :--- | :--- | :--- |
| `Get-ChildItem`| Отримати список файлів та папок. | `Get-ChildItem C:\Windows` |
| `Set-Location` | Переміститися в іншу директорію. | `Set-Location C:\Temp` |
| `Get-Location` | Показати поточну директорію. | `Get-Location` |
| `New-Item` | Створити новий файл або папку. | `New-Item "report.docx" -Type File`|
| `Remove-Item` | Видалити файл або папку. | `Remove-Item "old_log.txt"` |
| `Copy-Item` | Скопіювати файл або папку. | `Copy-Item "file.txt" -Dest "D:\"` |
| `Move-Item` | Перемістити файл або папку. | `Move-Item "report.docx" -Dest "C:\Archive"` |
| `Rename-Item` | Перейменувати файл або папку. | `Rename-Item "old.txt" -NewName "new.txt"` |
| `Get-Content` | Прочитати вміст файлу. | `Get-Content "config.ini"` |
| `Set-Content` | Записати/перезаписати вміст файлу. | `"data" | Set-Content "file.txt"` |
| `Add-Content` | Додати вміст у кінець файлу. | `Get-Date | Add-Content "log.txt"` |
| `Test-Path` | Перевірити, чи існує файл або папка. | `Test-Path "C:\Temp"` |

Потрібно **прочитати вміст** текстового файлу? Використовуйте `Get-Content`.
Потрібно **повністю перезаписати файл** новим вмістом? Використовуйте `Set-Content`.
Потрібно **додати рядок до лог-файлу**, не стираючи старі дані? Використовуйте `Add-Content`.
Потрібно **перевірити, чи існує файл** перед записом? Використовуйте `Test-Path`.

#### **2. Спеціалізовані командлети для просунутих завдань**
Коли базових командлетів недостатньо, PowerShell пропонує більш спеціалізовані інструменти. Вони не дублюють базові, а розширюють ваші можливості.

*   **Робота зі шляхами (Path)**
    *   **`Join-Path`**: Безпечно об'єднує частини шляху, автоматично вставляючи `\`.
    *   **`Split-Path`**: Розбиває шлях на частини (папка, ім'я файлу, розширення).
    *   **`Resolve-Path`**: Перетворює відносний шлях (наприклад, `.` або `..iles`) на повний, абсолютний.

*   **Робота з властивостями та вмістом (Item Properties and Content)**
    *   **`Get-ItemProperty`**: Отримує властивості конкретного файлу (наприклад, `IsReadOnly`, `CreationTime`).
    *   **`Set-ItemProperty`**: Змінює властивості файлу або папки.
    *   **`Clear-Content`**: Видаляє весь вміст з файлу, але залишає сам файл порожнім.

*   **Просунута навігація (Location Stack)**
    *   **`Push-Location`**: "Запам'ятовує" поточну директорію та переходить у нову.
    *   **`Pop-Location`**: Повертається до директорії, яку "запам'ятав" `Push-Location`.

*   **Керування правами доступу (ACL)**
    *   **`Get-Acl`**: Отримує список прав доступу (ACL) для файлу або папки.
    *   **`Set-Acl`**: Встановлює права доступу для файлу або папки (складна операція).

Потрібно **змінити атрибут файлу**, наприклад, зробити його «тільки для читання»? Використовуйте `Set-ItemProperty`.
Потрібно **повністю очистити лог-файл**, не видаляючи його? Використовуйте `Clear-Content`.
Потрібно **тимчасово перейти до іншої папки** у скрипті, а потім гарантовано повернутися назад? Використовуйте `Push-Location` та `Pop-Location`.
Потрібно **дізнатися, хто має права** на доступ до папки? Використовуйте `Get-Acl`.

У наступній частині ми дізнаємося, як працювати з іншими сховищами даних, такими як реєстр Windows,
використовуючи ті самі підходи, заглибимося в поняття функцій, розглянемо оператори логіки та навчимося інтерактивно взаємодіяти з оболонкою

Філософія PowerShell на github:
[Історія та перший командлет](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md)

Частина 2: [Конвеєр (Pipeline), змінні, Get-Member, файл .ps1 та експорт результатів.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/02.md)
Приклади до другої частини:
[system_monitor.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/02/system_monitor.ps1)

Частина 3: [Навігація та керування файловою системою.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/03.md)

Приклади до третьої частини:
[Find-DuplicateFiles.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/03/Find-DuplicateFiles.ps1)
[Backup-FolderToZip]()
