<h2>Философия PowerShell.</h2>
<h3>Часть 2: Конвейер (Pipeline), переменные, Get-Member, файл *.ps1* и экспорт результатов</h3>
<p><strong>❗ Важно:</strong><br>
Я пишу про <code>PS7</code> (<code>PowerShell 7</code>). Он отличается от <code>PS5</code> (<code>PowerShell 5</code>). Начиная с седьмой версии <code>ps</code> стал кросплатформенным. Из-за этого<br>
изменилось поведение некоторых команд.</p>
<p>В первой части мы установили ключевой принцип: <code>PowerShell</code> работает с **объектами**, а не с текстом.<br>
Этот пост посвящен некоторым важным инструментам <code>PowerShell</code>:<br>
научимся передавать объекты по **конвейеру**, анализировать их с помощью **<code>Get-Member</code>**,<br>
сохранять результаты в **переменные** и автоматизировать все это в **файлах скриптов (<code>.ps1</code>)** с **экспортом**<br>
результатов в удобные форматы.</p>
<h3>1. Что такое конвейер (<code>|</code>)?</h3>
<p>Конвейер в <code>PowerShell</code> это механизм передачи полноценных <code>.NET</code> объектов (а не просто текста) от одной команды<br>
к другой, где каждый следующий командлет получает структурированные объекты со всеми их свойствами и методами.</p>
<p>Символ <code>|</code> (вертикальная черта) — это оператор конвейера. Его задача — взять результат (вывод) команды, стоящей слева от него, и передать его на вход команде, стоящей справа.</p>
<p><code>Команда 1 (создает объекты)</code> → <code>|</code> → <code>Команда 2 (получает и обрабатывает объекты)</code> → <code>|</code> → <code>Команда 3 (получает обработанные объекты)</code> → | ...</p>
<h4>Классический <code>UNIX</code>-конвейер: Поток текста</h4>
<p>В <code>bash</code> по конвейеру передается **поток байтов**, который обычно интерпретируется как текст.</p>
<pre><code class="language-bash"># Найти все процессы 'nginx' и посчитать их количество
ps -ef | grep 'nginx' | wc -l
</code></pre>
<p>Здесь <code>ps</code> выводит текст, <code>grep</code> фильтрует этот текст, а <code>wc</code> считает строки. Каждая утилита ничего не знает о "процессах", она работает только со строками.</p>
<h4><code>PowerShell</code>-конвейер: Поток объектов</h4>
<p><strong>Пример:</strong> Давайте получим все процессы, отсортируем их по использованию <code>CPU</code> и выберем 5 самых "прожорливых".</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<p><img src="assets/02/1.png" alt="1"></p>
<p>Здесь <code>Get-Process</code> создает **объекты** процессов. <code>Sort-Object</code> получает эти **объекты** и сортирует их по свойству <code>CPU</code>. <code>Select-Object</code> получает отсортированные **объекты** и выбирает первые 5.</p>
<p>Вы наверняка заметили в команде слова, начинающиеся с дефиса (<code>-</code>): <code>-Property</code>, <code>-Descending</code>, <code>-First</code>. Это параметры.<br>
Параметры — это настройки, переключатели и инструкции для командлета. Они позволяют управлять тем, **КАК** команда будет выполнять свою работу.<br>
Без параметров команда работает в режиме по умолчанию, а с параметрами вы даете ей конкретные указания.</p>
<p>Основные типы параметров:</p>
<ul>
<li>Параметр со значением: требует дополнительной информации.</li>
</ul>
<p><code>-Property CPU</code>: Мы говорим <code>Sort-Object</code>, по какому свойству сортировать. <code>CPU</code> — это значение параметра.</p>
<p><code>-First 5</code>: Мы говорим <code>Select-Object</code>, сколько объектов выбрать. <code>5</code> — это значение параметра.</p>
<ul>
<li>Параметр-переключатель (флаг): Не требует значения. Само его наличие в команде включает или выключает определенное поведение.</li>
</ul>
<p><code>-Descending</code>: Этот флаг говорит <code>Sort-Object</code> изменить порядок сортировки на обратный (от большего к меньшему). Ему не нужно дополнительное значение — он сам по себе инструкция.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<p><img src="assets/02/2.png" alt="1"></p>
<p>Эта команда отвечает на очень простой вопрос:<br>
**"Сколько именно процессов с именем <code>svchost.exe</code> сейчас запущено в моей системе?"**</p>
<h4>Разбор по шагам</h4>
<h5>**Шаг 1: <code>Get-Process -Name 'svchost'</code>**</h5>
<p>Эта часть команды обращается к операционной системе и просит найти **все без исключения** запущенные процессы, у которых имя исполняемого файла — <code>svchost.exe</code>.<br>
В отличие от процессов типа <code>notepad</code> (которых обычно один или два), процессов <code>svchost</code> в системе всегда **много**. Команда вернет **массив (коллекцию) объектов**,<br>
где каждый объект — это отдельный, полноценный процесс <code>svchost</code> со своим уникальным <code>ID</code>, использованием памяти и т.д.<br>
<code>PowerShell</code> нашел в системе, например, 90 процессов <code>svchost</code> и теперь держит в руках коллекцию из 90 объектов.</p>
<h5>**Шаг 2: <code>|</code> (Оператор конвейера)**</h5>
<p>Этот символ берет коллекцию из 90 объектов <code>svchost</code>, полученную на первом шаге, и начинает передавать их **по одному** на вход следующей команде.</p>
<h5>**Шаг 3: <code>Measure-Object</code>**</h5>
<p>Поскольку мы вызвали <code>Measure-Object</code> без параметров (таких как <code>-Property</code>, <code>-Sum</code> и т.д.), он выполняет свою операцию **по умолчанию** — просто считает количество "предметов", которые ему передали.<br>
Раз, два, три ... После того как все объекты посчитаны, <code>Measure-Object</code> создает **свой собственный объект-результат**, в котором есть свойство <code>Count</code>, равное итоговому числу.</p>
<p><strong><code>Count: 90</code></strong> — это и есть ответ на наш вопрос. Запущено 90 процессов <code>svchost</code>.<br>
Остальные поля пустые, потому что мы не просили <code>Measure-Object</code> выполнять более сложные вычисления.</p>
<h4>Пример с <code>svchost</code> и параметрами</h4>
<p>Давайте изменим нашу задачу. Теперь мы хотим не просто посчитать процессы <code>svchost</code>,<br>
а узнать, **сколько всего оперативной памяти (в мегабайтах) они потребляют вместе**.</p>
<p>Для этого нам понадобятся параметры:</p>
<ul>
<li><code>-Property WorkingSet64</code>: Эта инструкция говорит <code>Measure-Object</code>: "Из каждого объекта <code>svchost</code>, который к тебе придет, возьми числовое значение из свойства <code>WorkingSet64</code> (это использование памяти в байтах)".</li>
<li><code>-Sum</code>: Эта инструкция-флаг говорит: "Сложи все эти значения, которые ты взял из свойства <code>WorkingSet64</code>".</li>
</ul>
<p>Наша новая команда будет выглядеть так:</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<p><img src="assets/02/3.png" alt="3"></p>
<ol>
<li><code>Get-Process</code> найдет количество объектов <code>svchost</code>.</li>
<li>Конвейер <code>|</code> передаст их в <code>Measure-Object</code>.</li>
<li>Но теперь <code>Measure-Object</code> работает по-новому:
<ul>
<li>Он берет первый объект <code>svchost</code>, смотрит его свойство <code>.WorkingSet64</code> (например, <code>25000000</code> байт) и запоминает это число.</li>
<li>Берет второй объект, смотрит его <code>.WorkingSet64</code> (например, <code>15000000</code> байт) и прибавляет к предыдущему.</li>
<li>...и так далее для всех объектов.</li>
</ul>
</li>
<li>В итоге <code>Measure-Object</code> создаст объект-результат, но теперь он будет другим.</li>
</ol>
<ul>
<li><strong><code>Count: 92</code></strong>: Количество объектов.</li>
<li><strong><code>Sum: 1661890560</code></strong>: Это общая сумма всех значений <code>WorkingSet64</code> в байтах.</li>
<li><strong><code>Property: WorkingSet64</code></strong>: Это поле теперь тоже заполнено, оно информирует нас, какое именно свойство было использовано для вычислений.</li>
</ul>
<h3>2. Переменные (Обычные и специальная <code>$_</code>)</h3>
<p>Переменная — это именованное хранилище в памяти, которое содержит какое-либо значение.</p>
<p>Этим значением может быть что угодно: текст, число, дата или, что самое важное для <code>PowerShell</code>,<br>
целый объект или даже коллекция объектов. Имя переменной в <code>PowerShell</code> всегда начинается со знака доллара (<code>$</code>).<br>
Примеры: <code>$name</code>, <code>$counter</code>, <code>$processList</code>.</p>
<p>Специальная переменная <code>$_</code>?</p>
<p><code>$_</code> — это сокращение для "текущий объект" или "вот эта штука".<br>
Представьте себе конвейер на заводе. По нему едут разные детали (объекты).</p>
<p><code>$_</code> — это та самая деталь, которая находится прямо сейчас перед вами (или перед роботом-обработчиком).</p>
<p>Источник (<code>Get-Process</code>) — высыпает на конвейер целую коробку с деталями (всеми процессами).</p>
<p>Конвейер (<code>|</code>) — заставляет эти детали двигаться по ленте по одной.</p>
<p>Обработчик (<code>Where-Object</code> или <code>ForEach-Object</code>) — это робот, который смотрит на каждую деталь.</p>
<p>Переменная <code>$_</code> — это та самая деталь, которая сейчас находится в "руках" у робота.</p>
<p>Когда робот закончит с одной деталью, конвейер подает ему следующую, и <code>$_</code> теперь будет указывать уже на нее.</p>
<p>Давайте посчитаем, сколько всего памяти используют процессы <code>svchost</code>, и выведем результат на монитор.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Выполняем команду и сохраняем ее сложный объект-результат в переменную $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Теперь мы можем работать с сохраненным объектом. Достаем из него свойство Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Выводим результат на экран, используя новую переменную
Write-Host "Все процессы svchost используют $memoryInMB МБ памяти."
</code></pre>
<p><img src="assets/02/4.png" alt="3"></p>
<ul>
<li><code>Write-Host</code> — это специализированный командлет, чья единственная задача — **показать текст непосредственно пользователю в консоли**.</li>
<li>Строка в двойных кавычках: <code>"..."</code> - текстовая строка, которую мы передаем командлету <code>Write-Host</code> в качестве аргумента. Почему двойные, а не одинарные кавычки?</li>
</ul>
<p>В <code>PowerShell</code> есть два типа кавычек:</p>
<ul>
<li>**Одинарные (<code>'...'</code>):** Создают **буквальную строку**. Все, что внутри них, воспринимается как обычный текст, без исключений.</li>
<li>**Двойные (<code>"..."</code>):** Создают **расширяемую (или подстановочную) строку**. <code>PowerShell</code> "сканирует" такую строку на предмет переменных (начинающихся с <code>$</code>) и подставляет на их место их значения.</li>
</ul>
<ul>
<li><code>$memoryInMB</code>. Это переменная, в которую мы **на предыдущем шаге** нашего скрипта положили результат вычислений. Когда <code>Write-Host</code> получает строку в двойных кавычках,<br>
происходит процесс, называемый **"подстановка переменных" (<code>String Expansion</code>)**:
<ol>
<li><code>PowerShell</code> видит текст <code>"Все процессы svchost используют "</code>.</li>
<li>Затем он натыкается на конструкцию <code>$memoryInMB</code>. Он понимает, что это не просто текст, а переменная.</li>
<li>Он заглядывает в память, находит значение, хранящееся в <code>$memoryInMB</code> (например, <code>1585.52</code>).</li>
<li>Он **подставляет это значение** прямо в строку.</li>
<li>Затем он добавляет оставшуюся часть текста: <code>" МБ памяти."</code>.</li>
<li>В итоге, в <code>Write-Host</code> передается уже готовая, собранная строка: <code>"Все процессы svchost используют 1585.52 МБ памяти."</code>.</li>
</ol>
</li>
</ul>
<p>Запустите блокнот:</p>
<ol>
<li>Находим процесс Блокнота и сохраняем его в переменную <code>$notepadProcess</code></li>
</ol>
<pre class="line-numbers"><code class="language-powershell">$notepadProcess = Get-Process -Name notepad
</code></pre>
<ol start="2">
<li>Обращаемся к свойству '<code>Id</code>' этого объекта через точку и выводим его</li>
</ol>
<pre class="line-numbers"><code class="language-powershell">Write-Host "ID процесса 'Блокнот' равен: $($notepadProcess.Id)"
</code></pre>
<p><img src="assets/02/5.png" alt="5"></p>
<p><strong>❗ Важно:</strong><br>
<code>Write-Host</code> "ломает" конвейер. Текст, выведенный им, нельзя передать дальше по конвейеру для обработки. Он предназначен только для отображения.</p>
<h3>3. <code>Get-Member</code> (Инспектор объектов)</h3>
<p>Мы знаем, что по конвейеру "текут" объекты. Но как узнать, из чего они состоят? Какие у них есть свойства и какие действия (методы) с ними можно совершать?</p>
<p>командлет **<code>Get-Member</code>** (псевдоним: <code>gm</code>) главный инструмент для исследования.<br>
Прежде чем работать с объектом, пропустите его через <code>Get-Member</code>, чтобы увидеть все его возможности.</p>
<p>Давайте проанализируем объекты, которые создает <code>Get-Process</code>:</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process | Get-Member
</code></pre>
<p><img src="assets/02/6.png" alt="6"></p>
<p><em>Разберем каждую часть вывода <code>Get-Member</code>.</em></p>
<p><code>TypeName: System.Diagnostics.Process</code> - Это полное, официальное "имя типа" объекта из библиотеки <code>.NET</code>. Это его "паспорт".<br>
Эта строка говорит вам, что все объекты, которые возвращает <code>Get-Process</code>, являются объектами типа <code>System.Diagnostics.Process</code>.<br>
Это гарантирует, что у них у всех будет одинаковый набор свойств и методов.<br>
Вы можете <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">загуглить</a> "<code>System.Diagnostics.Process</code>", чтобы найти официальную документацию <code>Microsoft</code> с еще более подробной информацией.</p>
<ul>
<li>Колонка 1: <code>Name</code></li>
</ul>
<p>Это простое, человекочитаемое **имя** свойства, метода или другого "члена" объекта. Именно это имя вы будете использовать в своем коде для доступа к данным или выполнения действий.</p>
<ul>
<li>Колонка 2: <code>MemberType</code> (Тип объекта)</li>
</ul>
<p>Это самая важная для понимания колонка. Она классифицирует, **чем является** каждый объект. Это его "должность", которая говорит вам, **КАК** его использовать.</p>
<ul>
<li><strong><code>Property</code> (Свойство):</strong> **характеристика** или **порция данных**, хранящаяся внутри объекта. Вы можете "прочитать" ее значение.<ul>
<li><em>Примеры на скриншоте:</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. Это просто данные, которые можно посмотреть.</li>
</ul>
</li>
<li><strong><code>Method</code> (Метод):</strong> **ДЕЙСТВИЕ**, которое можно совершить с объектом. Методы всегда вызываются с круглыми скобками <code>()</code>.<ul>
<li><em>Примеры на скриншоте:</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. Вы бы написали <code>$process.Kill()</code> или <code>$process.Refresh()</code>.</li>
</ul>
</li>
<li><strong><code>AliasProperty</code> (Псевдоним свойства):</strong> **дружелюбный псевдоним** для другого, более длинного свойства. <code>PowerShell</code> добавляет их для удобства и краткости.<ul>
<li><em>Примеры на скриншоте:</em> <code>WS</code> — это короткий псевдоним для <code>WorkingSet64</code>. <code>Name</code> — для <code>ProcessName</code>. <code>VM</code> — для <code>VirtualMemorySize64</code>.</li>
</ul>
</li>
<li><strong><code>Event</code> (Событие):</strong> **УВЕДОМЛЕНИЕ** о том, что что-то произошло, на которое можно "подписаться".<ul>
<li><em>Пример на скриншоте:</em> <code>Exited</code>. Ваш скрипт может "слушать" это событие, чтобы выполнить какое-то действие сразу после того, как процесс завершится.</li>
</ul>
</li>
<li><strong><code>CodeProperty</code> и <code>NoteProperty</code>:</strong> специальные типы свойств, часто добавляемые самим <code>PowerShell</code> для удобства. <code>CodeProperty</code> вычисляет свое значение "на лету", а <code>NoteProperty</code> — это простое свойство-заметка, добавленное к объекту.</li>
</ul>
<ul>
<li>Колонка 3: <code>Definition</code> (Определение)</li>
</ul>
<p>Это **техническое определение** или "подпись" члена. Она дает вам точные детали для его использования. Ее содержимое зависит от <code>MemberType</code>:</p>
<ul>
<li><strong>Для <code>AliasProperty</code>:</strong> Показывает, **чему равен псевдоним**. Это невероятно полезно!<ul>
<li><em>Пример на скриншоте:</em> <code>WS = WorkingSet64</code>. Вы сразу видите, что <code>WS</code> — это просто короткая запись для <code>WorkingSet64</code>.</li>
</ul>
</li>
<li><strong>Для <code>Property</code>:</strong> Показывает **тип данных**, который хранится в свойстве (например, <code>int</code> для целого числа, <code>string</code> для текста, <code>datetime</code> для даты и времени), и что можно с ним делать (<code>{get;}</code> — только читать, <code>{get;set;}</code> — читать и изменять).<ul>
<li><em>Пример на скриншоте:</em> <code>int BasePriority {get;}</code>. Это целочисленное свойство, которое можно только прочитать.</li>
</ul>
</li>
<li><strong>Для <code>Method</code>:</strong> Показывает, что метод возвращает (например, <code>void</code> — ничего, <code>bool</code> — <code>true/false</code>) и какие **параметры** (входные данные) он принимает в скобках.<ul>
<li><em>Пример на скриншоте:</em> <code>void Kill()</code>. Это значит, что метод <code>Kill</code> ничего не возвращает и может быть вызван без параметров. Также есть вторая версия <code>void Kill(bool entireProcessTree)</code>, которая принимает логическое значение (<code>true/false</code>).</li>
</ul>
</li>
</ul>
<h4>В виде таблицы</h4>
<table>
<thead>
<tr>
<th>Колонка</th>
<th>Что это?</th>
<th>Пример с скриншота</th>
<th>Для чего?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>Name</code></strong></td>
<td>Имя, которое вы используете в коде.</td>
<td><code>Kill</code>, <code>WS</code>, <code>Name</code></td>
<td>обратиться к свойству или методу (<code>$process.WS</code>, <code>$process.Kill()</code>).</td>
</tr>
<tr>
<td><strong><code>MemberType</code></strong></td>
<td>Тип члена (данные, действие и т.д.).</td>
<td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td>
<td><strong>как</strong> его использовать (читать значение или вызывать с <code>()</code>).</td>
</tr>
<tr>
<td><strong><code>Definition</code></strong></td>
<td>Технические детали.</td>
<td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td>
<td>что скрывается за псевдонимом и какие параметры нужны методу.</td>
</tr>
</tbody>
</table>
<h4>Пример: Работа с окнами процессов</h4>
<h5>1. Проблема:</h5>
<p>"Я открыл много окон Блокнота. Как мне программно свернуть все, кроме главного, а затем закрыть только то, у которого в заголовке есть слово 'Untitled'?"</p>
<h5>2. Исследование с <code>Get-Member</code>:</h5>
<p>Нам нужно найти свойства, связанные с окном и его заголовком.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name notepad | Get-Member
</code></pre>
<p><strong>Анализ результата <code>Get-Member</code>:</strong></p>
<ul>
<li>Листая свойства, мы находим <code>MainWindowTitle</code>. Тип <code>string</code>. Отлично, это заголовок главного окна!</li>
<li>В методах мы видим <code>CloseMainWindow()</code>. Это более "мягкий" способ закрыть окно, чем <code>Kill()</code>.</li>
<li>Также в методах есть <code>WaitForInputIdle()</code>. Звучит интересно, возможно, это поможет дождаться, пока процесс будет готов к взаимодействию.</li>
</ul>
<p><img src="assets/02/7.png" alt="7"></p>
<p><code>Get-Member</code> показал нам свойство <code>MainWindowTitle</code>, которое является ключом к решению задачи и позволяет взаимодействовать с процессами на основе состояния их окон, а не просто по имени.</p>
<h5>3. Решение:</h5>
<p>Теперь мы можем построить логику, основанную на заголовке окна.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Находим все процессы Блокнота
$notepads = Get-Process -Name notepad

# 2. Проходимся по каждому и проверяем заголовок
foreach ($pad in $notepads) {
    # Для каждого процесса ($pad) проверяем его свойство MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Найден несохраненный Блокнот (ID: $($pad.Id)). Закрываем его окно..."
        # $pad.CloseMainWindow() # Раскомментируйте, чтобы действительно закрыть
        Write-Host "Окно '$($pad.MainWindowTitle)' было бы закрыто." -ForegroundColor Yellow
    } else {
        Write-Host "Пропускаем Блокнот с заголовком: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<p><img src="assets/02/8.png" alt="8"></p>
<p><img src="assets/02/9.png" alt="9"></p>
<hr>
<h4>Пример: Найти родительский процесс</h4>
<h5>1. Проблема:</h5>
<p>"Иногда я вижу в системе много дочерних процессов <code>chrome.exe</code>. Как мне узнать, какой из них является главным, "родительским" процессом, который их всех запустил?"</p>
<h5>2. Исследование с <code>Get-Member</code>:</h5>
<p>Нам нужно найти что-то, что связывает один процесс с другим.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<p><img src="assets/02/10.png" alt="10"></p>
<p><strong>Анализ результата <code>Get-Member</code>:</strong></p>
<ul>
<li>Внимательно просматривая список, мы находим свойство типа <code>CodeProperty</code> с именем <code>Parent</code>.</li>
<li>Его определение (<code>Definition</code>) — <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>.<br>
Это вычисляемое свойство, которое при обращении к нему возвращает **объект родительского процесса**.
</li>
</ul>
<h5>3. Решение:</h5>
<p>Теперь мы можем написать скрипт, который для каждого процесса <code>chrome</code> будет выводить информацию о его родителе.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Получаем все процессы chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Для каждого из них выводим информацию о нем и его родителе
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Получаем родительский процесс
    $parent = $_.Parent
    
    # Формируем красивый вывод
    Write-Host "Процесс:" -ForegroundColor Green
    Write-Host "  - Имя: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Его родитель:" -ForegroundColor Yellow
    Write-Host "  - Имя: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<p><img src="assets/02/11.png" alt="11"></p>
<p><img src="assets/02/12.png" alt="12"></p>
<p>Мы сразу видим, что процессы с <code>ID 4756</code>, <code>7936</code>, <code>8268</code> и <code>9752</code> были запущены процессом с <code>ID 14908</code>. Также можно заметить интересный случай с процессом <code>ID: 7252</code>, у которого родительский процесс не определился (возможно, родитель уже успел завершиться к моменту проверки). Модификация скрипта с проверкой <code>if ($parent)</code> аккуратно обрабатывает этот случай, не вызывая ошибки.<br>
<code>Get-Member</code> помог нам обнаружить "скрытое" свойство <code>Parent</code>, которое предоставляет мощные возможности для анализа иерархии процессов.</p>
<h4>4. Файл *.ps1* (Создание скриптов)</h4>
<p>Когда ваша цепочка команд становится полезной, вы захотите сохранить ее для многократного использования. Для этого и нужны **скрипты** — текстовые файлы с расширением **<code>.ps1</code>**.</p>
<h5>Разрешение на запуск скриптов</h5>
<p>По умолчанию в <code>Windows</code> запрещен запуск локальных скриптов. Чтобы это исправить **для текущего пользователя**, выполните один раз в <code>PowerShell</code> **от имени администратора**:</p>
<pre class="line-numbers"><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<p>Это безопасная настройка, которая разрешает запускать ваши собственные скрипты и скрипты, подписанные доверенным издателем.</p>
<h5>Пример скрипта <code>system_monitor.ps1</code></h5>
<p>Создайте файл с таким именем и вставьте в него код ниже. Этот скрипт собирает информацию о системе и генерирует отчеты.</p>
<pre class="line-numbers"><code class="language-powershell"># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Скрипт для создания отчета о состоянии системы.
.DESCRIPTION
    Собирает информацию о процессах, службах и дисковом пространстве и генерирует отчеты.
.PARAMETER OutputPath
    Путь для сохранения отчетов. По умолчанию 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Блок 1: Подготовка ---
Write-Host "Подготовка к созданию отчета..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Блок 2: Сбор данных ---
Write-Host "Сбор информации..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Блок 3: Вызов функции для экспорта (см. следующий раздел) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Отчеты успешно сохранены в папке $OutputPath" -ForegroundColor Magenta
</code></pre>
<p><em>Примечание: функция <code>Export-Results</code> будет определена в следующем разделе как пример хорошей практики.</em></p>
<h4>5. Экспорт результатов</h4>
<p>Чистые данные — это хорошо, но часто их нужно представить в удобном для человека или другой программы виде. <code>PowerShell</code> предлагает множество командлетов для экспорта.</p>
<table>
<thead>
<tr>
<th>Метод</th>
<th>Команда</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Простой текст</strong></td>
<td><code>... \| Out-File C:\Temp\data.txt</code></td>
<td>Перенаправляет текстовое представление в файл.</td>
</tr>
<tr>
<td><strong><code>CSV</code> (для <code>Excel</code>)</strong></td>
<td><code>... \| Export-Csv C:\Temp\data.csv -NoTypeInfo</code></td>
<td>Экспортирует объекты в <code>CSV</code>. <code>-NoTypeInfo</code> убирает служебную первую строку.</td>
</tr>
<tr>
<td><strong><code>HTML</code>-отчет</strong></td>
<td><code>... \| ConvertTo-Html -Title "Отчет"</code></td>
<td>Создает <code>HTML</code>-код из объектов.</td>
</tr>
<tr>
<td><strong><code>JSON</code> (для <code>API</code>, веб)</strong></td>
<td><code>... \| ConvertTo-Json</code></td>
<td>Преобразует объекты в формат <code>JSON</code>.</td>
</tr>
<tr>
<td><strong><code>XML</code> (родной формат <code>PowerShell</code>)</strong></td>
<td><code>... \| Export-Clixml C:\Temp\data.xml</code></td>
<td>Сохраняет объекты со всеми типами данных. Их можно идеально восстановить через <code>Import-Clixml</code>.</td>
</tr>
</tbody>
</table>
<h5>Дополнение к скрипту: функция экспорта</h5>
<p>Давайте добавим в наш скрипт <code>system_monitor.ps1</code> функцию, которая будет заниматься экспортом. Поместите этот код **перед** вызовом <code>Export-Results</code>.</p>
<pre class="line-numbers"><code class="language-powershell">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Экспорт в CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Создание красивого HTML-отчета
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Топ-10 процессов по CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Статистика служб&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;Отчет о системе&lt;/title&gt;" -Body "&lt;h1&gt;Отчет о системе от $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<p>Теперь наш скрипт не просто собирает данные, но и аккуратно сохраняет их в двух форматах: <code>CSV</code> для анализа и <code>HTML</code> для быстрого просмотра.</p>
<h4>Заключение</h4>
<ol>
<li><strong>Конвейер (<code>|</code>)</strong> — главный инструмент для объединения команд и обработки объектов.</li>
<li><strong><code>Get-Member</code></strong> — анализ объектов, который показывает, из чего они состоят.</li>
<li><strong>Переменные (<code>$var</code>, <code>$_</code>)</strong> позволяют сохранять данные и обращаться к текущему объекту в конвейере.</li>
<li><strong>Файлы <code>.ps1</code></strong> превращают команды в переиспользуемые инструменты автоматизации.</li>
<li><strong>Командлеты экспорта</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) Экспортируют данные в соответствующем формате.</li>
</ol>
<p><strong>В следующей части мы применим эти знания для навигации и управления файловой системой, исследуя объекты <code>System.IO.DirectoryInfo</code> и <code>System.IO.FileInfo</code>.</strong></p>