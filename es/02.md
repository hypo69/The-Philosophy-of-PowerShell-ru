# Filosofía de PowerShell.
## Parte 2: Pipeline, variables, Get-Member, archivo *.ps1* y exportación de resultados
**❗ Importante:**
Estoy escribiendo sobre PS7 (PowerShell 7). Se diferencia de PS5 (PowerShell 5). A partir de la séptima versión, PS se volvió multiplataforma. Debido a esto,
el comportamiento de algunos comandos ha cambiado.

En la primera parte, establecimos un principio clave: PowerShell trabaja con **objetos**, no con texto.
Esta publicación está dedicada a algunas herramientas importantes de PowerShell:
aprenderemos a pasar objetos a través de un **pipeline**, analizarlos usando **`Get-Member`**,
guardar resultados en **variables** y automatizar todo esto en **archivos de script (`.ps1`)** con **exportación**
de resultados a formatos convenientes.

### 1. ¿Qué es un pipeline (`|`)?
Un pipeline en PowerShell es un mecanismo para pasar objetos .NET completos (no solo texto) de un comando
a otro, donde cada cmdlet subsiguiente recibe objetos estructurados con todas sus propiedades y métodos.

El símbolo `|` (barra vertical) es el operador de pipeline. Su tarea es tomar el resultado (salida) del comando a su izquierda y pasarlo como entrada al comando a su derecha.

`Comando 1 (crea objetos)` → `|` → `Comando 2 (recibe y procesa objetos)` → `|` → `Comando 3 (recibe objetos procesados)` → |

#### Pipeline clásico de UNIX: Flujo de texto

En `bash`, se pasa un **flujo de bytes** a través del pipeline, que generalmente se interpreta como texto.

```bash
# Encontrar todos los procesos 'nginx' y contarlos
ps -ef | grep 'nginx' | wc -l
```
Aquí `ps` muestra texto, `grep` filtra este texto, y `wc` cuenta líneas. Cada utilidad no sabe nada sobre "procesos"; solo trabaja con cadenas.

#### Pipeline de PowerShell: Flujo de objetos
**Ejemplo:** Obtengamos todos los procesos, ordenémoslos por uso de CPU y seleccionemos los 5 más "consumidores".

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
![1](assets/02/1.png)

Aquí `Get-Process` crea **objetos** de procesos. `Sort-Object` recibe estos **objetos** y los ordena por la propiedad `CPU`. `Select-Object` recibe los **objetos** ordenados y selecciona los primeros 5.

Probablemente haya notado palabras que comienzan con un guion (-) en el comando: -Property, -Descending, -First. Estos son parámetros.
Los parámetros son configuraciones, interruptores e instrucciones para un cmdlet. Le permiten controlar **CÓMO** un comando realizará su trabajo.
Sin parámetros, el comando funciona en modo predeterminado, pero con parámetros, le da instrucciones específicas.

Tipos principales de parámetros:

- Parámetro con un valor: requiere información adicional.

    `-Property CPU`: Le decimos a Sort-Object por qué propiedad ordenar. CPU es el valor del parámetro.
    
    `-First 5`: Le decimos a Select-Object cuántos objetos seleccionar. 5 es el valor del parámetro.

- Parámetro de interruptor (bandera): No requiere un valor. Su mera presencia en el comando habilita o deshabilita un comportamiento específico.

   `-Descending`: Esta bandera le dice a Sort-Object que invierta el orden de clasificación (de mayor a menor). No necesita un valor adicional, es una instrucción en sí misma.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
![1](assets/02/2.png)
Este comando responde a una pregunta muy simple:
**"¿Cuántos procesos `svchost.exe` se están ejecutando actualmente en mi sistema?"**

#### Desglose paso a paso

##### **Paso 1: `Get-Process -Name 'svchost'`**

Esta parte del comando consulta el sistema operativo y pide encontrar **todos** los procesos en ejecución cuyo nombre de archivo ejecutable sea `svchost.exe`.
A diferencia de procesos como `notepad` (de los cuales suele haber uno o dos), siempre hay **muchos** procesos `svchost` en el sistema. El comando devolverá una **matriz (colección) de objetos**,
donde cada objeto es un proceso `svchost` separado y completo con su ID único, uso de memoria, etc.
PowerShell encontró, por ejemplo, 90 procesos `svchost` en el sistema y ahora tiene una colección de 90 objetos.

##### **Paso 2: `|` (Operador de Pipeline)**

Este símbolo toma la colección de 90 objetos `svchost` obtenida en el primer paso y comienza a pasarlos **uno por uno** como entrada al siguiente comando.

##### **Paso 3: `Measure-Object`**

Dado que llamamos a `Measure-Object` sin parámetros (como `-Property`, `-Sum`, etc.), realiza su operación **predeterminada** — simplemente cuenta el número de "elementos" que se le pasaron.
Uno, dos, tres... Después de contar todos los objetos, `Measure-Object` crea **su propio objeto de resultado**, que tiene una propiedad `Count` igual al número total.


**`Count: 90`** — esta es la respuesta a nuestra pregunta. Hay 90 procesos `svchost` en ejecución.
Los otros campos están vacíos porque no le pedimos a `Measure-Object` que realizara cálculos más complejos.


#### Ejemplo con `svchost` y parámetros

Cambiemos nuestra tarea. Ahora no solo queremos contar los procesos `svchost`,
sino averiguar **cuánta RAM total (en megabytes) consumen juntos**.

Para esto, necesitaremos parámetros:
*   `-Property WorkingSet64`: Esta instrucción le dice a `Measure-Object`: "De cada objeto `svchost` que te llegue, toma el valor numérico de la propiedad `WorkingSet64` (este es el uso de memoria en bytes)".
*   `-Sum`: Esta instrucción de bandera dice: "Suma todos estos valores que tomaste de la propiedad `WorkingSet64`".

Nuestro nuevo comando se verá así:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
![3](assets/02/3.png)

1.  `Get-Process` encontrará el número de objetos `svchost`.
2.  El pipeline `|` los pasará a `Measure-Object`.
3.  Pero ahora `Measure-Object` funciona de manera diferente:
    *   Toma el primer objeto `svchost`, mira su propiedad `.WorkingSet64` (por ejemplo, `25000000` bytes) y recuerda este número.
    *   Toma el segundo objeto, mira su `.WorkingSet64` (por ejemplo, `15000000` bytes) y lo suma al anterior.
    *   ...y así sucesivamente para todos los objetos.
4.  Como resultado, `Measure-Object` creará un objeto de resultado, pero ahora será diferente.


*   **`Count: 92`**: Número de objetos.
*   **`Sum: 1661890560`**: Esta es la suma total de todos los valores `WorkingSet64` en bytes.
*   **`Property: WorkingSet64`**: Este campo ahora también está lleno, nos informa qué propiedad se utilizó para los cálculos.


### 2. Variables (Normales y la especial `$_`)

Una variable es un almacenamiento con nombre en la memoria que contiene algún valor.

Este valor puede ser cualquier cosa: texto, un número, una fecha o, lo más importante para PowerShell,
un objeto completo o incluso una colección de objetos. El nombre de una variable en PowerShell siempre comienza con un signo de dólar ($).
Ejemplos: $name, $counter, $processList.

¿Variable especial $_?

`$_` es la abreviatura de "objeto actual" o "esta cosa".
Imagine una cinta transportadora en una fábrica. Por ella se mueven diferentes piezas (objetos).

`$_` es la pieza que está justo ahora delante de usted (o delante del robot de procesamiento).

Fuente (Get-Process) — vierte una caja entera de piezas (todos los procesos) en la cinta transportadora.

Cinta transportadora (`|`) — hace que estas piezas se muevan por la cinta una por una.

Procesador (Where-Object o ForEach-Object) — es un robot que mira cada pieza.

Variable `$_` — es la pieza que está actualmente en las "manos" del robot.

Cuando el robot termina con una pieza, la cinta transportadora le entrega la siguiente, y `$_` ahora apuntará a ella.


Calculemos cuánta memoria total utilizan los procesos `svchost` y mostremos el resultado en el monitor.
```powershell
# 1. Ejecutamos el comando y guardamos su objeto de resultado complejo en la variable $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Ahora podemos trabajar con el objeto guardado. Extraemos la propiedad Sum de él
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Mostramos el resultado en pantalla usando la nueva variable
Write-Host "Todos los procesos svchost usan $memoryInMB MB de memoria."
```
![3](assets/02/4.png)

*   `Write-Host` — es un cmdlet especializado cuyo único propósito es **mostrar texto directamente al usuario en la consola**.

*   Cadena entre comillas dobles: `"..."` - una cadena de texto que pasamos al cmdlet `Write-Host` como argumento. ¿Por qué comillas dobles y no simples?
    
    En PowerShell, hay dos tipos de comillas:
    
    *   **Simples (`'...'`):** Crean una **cadena literal**. Todo lo que está dentro de ellas se trata como texto plano, sin excepciones.
    *   **Dobles (`"..."`):** Crean una **cadena expandible (o sustituible)**. PowerShell "escanea" dicha cadena en busca de variables (que comienzan con `$`) y sustituye sus valores en su lugar.

* `$memoryInMB`. Esta es una variable donde almacenamos el resultado de los cálculos en el **paso anterior** de nuestro script. Cuando `Write-Host` recibe una cadena entre comillas dobles,
se produce un proceso llamado **"Expansión de cadena" (String Expansion)**:
    1.  PowerShell ve el texto `"Todos los procesos svchost usan "`.
    2.  Luego encuentra la construcción `$memoryInMB`. Entiende que esto no es solo texto, sino una variable.
    3.  Busca en la memoria, encuentra el valor almacenado en `$memoryInMB` (por ejemplo, `1585.52`).
    4.  **Sustituye este valor** directamente en la cadena.
    5.  Luego agrega el texto restante: `" MB de memoria."`.<br>
    6.  Como resultado, la cadena lista y ensamblada se pasa a `Write-Host`: `"Todos los procesos svchost usan 1585.52 MB de memoria."`.<br>



Iniciar el Bloc de notas:
1. Encontramos el proceso del Bloc de notas y lo guardamos en la variable $notepadProcess
```powershell
$notepadProcess = Get-Process -Name notepad
```

2. Accedemos a la propiedad 'Id' de este objeto a través de la notación de puntos y la mostramos
```powershell
Write-Host "El ID del proceso 'Bloc de notas' es: $($notepadProcess.Id)"
```
![5](assets/02/5.png)

**❗ Importante:**
    `Write-Host` "rompe" el pipeline. El texto que muestra no se puede pasar más adelante en el pipeline para su procesamiento. Está destinado solo para visualización.

### 3. Get-Member (Inspector de objetos)

Sabemos que los objetos "fluyen" a través del pipeline. Pero, ¿cómo sabemos de qué están compuestos? ¿Qué propiedades tienen y qué acciones (métodos) se pueden realizar con ellos?

El cmdlet **`Get-Member`** (alias: `gm`) es la herramienta principal para la investigación.
Antes de trabajar con un objeto, páselo por `Get-Member` para ver todas sus capacidades.

Analicemos los objetos que crea `Get-Process`:
```powershell
Get-Process | Get-Member
```
![6](assets/02/6.png)

*Desglosemos cada parte de la salida de Get-Member.*

`TypeName: System.Diagnostics.Process` - Este es el nombre de tipo completo y oficial del objeto de la biblioteca .NET. Es su "pasaporte".
Esta línea le indica que todos los objetos devueltos por Get-Process son de tipo System.Diagnostics.Process.
Esto asegura que todos tendrán el mismo conjunto de propiedades y métodos.
Puede [buscar en Google](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process" para encontrar la documentación oficial de Microsoft con información aún más detallada.


- Columna 1: `Name`

Este es el **nombre** simple y legible para humanos de una propiedad, método u otro "miembro" de un objeto. Este es el nombre que usará en su código para acceder a datos o realizar acciones.


- Columna 2: `MemberType` (Tipo de objeto)

Esta es la columna más importante para entender. Clasifica **qué** es cada objeto. Es su "rol", que le dice **CÓMO** usarlo.

*   **`Property` (Propiedad):** Una **característica** o **parte de datos** almacenada dentro de un objeto. Puede "leer" su valor.
    *   *Ejemplos en la captura de pantalla:* `BasePriority`, `HandleCount`, `ExitCode`. Estos son solo datos que se pueden ver.

*   **`Method` (Método):** Una **ACCIÓN** que se puede realizar con un objeto. Los métodos siempre se llaman con paréntesis `()`.
    *   *Ejemplos en la captura de pantalla:* `Kill`, `Refresh`, `WaitForExit`. Escribiría `$process.Kill()` o `$process.Refresh()`.

*   **`AliasProperty` (Propiedad de alias):** Un **alias amigable** para otra propiedad más larga. PowerShell los agrega para mayor comodidad y brevedad.
    *   *Ejemplos en la captura de pantalla:* `WS` es un alias corto para `WorkingSet64`. `Name` es para `ProcessName`. `VM` es para `VirtualMemorySize64`.

*   **`Event` (Evento):** Una **NOTIFICACIÓN** de que algo ha sucedido, a la que se puede "suscribir".
    *   *Ejemplo en la captura de pantalla:* `Exited`. Su script puede "escuchar" este evento para realizar una acción inmediatamente después de que el proceso finalice.

*   **`CodeProperty` y `NoteProperty`:** Tipos especiales de propiedades, a menudo agregadas por el propio PowerShell para mayor comodidad. `CodeProperty` calcula su valor "sobre la marcha", mientras que `NoteProperty` es una propiedad de nota simple agregada al objeto.

- Columna 3: `Definition` (Definición)

Esta es la **definición técnica** o "firma" del miembro. Le proporciona detalles precisos para su uso. Su contenido depende de `MemberType`:

*   **Para `AliasProperty`:** Muestra **a qué es igual el alias**. ¡Esto es increíblemente útil!
    *   *Ejemplo en la captura de pantalla:* `WS = WorkingSet64`. Inmediatamente ve que `WS` es solo una abreviatura de `WorkingSet64`.

*   **Para `Property`:** Muestra el **tipo de datos** almacenado en la propiedad (por ejemplo, `int` para entero, `string` para texto, `datetime` para fecha y hora), y lo que se puede hacer con él (`{get;}` — solo lectura, `{get;set;}` — lectura y modificación).
    *   *Ejemplo en la captura de pantalla:* `int BasePriority {get;}`. Esta es una propiedad entera que solo se puede leer.

*   **Para `Method`:** Muestra lo que devuelve el método (por ejemplo, `void` — nada, `bool` — verdadero/falso) y qué **parámetros** (datos de entrada) acepta entre paréntesis.
    *   *Ejemplo en la captura de pantalla:* `void Kill()`. Esto significa que el método `Kill` no devuelve nada y se puede llamar sin parámetros. También hay una segunda versión `void Kill(bool entireProcessTree)`, que acepta un valor booleano (verdadero/falso).

#### En formato de tabla

| Columna      | ¿Qué es?                             | Ejemplo de captura de pantalla     | ¿Para qué?                                                              |
|--------------|--------------------------------------|------------------------------------|-------------------------------------------------------------------------|
| **Name**     | El nombre que usa en el código.      | `Kill`, `WS`, `Name`               | para acceder a una propiedad o método (`$process.WS`, `$process.Kill()`). |
| **MemberType**| Tipo de miembro (datos, acción, etc.). | `Method`, `Property`, `AliasProperty`| **cómo** usarlo (leer valor o llamar con `()`).                     |
| **Definition**| Detalles técnicos.                   | `WS = WorkingSet64`, `void Kill()` | qué hay detrás del alias y qué parámetros necesita el método.          |


#### Ejemplo: Trabajar con ventanas de procesos

##### 1. Problema:
"Abrí muchas ventanas del Bloc de notas. ¿Cómo puedo minimizar todas programáticamente, excepto la principal, y luego cerrar solo la que tiene la palabra 'Untitled' en su título?"

##### 2. Investigación con `Get-Member`:
Necesitamos encontrar propiedades relacionadas con la ventana y su título.

```powershell
Get-Process -Name notepad | Get-Member
```
**Análisis del resultado de `Get-Member`:**
*   Al desplazarnos por las propiedades, encontramos `MainWindowTitle`. Tipo `string`. ¡Excelente, este es el título de la ventana principal!
*   En los métodos, vemos `CloseMainWindow()`. Esta es una forma más "suave" de cerrar una ventana que `Kill()`.
*   También en los métodos, hay `WaitForInputIdle()`. Suena interesante, quizás ayude a esperar hasta que el proceso esté listo para la interacción.

![7](assets/02/7.png)

`Get-Member` nos mostró la propiedad `MainWindowTitle`, que es clave para resolver el problema y permite interactuar con los procesos en función del estado de sus ventanas, no solo por su nombre.

##### 3. Solución:
Ahora podemos construir la lógica basada en el título de la ventana.

```powershell
# 1. Encontramos todos los procesos del Bloc de notas
$notepads = Get-Process -Name notepad

# 2. Iteramos sobre cada uno y verificamos el título
foreach ($pad in $notepads) {
    # Para cada proceso ($pad), verificamos su propiedad MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Bloc de notas sin guardar encontrado (ID: $($pad.Id)). Cerrando su ventana..."
        # $pad.CloseMainWindow() # Descomentar para cerrar realmente
        Write-Host "La ventana '$($pad.MainWindowTitle)' se habría cerrado." -ForegroundColor Yellow
    } else {
        Write-Host "Saltando el Bloc de notas con título: $($pad.MainWindowTitle)"
    }
}
```

![8](assets/02/8.png)

![9](assets/02/9.png)

---

#### Ejemplo: Encontrar proceso padre

##### 1. Problema:
"A veces veo muchos procesos hijos `chrome.exe` en el sistema. ¿Cómo puedo averiguar cuál es el proceso principal, "padre" que los lanzó a todos?"

##### 2. Investigación con `Get-Member`:
Necesitamos encontrar algo que vincule un proceso con otro.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
![10](assets/02/10.png)

**Análisis del resultado de `Get-Member`:**
*   Revisando cuidadosamente la lista, encontramos una propiedad de tipo `CodeProperty` llamada `Parent`.
*   Su `Definition` es `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
Esta es una propiedad calculada que, cuando se accede a ella, devuelve el **objeto del proceso padre**.

##### 3. Solución:
Ahora podemos escribir un script que mostrará información sobre su padre para cada proceso `chrome`.

```powershell
# 1. Obtenemos todos los procesos de chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Para cada uno de ellos, mostramos información sobre él y su padre
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Obtenemos el proceso padre
    $parent = $_.Parent
    
    # Formateamos la salida de forma agradable
    Write-Host "Proceso:" -ForegroundColor Green
    Write-Host "  - Nombre: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Su padre:" -ForegroundColor Yellow
    Write-Host "  - Nombre: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
```
![11](assets/02/11.png)

![12](assets/02/12.png)

Inmediatamente vemos que los procesos con ID 4756, 7936, 8268 y 9752 fueron lanzados por el proceso con ID 14908. También podemos notar un caso interesante con el proceso ID: 7252, cuyo proceso padre no se determinó (posiblemente el padre ya había terminado en el momento de la verificación). La modificación del script con una verificación `if ($parent)` maneja este caso con elegancia sin causar un error.
`Get-Member` nos ayudó a descubrir la propiedad "oculta" `Parent`, que proporciona potentes capacidades para analizar la jerarquía de procesos.

#### 4. Archivo *.ps1* (Creación de scripts)

Cuando su cadena de comandos se vuelve útil, querrá guardarla para usarla repetidamente. Para esto sirven los **scripts** — archivos de texto con la extensión **`.ps1`**.

##### Permiso para ejecutar scripts
Por defecto, Windows prohíbe la ejecución de scripts locales. Para solucionar esto **para el usuario actual**, ejecute una vez en PowerShell **como administrador**:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
Esta es una configuración segura que le permite ejecutar sus propios scripts y scripts firmados por un editor de confianza.

##### Ejemplo de script `system_monitor.ps1`
Cree un archivo con este nombre y pegue el código a continuación. Este script recopila información del sistema y genera informes.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Script para crear un informe de estado del sistema.
.DESCRIPTION
    Recopila información sobre procesos, servicios y espacio en disco y genera informes.
.PARAMETER OutputPath
    Ruta para guardar los informes. Por defecto 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Bloque 1: Preparación ---
Write-Host "Preparando para crear informe..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Bloque 2: Recopilación de datos ---
Write-Host "Recopilando información..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Bloque 3: Llamada a la función de exportación (ver siguiente sección) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Informes guardados exitosamente en la carpeta $OutputPath" -ForegroundColor Magenta
```
*Nota: La función `Export-Results` se definirá en la siguiente sección como un ejemplo de buena práctica.*

#### 5. Exportación de resultados

Los datos limpios son buenos, pero a menudo es necesario presentarlos de una forma conveniente para el ser humano u otro programa. PowerShell ofrece muchos cmdlets para la exportación.

| Método                               | Comando                                            | Descripción                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Texto sin formato**               | `... \| Out-File C:\Temp\data.txt`                 | Redirige la representación de texto a un archivo.                                      |
| **CSV (para Excel)**                | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | Exporta objetos a CSV. `-NoTypeInfo` elimina la primera línea de servicio.     |
| **Informe HTML**                    | `... \| ConvertTo-Html -Title "Informe"`             | Crea código HTML a partir de objetos.                                                       |
| **JSON (para API, web)**            | `... \| ConvertTo-Json`                            | Convierte objetos a formato JSON.                                                  |
| **XML (formato nativo de PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml`            | Guarda objetos con todos los tipos de datos. Se pueden restaurar perfectamente a través de `Import-Clixml`. |

##### Complemento al script: función de exportación
Agreguemos a nuestro script `system_monitor.ps1` una función que se encargará de la exportación. Coloque este código **antes** de la llamada a `Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Exportar a CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Crear un bonito informe HTML
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Los 10 procesos principales por CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Estadísticas de servicios</h2>"

    ConvertTo-Html -Head "<title>Informe del sistema</title>" -Body "<h1>Informe del sistema de $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
Ahora nuestro script no solo recopila datos, sino que también los guarda cuidadosamente en dos formatos: CSV para análisis y HTML para una visualización rápida.

#### Conclusión

1.  **Pipeline (`|`)** — la herramienta principal para combinar comandos y procesar objetos.
2.  **`Get-Member`** — análisis de objetos que muestra de qué están compuestos.
3.  **Variables (`$var`, `$_`)** permiten guardar datos y acceder al objeto actual en el pipeline.
4.  **Archivos `.ps1`** convierten comandos en herramientas de automatización reutilizables.
5.  **Cmdlets de exportación** (`Export-Csv`, `ConvertTo-Html`) Exportan datos en el formato apropiado.

**En la siguiente parte, aplicaremos este conocimiento para navegar y administrar el sistema de archivos, explorando los objetos `System.IO.DirectoryInfo` y `System.IO.FileInfo`.**