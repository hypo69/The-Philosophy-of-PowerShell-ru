<h1>La Filosof√≠a de PowerShell.</h1>
<h2>Parte 0.</h2>
<p>¬øQu√© hab√≠a antes de PowerShell?
En 1981, se lanz√≥ MS-DOS 1.0 con el int√©rprete de comandos <code>COMMAND.COM</code>. Para la automatizaci√≥n de tareas, se utilizaban <strong>archivos por lotes (<code>.bat</code>)</strong>, simples archivos de texto con una secuencia de comandos de consola. Este fue un ascetismo sorprendente en la l√≠nea de comandos en comparaci√≥n con los sistemas compatibles con POSIX, donde el <strong>shell Bourne (<code>sh</code>)</strong> exist√≠a desde 1979.</p>
<h3>üìÖ Estado del mercado de los shells en el momento del lanzamiento de MS-DOS 1.0 (agosto de 1981)</h3>
<p>Aqu√≠ hay una tabla resumen de los sistemas operativos populares de la √©poca y su compatibilidad con los shells (<code>sh</code>, <code>csh</code>, etc.):</p>
<table>
<thead>
<tr>
<th>Sistema operativo</th>
<th>Compatibilidad con shells (<code>sh</code>, <code>csh</code>, etc.)</th>
<th>Comentario</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UNIX Versi√≥n 7 (V7)</strong></td>
<td><code>sh</code></td>
<td>El √∫ltimo UNIX cl√°sico de Bell Labs, muy extendido</td>
</tr>
<tr>
<td><strong>UNIX/32V</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>Versi√≥n de UNIX para la arquitectura VAX</td>
</tr>
<tr>
<td><strong>4BSD / 3BSD</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>Rama universitaria de UNIX de Berkeley</td>
</tr>
<tr>
<td><strong>UNIX System III</strong></td>
<td><code>sh</code></td>
<td>La primera versi√≥n comercial de AT&amp;T, predecesora de System V</td>
</tr>
<tr>
<td><strong>Xenix (de Microsoft)</strong></td>
<td><code>sh</code></td>
<td>Una versi√≥n con licencia de UNIX, vendida por Microsoft desde 1980</td>
</tr>
<tr>
<td><strong>IDRIS</strong></td>
<td><code>sh</code></td>
<td>Un sistema operativo similar a UNIX para PDP-11 e Intel</td>
</tr>
<tr>
<td><strong>Coherent (Mark Williams)</strong></td>
<td><code>sh</code> (similar)</td>
<td>Una alternativa econ√≥mica a UNIX para PC</td>
</tr>
<tr>
<td><strong>CP/M (Digital Research)</strong></td>
<td>‚ùå (Sin <code>sh</code>, solo una CLI muy b√°sica)</td>
<td>No es UNIX, el sistema operativo m√°s popular para PC de 8 bits</td>
</tr>
<tr>
<td><strong>MS-DOS 1.0</strong></td>
<td>‚ùå (solo <code>COMMAND.COM</code>)</td>
<td>Shell de comandos m√≠nimo, sin scripts ni tuber√≠as</td>
</tr>
</tbody>
</table>
<hr>
<h3>üí° ¬øQu√© son <code>sh</code>, <code>csh</code>?</h3>
<ul>
<li><code>sh</code> ‚Äî <strong>Bourne Shell</strong>, el principal int√©rprete de scripts de UNIX desde 1977.</li>
<li><code>csh</code> ‚Äî <strong>C Shell</strong>, un shell mejorado con una sintaxis similar a la de C y comodidades para el trabajo interactivo.</li>
<li>Estos shells <strong>admit√≠an redirecciones, tuber√≠as, variables, funciones y condiciones</strong>, todo lo que convirti√≥ a UNIX en una potente herramienta de automatizaci√≥n.</li>
</ul>
<hr>
<p>Microsoft se centr√≥ en los <strong>PC IBM de 16 bits baratos</strong>, que ten√≠an <strong>poca memoria</strong> (normalmente entre 64 y 256 KB), carec√≠an de multitarea y estaban pensados para <strong>uso dom√©stico y de oficina</strong>, no para servidores. UNIX era caro, requer√≠a una arquitectura y unos conocimientos complejos, mientras que los contables e ingenieros, que no eran administradores de sistemas, necesitaban un sistema operativo r√°pido y sencillo.</p>
<p>En lugar del complejo <code>sh</code>, la interfaz de DOS proporcionaba un √∫nico archivo, command.com, con un escaso conjunto de comandos internos [ (dir, copy, del, etc.)]<a href="https://www.techgeekbuzz.com/blog/dos-commands/" target="_blank">(dir, copy, del, etc.)</a> sin funciones, bucles ni m√≥dulos.</p>
<p>Tambi√©n hab√≠a comandos externos: archivos ejecutables independientes (.exe o .com). Ejemplos: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Los scripts de ejecuci√≥n se escrib√≠an en un archivo de texto con la extensi√≥n .bat (archivo por lotes).</p>
<p>Ejemplos de archivos de configuraci√≥n:</p>
<ul>
<li>AUTOEXEC.BAT</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Configuraci√≥n y arranque autom√°ticos de Windows 3.11
:: Autor: hypo69
:: A√±o: aproximadamente 1993
:: Prop√≥sito: Inicializa el entorno DOS, carga los controladores de red e inicia Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Establecer el s√≠mbolo del sistema
PROMPT $p$g

:: Establecer variables de entorno
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Cargar controladores y utilidades en la memoria alta
LH C:\DOS\SMARTDRV.EXE       :: Cach√© de disco
LH C:\DOS\MOUSE.COM          :: Controlador del rat√≥n

:: Cargar servicios de red (relevante para Windows para Trabajo en Grupo 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Iniciar Windows autom√°ticamente
WIN
</code></pre>
<ul>
<li>CONFIG.SYS</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî Configuraci√≥n de la memoria y los controladores de DOS para Windows 3.11
:: Autor: hypo69
:: A√±o: aproximadamente 1993
:: Prop√≥sito: Inicializa los controladores de memoria, configura los par√°metros del sistema
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE
</code></pre>
<p>Paralelamente a DOS, Microsoft comenz√≥ a desarrollar casi de inmediato un n√∫cleo fundamentalmente nuevo.</p>
<p>El n√∫cleo <a href="https://www.wikiwand.com/ru/articles/Windows_NT" target="_blank"><strong>Windows NT</strong></a> (Nueva Tecnolog√≠a) apareci√≥ por primera vez con el lanzamiento del sistema operativo:</p>
<blockquote>
<p><strong>Windows NT 3.1 ‚Äî 27 de julio de 1993</strong></p>
</blockquote>
<hr>
<ul>
<li><strong>El desarrollo comenz√≥</strong>: en <strong>1988</strong> bajo la direcci√≥n de <strong>Dave Cutler</strong> (un exingeniero de DEC y creador de VMS) con el objetivo de crear un sistema operativo completamente nuevo, seguro, port√°til y multitarea, no compatible con MS-DOS a nivel de n√∫cleo.</li>
<li><strong>NT 3.1</strong>: se llam√≥ as√≠ para enfatizar la compatibilidad con <strong>Windows 3.1</strong> a nivel de interfaz, pero era una <strong>arquitectura completamente nueva</strong>.</li>
</ul>
<hr>
<h4>üß† Lo que aport√≥ el n√∫cleo NT:</h4>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th>Descripci√≥n</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Arquitectura de 32 bits</strong></td>
<td>A diferencia de MS-DOS y Windows 3.x, que eran de 16 bits.</td>
</tr>
<tr>
<td><strong>Multitarea</strong></td>
<td>Verdadera multitarea apropiativa.</td>
</tr>
<tr>
<td><strong>Memoria protegida</strong></td>
<td>Los programas no pod√≠an da√±ar la memoria de los dem√°s.</td>
</tr>
<tr>
<td><strong>Modularidad</strong></td>
<td>Arquitectura del n√∫cleo de varias capas: HAL, Ejecutivo, N√∫cleo, controladores.</td>
</tr>
<tr>
<td><strong>Compatibilidad con multiplataforma</strong></td>
<td>NT 3.1 se ejecutaba en x86, MIPS y Alpha.</td>
</tr>
<tr>
<td><strong>Compatibilidad con POSIX</strong></td>
<td>NT ven√≠a con un <strong>subsistema POSIX</strong>, certificado seg√∫n POSIX.1.</td>
</tr>
</tbody>
</table>
<hr>
<h4>üìú El linaje de NT:</h4>
<table>
<thead>
<tr>
<th>Versi√≥n de NT</th>
<th>A√±o</th>
<th>Comentario</th>
</tr>
</thead>
<tbody>
<tr>
<td>NT 3.1</td>
<td>1993</td>
<td>Primer lanzamiento de NT</td>
</tr>
<tr>
<td>NT 3.5 / 3.51</td>
<td>1994‚Äì1995</td>
<td>Mejoras, optimizaci√≥n</td>
</tr>
<tr>
<td>NT 4.0</td>
<td>1996</td>
<td>Interfaz de Windows 95, pero n√∫cleo de NT</td>
</tr>
<tr>
<td>Windows 2000</td>
<td>2000</td>
<td>NT 5.0</td>
</tr>
<tr>
<td>Windows XP</td>
<td>2001</td>
<td>NT 5.1</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>2007</td>
<td>NT 6.0</td>
</tr>
<tr>
<td>Windows 10</td>
<td>2015</td>
<td>NT 10.0</td>
</tr>
<tr>
<td>Windows 11</td>
<td>2021</td>
<td>Tambi√©n NT 10.0 (marketing üòä)</td>
</tr>
</tbody>
</table>
<hr>
<p>Diferencia en las capacidades del sistema operativo:</p>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th><strong>MS-DOS</strong> (1981)</th>
<th><strong>Windows NT</strong> (1993)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tipo de sistema</strong></td>
<td>Monol√≠tico, monotarea</td>
<td>Micron√∫cleo/h√≠brido, multitarea</td>
</tr>
<tr>
<td><strong>Arquitectura</strong></td>
<td>16 bits</td>
<td>32 bits (con compatibilidad con 64 bits desde NT 5.2 / XP x64)</td>
</tr>
<tr>
<td><strong>Multitarea</strong></td>
<td>‚ùå Ausente (un proceso a la vez)</td>
<td>‚úÖ Multitarea apropiativa</td>
</tr>
<tr>
<td><strong>Memoria protegida</strong></td>
<td>‚ùå No</td>
<td>‚úÖ S√≠ (cada proceso en su propio espacio de direcciones)</td>
</tr>
<tr>
<td><strong>Modo multiusuario</strong></td>
<td>‚ùå No</td>
<td>‚úÖ Parcialmente (en NT Workstation/Server)</td>
</tr>
<tr>
<td><strong>Compatibilidad con POSIX</strong></td>
<td>‚ùå No</td>
<td>‚úÖ Subsistema POSIX integrado en NT 3.1‚Äì5.2</td>
</tr>
<tr>
<td><strong>Portabilidad del n√∫cleo</strong></td>
<td>‚ùå Solo x86</td>
<td>‚úÖ x86, MIPS, Alpha, PowerPC</td>
</tr>
<tr>
<td><strong>Controladores</strong></td>
<td>Acceso directo al hardware</td>
<td>A trav√©s de HAL y controladores en modo n√∫cleo</td>
</tr>
<tr>
<td><strong>Nivel de acceso de las aplicaciones</strong></td>
<td>Aplicaciones = nivel de sistema</td>
<td>Niveles de usuario/n√∫cleo separados</td>
</tr>
<tr>
<td><strong>Seguridad</strong></td>
<td>‚ùå Ausente</td>
<td>‚úÖ Modelo de seguridad: SID, ACL, tokens de acceso</td>
</tr>
<tr>
<td><strong>Estabilidad</strong></td>
<td>‚ùå La dependencia de un programa = fallo del sistema operativo</td>
<td>‚úÖ Aislamiento de procesos, protecci√≥n del n√∫cleo</td>
</tr>
</tbody>
</table>
<hr>
<p>¬°Pero hab√≠a un gran PERO! No se prest√≥ la debida atenci√≥n a las herramientas de automatizaci√≥n y administraci√≥n hasta 2002.</p>
<hr>
<p>Microsoft utiliz√≥ enfoques, estrategias y herramientas completamente diferentes para la administraci√≥n. Todo esto era <strong>disperso</strong>, a menudo orientado a la GUI y no siempre automatizable.</p>
<hr>
<h5>üìå Lista de algunas herramientas:</h5>
<table>
<thead>
<tr>
<th>Herramienta</th>
<th>Prop√≥sito</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmd.exe</code></td>
<td>Int√©rprete de comandos mejorado (reemplazo de <code>COMMAND.COM</code>)</td>
</tr>
<tr>
<td><code>.bat</code>, <code>.cmd</code></td>
<td>Scripts de l√≠nea de comandos</td>
</tr>
<tr>
<td><strong>Windows Script Host (WSH)</strong></td>
<td>Compatibilidad con VBScript y JScript para la automatizaci√≥n</td>
</tr>
<tr>
<td><code>reg.exe</code></td>
<td>Administrar el registro desde la l√≠nea de comandos</td>
</tr>
<tr>
<td><code>net.exe</code></td>
<td>Trabajar con usuarios, redes, impresoras</td>
</tr>
<tr>
<td><code>sc.exe</code></td>
<td>Administrar servicios</td>
</tr>
<tr>
<td><code>tasklist</code>, <code>taskkill</code></td>
<td>Administrar procesos</td>
</tr>
<tr>
<td><code>gpedit.msc</code></td>
<td>Directiva de grupo (local)</td>
</tr>
<tr>
<td><code>MMC</code></td>
<td>Consola con complementos para la administraci√≥n</td>
</tr>
<tr>
<td><code>WMI</code></td>
<td>Acceder a la informaci√≥n del sistema (a trav√©s de <code>wmic</code>, VBScript o COM)</td>
</tr>
<tr>
<td><code>WbemTest.exe</code></td>
<td>GUI para probar consultas WMI</td>
</tr>
<tr>
<td><code>eventvwr</code></td>
<td>Ver registros de eventos</td>
</tr>
<tr>
<td><code>perfmon</code></td>
<td>Supervisar recursos</td>
</tr>
</tbody>
</table>
<h5>üõ† Ejemplos de automatizaci√≥n:</h5>
<ul>
<li>Archivos VBScript (<code>*.vbs</code>) para administrar usuarios, redes, impresoras y servicios.</li>
<li><code>WMIC</code>: interfaz de l√≠nea de comandos para WMI (p. ej.: <code>wmic process list brief</code>).</li>
<li>Scripts <code>.cmd</code> con llamadas a <code>net</code>, <code>sc</code>, <code>reg</code>, <code>wmic</code>, etc.</li>
</ul>
<hr>
<h3>‚öôÔ∏è Windows Scripting Host (WSH)</h3>
<ul>
<li>Apareci√≥ por primera vez en <strong>Windows 98</strong>, se utiliz√≥ activamente en <strong>Windows 2000 y XP</strong>.</li>
<li>Permit√≠a ejecutar archivos VBScript y JScript desde la l√≠nea de comandos:</li>
</ul>
<pre class="line-numbers"><code class="language-vbscript">  Set objShell = WScript.CreateObject("WScript.Shell")
  objShell.Run "notepad.exe"
</code></pre>
<hr>
<h2>Parte 1.</h2>
<p>Solo en 2002 la empresa formul√≥ el proyecto <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, que m√°s tarde se convirti√≥ en PowerShell:</p>
<p>Inicio del desarrollo: aproximadamente en 2002</p>
<p>Anuncio p√∫blico: 2003, como "Monad Shell"</p>
<p>Primeras versiones beta: aparecieron en 2005</p>
<p>Lanzamiento final (PowerShell 1.0): noviembre de 2006</p>
<p>El autor y arquitecto jefe del proyecto Monad / PowerShell es Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a></p>
<p>Hoy en d√≠a, PowerShell Core se ejecuta en
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a></p>
<p>Paralelamente, se estaba desarrollando el framework .NET y PowerShell estaba profundamente integrado en √©l. En los pr√≥ximos cap√≠tulos, mostrar√© ejemplos.</p>
<p>¬°Y ahora, lo m√°s importante!</p>
<p>La principal ventaja de PowerShell en comparaci√≥n con los shells de comandos cl√°sicos es que funciona con <em>objetos</em>, no con texto. Cuando se ejecuta un comando, no devuelve solo texto, sino un objeto estructurado (o una colecci√≥n de objetos) que tiene propiedades y m√©todos claramente definidos.</p>
<p>Vea c√≥mo PowerShell supera a los shells cl√°sicos gracias al <strong>trabajo con objetos</strong></p>
<h3>üìÅ La forma antigua: <code>dir</code> y el an√°lisis manual</h3>
<p>En <strong>CMD</strong> (tanto en el antiguo <code>COMMAND.COM</code> como en <code>cmd.exe`), el comando <code>dir</code> devuelve el resultado como texto sin formato. Salida de ejemplo:</p>
<pre class="line-numbers"><code>24.07.2025  21:15         1.428  my_script.js
25.07.2025  08:01         3.980  report.html
</code></pre>
<p>Supongamos que desea extraer el <strong>nombre del archivo</strong> y el <strong>tama√±o</strong> de cada archivo. Tendr√≠a que analizar las cadenas manualmente:
<pre class="line-numbers"><code class="language-cmd">for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
</code></pre>
</p>
<ul>
<li>Esto es terriblemente dif√≠cil de leer, depende de la configuraci√≥n regional, el formato de la fecha y la fuente. Y se rompe con los espacios en los nombres.</li>
</ul>
<hr>
<h3>‚úÖ PowerShell: objetos en lugar de texto</h3>
<h4>‚úî Ejemplo simple y legible:</h4>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem | Select-Object Name, Length
</code></pre>
<p><strong>Resultado:</strong></p>
<pre class="line-numbers"><code>Name          Length
----          ------
my_script.js   1428
report.html    3980
</code></pre>
<ul>
<li><code>Get-ChildItem</code> devuelve una <strong>matriz de objetos de archivo/carpeta</strong></li>
<li><code>Select-Object</code> le permite obtener f√°cilmente las <strong>propiedades</strong> requeridas</li>
</ul>
<hr>
<h3>üîç ¬øQu√© devuelve realmente <code>Get-ChildItem</code>?</h3>
<pre class="line-numbers"><code class="language-powershell">$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
</code></pre>
<p><strong>Resultado:</strong></p>
<pre class="line-numbers"><code>TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
</code></pre>
<p>PowerShell devuelve <strong>objetos <code>System.IO.FileInfo</code></strong>, que tienen:</p>
<ul>
<li>üß± Propiedades (<code>Name</code>, <code>Length</code>, <code>CreationTime</code>, <code>Extension</code>, ‚Ä¶)</li>
<li>üõ† M√©todos (<code>Delete()</code>, <code>CopyTo()</code>, <code>MoveTo()</code>, etc.)</li>
</ul>
<p>Usted trabaja <strong>con objetos completos</strong>, no con cadenas.</p>
<hr>
<h3>Sintaxis "Verbo-Sustantivo":</h3>
<p>PowerShell utiliza una <strong>sintaxis de comandos estricta y l√≥gica</strong>:
<code>Verbo-Sustantivo</code></p>
<table>
<thead>
<tr>
<th>Verbo</th>
<th>Qu√© hace</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Get-</code></td>
<td>Obtener</td>
</tr>
<tr>
<td><code>Set-</code></td>
<td>Establecer</td>
</tr>
<tr>
<td><code>New-</code></td>
<td>Crear</td>
</tr>
<tr>
<td><code>Remove-</code></td>
<td>Eliminar</td>
</tr>
<tr>
<td><code>Start-</code></td>
<td>Iniciar</td>
</tr>
<tr>
<td><code>Stop-</code></td>
<td>Detener</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Sustantivo</th>
<th>Sobre qu√© funciona</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Process</code></td>
<td>Proceso</td>
</tr>
<tr>
<td><code>Service</code></td>
<td>Servicio</td>
</tr>
<tr>
<td><code>Item</code></td>
<td>Archivo/carpeta</td>
</tr>
<tr>
<td><code>EventLog</code></td>
<td>Registros de eventos</td>
</tr>
<tr>
<td><code>Computer</code></td>
<td>Ordenador</td>
</tr>
</tbody>
</table>
<h4>üîÑ Ejemplos:</h4>
<table>
<thead>
<tr>
<th>Qu√© hacer</th>
<th>Comando</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obtener procesos</td>
<td><code>Get-Process</code></td>
</tr>
<tr>
<td>Detener un servicio</td>
<td><code>Stop-Service</code></td>
</tr>
<tr>
<td>Crear un nuevo archivo</td>
<td><code>New-Item</code></td>
</tr>
<tr>
<td>Obtener el contenido de la carpeta</td>
<td><code>Get-ChildItem</code></td>
</tr>
<tr>
<td>Eliminar un archivo</td>
<td><code>Remove-Item</code></td>
</tr>
</tbody>
</table>
<p>‚û° Incluso si <strong>no conoce el comando exacto</strong>, puede <strong>adivinarlo</strong> por el significado, y casi siempre acertar√°.</p>
<hr>
<p>El cmdlet <code>Get-Help</code> es su principal ayudante.</p>
<ol>
<li><strong>Obtener ayuda sobre la propia ayuda:</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Help
</code></pre>
</li>
<li><strong>Obtener ayuda b√°sica sobre el comando para trabajar con procesos:</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Process
</code></pre>
</li>
<li><strong>Ver ejemplos de uso de este comando:</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Process -Examples
</code></pre>
<p>Este es un par√°metro incre√≠blemente √∫til que a menudo proporciona soluciones listas para usar para sus tareas.</p>
</li>
<li><strong>Obtener la informaci√≥n m√°s detallada sobre el comando:</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Process -Full
</code></pre>
</li>
</ol>
<p>En la siguiente parte: la canalizaci√≥n o cadena de comandos (PipeLines)</p>