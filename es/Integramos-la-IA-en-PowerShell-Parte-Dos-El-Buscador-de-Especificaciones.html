<h2>Integramos la IA en PowerShell. Parte Dos: El Buscador de Especificaciones</h2>
<p>La √∫ltima vez, vimos c√≥mo podemos interactuar con el modelo <code>Gemini</code> a trav√©s de la interfaz de l√≠nea de comandos usando <code>PowerShell</code>. En este art√≠culo, les mostrar√© c√≥mo beneficiarse de nuestro conocimiento. Convertiremos nuestra consola en una gu√≠a de referencia interactiva que tomar√° un identificador de componente (marca, modelo, categor√≠a, n√∫mero de pieza, etc.) como entrada y devolver√° una tabla interactiva con las especificaciones obtenidas del modelo <code>Gemini</code>.</p>
<p>Ingenieros, desarrolladores y otros especialistas a menudo se enfrentan a la necesidad de conocer los par√°metros exactos de, por ejemplo, una placa base, un disyuntor en un cuadro el√©ctrico o un conmutador de red. Nuestra gu√≠a de referencia estar√° siempre a mano y, previa solicitud, recopilar√° informaci√≥n, aclarar√° par√°metros en Internet y devolver√° la tabla deseada. En la tabla, podr√° seleccionar los par√°metros necesarios y, si es preciso, continuar con una b√∫squeda m√°s profunda. M√°s adelante, aprenderemos a pasar el resultado por la tuber√≠a para su posterior procesamiento: exportaci√≥n a una hoja de c√°lculo de <code>Excel</code> o <code>Google</code>, almacenamiento en una base de datos o transferencia a otro programa. En caso de fallo, el modelo aconsejar√° qu√© par√°metros deben aclararse. Pero v√©anlo ustedes mismos:</p>
<p><a href="https://github.com/user-attachments/assets/0e6690c1-5d49-4c75-89fc-ede2c7642c5f">v√≠deo</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/0e6690c1-5d49-4c75-89fc-ede2c7642c5f" type="video/mp4">
  Your browser does not support the video tag.
</video>
<h2>C√≥mo funciona el Buscador de Especificaciones impulsado por IA: del lanzamiento al resultado</h2>
<p>Analicemos el ciclo de vida completo de nuestro script: qu√© sucede desde el momento de su lanzamiento hasta la obtenci√≥n de los resultados.</p>
<h2>Inicializaci√≥n: Preparaci√≥n para el trabajo</h2>
<p>El script acepta un par√°metro <code>$Model</code> con validaci√≥n: puede elegir '<code>gemini-2.5-flash</code>' (el modelo r√°pido predeterminado) o '<code>gemini-2.5-pro</code>' (m√°s potente). Al iniciar, el script primero configura el entorno de trabajo. Establece la clave <code>API</code> para acceder a <code>Gemini AI</code>, define la carpeta actual como directorio base y crea una estructura para almacenar archivos. Para cada sesi√≥n, se crea un archivo con una marca de tiempo, por ejemplo, <code>ai_session_2025-08-26_14-30-15.jsonl</code>. Este es el historial de di√°logo.</p>
<p>A continuaci√≥n, el sistema verifica que todas las herramientas necesarias est√©n instaladas. Busca el <code>CLI</code> de <code>Gemini</code> en el sistema y verifica los archivos de configuraci√≥n en la carpeta <code>.gemini/</code>. El archivo <code>GEMINI.md</code> es particularmente importante: contiene el prompt del sistema para el modelo y es cargado autom√°ticamente por el <code>CLI</code> de <code>Gemini</code> al inicio. Esta es la ubicaci√≥n est√°ndar para las instrucciones del sistema. Tambi√©n se verifica el archivo <code>ShowHelp.md</code>, que contiene informaci√≥n de ayuda. Si falta algo cr√≠tico, el script advierte al usuario o termina.</p>
<h2>Inicio del modo interactivo</h2>
<p>Despu√©s de una inicializaci√≥n exitosa, el script muestra un mensaje de bienvenida que indica el modelo seleccionado ("Buscador de Especificaciones de <code>IA</code>. Modelo: '<code>gemini-2.5-flash</code>'."), la ruta al archivo de sesi√≥n e instrucciones para los comandos. Luego, entra en modo interactivo: muestra un prompt y espera la entrada del usuario. El prompt se ve como <code>ü§ñAI :) > </code> y cambia a <code>ü§ñAI [Selecci√≥n activa] :) > </code> cuando el sistema tiene datos para analizar.</p>
<h2>Procesamiento de la entrada del usuario</h2>
<p>Cada entrada del usuario se verifica primero para comandos de servicio mediante la funci√≥n <code>Command-Handler</code>. Esta funci√≥n reconoce comandos como <code>?</code> (ayuda del archivo <code>ShowHelp.md</code>), <code>history</code> (mostrar historial de sesi√≥n), <code>clear</code> y <code>clear-history</code> (borrar el archivo de historial), <code>gemini help</code> (ayuda del <code>CLI</code>), y <code>exit</code> y <code>quit</code> (salir). Si es un comando de servicio, se ejecuta inmediatamente sin contactar a la <code>IA</code>, y el bucle contin√∫a.</p>
<p>Si es una consulta regular, el sistema comienza a construir el contexto para enviar a <code>Gemini</code>. Lee el historial completo de la sesi√≥n actual del archivo <code>JSONL</code> (si existe), agrega un bloque con datos de la selecci√≥n anterior (si hay una selecci√≥n activa) y combina todo esto con la nueva consulta del usuario en un prompt estructurado con las secciones "HISTORIAL DE DI√ÅLOGO", "DATOS DE LA SELECCI√ìN" y "NUEVA TAREA". Despu√©s de su uso, los datos de selecci√≥n se borran.</p>
<h2>Interacci√≥n con la Inteligencia Artificial</h2>
<p>El prompt formado se env√≠a a <code>Gemini</code> a trav√©s de la l√≠nea de comandos con la llamada <code>& gemini -m $Model -p $Prompt 2>&1</code>. El sistema captura toda la salida (incluidos los errores a trav√©s de <code>2>&1</code>), verifica el c√≥digo de retorno y limpia el resultado de los mensajes de servicio del <code>CLI</code> ("La recopilaci√≥n de datos est√° deshabilitada" y "Credenciales en cach√© cargadas"). Si ocurre un error en esta etapa, el usuario recibe una advertencia, pero el script contin√∫a ejecut√°ndose.</p>
<h2>Procesamiento de la respuesta de la IA</h2>
<p>El sistema intenta interpretar la respuesta recibida de la <code>IA</code> como <code>JSON</code>. Primero, busca un bloque de c√≥digo en el formato <code>```json...```</code>, extrae el contenido e intenta analizarlo. Si no hay tal bloque, analiza toda la respuesta. Si el an√°lisis es exitoso, los datos se muestran en una tabla interactiva <code>Out-ConsoleGridView</code> con el t√≠tulo "Seleccionar filas para la siguiente consulta (OK) o cerrar (Cancelar)" y la selecci√≥n m√∫ltiple habilitada. Si el <code>JSON</code> no se reconoce (error de an√°lisis), la respuesta se muestra como texto sin formato en azul.</p>
<h2>Trabajar con la selecci√≥n de datos</h2>
<p>Cuando el usuario selecciona filas en la tabla y hace clic en <code>OK</code>, el sistema realiza varias acciones. Primero, se llama a la funci√≥n <code>Show-SelectionTable</code>, que analiza la estructura de los datos seleccionados: si son objetos con propiedades, identifica todos los campos √∫nicos y muestra los datos usando <code>Format-Table</code> con ajuste autom√°tico de tama√±o y ajuste de l√≠nea. Si son valores simples, los muestra como una lista numerada. Luego, muestra un contador de los elementos seleccionados y el mensaje "Selecci√≥n guardada. Agregue su pr√≥xima consulta (por ejemplo, 'comp√°relos')."</p>
<p>Los datos seleccionados se convierten a un <code>JSON</code> comprimido con una profundidad de anidamiento de 10 niveles y se guardan en la variable <code>$selectionContextJson</code> para su uso en solicitudes posteriores a la <code>IA</code>.</p>
<h2>Mantenimiento del historial</h2>
<p>Cada par "consulta de usuario - respuesta de <code>IA</code>" se guarda en el archivo de historial en formato <code>JSONL</code>. Esto asegura la continuidad del di√°logo: la <code>IA</code> "recuerda" toda la conversaci√≥n anterior y puede referirse a temas discutidos previamente.</p>
<h2>El ciclo contin√∫a</h2>
<p>Despu√©s de procesar la solicitud, el sistema vuelve a esperar una nueva entrada. Si el usuario tiene una selecci√≥n activa, esto se refleja en el prompt de la l√≠nea de comandos. El ciclo contin√∫a hasta que el usuario ingresa un comando de salida.</p>
<h2>Ejemplo pr√°ctico de funcionamiento</h2>
<p>Imagine que un usuario ejecuta el script y escribe "<code>RTX 4070 Ti Super</code>":</p>
<ul>
<li><strong>Preparaci√≥n del contexto:</strong> El sistema toma el prompt del sistema del archivo, agrega el historial (actualmente vac√≠o) y la nueva consulta.</li>
<li><strong>Solicitud a la <code>IA</code>:</strong> El prompt completo se env√≠a a <code>Gemini</code> con una solicitud para encontrar las especificaciones de las tarjetas de video.</li>
<li><strong>Recuperaci√≥n de datos:</strong> La <code>IA</code> devuelve un <code>JSON</code> con una matriz de objetos que contienen informaci√≥n sobre varios modelos de <code>RTX 4070 Ti Super</code>.</li>
<li><strong>Tabla interactiva:</strong> El usuario ve una tabla con fabricantes, especificaciones y precios, y selecciona 2-3 modelos de inter√©s.</li>
<li><strong>Visualizaci√≥n de la selecci√≥n:</strong> Aparece una tabla con los modelos seleccionados en la consola, y el prompt cambia a <code>[Selecci√≥n activa]</code>.</li>
<li><strong>Refinar consulta:</strong> El usuario escribe "comparar su rendimiento en juegos".</li>
<li><strong>An√°lisis contextual:</strong> La <code>IA</code> recibe la consulta inicial, los modelos seleccionados y la nueva pregunta, proporcionando una comparaci√≥n detallada de esas tarjetas espec√≠ficas.</li>
</ul>
<h2>Terminaci√≥n</h2>
<p>Cuando se ingresa <code>exit</code> o <code>quit</code>, el script termina correctamente, habiendo guardado todo el historial de la sesi√≥n en un archivo. El usuario puede volver a este di√°logo en cualquier momento viendo el contenido del archivo correspondiente en la carpeta <code>.chat_history</code>.</p>
<p>Toda esta l√≥gica compleja est√° oculta al usuario detr√°s de una interfaz de l√≠nea de comandos simple. La persona simplemente hace preguntas y recibe respuestas estructuradas, mientras que el sistema se encarga de todo el trabajo de mantener el contexto, analizar datos y administrar el estado del di√°logo.</p>
<hr>
<h2>Paso 1: Configuraci√≥n</h2>
<pre class="line-numbers"><code class="language-powershell"># --- Paso 1: Configuraci√≥n ---
$env:GEMINI_API_KEY = "AIzaSyCbq8bkt5Xr2hlE-73MIXFpdFYH-rLBd0k"
if (-not $env:GEMINI_API_KEY) { Write-Error "..."; return }

$scriptRoot = Get-Location
# --- CAMBIO: Variable renombrada ---
$HistoryDir = Join-Path $scriptRoot ".gemini/.chat_history"
# --- FIN DEL CAMBIO ---
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$historyFileName = "ai_session_$timestamp.jsonl"
$historyFilePath = Join-Path $HistoryDir $historyFileName
</code></pre>
<p><strong>Prop√≥sito de las l√≠neas:</strong></p>
<ul>
<li><code>$env:GEMINI_API_KEY = "..."</code> - establece la clave <code>API</code> para acceder a <code>Gemini AI</code>.</li>
<li><code>if (-not $env:GEMINI_API_KEY)</code> - verifica la presencia de la clave y termina el script si falta.</li>
<li><code>$scriptRoot = Get-Location</code> - obtiene el directorio de trabajo actual.</li>
<li><code>$HistoryDir = Join-Path...</code> - forma la ruta a la carpeta para almacenar el historial de di√°logos (<code>.gemini/.chat_history</code>).</li>
<li><code>$timestamp = Get-Date...</code> - crea una marca de tiempo en el formato <code>2025-08-26_14-30-15</code>.</li>
<li><code>$historyFileName = "ai_session_$timestamp.jsonl"</code> - genera un nombre de archivo de sesi√≥n √∫nico.</li>
<li><code>$historyFilePath = Join-Path...</code> - crea la ruta completa al archivo de historial de la sesi√≥n actual.</li>
</ul>
<h2>Verificaci√≥n del entorno - Qu√© debe instalarse</h2>
<pre class="line-numbers"><code class="language-powershell"># --- Paso 2: Verificaci√≥n del entorno ---
try { Get-Command gemini -ErrorAction Stop | Out-Null } 
catch { Write-Error "El comando 'gemini' no se encontr√≥..."; return }

if (-not (Test-Path (Join-Path $scriptRoot ".gemini/GEMINI.md"))) { 
    Write-Warning "El archivo de prompt del sistema .gemini/GEMINI.md no se encontr√≥..." 
}
if (-not (Test-Path (Join-Path $scriptRoot ".gemini/ShowHelp.md"))) { 
    Write-Warning "El archivo de ayuda .gemini/ShowHelp.md no se encontr√≥..." 
}
</code></pre>
<p><strong>Qu√© se verifica:</strong></p>
<ul>
<li>La presencia de <strong><code>Gemini CLI</code></strong> en el sistema: el script no funcionar√° sin √©l.</li>
<li>El archivo <strong><code>GEMINI.md</code></strong>: contiene el prompt del sistema (instrucciones para la <code>IA</code>).</li>
<li>El archivo <strong><code>ShowHelp.md</code></strong>: ayuda al usuario (el comando <code>?</code>).</li>
</ul>
<h2>Funci√≥n principal para interactuar con la IA</h2>
<pre class="line-numbers"><code class="language-powershell">function Invoke-GeminiPrompt {
    param([string]$Prompt, [string]$Model)
    try {
        $output = & gemini -m $Model -p $Prompt 2>&1
        if (-not $?) { $output | ForEach-Object { Write-Warning $_.ToString() }; return $null }
        
        $outputString = ($output -join [Environment]::NewLine).Trim()
        $cleanedOutput = $outputString -replace "(?m)^Data collection is disabled\.`r?`n" , ""
        $cleanedOutput = $cleanedOutput -replace "(?m)^Loaded cached credentials\.`r?`n", ""
        
        return $cleanedOutput.Trim()
    }
    catch { Write-Error "Error cr√≠tico al llamar a Gemini CLI: $_"; return $null }
}
</code></pre>
<p><strong>Tareas de la funci√≥n:</strong></p>
<ul>
<li>Llama al <code>CLI Gemini</code> con el modelo y el prompt especificados.</li>
<li>Captura toda la salida (incluidos los errores).</li>
<li>Limpia el resultado de los mensajes de servicio del <code>CLI</code>.</li>
<li>Devuelve la respuesta limpia de la <code>IA</code> o <code>$null</code> en caso de error.</li>
</ul>
<h2>Funciones de gesti√≥n del historial</h2>
<pre class="line-numbers"><code class="language-powershell">function Add-History { 
    param([string]$UserPrompt, [string]$ModelResponse)
    if (-not (Test-Path $HistoryDir)) { New-Item -Path $HistoryDir -ItemType Directory | Out-Null }
    @{ user = $UserPrompt } | ConvertTo-Json -Compress | Add-Content -Path $historyFilePath
    @{ model = $ModelResponse } | ConvertTo-Json -Compress | Add-Content -Path $historyFilePath
}

function Show-History {
    if (-not (Test-Path $historyFilePath)) { Write-Host "El historial de la sesi√≥n actual est√° vac√≠o." -ForegroundColor Yellow; return }
    Write-Host "`n--- Historial de la sesi√≥n actual ---" -ForegroundColor Cyan
    Get-Content -Path $historyFilePath
    Write-Host "------------------------------------`n" -ForegroundColor Cyan
}

function Clear-History {
    if (Test-Path $historyFilePath) {
        Remove-Item -Path $historyFilePath -Force -ErrorAction Stop
        Write-Host "El historial de la sesi√≥n actual ($historyFileName) ha sido eliminado." -ForegroundColor Yellow
    }
}
</code></pre>
<p><strong>Prop√≥sito:</strong></p>
<ul>
<li><code>Add-History</code>: guarda pares "pregunta-respuesta" en formato <code>JSONL</code>.</li>
<li><code>Show-History</code>: muestra el contenido del archivo de historial.</li>
<li><code>Clear-History</code>: elimina el archivo de historial de la sesi√≥n actual.</li>
</ul>
<h2>Funci√≥n para mostrar datos seleccionados</h2>
<pre class="line-numbers"><code class="language-powershell">function Show-SelectionTable {
    param([array]$SelectedData)
    
    if ($null -eq $SelectedData -or $SelectedData.Count -eq 0) { return }
    
    Write-Host "`n--- DATOS SELECCIONADOS ---" -ForegroundColor Yellow
    
    # Obtener todas las propiedades √∫nicas de los objetos seleccionados
    $allProperties = @()
    foreach ($item in $SelectedData) {
        if ($item -is [PSCustomObject]) {
            $properties = $item | Get-Member -MemberType Properties | Select-Object -ExpandProperty Name
            $allProperties = $allProperties + $properties | Sort-Object -Unique
        }
    }
    
    # Mostrar una tabla o una lista
    if ($allProperties.Count -gt 0) {
        $SelectedData | Format-Table -Property $allProperties -AutoSize -Wrap
    } else {
        for ($i = 0; $i -lt $SelectedData.Count; $i++) {
            Write-Host "[$($i + 1)] $($SelectedData[$i])" -ForegroundColor White
        }
    }
    
    Write-Host "-------------------------" -ForegroundColor Yellow
    Write-Host "Elementos seleccionados: $($SelectedData.Count)" -ForegroundColor Magenta
}
</code></pre>
<p><strong>Tarea de la funci√≥n:</strong> Despu√©s de seleccionar elementos en <code>Out-ConsoleGridView</code>, los muestra en la consola como una tabla ordenada, para que el usuario pueda ver exactamente lo que se eligi√≥.</p>
<h2>Bucle de trabajo principal</h2>
<pre class="line-numbers"><code class="language-powershell">while ($true) {
    # Mostrar prompt con indicador de estado
    if ($selectionContextJson) {
        Write-Host -NoNewline -ForegroundColor Green "ü§ñAI [Selecci√≥n activa] :) > "
    } else {
        Write-Host -NoNewline -ForegroundColor Green "ü§ñAI :) > "
    }
    
    $UserPrompt = Read-Host
    
    # Manejar comandos de servicio
    $commandResult = Command-Handler -Command $UserPrompt
    if ($commandResult -eq 'break') { break }
    if ($commandResult -eq 'continue') { continue }
    
    # Formar el prompt completo con contexto
    $fullPrompt = @"
### HISTORIAL DE DI√ÅLOGO (CONTEXTO)
$historyContent

### DATOS DE LA SELECCI√ìN (PARA AN√ÅLISIS)
$selectionContextJson

### NUEVA TAREA
$UserPrompt
"@
    
    # Llamar a la IA y procesar la respuesta
    $ModelResponse = Invoke-GeminiPrompt -Prompt $fullPrompt -Model $Model
    
    # Intentar analizar JSON y mostrar la tabla interactiva
    try {
        $jsonObject = $jsonToParse | ConvertFrom-Json
        $gridSelection = $jsonObject | Out-ConsoleGridView -Title "Seleccionar filas..." -OutputMode Multiple
        
        if ($null -ne $gridSelection) {
            Show-SelectionTable -SelectedData $gridSelection
            $selectionContextJson = $gridSelection | ConvertTo-Json -Compress -Depth 10
        }
    }
    catch {
        Write-Host $ModelResponse -ForegroundColor Cyan
    }
    
    Add-History -UserPrompt $UserPrompt -ModelResponse $ModelResponse
}
</code></pre>
<p><strong>Caracter√≠sticas clave:</strong></p>
<ul>
<li>El indicador <code>[Selecci√≥n activa]</code> muestra que hay datos para analizar.</li>
<li>Cada consulta incluye el historial completo del di√°logo para mantener el contexto.</li>
<li>La <code>IA</code> recibe tanto el historial como los datos seleccionados por el usuario.</li>
<li>El resultado se intenta mostrar como una tabla interactiva.</li>
<li>Si el an√°lisis de <code>JSON</code> falla, se muestra texto sin formato.</li>
</ul>
<h2>Estructura de archivos de trabajo</h2>
<p>El script crea la siguiente estructura:</p>
<pre><code>‚îú‚îÄ‚îÄ Find-Spec.ps1
‚îú‚îÄ‚îÄ .gemini/
‚îÇ   ‚îú‚îÄ‚îÄ GEMINI.md              # Prompt del sistema para la IA
‚îÇ   ‚îú‚îÄ‚îÄ ShowHelp.md            # Ayuda del usuario
‚îÇ   ‚îî‚îÄ‚îÄ .chat_history/         # Carpeta con el historial de sesiones
‚îÇ       ‚îú‚îÄ‚îÄ ai_session_2025-08-26_10-15-30.jsonl
‚îÇ       ‚îî‚îÄ‚îÄ ai_session_2025-08-26_14-22-45.jsonl
</code></pre>
<p>El archivo <code>GEMINI.md</code> en la carpeta <code>.gemini/</code> es la ubicaci√≥n est√°ndar para el prompt del sistema para el <code>CLI</code> de <code>Gemini</code>. En cada ejecuci√≥n, el modelo carga autom√°ticamente las instrucciones de este archivo, lo que define su comportamiento y el formato de sus respuestas.</p>
<p>En la siguiente parte, examinaremos el contenido de los archivos de configuraci√≥n y ejemplos de uso pr√°ctico.</p>