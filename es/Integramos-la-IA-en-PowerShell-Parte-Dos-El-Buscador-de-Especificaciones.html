<h2>Integramos la IA en PowerShell. Parte Dos: El Buscador de Especificaciones</h2>
<p>La última vez, vimos cómo podemos interactuar con el modelo <code>Gemini</code> a través de la interfaz de línea de comandos usando <code>PowerShell</code>. En este artículo, les mostraré cómo beneficiarse de nuestro conocimiento. Convertiremos nuestra consola en una guía de referencia interactiva que tomará un identificador de componente (marca, modelo, categoría, número de pieza, etc.) como entrada y devolverá una tabla interactiva con las especificaciones obtenidas del modelo <code>Gemini</code>.</p>
<p>Ingenieros, desarrolladores y otros especialistas a menudo se enfrentan a la necesidad de conocer los parámetros exactos de, por ejemplo, una placa base, un disyuntor en un cuadro eléctrico o un conmutador de red. Nuestra guía de referencia estará siempre a mano y, previa solicitud, recopilará información, aclarará parámetros en Internet y devolverá la tabla deseada. En la tabla, podrá seleccionar los parámetros necesarios y, si es preciso, continuar con una búsqueda más profunda. Más adelante, aprenderemos a pasar el resultado por la tubería para su posterior procesamiento: exportación a una hoja de cálculo de <code>Excel</code> o <code>Google</code>, almacenamiento en una base de datos o transferencia a otro programa. En caso de fallo, el modelo aconsejará qué parámetros deben aclararse. Pero véanlo ustedes mismos:</p>
<p><a href="https://github.com/user-attachments/assets/0e6690c1-5d49-4c75-89fc-ede2c7642c5f">vídeo</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/0e6690c1-5d49-4c75-89fc-ede2c7642c5f" type="video/mp4">
  Your browser does not support the video tag.
</video>
<h2>Cómo funciona el Buscador de Especificaciones impulsado por IA: del lanzamiento al resultado</h2>
<p>Analicemos el ciclo de vida completo de nuestro script: qué sucede desde el momento de su lanzamiento hasta la obtención de los resultados.</p>
<h2>Inicialización: Preparación para el trabajo</h2>
<p>El script acepta un parámetro <code>$Model</code> con validación: puede elegir '<code>gemini-2.5-flash</code>' (el modelo rápido predeterminado) o '<code>gemini-2.5-pro</code>' (más potente). Al iniciar, el script primero configura el entorno de trabajo. Establece la clave <code>API</code> para acceder a <code>Gemini AI</code>, define la carpeta actual como directorio base y crea una estructura para almacenar archivos. Para cada sesión, se crea un archivo con una marca de tiempo, por ejemplo, <code>ai_session_2025-08-26_14-30-15.jsonl</code>. Este es el historial de diálogo.</p>
<p>A continuación, el sistema verifica que todas las herramientas necesarias estén instaladas. Busca el <code>CLI</code> de <code>Gemini</code> en el sistema y verifica los archivos de configuración en la carpeta <code>.gemini/</code>. El archivo <code>GEMINI.md</code> es particularmente importante: contiene el prompt del sistema para el modelo y es cargado automáticamente por el <code>CLI</code> de <code>Gemini</code> al inicio. Esta es la ubicación estándar para las instrucciones del sistema. También se verifica el archivo <code>ShowHelp.md</code>, que contiene información de ayuda. Si falta algo crítico, el script advierte al usuario o termina.</p>
<h2>Inicio del modo interactivo</h2>
<p>Después de una inicialización exitosa, el script muestra un mensaje de bienvenida que indica el modelo seleccionado ("Buscador de Especificaciones de <code>IA</code>. Modelo: '<code>gemini-2.5-flash</code>'."), la ruta al archivo de sesión e instrucciones para los comandos. Luego, entra en modo interactivo: muestra un prompt y espera la entrada del usuario. El prompt se ve como <code>🤖AI :) > </code> y cambia a <code>🤖AI [Selección activa] :) > </code> cuando el sistema tiene datos para analizar.</p>
<h2>Procesamiento de la entrada del usuario</h2>
<p>Cada entrada del usuario se verifica primero para comandos de servicio mediante la función <code>Command-Handler</code>. Esta función reconoce comandos como <code>?</code> (ayuda del archivo <code>ShowHelp.md</code>), <code>history</code> (mostrar historial de sesión), <code>clear</code> y <code>clear-history</code> (borrar el archivo de historial), <code>gemini help</code> (ayuda del <code>CLI</code>), y <code>exit</code> y <code>quit</code> (salir). Si es un comando de servicio, se ejecuta inmediatamente sin contactar a la <code>IA</code>, y el bucle continúa.</p>
<p>Si es una consulta regular, el sistema comienza a construir el contexto para enviar a <code>Gemini</code>. Lee el historial completo de la sesión actual del archivo <code>JSONL</code> (si existe), agrega un bloque con datos de la selección anterior (si hay una selección activa) y combina todo esto con la nueva consulta del usuario en un prompt estructurado con las secciones "HISTORIAL DE DIÁLOGO", "DATOS DE LA SELECCIÓN" y "NUEVA TAREA". Después de su uso, los datos de selección se borran.</p>
<h2>Interacción con la Inteligencia Artificial</h2>
<p>El prompt formado se envía a <code>Gemini</code> a través de la línea de comandos con la llamada <code>& gemini -m $Model -p $Prompt 2>&1</code>. El sistema captura toda la salida (incluidos los errores a través de <code>2>&1</code>), verifica el código de retorno y limpia el resultado de los mensajes de servicio del <code>CLI</code> ("La recopilación de datos está deshabilitada" y "Credenciales en caché cargadas"). Si ocurre un error en esta etapa, el usuario recibe una advertencia, pero el script continúa ejecutándose.</p>
<h2>Procesamiento de la respuesta de la IA</h2>
<p>El sistema intenta interpretar la respuesta recibida de la <code>IA</code> como <code>JSON</code>. Primero, busca un bloque de código en el formato <code>```json...```</code>, extrae el contenido e intenta analizarlo. Si no hay tal bloque, analiza toda la respuesta. Si el análisis es exitoso, los datos se muestran en una tabla interactiva <code>Out-ConsoleGridView</code> con el título "Seleccionar filas para la siguiente consulta (OK) o cerrar (Cancelar)" y la selección múltiple habilitada. Si el <code>JSON</code> no se reconoce (error de análisis), la respuesta se muestra como texto sin formato en azul.</p>
<h2>Trabajar con la selección de datos</h2>
<p>Cuando el usuario selecciona filas en la tabla y hace clic en <code>OK</code>, el sistema realiza varias acciones. Primero, se llama a la función <code>Show-SelectionTable</code>, que analiza la estructura de los datos seleccionados: si son objetos con propiedades, identifica todos los campos únicos y muestra los datos usando <code>Format-Table</code> con ajuste automático de tamaño y ajuste de línea. Si son valores simples, los muestra como una lista numerada. Luego, muestra un contador de los elementos seleccionados y el mensaje "Selección guardada. Agregue su próxima consulta (por ejemplo, 'compárelos')."</p>
<p>Los datos seleccionados se convierten a un <code>JSON</code> comprimido con una profundidad de anidamiento de 10 niveles y se guardan en la variable <code>$selectionContextJson</code> para su uso en solicitudes posteriores a la <code>IA</code>.</p>
<h2>Mantenimiento del historial</h2>
<p>Cada par "consulta de usuario - respuesta de <code>IA</code>" se guarda en el archivo de historial en formato <code>JSONL</code>. Esto asegura la continuidad del diálogo: la <code>IA</code> "recuerda" toda la conversación anterior y puede referirse a temas discutidos previamente.</p>
<h2>El ciclo continúa</h2>
<p>Después de procesar la solicitud, el sistema vuelve a esperar una nueva entrada. Si el usuario tiene una selección activa, esto se refleja en el prompt de la línea de comandos. El ciclo continúa hasta que el usuario ingresa un comando de salida.</p>
<h2>Ejemplo práctico de funcionamiento</h2>
<p>Imagine que un usuario ejecuta el script y escribe "<code>RTX 4070 Ti Super</code>":</p>
<ul>
<li><strong>Preparación del contexto:</strong> El sistema toma el prompt del sistema del archivo, agrega el historial (actualmente vacío) y la nueva consulta.</li>
<li><strong>Solicitud a la <code>IA</code>:</strong> El prompt completo se envía a <code>Gemini</code> con una solicitud para encontrar las especificaciones de las tarjetas de video.</li>
<li><strong>Recuperación de datos:</strong> La <code>IA</code> devuelve un <code>JSON</code> con una matriz de objetos que contienen información sobre varios modelos de <code>RTX 4070 Ti Super</code>.</li>
<li><strong>Tabla interactiva:</strong> El usuario ve una tabla con fabricantes, especificaciones y precios, y selecciona 2-3 modelos de interés.</li>
<li><strong>Visualización de la selección:</strong> Aparece una tabla con los modelos seleccionados en la consola, y el prompt cambia a <code>[Selección activa]</code>.</li>
<li><strong>Refinar consulta:</strong> El usuario escribe "comparar su rendimiento en juegos".</li>
<li><strong>Análisis contextual:</strong> La <code>IA</code> recibe la consulta inicial, los modelos seleccionados y la nueva pregunta, proporcionando una comparación detallada de esas tarjetas específicas.</li>
</ul>
<h2>Terminación</h2>
<p>Cuando se ingresa <code>exit</code> o <code>quit</code>, el script termina correctamente, habiendo guardado todo el historial de la sesión en un archivo. El usuario puede volver a este diálogo en cualquier momento viendo el contenido del archivo correspondiente en la carpeta <code>.chat_history</code>.</p>
<p>Toda esta lógica compleja está oculta al usuario detrás de una interfaz de línea de comandos simple. La persona simplemente hace preguntas y recibe respuestas estructuradas, mientras que el sistema se encarga de todo el trabajo de mantener el contexto, analizar datos y administrar el estado del diálogo.</p>
<hr>
<h2>Paso 1: Configuración</h2>
<pre class="line-numbers"><code class="language-powershell"># --- Paso 1: Configuración ---
$env:GEMINI_API_KEY = "AIzaSyCbq8bkt5Xr2hlE-73MIXFpdFYH-rLBd0k"
if (-not $env:GEMINI_API_KEY) { Write-Error "..."; return }

$scriptRoot = Get-Location
# --- CAMBIO: Variable renombrada ---
$HistoryDir = Join-Path $scriptRoot ".gemini/.chat_history"
# --- FIN DEL CAMBIO ---
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$historyFileName = "ai_session_$timestamp.jsonl"
$historyFilePath = Join-Path $HistoryDir $historyFileName
</code></pre>
<p><strong>Propósito de las líneas:</strong></p>
<ul>
<li><code>$env:GEMINI_API_KEY = "..."</code> - establece la clave <code>API</code> para acceder a <code>Gemini AI</code>.</li>
<li><code>if (-not $env:GEMINI_API_KEY)</code> - verifica la presencia de la clave y termina el script si falta.</li>
<li><code>$scriptRoot = Get-Location</code> - obtiene el directorio de trabajo actual.</li>
<li><code>$HistoryDir = Join-Path...</code> - forma la ruta a la carpeta para almacenar el historial de diálogos (<code>.gemini/.chat_history</code>).</li>
<li><code>$timestamp = Get-Date...</code> - crea una marca de tiempo en el formato <code>2025-08-26_14-30-15</code>.</li>
<li><code>$historyFileName = "ai_session_$timestamp.jsonl"</code> - genera un nombre de archivo de sesión único.</li>
<li><code>$historyFilePath = Join-Path...</code> - crea la ruta completa al archivo de historial de la sesión actual.</li>
</ul>
<h2>Verificación del entorno - Qué debe instalarse</h2>
<pre class="line-numbers"><code class="language-powershell"># --- Paso 2: Verificación del entorno ---
try { Get-Command gemini -ErrorAction Stop | Out-Null } 
catch { Write-Error "El comando 'gemini' no se encontró..."; return }

if (-not (Test-Path (Join-Path $scriptRoot ".gemini/GEMINI.md"))) { 
    Write-Warning "El archivo de prompt del sistema .gemini/GEMINI.md no se encontró..." 
}
if (-not (Test-Path (Join-Path $scriptRoot ".gemini/ShowHelp.md"))) { 
    Write-Warning "El archivo de ayuda .gemini/ShowHelp.md no se encontró..." 
}
</code></pre>
<p><strong>Qué se verifica:</strong></p>
<ul>
<li>La presencia de <strong><code>Gemini CLI</code></strong> en el sistema: el script no funcionará sin él.</li>
<li>El archivo <strong><code>GEMINI.md</code></strong>: contiene el prompt del sistema (instrucciones para la <code>IA</code>).</li>
<li>El archivo <strong><code>ShowHelp.md</code></strong>: ayuda al usuario (el comando <code>?</code>).</li>
</ul>
<h2>Función principal para interactuar con la IA</h2>
<pre class="line-numbers"><code class="language-powershell">function Invoke-GeminiPrompt {
    param([string]$Prompt, [string]$Model)
    try {
        $output = & gemini -m $Model -p $Prompt 2>&1
        if (-not $?) { $output | ForEach-Object { Write-Warning $_.ToString() }; return $null }
        
        $outputString = ($output -join [Environment]::NewLine).Trim()
        $cleanedOutput = $outputString -replace "(?m)^Data collection is disabled\.`r?`n" , ""
        $cleanedOutput = $cleanedOutput -replace "(?m)^Loaded cached credentials\.`r?`n", ""
        
        return $cleanedOutput.Trim()
    }
    catch { Write-Error "Error crítico al llamar a Gemini CLI: $_"; return $null }
}
</code></pre>
<p><strong>Tareas de la función:</strong></p>
<ul>
<li>Llama al <code>CLI Gemini</code> con el modelo y el prompt especificados.</li>
<li>Captura toda la salida (incluidos los errores).</li>
<li>Limpia el resultado de los mensajes de servicio del <code>CLI</code>.</li>
<li>Devuelve la respuesta limpia de la <code>IA</code> o <code>$null</code> en caso de error.</li>
</ul>
<h2>Funciones de gestión del historial</h2>
<pre class="line-numbers"><code class="language-powershell">function Add-History { 
    param([string]$UserPrompt, [string]$ModelResponse)
    if (-not (Test-Path $HistoryDir)) { New-Item -Path $HistoryDir -ItemType Directory | Out-Null }
    @{ user = $UserPrompt } | ConvertTo-Json -Compress | Add-Content -Path $historyFilePath
    @{ model = $ModelResponse } | ConvertTo-Json -Compress | Add-Content -Path $historyFilePath
}

function Show-History {
    if (-not (Test-Path $historyFilePath)) { Write-Host "El historial de la sesión actual está vacío." -ForegroundColor Yellow; return }
    Write-Host "`n--- Historial de la sesión actual ---" -ForegroundColor Cyan
    Get-Content -Path $historyFilePath
    Write-Host "------------------------------------`n" -ForegroundColor Cyan
}

function Clear-History {
    if (Test-Path $historyFilePath) {
        Remove-Item -Path $historyFilePath -Force -ErrorAction Stop
        Write-Host "El historial de la sesión actual ($historyFileName) ha sido eliminado." -ForegroundColor Yellow
    }
}
</code></pre>
<p><strong>Propósito:</strong></p>
<ul>
<li><code>Add-History</code>: guarda pares "pregunta-respuesta" en formato <code>JSONL</code>.</li>
<li><code>Show-History</code>: muestra el contenido del archivo de historial.</li>
<li><code>Clear-History</code>: elimina el archivo de historial de la sesión actual.</li>
</ul>
<h2>Función para mostrar datos seleccionados</h2>
<pre class="line-numbers"><code class="language-powershell">function Show-SelectionTable {
    param([array]$SelectedData)
    
    if ($null -eq $SelectedData -or $SelectedData.Count -eq 0) { return }
    
    Write-Host "`n--- DATOS SELECCIONADOS ---" -ForegroundColor Yellow
    
    # Obtener todas las propiedades únicas de los objetos seleccionados
    $allProperties = @()
    foreach ($item in $SelectedData) {
        if ($item -is [PSCustomObject]) {
            $properties = $item | Get-Member -MemberType Properties | Select-Object -ExpandProperty Name
            $allProperties = $allProperties + $properties | Sort-Object -Unique
        }
    }
    
    # Mostrar una tabla o una lista
    if ($allProperties.Count -gt 0) {
        $SelectedData | Format-Table -Property $allProperties -AutoSize -Wrap
    } else {
        for ($i = 0; $i -lt $SelectedData.Count; $i++) {
            Write-Host "[$($i + 1)] $($SelectedData[$i])" -ForegroundColor White
        }
    }
    
    Write-Host "-------------------------" -ForegroundColor Yellow
    Write-Host "Elementos seleccionados: $($SelectedData.Count)" -ForegroundColor Magenta
}
</code></pre>
<p><strong>Tarea de la función:</strong> Después de seleccionar elementos en <code>Out-ConsoleGridView</code>, los muestra en la consola como una tabla ordenada, para que el usuario pueda ver exactamente lo que se eligió.</p>
<h2>Bucle de trabajo principal</h2>
<pre class="line-numbers"><code class="language-powershell">while ($true) {
    # Mostrar prompt con indicador de estado
    if ($selectionContextJson) {
        Write-Host -NoNewline -ForegroundColor Green "🤖AI [Selección activa] :) > "
    } else {
        Write-Host -NoNewline -ForegroundColor Green "🤖AI :) > "
    }
    
    $UserPrompt = Read-Host
    
    # Manejar comandos de servicio
    $commandResult = Command-Handler -Command $UserPrompt
    if ($commandResult -eq 'break') { break }
    if ($commandResult -eq 'continue') { continue }
    
    # Formar el prompt completo con contexto
    $fullPrompt = @"
### HISTORIAL DE DIÁLOGO (CONTEXTO)
$historyContent

### DATOS DE LA SELECCIÓN (PARA ANÁLISIS)
$selectionContextJson

### NUEVA TAREA
$UserPrompt
"@
    
    # Llamar a la IA y procesar la respuesta
    $ModelResponse = Invoke-GeminiPrompt -Prompt $fullPrompt -Model $Model
    
    # Intentar analizar JSON y mostrar la tabla interactiva
    try {
        $jsonObject = $jsonToParse | ConvertFrom-Json
        $gridSelection = $jsonObject | Out-ConsoleGridView -Title "Seleccionar filas..." -OutputMode Multiple
        
        if ($null -ne $gridSelection) {
            Show-SelectionTable -SelectedData $gridSelection
            $selectionContextJson = $gridSelection | ConvertTo-Json -Compress -Depth 10
        }
    }
    catch {
        Write-Host $ModelResponse -ForegroundColor Cyan
    }
    
    Add-History -UserPrompt $UserPrompt -ModelResponse $ModelResponse
}
</code></pre>
<p><strong>Características clave:</strong></p>
<ul>
<li>El indicador <code>[Selección activa]</code> muestra que hay datos para analizar.</li>
<li>Cada consulta incluye el historial completo del diálogo para mantener el contexto.</li>
<li>La <code>IA</code> recibe tanto el historial como los datos seleccionados por el usuario.</li>
<li>El resultado se intenta mostrar como una tabla interactiva.</li>
<li>Si el análisis de <code>JSON</code> falla, se muestra texto sin formato.</li>
</ul>
<h2>Estructura de archivos de trabajo</h2>
<p>El script crea la siguiente estructura:</p>
<pre><code>├── Find-Spec.ps1
├── .gemini/
│   ├── GEMINI.md              # Prompt del sistema para la IA
│   ├── ShowHelp.md            # Ayuda del usuario
│   └── .chat_history/         # Carpeta con el historial de sesiones
│       ├── ai_session_2025-08-26_10-15-30.jsonl
│       └── ai_session_2025-08-26_14-22-45.jsonl
</code></pre>
<p>El archivo <code>GEMINI.md</code> en la carpeta <code>.gemini/</code> es la ubicación estándar para el prompt del sistema para el <code>CLI</code> de <code>Gemini</code>. En cada ejecución, el modelo carga automáticamente las instrucciones de este archivo, lo que define su comportamiento y el formato de sus respuestas.</p>
<p>En la siguiente parte, examinaremos el contenido de los archivos de configuración y ejemplos de uso práctico.</p>