<h2>La filosof√≠a de PowerShell.</h2>
<h3>Parte 0.</h3>
<p>¬øQu√© hab√≠a antes de PowerShell?</p>
<p>en 1981, se lanz√≥ MS-DOS 1.0 con el int√©rprete de comandos `COMMAND.COM`. Para automatizar tareas, se usaban **archivos por lotes (`.bat`)**, simples archivos de texto con una secuencia de comandos de consola. Un asombroso ascetismo de la l√≠nea de comandos en comparaci√≥n con los sistemas compatibles con POSIX, donde el **shell de Bourne (`sh`)** exist√≠a desde 1979.</p>

<h3>üìÖ Estado del mercado de shells en el momento del lanzamiento de MS-DOS 1.0 (agosto de 1981)</h3>
<p>Aqu√≠ hay una tabla resumen de los sistemas operativos populares de la √©poca y su compatibilidad con los shells (`sh`, `csh`, etc.):</p>
<table>
<thead>
<tr>
<th>Sistema operativo</th>
<th>Soporte de shell (`sh`, `csh`, etc.)</th>
<th>Comentario</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UNIX Versi√≥n 7 (V7)</strong></td>
<td>`sh`</td>
<td>El √∫ltimo UNIX cl√°sico de Bell Labs, ampliamente distribuido</td>
</tr>
<tr>
<td><strong>UNIX/32V</strong></td>
<td>`sh`, `csh`</td>
<td>Versi√≥n de UNIX para la arquitectura VAX</td>
</tr>
<tr>
<td><strong>4BSD / 3BSD</strong></td>
<td>`sh`, `csh`</td>
<td>Rama universitaria de UNIX de Berkeley</td>
</tr>
<tr>
<td><strong>UNIX System III</strong></td>
<td>`sh`</td>
<td>La primera versi√≥n comercial de AT&amp;T, predecesora de System V</td>
</tr>
<tr>
<td><strong>Xenix (de Microsoft)</strong></td>
<td>`sh`</td>
<td>Versi√≥n con licencia de UNIX, vendida por Microsoft desde 1980</td>
</tr>
<tr>
<td><strong>IDRIS</strong></td>
<td>`sh`</td>
<td>SO similar a UNIX para PDP-11 e Intel</td>
</tr>
<tr>
<td><strong>Coherent (Mark Williams)</strong></td>
<td>`sh` (similar)</td>
<td>Alternativa econ√≥mica a UNIX para PC</td>
</tr>
<tr>
<td><strong>CP/M (Digital Research)</strong></td>
<td>‚ùå (Sin `sh`, solo un CLI simple)</td>
<td>No es UNIX, el SO m√°s popular para PC de 8 bits</td>
</tr>
<tr>
<td><strong>MS-DOS 1.0</strong></td>
<td>‚ùå (solo `COMMAND.COM`)</td>
<td>Shell de comandos m√≠nimo, sin scripts ni tuber√≠as</td>
</tr>
</tbody>
</table>
<hr>
<h3>üí° ¬øQu√© son `sh`, `csh`?</h3>
<ul>
<li>`sh` ‚Äî <strong>Bourne Shell</strong>, el principal int√©rprete de scripts de UNIX desde 1977.</li>
<li>`csh` ‚Äî <strong>C Shell</strong>, un shell mejorado con una sintaxis similar a C y comodidades para el trabajo interactivo.</li>
<li>Estos shells <strong>admit√≠an redirecciones, tuber√≠as, variables, funciones y condiciones</strong>, todo lo que convirti√≥ a UNIX en una poderosa herramienta de automatizaci√≥n.</li>
</ul>
<hr>
<p>Microsoft se centr√≥ en los <strong>PC IBM de 16 bits baratos</strong>, que ten√≠an <strong>poca memoria</strong> (generalmente de 64 a 256 KB), no ten√≠an multitarea y estaban destinados al <strong>uso dom√©stico y de oficina</strong>, no a los servidores. UNIX era de pago, requer√≠a una arquitectura y experiencia complejas, y los contables e ingenieros, no los administradores de sistemas, necesitaban un sistema operativo r√°pido y sencillo.</p>
<p>En lugar del complejo `sh`, la interfaz de DOS era un √∫nico archivo command.com con un escaso conjunto de comandos internos <a href="https://www.techgeekbuzz.com/blog/dos-commands/" target="_blank">(dir, copy, del, etc.)</a> sin funciones, bucles ni m√≥dulos.</p>
<p>Tambi√©n hab√≠a comandos externos: archivos ejecutables separados (.exe o .com). Ejemplos: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Los escenarios de ejecuci√≥n se escrib√≠an en un archivo de texto con la extensi√≥n .bat (archivo por lotes).</p>
<p>Ejemplos de archivos de configuraci√≥n:</p>
<ul>
<li>AUTOEXEC.BAT</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Configuraci√≥n y arranque autom√°ticos de Windows 3.11
:: Autor: hypo69
:: A√±o: aproximadamente 1993
:: Prop√≥sito: inicializa el entorno de DOS, carga los controladores de red e inicia Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Configuraci√≥n del s√≠mbolo del sistema
PROMPT $p$g

:: Configuraci√≥n de las variables de entorno
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Carga de controladores y utilidades en la memoria alta
LH C:\DOS\SMARTDRV.EXE       :: Cach√© de disco
LH C:\DOS\MOUSE.COM          :: Controlador del rat√≥n

:: Carga de los servicios de red (relevante para Windows para Trabajo en Grupo 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Inicio autom√°tico de Windows
WIN
</code></pre>
<ul>
<li>CONFIG.SYS</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî Configuraci√≥n de la memoria y los controladores de DOS para Windows 3.11
:: Autor: hypo69
:: A√±o: aproximadamente 1993
:: Prop√≥sito: inicializa los controladores de memoria, configura los par√°metros del sistema
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE
</code></pre>
<p>En paralelo a DOS, Microsoft comenz√≥ a desarrollar casi de inmediato un n√∫cleo fundamentalmente nuevo.</p>
<p>El n√∫cleo de <strong>Windows NT</strong> (New Technology) apareci√≥ por primera vez con el lanzamiento del sistema operativo:</p>
<blockquote>
<p><strong>Windows NT 3.1 ‚Äî 27 de julio de 1993</strong></p>
</blockquote>
<hr>
<ul>
<li><strong>El desarrollo comenz√≥</strong>: en <strong>1988</strong> bajo la direcci√≥n de <strong>Dave Cutler</strong> (un exingeniero de DEC, creador de VMS) con el objetivo de crear un sistema operativo completamente nuevo, seguro, port√°til y multitarea, no compatible con MS-DOS a nivel de n√∫cleo.</li>
<li><strong>NT 3.1</strong>: se llam√≥ as√≠ para enfatizar la compatibilidad con <strong>Windows 3.1</strong> a nivel de interfaz, pero era una <strong>arquitectura completamente nueva</strong>.</li>
</ul>
<hr>
<h4>üß† Lo que trajo el n√∫cleo de NT:</h4>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th>Descripci√≥n</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Arquitectura de 32 bits</strong></td>
<td>A diferencia de MS-DOS y Windows 3.x, que eran de 16 bits.</td>
</tr>
<tr>
<td><strong>Multitarea</strong></td>
<td>Verdadera multitarea apropiativa.</td>
</tr>
<tr>
<td><strong>Memoria protegida</strong></td>
<td>Los programas no pod√≠an da√±ar la memoria de los dem√°s.</td>
</tr>
<tr>
<td><strong>Modularidad</strong></td>
<td>Arquitectura de n√∫cleo de varios niveles: HAL, Ejecutivo, N√∫cleo, controladores.</td>
</tr>
<tr>
<td><strong>Soporte multiplataforma</strong></td>
<td>NT 3.1 se ejecutaba en x86, MIPS y Alpha.</td>
</tr>
<tr>
<td><strong>Compatibilidad con POSIX</strong></td>
<td>NT ven√≠a con un <strong>subsistema POSIX</strong>, certificado seg√∫n POSIX.1.</td>
</tr>
</tbody>
</table>
<hr>
<h4>üìú La l√≠nea NT:</h4>
<table>
<thead>
<tr>
<th>Versi√≥n de NT</th>
<th>A√±o</th>
<th>Comentario</th>
</tr>
</thead>
<tbody>
<tr>
<td>NT 3.1</td>
<td>1993</td>
<td>Primer lanzamiento de NT</td>
</tr>
<tr>
<td>NT 3.5 / 3.51</td>
<td>1994‚Äì1995</td>
<td>Mejoras, optimizaci√≥n</td>
</tr>
<tr>
<td>NT 4.0</td>
<td>1996</td>
<td>Interfaz de Windows 95, pero n√∫cleo de NT</td>
</tr>
<tr>
<td>Windows 2000</td>
<td>2000</td>
<td>NT 5.0</td>
</tr>
<tr>
<td>Windows XP</td>
<td>2001</td>
<td>NT 5.1</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>2007</td>
<td>NT 6.0</td>
</tr>
<tr>
<td>Windows 10</td>
<td>2015</td>
<td>NT 10.0</td>
</tr>
<tr>
<td>Windows 11</td>
<td>2021</td>
<td>Tambi√©n NT 10.0 (marketing üòä)</td>
</tr>
</tbody>
</table>
<hr>
<p>Diferencia en las capacidades del sistema operativo:</p>
<table>
<thead>
<tr>
<th>Caracter√≠stica</th>
<th><strong>MS-DOS</strong> (1981)</th>
<th><strong>Windows NT</strong> (1993)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tipo de sistema</strong></td>
<td>Monol√≠tico, monotarea</td>
<td>Microkernel/h√≠brido, multitarea</td>
</tr>
<tr>
<td><strong>Ancho de bits</strong></td>
<td>16 bits</td>
<td>32 bits (con soporte de 64 bits con NT 5.2 / XP x64)</td>
</tr>
<tr>
<td><strong>Multitarea</strong></td>
<td>‚ùå Ausente (un proceso a la vez)</td>
<td>‚úÖ Multitarea apropiativa</td>
</tr>
<tr>
<td><strong>Memoria protegida</strong></td>
<td>‚ùå No</td>
<td>‚úÖ S√≠ (cada proceso en su propio espacio de direcciones)</td>
</tr>
<tr>
<td><strong>Modo multiusuario</strong></td>
<td>‚ùå No</td>
<td>‚úÖ Parcialmente (en NT Workstation/Server)</td>
</tr>
<tr>
<td><strong>Compatibilidad con POSIX</strong></td>
<td>‚ùå No</td>
<td>‚úÖ Subsistema POSIX integrado en NT 3.1‚Äì5.2</td>
</tr>
<tr>
<td><strong>Portabilidad del n√∫cleo</strong></td>
<td>‚ùå Solo x86</td>
<td>‚úÖ x86, MIPS, Alpha, PowerPC</td>
</tr>
<tr>
<td><strong>Controladores</strong></td>
<td>Acceso directo al hardware</td>
<td>A trav√©s de HAL y controladores en modo kernel</td>
</tr>
<tr>
<td><strong>Nivel de acceso de la aplicaci√≥n</strong></td>
<td>Aplicaciones = nivel de sistema</td>
<td>Nivel de usuario / Nivel de kernel separados</td>
</tr>
<tr>
<td><strong>Seguridad</strong></td>
<td>‚ùå Ausente</td>
<td>‚úÖ Modelo de seguridad: SID, ACL, tokens de acceso</td>
</tr>
<tr>
<td><strong>Estabilidad</strong></td>
<td>‚ùå La dependencia de un programa = bloqueo del SO</td>
<td>‚úÖ Aislamiento de procesos, protecci√≥n del n√∫cleo</td>
</tr>
</tbody>
</table>
<hr>
<p>¬°Pero hab√≠a un gran PERO! Pero no se prest√≥ la debida atenci√≥n a las herramientas de automatizaci√≥n y administraci√≥n hasta 2002.</p>
<hr>
<p>Microsoft utiliz√≥ enfoques, estrategias y herramientas completamente diferentes para la administraci√≥n. Todo esto era <strong>dispar</strong>, a menudo orientado a la GUI y no siempre automatizable.</p>
<hr>
<h5>üìå Lista de algunas herramientas:</h5>
<table>
<thead>
<tr>
<th>Herramienta</th>
<th>Prop√≥sito</th>
</tr>
</thead>
<tbody>
<tr>
<td>`cmd.exe`</td>
<td>Int√©rprete de comandos mejorado (reemplazo de `COMMAND.COM`)</td>
</tr>
<tr>
<td>`.bat`, `.cmd`</td>
<td>Scripts de l√≠nea de comandos</td>
</tr>
<tr>
<td><strong>Windows Script Host (WSH)</strong></td>
<td>Soporte para VBScript y JScript para automatizaci√≥n</td>
</tr>
<tr>
<td>`reg.exe`</td>
<td>Administrar el registro desde la l√≠nea de comandos</td>
</tr>
<tr>
<td>`net.exe`</td>
<td>Trabajar con usuarios, redes, impresoras</td>
</tr>
<tr>
<td>`sc.exe`</td>
<td>Administrar servicios</td>
</tr>
<tr>
<td>`tasklist`, `taskkill`</td>
<td>Administrar procesos</td>
</tr>
<tr>
<td>`gpedit.msc`</td>
<td>Directiva de grupo (local)</td>
</tr>
<tr>
<td>`MMC`</td>
<td>Consola con complementos para la administraci√≥n</td>
</tr>
<tr>
<td>`WMI`</td>
<td>Acceso a la informaci√≥n del sistema (a trav√©s de `wmic`, VBScript o COM)</td>
</tr>
<tr>
<td>`WbemTest.exe`</td>
<td>GUI para probar consultas WMI</td>
</tr>
<tr>
<td>`eventvwr`</td>
<td>Ver registros de eventos</td>
</tr>
<tr>
<td>`perfmon`</td>
<td>Supervisi√≥n de recursos</td>
</tr>
</tbody>
</table>
<h5>üõ† Ejemplos de automatizaci√≥n:</h5>
<ul>
<li>Archivos VBScript (`*.vbs`) para administrar usuarios, redes, impresoras y servicios.</li>
<li>`WMIC`: interfaz de l√≠nea de comandos para WMI (por ejemplo, `wmic process list brief`).</li>
<li>Scripts `.cmd` con llamadas a `net`, `sc`, `reg`, `wmic`, etc.</li>
</ul>
<hr>
<h3>‚öôÔ∏è Windows Scripting Host (WSH)</h3>
<ul>
<li>Apareci√≥ por primera vez en <strong>Windows 98</strong>, se us√≥ activamente en <strong>Windows 2000 y XP</strong>.</li>
<li>Permit√≠a ejecutar archivos VBScript y JScript desde la l√≠nea de comandos:</li>
</ul>
<pre class="line-numbers"><code class="language-vbscript">Set objShell = WScript.CreateObject("WScript.Shell")
objShell.Run "notepad.exe"
</code></pre>
<hr>
<h2>Parte 1.</h2>
<p>Solo en 2002 la empresa formul√≥ el proyecto <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, que m√°s tarde dio como resultado powershell:</p>
<p>Inicio del desarrollo: aproximadamente en 2002</p>
<p>Anuncio p√∫blico: 2003, como "Monad Shell"</p>
<p>Primeras versiones beta: aparecieron en 2005</p>
<p>Lanzamiento final (PowerShell 1.0): noviembre de 2006</p>
<p>El autor y arquitecto jefe del proyecto Monad / PowerShell es Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank">(Jeffrey Snover)</a></p>
<p>Hoy PowerShell Core funciona en
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a></p>
<p>Paralelamente, se estaba desarrollando el marco .NET, y powershell estaba profundamente integrado en √©l, en los siguientes cap√≠tulos mostrar√© ejemplos</p>
<p>Y ahora, ¬°lo m√°s importante!</p>
<p>La principal ventaja de PowerShell en comparaci√≥n con los shells de comandos cl√°sicos es que funciona con <em>objetos</em>, no con texto. Cuando ejecuta un comando, no devuelve solo texto, sino un objeto estructurado (o una colecci√≥n de objetos) que tiene propiedades y m√©todos claramente definidos.</p>
<p>Vea c√≥mo PowerShell supera a los shells cl√°sicos gracias a que <strong>trabaja con objetos</strong></p>
<h3>üìÅ C√≥mo era antes: `dir` y an√°lisis manual</h3>
<p>En <strong>CMD</strong> (tanto en el antiguo `COMMAND.COM` como en `cmd.exe`), el comando `dir` devuelve el resultado como texto sin formato. Salida de ejemplo:</p>
<pre class="line-numbers"><code>24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
</code></pre>
<p>Supongamos que desea extraer el <strong>nombre de archivo</strong> y el <strong>tama√±o</strong> de cada archivo. Tendr√≠a que analizar las cadenas manualmente:</p>
<pre class="line-numbers"><code class="language-cmd">for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
</code></pre>
<ul>
<li>Esto es terriblemente dif√≠cil de leer, depende de la configuraci√≥n regional, el formato de fecha y la fuente. Y se rompe con espacios en los nombres</li>
</ul>
<hr>
<h3>‚úÖ PowerShell: objetos en lugar de texto</h3>
<h4>‚úî Ejemplo simple y legible:</h4>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem | Select-Object Name, Length
</code></pre>
<p><strong>Resultado:</strong></p>
<pre class="line-numbers"><code>Name          Length
----          ------
my_script.js   1428
report.html    3980
</code></pre>
<ul>
<li>`Get-ChildItem` devuelve una <strong>matriz de objetos de archivo/carpeta</strong></li>
<li>`Select-Object` le permite obtener f√°cilmente las <strong>propiedades</strong> requeridas</li>
</ul>
<hr>
<h3>üîç ¬øQu√© devuelve realmente `Get-ChildItem`?</h3>
<pre class="line-numbers"><code class="language-powershell">$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
</code></pre>
<p><strong>Resultado:</strong></p>
<pre class="line-numbers"><code>TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
</code></pre>
<p>PowerShell devuelve <strong>objetos `System.IO.FileInfo`</strong>, que tienen:</p>
<ul>
<li>üß± Propiedades (`Name`, `Length`, `CreationTime`, `Extension`, ‚Ä¶)</li>
<li>üõ† M√©todos (`Delete()`, `CopyTo()`, `MoveTo()`, etc.)</li>
</ul>
<p>Usted trabaja <strong>con objetos completos</strong>, no con cadenas.</p>
<hr>
<h3>Sintaxis "Verbo-Sustantivo":</h3>
<p>PowerShell utiliza una <strong>sintaxis de comandos estricta y l√≥gica</strong>:
`Verbo-Sustantivo`</p>
<table>
<thead>
<tr>
<th>Verbo</th>
<th>Qu√© hace</th>
</tr>
</thead>
<tbody>
<tr>
<td>`Get-`</td>
<td>Obtener</td>
</tr>
<tr>
<td>`Set-`</td>
<td>Establecer</td>
</tr>
<tr>
<td>`New-`</td>
<td>Crear</td>
</tr>
<tr>
<td>`Remove-`</td>
<td>Eliminar</td>
</tr>
<tr>
<td>`Start-`</td>
<td>Iniciar</td>
</tr>
<tr>
<td>`Stop-`</td>
<td>Detener</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Sustantivo</th>
<th>Sobre qu√© trabaja</th>
</tr>
</thead>
<tbody>
<tr>
<td>`Process`</td>
<td>Proceso</td>
</tr>
<tr>
<td>`Service`</td>
<td>Servicio</td>
</tr>
<tr>
<td>`Item`</td>
<td>Archivo/carpeta</td>
</tr>
<tr>
<td>`EventLog`</td>
<td>Registros de eventos</td>
</tr>
<tr>
<td>`Computer`</td>
<td>Computadora</td>
</tr>
</tbody>
</table>
<h4>üîÑ Ejemplos:</h4>
<table>
<thead>
<tr>
<th>Qu√© hacer</th>
<th>Comando</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obtener procesos</td>
<td>`Get-Process`</td>
</tr>
<tr>
<td>Detener un servicio</td>
<td>`Stop-Service`</td>
</tr>
<tr>
<td>Crear un nuevo archivo</td>
<td>`New-Item`</td>
</tr>
<tr>
<td>Obtener el contenido de una carpeta</td>
<td>`Get-ChildItem`</td>
</tr>
<tr>
<td>Eliminar un archivo</td>
<td>`Remove-Item`</td>
</tr>
</tbody>
</table>
<p>‚û° Incluso si <strong>no conoce el comando exacto</strong>, puede <strong>adivinarlo</strong> por el significado, y casi siempre acertar√°.</p>
<hr>
<p>El cmdlet `Get-Help` es su principal asistente.</p>
<ol>
<li><strong>Obtener ayuda sobre la propia ayuda:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Help
</code></pre>
</li>
<li><strong>Obtener ayuda b√°sica sobre el comando para trabajar con procesos:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process
</code></pre>
</li>
<li><strong>Ver ejemplos de uso de este comando:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Examples
</code></pre>
Este es un par√°metro incre√≠blemente √∫til que a menudo proporciona soluciones listas para usar para sus tareas.</li>
<li><strong>Obtener la informaci√≥n m√°s detallada sobre el comando:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Full
</code></pre>
En la siguiente parte: la canalizaci√≥n o cadena de comandos (PipeLines)</li>
</ol>