<h2>La filosofía de PowerShell.</h2>
<h3><strong>Parte 3: Navegación y administración del sistema de archivos. Operadores lógicos. Introducción a las funciones.</strong></h3>
<p>En la <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md">parte anterior</a>, exploramos las canalizaciones y los objetos de proceso abstractos.
Ahora apliquemos nuestro conocimiento de la canalización y los objetos a una de las tareas más comunes de un usuario o administrador: trabajar con el sistema de archivos.
En PowerShell, este trabajo se basa en los mismos principios: los comandos devuelven objetos que se pueden pasar a través de la canalización para su posterior procesamiento.</p>
<hr>
<h3><strong>1. El concepto de unidades de PowerShell (PSDrives)</strong></h3>
<p>Antes de comenzar a trabajar con archivos, es importante comprender el concepto de <strong>unidades de PowerShell (PSDrives)</strong>. A diferencia de `cmd.exe`, donde las unidades son solo las letras `C:`, `D:`, etc., en PowerShell, una "unidad" es una abstracción para acceder a cualquier almacén de datos jerárquico.</p>
<pre class="line-numbers"><code class="language-powershell">Get-PSDrive
</code></pre>
<p>El resultado mostrará no solo las unidades físicas, sino también las pseudounidades:</p>
<table>
<thead>
<tr>
<th>Nombre</th>
<th>Proveedor</th>
<th>Raíz</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alias</td>
<td>Alias</td>
<td>Alias:\</td>
<td>Alias de comando</td>
</tr>
<tr>
<td>C</td>
<td>FileSystem</td>
<td>C:\</td>
<td>Unidad local C</td>
</tr>
<tr>
<td>Cert</td>
<td>Certificate</td>
<td>Cert:\</td>
<td>Almacén de certificados</td>
</tr>
<tr>
<td>Env</td>
<td>Environment</td>
<td>Env:\</td>
<td>Variables de entorno</td>
</tr>
<tr>
<td>Function</td>
<td>Function</td>
<td>Function:\</td>
<td>Funciones cargadas</td>
</tr>
<tr>
<td>HKCU</td>
<td>Registry</td>
<td>HKEY_CURRENT_USER</td>
<td>Subárbol del Registro</td>
</tr>
<tr>
<td>HKLM</td>
<td>Registry</td>
<td>HKEY_LOCAL_MACHINE</td>
<td>Subárbol del Registro</td>
</tr>
<tr>
<td>Variable</td>
<td>Variable</td>
<td>Variable:\</td>
<td>Variables de sesión</td>
</tr>
<tr>
<td>WSMan</td>
<td>WSMan</td>
<td>WSMan:\</td>
<td>Configuración de WinRM</td>
</tr>
</tbody>
</table>
<p>Esta unificación significa que puede "entrar" en el registro (`Set-Location HKLM:`) y obtener una lista de sus claves con el mismo comando `Get-ChildItem` que utiliza para obtener una lista de archivos en la unidad C:. Este es un concepto increíblemente poderoso.</p>
<h4><strong>Ejemplos de trabajo con diferentes proveedores</strong></h4>
<ul>
<li>
<p><strong>Almacén de certificados (Cert:)</strong>
Le permite trabajar con certificados digitales como si fueran archivos en carpetas.</p>
<p><strong>Tarea:</strong> buscar todos los certificados SSL en la máquina local que caduquen en los próximos 30 días.
```powershell
# Ir al almacén de certificados de la máquina local
Set-Location Cert:\LocalMachine\My

# Buscar certificados donde la fecha de caducidad sea inferior a hoy + 30 días
Get-ChildItem | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) } | Select-Object Subject, NotAfter, Thumbprint
```</p>
</li>
<li>
<p><strong>Variables de entorno (Env:)</strong>
Proporciona acceso a las variables de entorno de Windows (`%PATH%`, `%windir%`, etc.) como si fueran archivos.</p>
<p><strong>Tarea:</strong> obtener la ruta a la carpeta del sistema de Windows y agregarle la ruta a `System32`.
```powershell
# Obtener el valor de la variable windir
$windowsPath = (Get-Item Env:windir).Value
# O más simple: $windowsPath = $env:windir

# Construir la ruta completa de forma segura
$system32Path = Join-Path -Path $windowsPath -ChildPath "System32"
Write-Host $system32Path
# Resultado: C:\WINDOWS\System32
```</p>
</li>
<li>
<p><strong>Registro de Windows (HKCU: y HKLM:)</strong>
Imagine que el registro es solo otro sistema de archivos. Los subárboles son carpetas y las claves son propiedades de esas carpetas.</p>
<p><strong>Tarea:</strong> averiguar el nombre completo de la versión instalada de Windows desde el registro.
```powershell
# Ir al subárbol del registro deseado
Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

# Obtener la propiedad (valor del registro) llamada "ProductName"
Get-ItemProperty -Path . -Name "ProductName"
# Resultado: ProductName : Windows 11 Pro
```</p>
</li>
<li>
<p><strong>Funciones cargadas (Function:)</strong>
Muestra todas las funciones disponibles en la sesión actual de PowerShell como si fueran archivos.</p>
<p><strong>Tarea:</strong> buscar todas las funciones cargadas que tengan la palabra "Help" en su nombre y ver el código de una de ellas.
```powershell
# Buscar funciones por máscara
Get-ChildItem Function: | Where-Object { $_.Name -like "*Help*" }

# Obtener el código completo (definición) de la función Get-Help
(Get-Item Function:Get-Help).Definition
```</p>
</li>
<li>
<p><strong>Variables de sesión (Variable:)</strong>
Le permite administrar todas las variables (`$myVar`, `$PROFILE`, `$Error`, etc.) definidas en la sesión actual.</p>
<p><strong>Tarea:</strong> buscar todas las variables relacionadas con la versión de PowerShell (`$PSVersionTable`, `$PSHOME`, etc.).
```powershell
# Buscar todas las variables que comiencen con "PS"
Get-ChildItem Variable:PS*

# Obtener el valor de una variable específica
Get-Variable -Name "PSVersionTable"
```</p>
</li>
</ul>
<hr>
<h3>2. <strong>Navegación y análisis</strong></h3>
<h4><strong>Conceptos básicos de navegación</strong></h4>
<pre class="line-numbers"><code class="language-powershell"># Averiguar dónde estamos (devuelve un objeto PathInfo)
Get-Location          # Alias: gl, pwd

# Ir a la raíz de la unidad C:
Set-Location C:\      # Alias: sl, cd

# Ir a la carpeta de inicio del usuario actual
Set-Location ~

# Mostrar el contenido de la carpeta actual (devuelve una colección de objetos)
Get-ChildItem         # Alias: gci, ls, dir
</code></pre>
<pre class="line-numbers"><code class="language-powershell"># **Búsqueda recursiva**
# Buscar el archivo hosts en el sistema, ignorando los errores de "Acceso denegado"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
</code></pre>
<p><strong>Modificador `-Recurse` (Recursivo):</strong> obliga al cmdlet a trabajar no solo con el elemento especificado, sino también con todo su contenido.</p>
<p><strong>Modificador `-ErrorAction SilentlyContinue`:</strong> una instrucción para ignorar los errores y continuar trabajando en silencio.</p>
<h5><strong>Análisis del espacio en disco</strong></h5>
<p>Un ejemplo clásico del poder de la canalización: buscar, ordenar, formatear y seleccionar.
```powershell
Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue |
    Sort-Object Length -Descending |
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} |
    Select-Object -First 20
```</p>
<h6><strong>Consejo sobre cómo introducir comandos largos.</strong></h6>
<blockquote>
<p>PowerShell le permite dividirlos en varias líneas para facilitar la lectura.</p>
<ul>
<li><strong>Después del operador de canalización (`|`):</strong> esta es la forma más común y conveniente. Simplemente presione `Intro` después del símbolo `|`. PowerShell verá que el comando no ha finalizado y esperará la continuación en la siguiente línea.</li>
<li><strong>En cualquier otro lugar:</strong> use el carácter de acento grave (`) al final de la línea y luego presione `Intro`. Este carácter le dice a PowerShell: "El comando continuará en la siguiente línea".</li>
<li><strong>En editores (ISE, VS Code):</strong> la combinación de teclas `Mayús+Intro` generalmente inserta automáticamente un salto de línea sin ejecutar el comando.</li>
</ul>
</blockquote>
<h4><strong>Filtrado de contenido y operadores lógicos</strong></h4>
<pre class="line-numbers"><code class="language-powershell"># Buscar todos los archivos .exe. El parámetro -Filter funciona muy rápido.
Get-ChildItem C:\Windows -Filter "*.exe"
</code></pre>
<p>`Get-ChildItem` devuelve una colección de objetos. Podemos pasarla a través de la canalización a `Where-Object` para un filtrado adicional.</p>
<pre class="line-numbers"><code class="language-powershell"># Mostrar solo archivos
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
</code></pre>
<p>Este comando nos introduce a uno de los conceptos fundamentales en los scripts de PowerShell: los <strong>operadores de comparación</strong>.</p>
<h4><strong>Operadores de comparación y lógicos</strong></h4>
<p>Estas son claves especiales para comparar valores. Siempre comienzan con un guión (`-`) y son la base para filtrar datos en `Where-Object` y construir lógica en `if`.</p>
<table>
<thead>
<tr>
<th>Operador</th>
<th>Descripción</th>
<th>Ejemplo en la canalización</th>
</tr>
</thead>
<tbody>
<tr>
<td>`-eq`</td>
<td>Igual</td>
<td>`$_.Name -eq "svchost.exe"`</td>
</tr>
<tr>
<td>`-ne`</td>
<td>No igual</td>
<td>`$_.Status -ne "Running"`</td>
</tr>
<tr>
<td>`-gt`</td>
<td>Mayor que</td>
<td>`$_.Length -gt 1MB`</td>
</tr>
<tr>
<td>`-ge`</td>
<td>Mayor o igual que</td>
<td>`$_.Handles -ge 500`</td>
</tr>
<tr>
<td>`-lt`</td>
<td>Menor que</td>
<td>`$_.LastWriteTime -lt (Get-Date).AddDays(-30)`</td>
</tr>
<tr>
<td>`-le`</td>
<td>Menor o igual que</td>
<td>`$_.Count -le 1`</td>
</tr>
<tr>
<td>`-like`</td>
<td>Como (con comodines `*`, `?`)</td>
<td>`$_.Name -like "win*"`</td>
</tr>
<tr>
<td>`-notlike`</td>
<td>No como</td>
<td>`$_.Name -notlike "*.tmp"`</td>
</tr>
<tr>
<td>`-in`</td>
<td>El valor está en una colección</td>
<td>`$_.Extension -in ".log", ".txt"`</td>
</tr>
<tr>
<td>`-and`</td>
<td>Y lógico (ambas condiciones son verdaderas)</td>
<td></td>
</tr>
<tr>
<td>`-or`</td>
<td>O lógico (al menos una condición es verdadera)</td>
<td></td>
</tr>
<tr>
<td>`-not`</td>
<td>NO lógico (invierte la condición)</td>
<td></td>
</tr>
</tbody>
</table>
<p>El tema de los operadores lógicos es muy extenso y le dedicaré una parte separada (o incluso dos). Mientras tanto, armados con estos operadores,
podemos <strong>filtrar, ordenar y seleccionar los archivos y carpetas que necesitamos</strong>, utilizando toda la potencia de la canalización de objetos.</p>
<h4><strong>Ejemplos de uso en el sistema de archivos</strong></h4>
<ul>
<li>
<p><strong>Buscar un archivo por su nombre exacto (sensible a mayúsculas y minúsculas):</strong>
```powershell
Get-ChildItem C:\Windows\System32 -Recurse | Where-Object { $_.Name -eq "kernel32.dll" }
```</p>
</li>
<li>
<p><strong>Buscar todos los archivos que comiencen con "host" pero que no sean carpetas:</strong>
```powershell
Get-ChildItem C:\Windows\System32\drivers\etc | Where-Object { ($_.Name -like "host*") -and (-not $_.PSIsContainer) }
```</p>
</li>
<li>
<p><strong>Buscar todos los archivos de registro (.log) de más de 50 megabytes:</strong>
```powershell
Get-ChildItem C:\Windows\Logs -Filter "*.log" -Recurse | Where-Object { $_.Length -gt 50MB }
```</p>
</li>
<li>
<p><strong>Buscar todos los archivos temporales (.tmp) y los archivos de copia de seguridad (.bak) para limpiarlos:</strong>
El operador `-in` es mucho más elegante aquí que varias condiciones con `-or`.
```powershell
$extensionsToDelete = ".tmp", ".bak", ".old"
Get-ChildItem C:\Temp -Recurse | Where-Object { $_.Extension -in $extensionsToDelete }
```</p>
</li>
<li>
<p><strong>Buscar todos los archivos de Word (.docx) creados en la última semana:</strong>
```powershell
$oneWeekAgo = (Get-Date).AddDays(-7)
Get-ChildItem C:\Users\MyUser\Documents -Filter "*.docx" -Recurse | Where-Object { $_.CreationTime -ge $oneWeekAgo }
```</p>
</li>
<li>
<p><strong>Buscar archivos vacíos (de 0 bytes de tamaño) que no sean carpetas:</strong>
```powershell
Get-ChildItem C:\Downloads -Recurse | Where-Object { ($_.Length -eq 0) -and (-not $_.PSIsContainer) }
```</p>
</li>
<li>
<p><strong>Buscar todos los archivos ejecutables (.exe) que se modificaron este año, pero NO este mes:</strong>
Este complejo ejemplo demuestra el poder de combinar operadores.
```powershell
Get-ChildItem "C:\Program Files" -Filter "*.exe" -Recurse | Where-Object {
    ($_.LastWriteTime.Year -eq (Get-Date).Year) -and ($_.LastWriteTime.Month -ne (Get-Date).Month)
}
```
<em>(Nota: los paréntesis `()` alrededor de cada condición se utilizan para agrupar y mejorar la legibilidad, especialmente en casos complejos).</em></p>
</li>
</ul>
<p>Tenga cuidado con la recursividad:
Muchos archivos/carpetas: -Recurse puede entrar de forma recursiva en decenas de miles de elementos.
Enlaces simbólicos/enlaces circulares: pueden provocar una recursividad infinita.
Archivos sin derechos de acceso: pueden bloquear la ejecución.</p>
<h3>4. <strong>Creación, administración y eliminación segura</strong></h3>
<h4><strong>Creación, copia y movimiento</strong></h4>
<pre class="line-numbers"><code class="language-powershell">New-Item -Path "C:\Temp\MyFolder" -ItemType Directory
Add-Content -Path "C:\Temp\MyFolder\MyFile.txt" -Value "Primera línea"
Copy-Item -Path "C:\Temp\MyFolder" -Destination "C:\Temp\MyFolder_Copy" -Recurse
</code></pre>
<h4><strong>Eliminación segura</strong></h4>
<p>`Remove-Item` es un cmdlet potencialmente peligroso, por lo que PowerShell tiene mecanismos de protección integrados.
> <strong>Modificador `-WhatIf` (¿Qué pasaría si?):</strong> su mejor amigo. <strong>No ejecuta</strong> el comando, sino que solo muestra un mensaje en la consola sobre <strong>lo que habría sucedido</strong>.</p>
<pre class="line-numbers"><code class="language-powershell"># COMPROBACIÓN segura antes de eliminar
Remove-Item C:\Temp\MyFolder -Recurse -Force -WhatIf
# Resultado: What if: Performing the operation "Remove Directory" on target "C:\Temp\MyFolder".

# Solo después de asegurarse de que todo es correcto, eliminamos -WhatIf y EJECUTAMOS el comando
Remove-Item C:\Temp\MyFolder -Recurse -Force
</code></pre>
<hr>
<h3><strong>Introducción a las funciones</strong></h3>
<p>Cuando una sola línea de código se convierte en un conjunto complejo de comandos que desea usar una y otra vez, es hora de crear <strong>funciones</strong>.</p>
<h4><strong>Cómo usar y guardar funciones</strong></h4>
<p>Hay tres formas principales de hacer que sus funciones estén disponibles:</p>
<p><strong>Método 1: temporal (para pruebas)</strong>
Puede escribir en la consola o simplemente copiar y pegar todo el código de la función en la consola de PowerShell. La función estará disponible hasta que se cierre esta ventana.</p>
<p><strong>Método 2: permanente, pero manual (a través de un archivo `.ps1`)</strong>
Esta es la forma más común de organizar y compartir herramientas. Guarda la función en un archivo `.ps1` y la carga en la sesión cuando la necesita.
> <strong>Dot Sourcing (`. .ile.ps1`):</strong> este comando especial ejecuta el script en el contexto <em>actual</em>, haciendo que todas sus funciones y variables estén disponibles en su consola.</p>
<p><strong>Método 3: automático (a través del perfil de PowerShell)</strong>
Esta es la forma más poderosa para sus herramientas personales y de uso frecuente.
> <strong>¿Qué es un perfil de PowerShell?</strong> Es un script `.ps1` especial que PowerShell ejecuta automáticamente cada vez que se inicia. Todo lo que ponga en este archivo (alias, variables y, por supuesto, funciones) estará disponible en cada una de sus sesiones de forma predeterminada.</p>
<h5><strong>Ejemplo 1: buscar archivos duplicados</strong></h5>
<p>Repasemos todos los pasos usando la función `Find-DuplicateFiles` como ejemplo.</p>
<p><strong>Paso 1: definir el código de la función</strong>
```powershell
$functionCode = @'
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue |
        Group-Object Name, Length |
        Where-Object { $_.Count -gt 1 } |
        ForEach-Object {
            # ESTA ES LA LÍNEA CORREGIDA:
            # Dentro del operador $(), las variables no se escapan.
            Write-Host "Se encontraron duplicados: $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
        }
}
'@
```</p>
<p><strong>Paso 2 (Opción A): guardar en un archivo separado para cargarlo manualmente</strong>
```powershell
# Guardar
Set-Content -Path ".\Find-DuplicateFiles.ps1" -Value $functionCode
# Cargar
. .\Find-DuplicateFiles.ps1
```
> Dot Sourcing (. .\Find-DuplicateFiles.ps1): este comando especial ejecuta el script en el contexto actual, haciendo que todas sus funciones y variables estén disponibles en su consola.
```powershell
# Llamar
Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Downloads"
```</p>
<p><strong>Paso 2 (Opción B): agregar al perfil para cargarlo automáticamente</strong>
Hagamos que esta función esté siempre disponible.
>¿Qué es un perfil de PowerShell? Es un script .ps1 especial que PowerShell ejecuta automáticamente cada vez que se inicia. Todo lo que ponga en este archivo (alias, variables y funciones) estará disponible en cada una de sus sesiones de forma predeterminada.
1.  <strong>Buscar la ruta al archivo de perfil.</strong> PowerShell la almacena en la variable `$PROFILE`.
    ```powershell
    $PROFILE
    ```
2.  <strong>Crear el archivo de perfil si no existe.</strong>
    ```powershell
    if (-not (Test-Path $PROFILE)) {
        New-Item -Path $PROFILE -Type File -Force
    }
    ```
3.  <strong>Agregar el código de nuestra función al final del archivo de perfil.</strong>
    ```powershell
    Add-Content -Path $PROFILE -Value $functionCode
    ```
4.  <strong>Reinicie PowerShell</strong> (o ejecute `. $PROFILE`), y ahora su comando `Find-DuplicateFiles` siempre estará disponible, al igual que `Get-ChildItem`.</p>
<h5><strong>Ejemplo 2: crear un archivo ZIP con una copia de seguridad</strong></h5>
<p><strong>Código para el archivo `Backup-FolderToZip.ps1`:</strong>
```powershell
function Backup-FolderToZip {
    param([string]$SourcePath, [string]$DestinationPath)
    if (-not (Test-Path $SourcePath)) { Write-Error "No se encontró la carpeta de origen."; return }
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName
    if (-not (Test-Path $DestinationPath)) { New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null }
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force
    Write-Host "Copia de seguridad completada: $fullArchivePath" -ForegroundColor Green
}
```</p>
<p>Haré un análisis detallado de las funciones en las siguientes partes.</p>
<hr>
<h3><strong>Referencia de cmdlets para trabajar con el sistema de archivos</strong></h3>
<h4><strong>1. Cmdlets básicos</strong></h4>
<p>Esta lista incluye los 12 cmdlets más esenciales que cubren el 90 % de las tareas diarias.</p>
<table>
<thead>
<tr>
<th>Cmdlet</th>
<th>Propósito principal</th>
<th>Ejemplo de uso</th>
</tr>
</thead>
<tbody>
<tr>
<td>`Get-ChildItem`</td>
<td>Obtener una lista de archivos y carpetas.</td>
<td>`Get-ChildItem C:\Windows`</td>
</tr>
<tr>
<td>`Set-Location`</td>
<td>Moverse a otro directorio.</td>
<td>`Set-Location C:\Temp`</td>
</tr>
<tr>
<td>`Get-Location`</td>
<td>Mostrar el directorio actual.</td>
<td>`Get-Location`</td>
</tr>
<tr>
<td>`New-Item`</td>
<td>Crear un nuevo archivo o carpeta.</td>
<td>`New-Item "report.docx" -Type File`</td>
</tr>
<tr>
<td>`Remove-Item`</td>
<td>Eliminar un archivo o carpeta.</td>
<td>`Remove-Item "old_log.txt"`</td>
</tr>
<tr>
<td>`Copy-Item`</td>
<td>Copiar un archivo o carpeta.</td>
<td>`Copy-Item "file.txt" -Dest "D:\"`</td>
</tr>
<tr>
<td>`Move-Item`</td>
<td>Mover un archivo o carpeta.</td>
<td>`Move-Item "report.docx" -Dest "C:\Archive"`</td>
</tr>
<tr>
<td>`Rename-Item`</td>
<td>Renombrar un archivo o carpeta.</td>
<td>`Rename-Item "old.txt" -NewName "new.txt"`</td>
</tr>
<tr>
<td>`Get-Content`</td>
<td>Leer el contenido de un archivo.</td>
<td>`Get-Content "config.ini"`</td>
</tr>
<tr>
<td>`Set-Content`</td>
<td>Escribir/sobrescribir el contenido de un archivo.</td>
<td>`"data" | Set-Content "file.txt"`</td>
</tr>
<tr>
<td>`Add-Content`</td>
<td>Agregar contenido al final de un archivo.</td>
<td>`Get-Date | Add-Content "log.txt"`</td>
</tr>
<tr>
<td>`Test-Path`</td>
<td>Comprobar si existe un archivo o carpeta.</td>
<td>`Test-Path "C:\Temp"`</td>
</tr>
</tbody>
</table>
<p>¿Necesita <strong>leer el contenido</strong> de un archivo de texto? Use `Get-Content`.
¿Necesita <strong>sobrescribir completamente un archivo</strong> con contenido nuevo? Use `Set-Content`.
¿Necesita <strong>agregar una línea a un archivo de registro</strong> sin borrar los datos antiguos? Use `Add-Content`.
¿Necesita <strong>comprobar si existe un archivo</strong> antes de escribir? Use `Test-Path`.</p>
<h4><strong>2. Cmdlets especializados para tareas avanzadas</strong></h4>
<p>Cuando los cmdlets básicos no son suficientes, PowerShell ofrece herramientas más especializadas. No duplican las básicas, sino que amplían sus capacidades.</p>
<ul>
<li>
<p><strong>Trabajar con rutas (Path)</strong>
*   <strong>`Join-Path`</strong>: une de forma segura partes de una ruta, insertando automáticamente `\`.
*   <strong>`Split-Path`</strong>: divide una ruta en partes (carpeta, nombre de archivo, extensión).
*   <strong>`Resolve-Path`</strong>: convierte una ruta relativa (p. ej., `.` o `..\files`) en una ruta completa y absoluta.</p>
</li>
<li>
<p><strong>Trabajar con propiedades y contenido (Item Properties and Content)</strong>
*   <strong>`Get-ItemProperty`</strong>: obtiene las propiedades de un archivo específico (p. ej., `IsReadOnly`, `CreationTime`).
*   <strong>`Set-ItemProperty`</strong>: cambia las propiedades de un archivo o carpeta.
*   <strong>`Clear-Content`</strong>: elimina todo el contenido de un archivo, pero deja el archivo vacío.</p>
</li>
<li>
<p><strong>Navegación avanzada (Location Stack)</strong>
*   <strong>`Push-Location`</strong>: "recuerda" el directorio actual y va a uno nuevo.
*   <strong>`Pop-Location`</strong>: vuelve al directorio que `Push-Location` "recordó".</p>
</li>
<li>
<p><strong>Administración de control de acceso (ACL)</strong>
*   <strong>`Get-Acl`</strong>: obtiene la lista de control de acceso (ACL) de un archivo o carpeta.
*   <strong>`Set-Acl`</strong>: establece la lista de control de acceso de un archivo o carpeta (una operación compleja).</p>
</li>
</ul>
<p>¿Necesita <strong>cambiar un atributo de archivo</strong>, por ejemplo, hacerlo de "solo lectura"? Use `Set-ItemProperty`.
¿Necesita <strong>borrar completamente un archivo de registro</strong> sin eliminarlo? Use `Clear-Content`.
¿Necesita <strong>ir temporalmente a otra carpeta</strong> en un script y luego tener la garantía de volver? Use `Push-Location` y `Pop-Location`.
¿Necesita <strong>saber quién tiene derechos</strong> para acceder a una carpeta? Use `Get-Acl`.</p>
<p>En la siguiente parte, aprenderemos a trabajar con otros almacenes de datos, como el registro de Windows,
utilizando los mismos enfoques, profundizaremos en el concepto de funciones, consideraremos los operadores lógicos y aprenderemos a interactuar con el shell de forma interactiva</p>
<p>La filosofía de PowerShell en github:
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md">Historia y el primer cmdlet</a></p>
<p>Parte 2: <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/02.md">Canalización, variables, Get-Member, archivo .ps1 y exportación de resultados.</a>
Ejemplos de la segunda parte:
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/02/system_monitor.ps1">system_monitor.ps1</a></p>
<p>Parte 3: <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/03.md">Navegación y administración del sistema de archivos.</a></p>
<p>Ejemplos de la tercera parte:
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/03/Find-DuplicateFiles.ps1">Find-DuplicateFiles.ps1</a>
<a href="">Backup-FolderToZip</a></p>
