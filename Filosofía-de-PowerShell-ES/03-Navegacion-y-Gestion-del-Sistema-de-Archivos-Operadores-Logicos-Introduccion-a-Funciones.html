# Filosofía de PowerShell.

### **Parte 3: Navegación y gestión del sistema de archivos. Operadores lógicos. Introducción a las funciones.**

En la [parte anterior](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md) exploramos las canalizaciones y los objetos de proceso abstractos.
Ahora apliquemos nuestros conocimientos de canalizaciones y objetos a una de las tareas comunes de un usuario o administrador: trabajar con el sistema de archivos.
En PowerShell, este trabajo se basa en los mismos principios: los comandos devuelven objetos que se pueden canalizar para su posterior procesamiento.



***


### **1. El concepto de PowerShell Drives (PSDrives)**

Antes de empezar a trabajar con archivos, es importante comprender el concepto de **PowerShell Drives (PSDrives)**. A diferencia de `cmd.exe`, donde las unidades son solo letras `C:`, `D:`, etc., en PowerShell una "unidad" es una abstracción para acceder a cualquier almacén de datos jerárquico.

```powershell
Get-PSDrive
```
El resultado mostrará no solo las unidades físicas, sino también las pseudo-unidades:

| Nombre | Proveedor | Raíz | Descripción |
|---|---|---|---|
| Alias | Alias | Alias:\ | Alias de comandos |
| C | FileSystem | C:\ | Unidad local C |
| Cert | Certificate | Cert:\ | Almacén de certificados |
| Env | Environment | Env:\ | Variables de entorno |
| Function | Function | Function:\ | Funciones cargadas |
| HKCU | Registry | HKEY_CURRENT_USER | Rama del registro |
| HKLM | Registry | HKEY_LOCAL_MACHINE | Rama del registro |
| Variable | Variable | Variable:\ | Variables de sesión |
| WSMan | WSMan | WSMan:\ | Configuración de WinRM |

Esta unificación significa que puede "entrar" en el registro (`Set-Location HKLM:`) y obtener una lista de sus claves con el mismo comando `Get-ChildItem` que usa para obtener una lista de archivos en la unidad C:. Este es un concepto increíblemente poderoso.

#### **Ejemplos de trabajo con diferentes proveedores**

*   **Almacén de certificados (Cert:)**
     Le permite trabajar con certificados digitales como si fueran archivos en carpetas.
    
     **Tarea:** Encontrar todos los certificados SSL en la máquina local que caduquen en los próximos 30 días.
    ```powershell
    # Navegar al almacén de certificados del equipo local
    Set-Location Cert:\LocalMachine\My
    
    # Encontrar certificados cuya fecha de finalización sea inferior a hoy + 30 días
    Get-ChildItem | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) } | Select-Object Subject, NotAfter, Thumbprint
    ```

*   **Variables de entorno (Env:)**
     Proporciona acceso a las variables de entorno de Windows (`%PATH%`, `%windir%`, etc.) como si fueran archivos.
    
     **Tarea:** Obtener la ruta a la carpeta del sistema de Windows y agregarle la ruta a `System32`.
    ```powershell
    # Obtener el valor de la variable windir
    $windowsPath = (Get-Item Env:windir).Value
    # O más simple: $windowsPath = $env:windir
    
    # Construir la ruta completa de forma segura
    $system32Path = Join-Path -Path $windowsPath -ChildPath "System32"
    Write-Host $system32Path
    # Resultado: C:\WINDOWS\System32
    ```

*   **Registro de Windows (HKCU: y HKLM:)**
     Imagine que el registro es solo otro sistema de archivos. Las ramas son carpetas y los parámetros son propiedades de estas carpetas.
    
     **Tarea:** Averiguar el nombre completo de la versión de Windows instalada desde el registro.
    ```powershell
    # Navegar a la rama de registro deseada
    Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
    
    # Obtener la propiedad (parámetro de registro) llamada "ProductName"
    Get-ItemProperty -Path . -Name "ProductName"
    # Resultado: ProductName : Windows 11 Pro
    ```

*   **Funciones cargadas (Function:)**
     Muestra todas las funciones disponibles en la sesión actual de PowerShell, como si fueran archivos.
    
     **Tarea:** Encontrar todas las funciones cargadas cuyo nombre contenga la palabra "Help" y ver el código de una de ellas.
    ```powershell
    # Buscar funciones por máscara
    Get-ChildItem Function: | Where-Object { $_.Name -like "*Help*" }
    
    # Obtener el código completo (definición) de la función Get-Help
    (Get-Item Function:Get-Help).Definition
    ```

*   **Variables de sesión (Variable:)**
     Le permite administrar todas las variables (`$myVar`, `$PROFILE`, `$Error`, etc.) definidas en la sesión actual.
    
     **Tarea:** Encontrar todas las variables relacionadas con la versión de PowerShell (`$PSVersionTable`, `$PSHOME`, etc.).
    ```powershell
    # Encontrar todas las variables que comienzan con "PS"
    Get-ChildItem Variable:PS*
    
    # Obtener el valor de una variable específica
    Get-Variable -Name "PSVersionTable"
    ```


### 2. **Navegación y análisis**


#### **Conceptos básicos de navegación**

```powershell
# Saber dónde estamos (devuelve un objeto PathInfo)
Get-Location          # Alias: gl, pwd

# Navegar a la raíz de la unidad C:
Set-Location C:\      # Alias: sl, cd

# Navegar a la carpeta de inicio del usuario actual
Set-Location ~

# Mostrar el contenido de la carpeta actual (devuelve una colección de objetos)
Get-ChildItem         # Alias: gci, ls, dir
```

```powershell
# **Búsqueda recursiva**
# Encontrar el archivo hosts en el sistema, ignorando los errores "Acceso denegado"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
```
 **El modificador `-Recurse` (Recursivo):** Hace que el cmdlet funcione no solo con el elemento especificado, sino también con todo su contenido.

 **El modificador `-ErrorAction SilentlyContinue`:** Una instrucción para ignorar errores y continuar en silencio.


##### **Análisis del espacio en disco**
Un ejemplo clásico del poder de la canalización: encontrar, ordenar, formatear y seleccionar.
```powershell
Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue |
    Sort-Object Length -Descending |
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} |
    Select-Object -First 20
```

###### **Consejo sobre cómo introducir comandos largos.**
> PowerShell le permite dividirlos en varias líneas para facilitar la lectura.
> 
> *   **Después del operador de canalización (`|`):** Esta es la forma más común y conveniente. Simplemente presione `Enter` después del símbolo `|`. PowerShell verá que el comando no está completo y esperará la continuación en la siguiente línea.
> *   **En cualquier otro lugar:** Use el carácter de acento grave (backtick) `` ` `` al final de la línea, luego presione `Enter`. Este carácter le dice a PowerShell: "El comando continuará en la siguiente línea."
> *   **En editores (ISE, VS Code):** La combinación de teclas `Shift+Enter` generalmente inserta automáticamente un salto de línea sin ejecutar el comando.



#### **Filtrado de contenido y operadores lógicos**

```powershell
# Encontrar todos los archivos .exe. El parámetro -Filter funciona muy rápido.
Get-ChildItem C:\Windows -Filter "*.exe"
```

`Get-ChildItem` devuelve una colección de objetos. Podemos canalizarla a `Where-Object` para un filtrado posterior.

```powershell
# Mostrar solo archivos
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
```
Este comando nos introduce a uno de los conceptos fundamentales en los scripts de PowerShell: los **operadores de comparación**.

#### **Operadores de comparación y lógicos**

 Son palabras clave especiales para comparar valores. Siempre comienzan con un guión (`-`) y son la base para filtrar datos en `Where-Object` y construir lógica en `if`.

 | Operador | Descripción | Ejemplo en la canalización |
 | :--- | :--- | :--- |
 | `-eq` | Igual | `$_.Name -eq "svchost.exe"` |
 | `-ne` | No igual | `$_.Status -ne "Running"` |
 | `-gt` | Mayor que | `$_.Length -gt 1MB` |
 | `-ge` | Mayor o igual que | `$_.Handles -ge 500` |
 | `-lt` | Menor que | `$_.LastWriteTime -lt (Get-Date).AddDays(-30)`|
 | `-le` | Menor o igual que | `$_.Count -le 1` |
 | `-like` | Similar a (con comodines `*`, `?`)| `$_.Name -like "win*"` |
 | `-notlike`| No similar a | `$_.Name -notlike "*.tmp"` |
 | `-in` | El valor está contenido en la colección | `$_.Extension -in ".log", ".txt"` |
 | `-and` | Y lógico (ambas condiciones son verdaderas) | |
 | `-or` | O lógico (al menos una condición es verdadera) | |
 | `-not` | NO lógico (invierte la condición) | |

El tema de los operadores lógicos es muy extenso, y le dedicaré una parte separada (o incluso dos). Por ahora, armados con estos operadores, podemos **filtrar, ordenar y seleccionar los archivos y carpetas que necesitamos**, utilizando todo el poder de la canalización de objetos.


#### **Ejemplos de uso en el sistema de archivos**

*   **Encontrar un archivo por nombre exacto (sensible a mayúsculas y minúsculas):**
    ```powershell
    Get-ChildItem C:\Windows\System32 -Recurse | Where-Object { $_.Name -eq "kernel32.dll" }
    ```

*   **Encontrar todos los archivos .exe. El parámetro -Filter funciona muy rápido:**
    ```powershell
    Get-ChildItem C:\Windows -Filter "*.exe"
    ```

*   **Mostrar solo archivos:**
    ```powershell
    Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
    ```

*   **Encontrar todos los archivos que comienzan con "host" pero no son carpetas:**
    ```powershell
    Get-ChildItem C:\Windows\System32\drivers\etc | Where-Object { ($_.Name -like "host*") -and (-not $_.PSIsContainer) }
    ```

*   **Encontrar todos los archivos de registro (.log) de más de 50 megabytes:**
    ```powershell
    Get-ChildItem C:\Windows\Logs -Filter "*.log" -Recurse | Where-Object { $_.Length -gt 50MB }
    ```

*   **Encontrar todos los archivos temporales (.tmp) y de copia de seguridad (.bak) para limpiar:**
    El operador `-in` aquí es mucho más elegante que múltiples condiciones con `-or`.
    ```powershell
    $extensionsToDelete = ".tmp", ".bak", ".old"
    Get-ChildItem C:\Temp -Recurse | Where-Object { $_.Extension -in $extensionsToDelete }
    ```

*   **Encontrar todos los archivos de Word (.docx) creados la semana pasada:**
    ```powershell
    $oneWeekAgo = (Get-Date).AddDays(-7)
    Get-ChildItem C:\Users\MyUser\Documents -Filter "*.docx" -Recurse | Where-Object { $_.CreationTime -ge $oneWeekAgo }
    ```

*   **Encontrar archivos vacíos (0 bytes) que no son carpetas:**
    ```powershell
    Get-ChildItem C:\Downloads -Recurse | Where-Object { ($_.Length -eq 0) -and (-not $_.PSIsContainer) }
    ```

*   **Encontrar todos los archivos ejecutables (.exe) que se modificaron este año, pero NO este mes:**
    Este complejo ejemplo demuestra el poder de combinar operadores.
    ```powershell
    Get-ChildItem "C:\Program Files" -Filter "*.exe" -Recurse | Where-Object {
        ($_.LastWriteTime.Year -eq (Get-Date).Year) -and ($_.LastWriteTime.Month -ne (Get-Date).Month)
    }
    ```
*(Nota: los paréntesis `()` alrededor de cada condición se utilizan para agrupar y mejorar la legibilidad, especialmente en casos complejos).*

Tenga cuidado con la recursión:
Demasiados archivos/carpetas — -Recurse puede entrar recursivamente en decenas de miles de elementos.
Enlaces simbólicos / enlaces circulares — pueden causar una recursión infinita.
Archivos sin permisos de acceso — pueden bloquear la ejecución.


### 4. **Creación, gestión y eliminación segura**

#### **Creación, copia y movimiento**
```powershell
New-Item -Path "C:\Temp\MyFolder" -ItemType Directory
Add-Content -Path "C:\Temp\MyFolder\MyFile.txt" -Value "Primera línea"
Copy-Item -Path "C:\Temp\MyFolder" -Destination "C:\Temp\MyFolder_Copy" -Recurse
```

#### **Eliminación segura**
`Remove-Item` es un cmdlet potencialmente peligroso, por lo que PowerShell tiene mecanismos de protección incorporados.
> **El modificador `-WhatIf` (¿Qué pasaría si?):** Su mejor amigo. **No ejecuta** el comando, sino que solo muestra un mensaje en la consola sobre **lo que sucedería**.

```powershell
# VERIFICACIÓN segura antes de la eliminación
Remove-Item C:\Temp\MyFolder -Recurse -Force -WhatIf
# Resultado: What if: Performing the operation "Remove Directory" on target "C:\Temp\MyFolder".

# Solo después de asegurarse de que todo es correcto, elimine -WhatIf y EJECUTE el comando
Remove-Item C:\Temp\MyFolder -Recurse -Force
```


### **Introducción a las funciones**

Cuando una sola línea de código se convierte en un conjunto complejo de comandos que desea usar una y otra vez, es hora de crear **funciones**.

#### **Cómo usar y guardar funciones**

Hay tres formas principales de hacer que sus funciones estén disponibles:

**Método 1: Temporal (para pruebas)**
Puede escribir en la consola o simplemente copiar y pegar todo el código de la función en la consola de PowerShell. La función estará disponible hasta que se cierre esta ventana.

**Método 2: Permanente, pero manual (a través de un archivo `.ps1`)**
Esta es la forma más común de organizar y compartir herramientas. Guarda la función en un archivo `.ps1` y la carga en la sesión cuando la necesite.
> **Dot Sourcing (`. .\<script.ps1>`):** Este comando especial ejecuta el script en el contexto *actual*, haciendo que todas sus funciones y variables estén disponibles en su consola.

**Método 3: Automático (a través del perfil de PowerShell)**
Esta es la forma más poderosa para sus herramientas personales de uso frecuente.
> **¿Qué es un perfil de PowerShell?** Es un script `.ps1` especial que PowerShell ejecuta automáticamente cada vez que se inicia. Todo lo que ponga en este archivo (alias, variables y, por supuesto, funciones) estará disponible en cada sesión de forma predeterminada.
1.  **Encuentre la ruta al archivo de perfil.** PowerShell lo almacena en la variable `$PROFILE`.
    ```powershell
    $PROFILE
    ```
2.  **Cree el archivo de perfil si no existe.**
    ```powershell
    if (-not (Test-Path $PROFILE)) {
        New-Item -Path $PROFILE -Type File -Force
    }
    ```
3.  **Agregue el código de nuestra función al final del archivo de perfil.**
    ```powershell
    Add-Content -Path $PROFILE -Value $functionCode
    ```
4.  **Reinicie PowerShell** (o ejecute `. $PROFILE`), y ahora su comando `Find-DuplicateFiles` siempre estará disponible, al igual que `Get-ChildItem`.



##### **Ejemplo 1: Búsqueda de archivos duplicados**

Repasemos todos los pasos usando la función `Find-DuplicateFiles` como ejemplo.

**Paso 1: Definir el código de la función**
```powershell
$functionCode = @'
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue |
        Group-Object Name, Length |
        Where-Object { $_.Count -gt 1 } |
        ForEach-Object {
            # ESTA ES LA LÍNEA CORREGIDA:
            # Dentro del operador $() las variables no se escapan.
            Write-Host "Se encontraron duplicados: $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
        }
}
'@
```

**Paso 2 (Opción A): Guardar en un archivo separado para carga manual**
```powershell
# Guardar
Set-Content -Path ".\Find-DuplicateFiles.ps1" -Value $functionCode
# Cargar 
. .\Find-DuplicateFiles.ps1
```
<blockquote>
<p>Dot Sourcing (<code>. .\Find-DuplicateFiles.ps1</code>): Este comando especial ejecuta el script en el contexto actual, haciendo que todas sus funciones y variables estén disponibles en su consola.</p>
</blockquote>
<pre class="line-numbers"><code class="language-powershell"># Llamar
Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Downloads"
</code></pre>
<p><strong>Paso 2 (Opción B): Agregar al perfil para carga automática</strong>
Hagamos que esta función esté siempre disponible.</p>
<blockquote>
<p>¿Qué es un perfil de PowerShell? Es un script <code>.ps1</code> especial que PowerShell ejecuta automáticamente cada vez que se inicia. Todo lo que ponga en este archivo (alias, variables y funciones) estará disponible en cada sesión de forma predeterminada.</p>
</blockquote>
<ol>
<li>
<p><strong>Encuentre la ruta al archivo de perfil.</strong> PowerShell lo almacena en la variable <code>$PROFILE</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$PROFILE
</code></pre>
</li>
<li>
<p><strong>Cree el archivo de perfil si no existe.</strong></p>
<pre class="line-numbers"><code class="language-powershell">if (-not (Test-Path $PROFILE)) {
        New-Item -Path $PROFILE -Type File -Force
    }
</code></pre>
</li>
<li>
<p><strong>Agregue el código de nuestra función al final del archivo de perfil.</strong></p>
<pre class="line-numbers"><code class="language-powershell">
Add-Content -Path $PROFILE -Value $functionCode
</code></pre>
</li>
<li>
<p><strong>Reinicie PowerShell</strong> (o ejecute <code>. $PROFILE</code>), y ahora su comando <code>Find-DuplicateFiles</code> siempre estará disponible, al igual que <code>Get-ChildItem</code>.</p>
</li>
</ol>
<h5><strong>Ejemplo 2: Creación de un archivo ZIP con una copia de seguridad</strong></h5>
<p><strong>Código para el archivo <code>Backup-FolderToZip.ps1</code>:</strong></p>
<pre class="line-numbers"><code class="language-powershell">function Backup-FolderToZip {
    param([string]$SourcePath, [string]$DestinationPath)
    if (-not (Test-Path $SourcePath)) { Write-Error "Исходная папка не найдена."; return }
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName
    if (-not (Test-Path $DestinationPath)) { New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null }
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force
    Write-Host "Резервное копирование завершено: $fullArchivePath" -ForegroundColor Green
}
</code></pre>
<p>Proporcionaré un desglose detallado de las funciones en partes posteriores.</p>
<hr>
<h3><strong>Referencia de cmdlets para operaciones del sistema de archivos</strong></h3>
<h4><strong>1. Cmdlets básicos</strong></h4>
<p>Esta lista incluye 12 cmdlets esenciales que cubren el 90% de las tareas diarias.</p>
<table>
<thead>
<tr>
<th>Cmdlet</th>
<th>Propósito principal</th>
<th>Ejemplo de uso</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Get-ChildItem</code></td>
<td>Obtener una lista de archivos y carpetas.</td>
<td><code>Get-ChildItem C:\Windows</code></td>
</tr>
<tr>
<td><code>Set-Location</code></td>
<td>Cambiar a otro directorio.</td>
<td><code>Set-Location C:\Temp</code></td>
</tr>
<tr>
<td><code>Get-Location</code></td>
<td>Mostrar el directorio actual.</td>
<td><code>Get-Location</code></td>
</tr>
<tr>
<td><code>New-Item</code></td>
<td>Crear un nuevo archivo o carpeta.</td>
<td><code>New-Item "report.docx" -Type File</code></td>
</tr>
<tr>
<td><code>Remove-Item</code></td>
<td>Eliminar un archivo o carpeta.</td>
<td><code>Remove-Item "old_log.txt"</code></td>
</tr>
<tr>
<td><code>Copy-Item</code></td>
<td>Copiar un archivo o carpeta.</td>
<td><code>Copy-Item "file.txt" -Dest "D:\"</code></td>
</tr>
<tr>
<td><code>Move-Item</code></td>
<td>Mover un archivo o carpeta.</td>
<td><code>Move-Item "report.docx" -Dest "C:\Archive"</code></td>
</tr>
<tr>
<td><code>Rename-Item</code></td>
<td>Renombrar un archivo o carpeta.</td>
<td><code>Rename-Item "old.txt" -NewName "new.txt"</code></td>
</tr>
<tr>
<td><code>Get-Content</code></td>
<td>Leer el contenido de un archivo.</td>
<td><code>Get-Content "config.ini"</code></td>
</tr>
<tr>
<td><code>Set-Content</code></td>
<td>Escribir/sobrescribir el contenido de un archivo.</td>
<td><code>"data" | Set-Content "file.txt"</code></td>
</tr>
<tr>
<td><code>Add-Content</code></td>
<td>Agregar contenido al final de un archivo.</td>
<td><code>Get-Date | Add-Content "log.txt"</code></td>
</tr>
<tr>
<td><code>Test-Path</code></td>
<td>Comprobar si un archivo o carpeta existe.</td>
<td><code>Test-Path "C:\Temp"</code></td>
</tr>
</tbody>
</table>
<p>¿Necesita <strong>leer el contenido</strong> de un archivo de texto? Use <code>Get-Content</code>.
¿Necesita <strong>sobrescribir completamente un archivo</strong> con contenido nuevo? Use <code>Set-Content</code>.
¿Necesita <strong>agregar una línea a un archivo de registro</strong> sin borrar los datos antiguos? Use <code>Add-Content</code>.
¿Necesita <strong>comprobar si un archivo existe</strong> antes de escribir? Use <code>Test-Path</code>.</p>
<h4><strong>2. Cmdlets especializados para tareas avanzadas</strong></h4>
<p>Cuando los cmdlets básicos no son suficientes, PowerShell ofrece herramientas más especializadas. No duplican los básicos, sino que amplían sus capacidades.</p>
<ul>
<li>
<p><strong>Trabajar con rutas</strong></p>
<ul>
<li><strong><code>Join-Path</code></strong>: Combina de forma segura partes de rutas, insertando automáticamente <code>\</code>.</li>
<li><strong><code>Split-Path</code></strong>: Divide una ruta en partes (carpeta, nombre de archivo, extensión).</li>
<li><strong><code>Resolve-Path</code></strong>: Convierte una ruta relativa (p. ej., <code>.</code> o <code>..\files</code>) en una absoluta completa.</li>
</ul>
</li>
<li>
<p><strong>Trabajar con propiedades y contenido de elementos</strong></p>
<ul>
<li><strong><code>Get-ItemProperty</code></strong>: Obtiene las propiedades de un archivo específico (p. ej., <code>IsReadOnly</code>, <code>CreationTime</code>).</li>
<li><strong><code>Set-ItemProperty</code></strong>: Cambia las propiedades de un archivo o carpeta.</li>
<li><strong><code>Clear-Content</code></strong>: Elimina todo el contenido de un archivo, pero deja el archivo vacío.</li>
</ul>
</li>
<li>
<p><strong>Navegación avanzada (pila de ubicaciones)</strong></p>
<ul>
<li><strong><code>Push-Location</code></strong>: "Recuerda" el directorio actual y se mueve a uno nuevo.</li>
<li><strong><code>Pop-Location</code></strong>: Vuelve al directorio que <code>Push-Location</code> "recordó".</li>
</ul>
</li>
<li>
<p><strong>Gestión de derechos de acceso (ACL)</strong></p>
<ul>
<li><strong><code>Get-Acl</code></strong>: Obtiene una lista de derechos de acceso (ACL) para un archivo o carpeta.</li>
<li><strong><code>Set-Acl</code></strong>: Establece los derechos de acceso para un archivo o carpeta (operación compleja).</li>
</ul>
</li>
</ul>
<p>¿Necesita <strong>cambiar un atributo de archivo</strong>, por ejemplo, hacerlo "solo lectura"? Use <code>Set-ItemProperty</code>.
¿Necesita <strong>borrar completamente un archivo de registro</strong> sin eliminarlo? Use <code>Clear-Content</code>.
¿Necesita <strong>cambiar temporalmente a otra carpeta</strong> en un script y luego regresar de forma fiable? Use <code>Push-Location</code> y <code>Pop-Location</code>.
¿Necesita <strong>saber quién tiene acceso</strong> a una carpeta? Use <code>Get-Acl</code>.</p>
<p>En la siguiente parte, aprenderemos a trabajar con otros almacenes de datos, como el registro de Windows,
utilizando los mismos enfoques, profundizaremos en el concepto de funciones, consideraremos los operadores lógicos y aprenderemos a interactuar de forma interactiva con el shell.</p>
<p>Filosofía de PowerShell en github:
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md">Historia y primer cmdlet</a></p>
<p>Parte 2: <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/02.md">Canalización, variables, Get-Member, archivo .ps1 y exportación de resultados.</a>
Ejemplos para la segunda parte:
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/02/system_monitor.ps1">system_monitor.ps1</a></p>
<p>Parte 3: <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/03.md">Navegación y gestión del sistema de archivos.</a></p>
<p>Ejemplos para la tercera parte:
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/03/Find-DuplicateFiles.ps1">Find-DuplicateFiles.ps1</a>
<a href="">Backup-FolderToZip</a></p>
