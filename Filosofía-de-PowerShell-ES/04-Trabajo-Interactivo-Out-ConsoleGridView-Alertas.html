<h2>Filosof√≠a PowerShell.</h2>
<h2>Parte 4: Trabajo interactivo: <code>Out-ConsoleGridView</code>, alertas.</h2>
<ul>
<li>En la <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md">primera parte</a> definimos dos conceptos clave de <code>PowerShell</code>: la tuber√≠a y el objeto.</li>
<li>En la <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md">segunda parte</a> expliqu√© qu√© son los objetos y la tuber√≠a.</li>
<li>En la <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md">tercera parte</a> nos familiarizamos con el sistema de archivos y los proveedores.</li>
<li>Hoy veremos el trabajo interactivo con datos en la consola, as√≠ como las alertas y notificaciones.</li>
</ul>
<h3>Cap√≠tulo uno: Trabajo interactivo con datos en la consola.</h3>
<h4><code>Out-ConsoleGridView</code>. <code>GUI</code> en la consola de <code>PowerShell</code>.</h4>
<p><strong>‚ùó Importante:</strong> Todas las herramientas descritas a continuaci√≥n requieren **<code>PowerShell 7.2</code> o posterior</strong>.</p>
<p><code>Out-ConsoleGridView</code> es una tabla interactiva, directamente en la consola de <code>PowerShell</code>, que permite:
- ver datos en formato de tabla;
- filtrar y ordenar columnas;
- seleccionar filas con el cursor ‚Äì para pasarlas por la tuber√≠a;
- y mucho m√°s.</p>
<p><code>Out-ConsoleGridView</code> forma parte del m√≥dulo <code>Microsoft.PowerShell.ConsoleGuiTools</code>. Para usarlo, primero debe instalar este m√≥dulo.</p>
<p>Para instalar el m√≥dulo, ejecute el siguiente comando en <code>PowerShell</code>:</p>
<pre class="line-numbers"><code class="language-powershell">Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
</code></pre>
<p><img src="assets/04/1.png" alt="Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser"></p>
<p><code>Install-Module</code> descarga e instala el m√≥dulo especificado desde el repositorio en el sistema. An√°logos: <code>pip install</code> en <code>Python</code> o <code>npm install</code> en <code>Node.js</code>.</p>
<p>üìé Par√°metros clave de <code>Install-Module</code></p>
<table>
<thead>
<tr>
<th>Par√°metro</th>
<th>Descripci√≥n</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Name</code></td>
<td>Nombre del m√≥dulo a instalar.</td>
</tr>
<tr>
<td><code>-Scope</code></td>
<td>√Åmbito de instalaci√≥n: <code>AllUsers</code> (predeterminado, requiere derechos de administrador) o <code>CurrentUser</code> (no requiere derechos de administrador).</td>
</tr>
<tr>
<td><code>-Repository</code></td>
<td>Especifica el repositorio, por ejemplo <code>PSGallery</code>.</td>
</tr>
<tr>
<td><code>-Force</code></td>
<td>Instalaci√≥n forzada sin confirmaci√≥n.</td>
</tr>
<tr>
<td><code>-AllowClobber</code></td>
<td>Permite sobrescribir comandos existentes.</td>
</tr>
<tr>
<td><code>-AcceptLicense</code></td>
<td>Acepta autom√°ticamente la licencia del m√≥dulo.</td>
</tr>
<tr>
<td><code>-RequiredVersion</code></td>
<td>Instala una versi√≥n espec√≠fica del m√≥dulo.</td>
</tr>
</tbody>
</table>
<p>Despu√©s de la instalaci√≥n, puede pasar cualquier salida a <code>Out-ConsoleGridView</code> para un trabajo interactivo.</p>
<pre class="line-numbers"><code class="language-powershell"># Ejemplo cl√°sico: mostrar una lista de procesos en una tabla interactiva
Get-Process | Out-ConsoleGridView
</code></pre>
<p><a href="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be">1</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p><strong>Interfaz:</strong></p>
<ul>
<li><strong>Filtrado:</strong> Simplemente comience a escribir texto, y la lista se filtrar√° sobre la marcha.</li>
<li><strong>Navegaci√≥n:</strong> Use las teclas de flecha para moverse por la lista.</li>
<li><strong>Selecci√≥n:</strong> Presione <code>Espacio</code> para seleccionar/deseleccionar un elemento.</li>
<li><strong>Selecci√≥n m√∫ltiple:</strong> <code>Ctrl+A</code> para seleccionar todos los elementos, <code>Ctrl+D</code> para deseleccionar todo.</li>
<li><strong>Confirmaci√≥n:</strong> Presione <code>Enter</code> para devolver los objetos seleccionados.</li>
<li><strong>Cancelaci√≥n:</strong> Presione <code>ESC</code> para cerrar la ventana sin devolver datos.</li>
</ul>
<h2>Qu√© puede hacer <code>Out-ConsoleGridView</code>:</h2>
<ul>
<li>Mostrar datos tabulares directamente en la consola en forma de tabla interactiva con navegaci√≥n por filas y columnas.</li>
<li>Ordenar columnas presionando teclas.</li>
<li>Filtrar datos usando la b√∫squeda.</li>
<li>Seleccionar una o varias filas con devoluci√≥n del resultado.</li>
<li>Trabajar en una consola limpia sin ventanas <code>GUI</code>.</li>
<li>Admitir una gran cantidad de filas con desplazamiento.</li>
<li>Admitir varios tipos de datos (cadenas, n√∫meros, fechas, etc.).</li>
</ul>
<hr>
<h2>Ejemplos de uso de <code>Out-ConsoleGridView</code></h2>
<h3>Uso b√°sico: mostrar una tabla con la opci√≥n de selecci√≥n interactiva. (casilla de verificaci√≥n)</h3>
<pre class="line-numbers"><code class="language-powershell">Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Mostrar tabla con opciones de filtrado, ordenaci√≥n y selecci√≥n de filas
$selected = $data | Out-ConsoleGridView -Title "Select process(es)" -OutputMode Multiple

$selected | Format-Table -AutoSize
</code></pre>
<p><a href="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356">2</a></p>
<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>Se muestra una lista de procesos en una tabla interactiva de consola. Se puede filtrar por nombre, ordenar columnas y seleccionar procesos. Los procesos seleccionados se devuelven a la variable <code>$selected</code>.</p>
<hr>
<h3>Selecci√≥n de una sola fila con devoluci√≥n obligatoria del resultado. (radio)</h3>
<pre class="line-numbers"><code class="language-powershell">$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Select a service" -OutputMode Single

Write-Host "You selected service: $($choice.Name)"
</code></pre>
<p><a href="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e"></a></p>
<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>El usuario selecciona una sola fila (servicio). <code>-OutputMode Single</code> proh√≠be seleccionar varias.</p>
<hr>
<h3>Filtrado y ordenaci√≥n de grandes matrices</h3>
<pre class="line-numbers"><code class="language-powershell">$data = 1..1000 | ForEach-Object {
    [PSCustomObject]@{
        Number = $_
        Square = $_ * $_
        Cube    = $_ * $_ * $_
    }
}

$data | Out-ConsoleGridView -Title "Numbers and powers"  -OutputMode Multiple
</code></pre>
<p>Muestra una tabla de 1000 filas con n√∫meros y sus potencias.</p>
<h3>**Gesti√≥n interactiva de procesos:**</h3>
<p>Puede seleccionar varios procesos para detener. El par√°metro <code>-OutputMode Multiple</code> indica que queremos devolver todos los elementos seleccionados.</p>
<pre class="line-numbers"><code class="language-powershell"># Pasar los resultados por la tuber√≠a.
# Detener los procesos seleccionados con el par√°metro -WhatIf para una vista previa.
# Para ello, definiremos la variable $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple
    
# Si se seleccion√≥ algo, pasar los objetos por la tuber√≠a
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
</code></pre>
<h3>**Selecci√≥n de archivos para archivar:**</h3>
<p>Encontraremos todos los archivos <code>.log</code> en la carpeta, seleccionaremos los necesarios y crearemos un archivo a partir de ellos.</p>
<pre class="line-numbers"><code class="language-powershell">$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
</code></pre>
<p>‚ùó Tenga cuidado con la recursi√≥n</p>
<pre class="line-numbers"><code class="language-powershell">if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip
    
    # Agregar un mensaje de √©xito
    Write-Host "‚úÖ ¬°Archivado completado con √©xito!" -ForegroundColor Green
}
</code></pre>
<h3>**Selecci√≥n de un elemento para an√°lisis detallado:**</h3>
<h4>Patr√≥n "Drill-Down" ‚Äî de una lista general a detalles con <code>Out-ConsoleGridView</code></h4>
<p>A menudo, al trabajar con objetos del sistema, nos enfrentamos a un dilema:</p>
<ol>
<li>Si solicitamos **todas las propiedades** para **todos los objetos** (<code>Get-NetAdapter | Format-List *</code>), la salida ser√° enorme e ilegible.</li>
<li>Si mostramos una **tabla concisa**, perderemos detalles importantes.</li>
<li>A veces, intentar obtener todos los datos a la vez puede provocar un error si uno de los objetos contiene valores incorrectos.</li>
</ol>
<p>La soluci√≥n a este problema es el patr√≥n **"Drill-Down"** (detallado o "profundizaci√≥n"). Su esencia es simple:</p>
<ul>
<li><strong>Paso 1 (Resumen):</strong> Mostrar al usuario una lista de elementos limpia, concisa y segura para la **selecci√≥n**.</li>
<li><strong>Paso 2 (Detalle):</strong> Una vez que el usuario ha seleccionado un elemento espec√≠fico, mostrarle **toda la informaci√≥n disponible** sobre ese elemento.</li>
</ul>
<h4>Ejemplo pr√°ctico: Creaci√≥n de un explorador de adaptadores de red</h4>
<p>Implementaremos este patr√≥n usando el comando <code>Get-NetAdapter</code>.</p>
<p><strong>Tarea:</strong> Primero, mostrar una lista concisa de adaptadores de red. Despu√©s de seleccionar uno, abrir una segunda ventana con todas sus propiedades.</p>
<p><strong>C√≥digo listo para usar:</strong></p>
<pre class="line-numbers"><code class="language-powershell"># --- Etapa 1: Selecci√≥n del adaptador de la lista concisa ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "ETAPA 1: Seleccione un adaptador de red"

# --- Etapa 2: Mostrar informaci√≥n detallada o mensaje de cancelaci√≥n ---
if ($null -ne $selectedAdapter) {
    # Obtener TODAS las propiedades para el adaptador SELECCIONADO
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Usar nuestro truco con .psobject.Properties para transformar el objeto en una tabla conveniente "Nombre-Valor"
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value
    
    # Abrir la SEGUNDA ventana GridView con la informaci√≥n completa
    $detailedInfoForGrid | Out-ConsoleGridView -Title "ETAPA 2: Informaci√≥n completa sobre '$($selectedAdapter.Name)'"
} else {
    Write-Host "Operaci√≥n cancelada. No se seleccion√≥ ning√∫n adaptador." -ForegroundColor Yellow
}
</code></pre>
<h4>Desglose paso a paso</h4>
<ol>
<li>
<p><strong>Creaci√≥n de una lista "segura":</strong>
<code>$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed</code>
No pasamos la salida de <code>Get-NetAdapter</code> directamente. En su lugar, creamos nuevos objetos "limpios" usando <code>Select-Object</code>, incluyendo solo las propiedades que necesitamos para la descripci√≥n general. Esto garantiza que los datos problem√°ticos que causaron el error ser√°n descartados.</p>
</li>
<li>
<p><strong>Primera ventana interactiva:</strong>
<code>$selectedAdapter = $adapterList | Out-ConsoleGridView ...</code>
El script muestra la primera ventana y **detiene su ejecuci√≥n**, esperando su selecci√≥n. Tan pronto como seleccione una fila y presione <code>Enter</code>, el objeto correspondiente a esa fila se escribir√° en la variable <code>$selectedAdapter</code>.</p>
</li>
<li>
<p><strong>Verificaci√≥n de la selecci√≥n:</strong>
<code>if ($null -ne $selectedAdapter)</code>
Esta es una verificaci√≥n cr√≠ticamente importante. Si el usuario presiona <code>Esc</code> o cierra la ventana, la variable <code>$selectedAdapter</code> estar√° vac√≠a (<code>$null</code>). Esta verificaci√≥n evita que el resto del c√≥digo se ejecute y que ocurran errores.</p>
</li>
<li>
<p><strong>Obtenci√≥n de informaci√≥n completa:</strong>
<code>$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name</code>
Aqu√≠ est√° el punto clave del patr√≥n. Volvemos a llamar a <code>Get-NetAdapter</code>, pero esta vez solicitamos **solo un** objeto por su nombre, que tomamos del elemento seleccionado en la primera etapa. Ahora obtenemos el objeto completo con todas sus propiedades.</p>
</li>
<li>
<p><strong>Transformaci√≥n para la segunda ventana:</strong>
<code>$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...</code>
Usamos el potente truco que ya conoce para "desplegar" este objeto complejo √∫nico en una larga lista de pares "Nombre de propiedad" | "Valor", lo que es ideal para mostrar en una tabla.</p>
</li>
<li>
<p><strong>Segunda ventana interactiva:</strong>
<code>$detailedInfoForGrid | Out-ConsoleGridView ...</code>
Aparece una segunda ventana en la pantalla, esta vez con informaci√≥n exhaustiva sobre el adaptador que seleccion√≥.</p>
</li>
</ol>
<hr>
<h3>Ejemplo con t√≠tulo y sugerencias personalizados</h3>
<p>Mostrar el registro de eventos de <code>Windows</code> en una tabla interactiva con el t√≠tulo "System Events".</p>
<pre class="line-numbers"><code class="language-powershell">Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
</code></pre>
<p>Este c√≥digo obtiene los 50 eventos m√°s recientes del registro del sistema de <code>Windows</code>, selecciona solo cuatro propiedades clave de cada evento (tiempo, tipo, origen y mensaje) y los muestra en la ventana <code>Out-ConsoleGridView</code>.</p>
<hr>
<h3>Informaci√≥n del sistema.</h3>
<p><a href="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06">1</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>c√≥digo del script para obtener informaci√≥n del sistema:
<a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1">Get-SystemMonitor.ps1</a></p>
<h3>Creaci√≥n del cmdlet 'Get-SystemMonitor'</h3>
<h4>Paso 1: Configuraci√≥n de la variable <code>PATH</code></h4>
<ol>
<li><strong>Cree una carpeta permanente para sus herramientas,</strong> si a√∫n no lo ha hecho. Por ejemplo:
<code>C:\PowerShell\Scripts</code></li>
<li><strong>Coloque su archivo</strong> <code>Get-SystemMonitor.ps1</code> en esta carpeta.</li>
<li><strong>Agregue esta carpeta a la variable del sistema <code>PATH</code></strong>,</li>
</ol>
<h4>Paso 2: Configuraci√≥n del alias en el perfil de <code>PowerShell</code></h4>
<p>Ahora que el sistema sabe d√≥nde encontrar su script por su nombre completo, podemos crear un alias corto para √©l.</p>
<ol>
<li><strong>Abra su archivo de perfil de <code>PowerShell</code></strong>:</li>
</ol>
<pre class="line-numbers"><code class="language-powershell">notepad $PROFILE
</code></pre>
<ol start="2">
<li><strong>Agregue la siguiente l√≠nea:</strong></li>
</ol>
<pre class="line-numbers"><code class="language-powershell"># Alias para el monitor del sistema
Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
</code></pre>
<p><strong>Tenga en cuenta el punto clave:</strong> Dado que la carpeta con el script ya est√° en <code>PATH</code>, ¬°ya **no necesitamos especificar la ruta completa** al archivo! Simplemente nos referimos a su nombre. Esto hace que su perfil sea m√°s limpio y confiable. Si alguna vez mueve la carpeta <code>C:\PowerShell\Scripts</code>, solo necesitar√° actualizar la variable <code>PATH</code>, y su archivo de perfil permanecer√° sin cambios.</p>
<h4>Reinicie <code>PowerShell</code></h4>
<p>Cierre **todas** las ventanas de <code>PowerShell</code> abiertas y abra una nueva. Esto es necesario para que el sistema aplique los cambios tanto en la variable <code>PATH</code> como en su perfil.</p>
<hr>
<h3>Resultado: Lo que obtiene</h3>
<p>Despu√©s de realizar estos pasos, podr√° llamar a su script **de dos maneras desde cualquier lugar del sistema**:</p>
<ol>
<li>
<p><strong>Por nombre completo (confiable, para usar en otros scripts):</strong></p>
<pre class="line-numbers"><code class="language-powershell">Get-SystemMonitor.ps1
Get-SystemMonitor.ps1 -Resource storage
</code></pre>
</li>
<li>
<p><strong>Por alias corto (conveniente, para trabajo interactivo):</strong></p>
<pre class="line-numbers"><code class="language-powershell">sysmon
symon -Resource memory
</code></pre>
</li>
</ol>
<p>Ha "registrado" con √©xito su script en el sistema de la manera m√°s profesional y flexible.</p>
<p>¬ø√ötil? Suscr√≠base.
¬øLe gust√≥? ‚Äî ponga ¬´+¬ª
¬°Buena suerte! üöÄ</p>
<p>Otros art√≠culos sobre <code>PowerShell</code>:</p>