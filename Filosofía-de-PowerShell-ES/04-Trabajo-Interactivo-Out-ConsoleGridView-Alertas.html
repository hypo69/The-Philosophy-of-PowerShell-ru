# Filosof√≠a de PowerShell.

## Parte 4: Trabajo interactivo: `Out-ConsoleGridView`, alertas.

- En la [primera parte](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md) definimos dos conceptos clave de PowerShell: la canalizaci√≥n y el objeto.

- En la [segunda parte](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md) expliqu√© qu√© son los objetos y las canalizaciones.

- En la [tercera parte](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md) nos familiarizamos con el sistema de archivos y los proveedores.

- Hoy veremos el trabajo interactivo con datos en la consola, as√≠ como las alertas y notificaciones.

### Cap√≠tulo uno: Trabajo interactivo con datos en la consola.

#### `Out-ConsoleGridView`. GUI en la consola de PowerShell.


**‚ùó Importante:** Todas las herramientas que se describen a continuaci√≥n requieren **PowerShell 7.2 o posterior**.

Out-ConsoleGridView es una tabla interactiva, directamente en la consola de PowerShell, que permite:
- ver datos en una tabla;
- filtrar y ordenar columnas;
- seleccionar filas con el cursor ‚Äî para pasarlas m√°s adelante en la canalizaci√≥n.
- y mucho m√°s.

`Out-ConsoleGridView` forma parte del m√≥dulo `Microsoft.PowerShell.ConsoleGuiTools`. 
Para usarlo, primero debe instalar este m√≥dulo.

Para instalar el m√≥dulo, ejecute el siguiente comando en PowerShell:
```powershell
Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
```
![Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser](assets/04/1.png)

*Install-Module* descarga e instala el m√≥dulo especificado desde el repositorio al sistema. 
An√°logos: `pip install` en `Python` o `npm install` en `Node.js`.

üìé Par√°metros clave de *Install-Module*

------------------------------------------------------------------------------------------------------------------------------------------------------
| Par√°metro | Descripci√≥n |
|---|---|
| `-Name` | El nombre del m√≥dulo a instalar. |
| `-Scope` | √Åmbito de instalaci√≥n: `AllUsers` (predeterminado, requiere derechos de administrador) o `CurrentUser` (no requiere derechos de administrador). |
| `-Repository` | Especifica el repositorio, por ejemplo `PSGallery`. |
| `-Force` | Instalaci√≥n forzada sin confirmaci√≥n. |
| `-AllowClobber` | Permite sobrescribir comandos existentes. |
| `-AcceptLicense` | Acepta autom√°ticamente la licencia del m√≥dulo. |
| `-RequiredVersion` | Instala una versi√≥n espec√≠fica del m√≥dulo. |



Despu√©s de la instalaci√≥n, puede canalizar cualquier salida a `Out-ConsoleGridView` para un trabajo interactivo.

```powershell   
# Ejemplo cl√°sico: mostrar una lista de procesos en una tabla interactiva
Get-Process | Out-ConsoleGridView
```

[1](https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>



**Interfaz:**
*   **Filtrado:** Simplemente comience a escribir, y la lista se filtrar√° sobre la marcha.
*   **Navegaci√≥n:** Use las teclas de flecha para moverse por la lista.
*   **Selecci√≥n:** Presione `Espacio` para seleccionar/deseleccionar un elemento.
*   **Selecci√≥n m√∫ltiple:** `Ctrl+A` para seleccionar todos los elementos, `Ctrl+D` para deseleccionar todos.
*   **Confirmaci√≥n:** Presione `Enter` para devolver los objetos seleccionados.
*   **Cancelar:** Presione `ESC` para cerrar la ventana sin devolver datos.




## Qu√© puede hacer `Out-ConsoleGridView`:

* Mostrar datos tabulares directamente en la consola de PowerShell como una tabla interactiva con navegaci√≥n por filas y columnas.
* Ordenar columnas presionando teclas.
* Filtrar datos usando la b√∫squeda.
* Seleccionar una o varias filas con retorno de resultados.
* Trabajar en una consola limpia sin ventanas GUI.
* Admitir un gran n√∫mero de filas con desplazamiento.
* Admitir varios tipos de datos (cadenas, n√∫meros, fechas, etc.).

---

## Ejemplos de uso de `Out-ConsoleGridView`

### Uso b√°sico ‚Äî mostrar una tabla con capacidad de selecci√≥n interactiva. (casilla de verificaci√≥n)

```powershell
Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Mostrar una tabla con capacidades de filtrado, ordenaci√≥n y selecci√≥n de filas
$selected = $data | Out-ConsoleGridView -Title "Seleccionar proceso(s)" -OutputMode Multiple

$selected | Format-Table -AutoSize
```

[2](https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356)

<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>



La lista de procesos se muestra en una tabla de consola interactiva. 
Puede filtrar por nombre, ordenar columnas y seleccionar procesos. 
Los procesos seleccionados se devuelven a la variable `$selected`.

---

### Selecci√≥n de una sola fila con retorno de resultado obligatorio. (radio)



```powershell
$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Seleccionar un servicio" -OutputMode Single

Write-Host "Ha seleccionado el servicio: $($choice.Name)"
```

[](https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e)

<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>


El usuario selecciona una sola fila (servicio). `-OutputMode Single` impide selecciones m√∫ltiples.

---

### Filtrado y ordenaci√≥n de grandes matrices

```powershell
$data = 1..1000 | ForEach-Object { 
    [PSCustomObject]@{ 
        Number = $_ 
        Square = $_ * $_ 
        Cube    = $_ * $_ * $_ 
    } 
}

$data | Out-ConsoleGridView -Title "N√∫meros y potencias"  -OutputMode Multiple
```

Muestra una tabla de 1000 filas con n√∫meros y sus potencias.



### **Gesti√≥n interactiva de procesos:**

Puede seleccionar varios procesos para detener. El par√°metro `-OutputMode Multiple` indica que queremos devolver todos los elementos seleccionados.



```powershell
# Canalizar los resultados.
# Detener los procesos seleccionados con el par√°metro -WhatIf para vista previa.
# Para ello, defina la variable $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple
    
# Si se seleccion√≥ algo, pase los objetos m√°s adelante en la canalizaci√≥n
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
```

### **Selecci√≥n de archivos para archivar:**
    Encuentre todos los archivos `.log` en una carpeta, seleccione los necesarios y cree un archivo a partir de ellos.

```powershell
$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
```

    ‚ùóTenga cuidado con la recursi√≥n

```powershell
if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip
    
    # Agregar mensaje de √©xito
    Write-Host "‚úÖ ¬°Archivado completado con √©xito!" -ForegroundColor Green
}
```


### **Selecci√≥n de un solo elemento para an√°lisis detallado:**


#### Patr√≥n "Drill-Down" ‚Äî de la lista general a los detalles con `Out-ConsoleGridView`

A menudo, al trabajar con objetos del sistema, nos enfrentamos a un dilema:
1.  Si solicita **todas las propiedades** para **todos los objetos** (`Get-NetAdapter | Format-List *`), la salida ser√° enorme e ilegible.
2.  Si muestra una **tabla breve**, perderemos detalles importantes.
3.  A veces, intentar obtener todos los datos a la vez puede provocar un error si uno de los objetos contiene valores no v√°lidos.

La soluci√≥n a este problema es el patr√≥n **"Drill-Down"** (detallado o "profundizaci√≥n"). Su esencia es simple:

*   **Paso 1 (Descripci√≥n general):** Mostrar al usuario una lista de elementos limpia, concisa y segura para la **selecci√≥n**.
*   **Paso 2 (Detalle):** Despu√©s de que el usuario haya seleccionado un elemento espec√≠fico, mostrarle **toda la informaci√≥n disponible** para ese elemento en particular.


#### Ejemplo pr√°ctico: Creaci√≥n de un explorador de adaptadores de red

Implementemos este patr√≥n usando el comando `Get-NetAdapter` como ejemplo.

**Tarea:** Primero, mostrar una breve lista de adaptadores de red. Despu√©s de seleccionar uno de ellos, abrir una segunda ventana con todas sus propiedades.

**C√≥digo listo:**
```powershell
# --- Etapa 1: Selecci√≥n de un adaptador de una lista breve ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "ETAPA 1: Seleccione un adaptador de red"

# --- Etapa 2: Mostrar informaci√≥n detallada o un mensaje de cancelaci√≥n ---
if ($null -ne $selectedAdapter) {
    # Obtener TODAS las propiedades para el adaptador SELECCIONADO
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Use nuestro truco con .psobject.Properties para convertir el objeto en una tabla conveniente "Nombre-Valor"
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value
    
    # Abrir una SEGUNDA ventana de GridView con informaci√≥n completa
    $detailedInfoForGrid | Out-ConsoleGridView -Title "ETAPA 2: Informaci√≥n completa para '$($selectedAdapter.Name)'"
} else {
    Write-Host "Operaci√≥n cancelada. No se seleccion√≥ ning√∫n adaptador." -ForegroundColor Yellow
}
```

#### Desglose paso a paso

1.  **Creaci√≥n de una lista "segura":**
    `$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed`
    No canalizamos la salida de `Get-NetAdapter` directamente. En su lugar, creamos nuevos objetos "limpios" usando `Select-Object`, incluyendo solo las propiedades que necesitamos para una descripci√≥n general. Esto asegura que los datos problem√°ticos que causaron un error ser√°n descartados.

2.  **Primera ventana interactiva:**
    `$selectedAdapter = $adapterList | Out-ConsoleGridView ...`
    El script muestra la primera ventana y **pausa su ejecuci√≥n**, esperando su selecci√≥n. Una vez que seleccione una fila y presione `Enter`, el objeto correspondiente a esa fila se escribir√° en la variable `$selectedAdapter`.

3.  **Comprobaci√≥n de la selecci√≥n:**
    `if ($null -ne $selectedAdapter)`
    Esta es una comprobaci√≥n de importancia cr√≠tica. Si el usuario presiona `Esc` o cierra la ventana, la variable `$selectedAdapter` estar√° vac√≠a (`$null`). Esta comprobaci√≥n evita que el resto del c√≥digo se ejecute y que se produzcan errores.

4.  **Obtenci√≥n de informaci√≥n completa:**
    `$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name`
    Aqu√≠ est√° el punto clave del patr√≥n. Volvemos a llamar a `Get-NetAdapter`, pero esta vez solicitamos **solo un** objeto por su nombre, que tomamos del elemento seleccionado en la primera etapa. Ahora obtenemos el objeto completo con todas sus propiedades.

5.  **Transformaci√≥n para la segunda ventana:**
    `$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...`
    Usamos el potente truco que ya conoce para "desenrollar" este √∫nico objeto complejo en una larga lista de pares "Nombre de propiedad" | "Valor", lo cual es ideal para mostrar en una tabla.

6.  **Segunda ventana interactiva:**
    `$detailedInfoForGrid | Out-ConsoleGridView ...`
    Aparece una segunda ventana en la pantalla, esta vez con informaci√≥n completa sobre el adaptador que seleccion√≥.


---



### Ejemplo con t√≠tulo personalizado y sugerencias

Mostrar el registro de eventos de Windows en una tabla interactiva con el t√≠tulo "Eventos del sistema".

```powershell
Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
```
Este c√≥digo recupera los √∫ltimos 50 eventos del registro del sistema de Windows, selecciona solo cuatro propiedades clave (hora, tipo, origen y mensaje) de cada evento y los muestra en la ventana Out-ConsoleGridView.

----

### Informaci√≥n del sistema.


[1](https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>


C√≥digo para el script de informaci√≥n del sistema:
[Get-SystemMonitor.ps1](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1)


### Creaci√≥n del cmdlet 'Get-SystemMonitor'


#### Paso 1: Configuraci√≥n de la variable `PATH`

1.  **Cree una carpeta permanente para sus herramientas,** si a√∫n no lo ha hecho. Por ejemplo:
    `C:\PowerShell\Scripts`

2.  **Coloque su archivo** `Get-SystemMonitor.ps1` en esta carpeta.

3.  **Agregue esta carpeta a la variable del sistema `PATH`**,

#### Paso 2: Configuraci√≥n de un alias en el perfil de PowerShell

Ahora que el sistema sabe d√≥nde encontrar su script por su nombre completo, podemos crear un alias corto para √©l.

1.  **Abra su archivo de perfil de PowerShell**:
    ```powershell
    notepad $PROFILE
    ```

2.  **Agregue la siguiente l√≠nea:**
    ```powershell
    # Alias para el monitor del sistema
    Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
    ```

    **Tenga en cuenta el punto clave:** Dado que la carpeta con el script ya est√° en `PATH`, ¬°ya no necesitamos especificar la ruta completa al archivo! Simplemente nos referimos a su nombre. Esto hace que su perfil sea m√°s limpio y confiable. Si alguna vez mueve la carpeta `C:\PowerShell\Scripts`, solo necesitar√° actualizar la variable `PATH`, y su archivo de perfil permanecer√° sin cambios.

#### Reiniciar PowerShell

Cierre **todas** las ventanas de PowerShell abiertas y abra una nueva. Esto es necesario para que el sistema aplique los cambios tanto a la variable `PATH` como a su perfil.

---

### Resultado: Lo que obtiene

Despu√©s de realizar estos pasos, podr√° llamar a su script **de dos maneras desde cualquier lugar del sistema**:

1.  **Por nombre completo (confiable, para usar en otros scripts):**
    ```powershell
    Get-SystemMonitor.ps1
    Get-SystemMonitor.ps1 -Resource storage
    ```

2.  **Por alias corto (conveniente, para trabajo interactivo):**
    ```powershell
    sysmon
    sysmon -Resource memory
    ```

Ha "registrado" con √©xito su script en el sistema de la manera m√°s profesional y flexible.


¬ø√ötil? Suscr√≠base.
Le gust√≥ ‚Äî ponga "+"
¬°Buena suerte! üöÄ

Otros art√≠culos de PowerShell:
