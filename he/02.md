# פילוסופיית PowerShell.
## חלק 2: צינור (Pipeline), משתנים, Get-Member, קובץ \*.ps1 וייצוא תוצאות
**❗ חשוב:**
אני כותב על PS7 (PowerShell 7). הוא שונה מ-PS5 (PowerShell 5). החל מהגרסה השביעית, PowerShell הפך לחוצה פלטפורמות. בגלל זה, התנהגותן של פקודות מסוימות השתנתה.

בחלק הראשון קבענו עיקרון מפתח: PowerShell עובד עם **אובייקטים**, לא עם טקסט.
פוסט זה מוקדש לכמה כלים חשובים של PowerShell: נלמד כיצד להעביר אובייקטים דרך **צינור (pipeline)**, לנתח אותם באמצעות **`Get-Member`**, לשמור תוצאות ב**משתנים** ולאוטומט את כל זה ב**קבצי סקריפט (`.ps1`)** עם **ייצוא** תוצאות לפורמטים נוחים.

### 1. מהו צינור (`|`)?
צינור ב-PowerShell הוא מנגנון להעברת אובייקטי .NET מלאים (ולא רק טקסט) מפקודה אחת לאחרת, כאשר כל cmdlet הבא מקבל אובייקטים מובנים עם כל התכונות והמתודות שלהם.

הסימן `|` (קו אנכי) הוא אופרטור הצינור. תפקידו לקחת את התוצאה (הפלט) של הפקודה משמאל לו, ולהעביר אותה כקלט לפקודה מימין לו.

`פקודה 1 (יוצרת אובייקטים)` → `|` → `פקודה 2 (מקבלת ומעבדת אובייקטים)` → `|` → `פקודה 3 (מקבלת אובייקטים מעובדים)` → | ...

#### צינור UNIX קלאסי: זרם טקסט

ב-`bash`, הצינור מעביר **זרם בתים**, אשר בדרך כלל מתפרש כטקסט.

```bash
# מצא את כל תהליכי 'nginx' וספור את כמותם
ps -ef | grep 'nginx' | wc -l
```
כאן `ps` מוציא טקסט, `grep` מסנן את הטקסט הזה, ו-`wc` סופר שורות. כל כלי עזר אינו יודע דבר על "תהליכים", הוא עובד רק עם שורות.

#### צינור PowerShell: זרם אובייקטים
**דוגמה:** בואו נקבל את כל התהליכים, נמיין אותם לפי שימוש במעבד ונבחר את 5 ה"זללנים" ביותר.

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
!(assets/02/1.png)

כאן `Get-Process` יוצר **אובייקטי** תהליכים. `Sort-Object` מקבל את ה**אובייקטים** הללו וממיין אותם לפי המאפיין `CPU`. `Select-Object` מקבל את ה**אובייקטים** הממוינים ובוחר את 5 הראשונים.

בטח שמתם לב במילים בפקודה שמתחילות במקף (-): -Property, -Descending, -First. אלו פרמטרים.
פרמטרים הם הגדרות, מתגים והוראות עבור ה-cmdlet. הם מאפשרים לשלוט **כיצד** הפקודה תבצע את עבודתה.
ללא פרמטרים, הפקודה פועלת במצב ברירת מחדל, ועם פרמטרים אתם נותנים לה הנחיות ספציפיות.

סוגי פרמטרים עיקריים:

- פרמטר עם ערך: דורש מידע נוסף.

    `-Property CPU`: אנו אומרים ל-Sort-Object לפי איזה מאפיין למיין. CPU הוא ערך הפרמטר.

    `-First 5`: אנו אומרים ל-Select-Object כמה אובייקטים לבחור. 5 הוא ערך הפרמטר.

- פרמטר-מתג (דגל): אינו דורש ערך. עצם נוכחותו בפקודה מפעילה או מכבה התנהגות מסוימת.

   `-Descending`: דגל זה אומר ל-Sort-Object לשנות את סדר המיון לסדר הפוך (מהגדול לקטן). הוא אינו זקוק לערך נוסף – הוא עצמו הוראה.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
!(assets/02/2.png)
פקודה זו עונה על שאלה פשוטה מאוד:
**"כמה תהליכים בדיוק בשם `svchost.exe` פועלים כעת במערכת שלי?"**

#### ניתוח שלבים

##### **שלב 1: `Get-Process -Name 'svchost'`**

חלק זה של הפקודה פונה למערכת ההפעלה ומבקש למצוא **ללא יוצא מן הכלל** את כל התהליכים הפועלים, אשר שם קובץ ההפעלה שלהם הוא `svchost.exe`.
בניגוד לתהליכים מסוג `notepad` (שבדרך כלל יש אחד או שניים), תהליכי `svchost` תמיד **רבים** במערכת. הפקודה תחזיר **מערך (אוסף) של אובייקטים**,
כאשר כל אובייקט הוא תהליך `svchost` נפרד ומלא עם ID ייחודי משלו, שימוש בזיכרון וכו'.
PowerShell מצא במערכת, לדוגמה, 90 תהליכי `svchost` וכעת מחזיק בידיו אוסף של 90 אובייקטים.

##### **שלב 2: `|` (אופרטור צינור)**

סימן זה לוקח את אוסף 90 אובייקטי ה-`svchost`, שהתקבלו בשלב הראשון, ומתחיל להעביר אותם **אחד אחד** כקלט לפקודה הבאה.

##### **שלב 3: `Measure-Object`**

מכיוון שקראנו ל-`Measure-Object` ללא פרמטרים (כגון `-Property`, `-Sum` וכו'), הוא מבצע את פעולתו **כברירת מחדל** – פשוט סופר את מספר ה"פריטים" שהועברו אליו.
אחד, שניים, שלושה... לאחר שכל האובייקטים נספרו, `Measure-Object` יוצר **אובייקט תוצאה משלו**, ובו קיים מאפיין `Count`, השווה למספר הסופי.

**`Count: 90`** – זוהי התשובה לשאלתנו. 90 תהליכי `svchost` פועלים.
שדות אחרים ריקים, מכיוון שלא ביקשנו מ-`Measure-Object` לבצע חישובים מורכבים יותר.

#### דוגמה עם `svchost` ופרמטרים

בואו נשנה את המשימה שלנו. כעת איננו רוצים רק לספור את תהליכי ה-`svchost`,
אלא לדעת **כמה זיכרון RAM בסך הכל (במגה-בייט) הם צורכים יחד**.

לשם כך נצטרך פרמטרים:
*   `-Property WorkingSet64`: הוראה זו אומרת ל-`Measure-Object`: "מכל אובייקט `svchost` שיגיע אליך, קח את הערך המספרי מהמאפיין `WorkingSet64` (זהו שימוש בזיכרון בבתים)".
*   `-Sum`: הוראה-דגל זו אומרת: "סכם את כל הערכים האלה שלקחת מהמאפיין `WorkingSet64`".

הפקודה החדשה שלנו תיראה כך:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
!(assets/02/3.png)

1.  `Get-Process` ימצא את מספר אובייקטי ה-`svchost`.
2.  הצינור `|` יעביר אותם ל-`Measure-Object`.
3.  אבל כעת `Measure-Object` עובד בצורה חדשה:
    *   הוא לוקח את אובייקט ה-`svchost` הראשון, בודק את המאפיין שלו `.WorkingSet64` (לדוגמה, `25000000` בתים) וזוכר את המספר הזה.
    *   הוא לוקח את האובייקט השני, בודק את המאפיין שלו `.WorkingSet64` (לדוגמה, `15000000` בתים) ומוסיף אותו לקודם.
    *   ...וכן הלאה עבור כל האובייקטים.
4.  בסופו של דבר, `Measure-Object` ייצור אובייקט תוצאה, אך הפעם הוא יהיה שונה.

*   **`Count: 92`**: מספר האובייקטים.
*   **`Sum: 1661890560`**: זהו הסכום הכולל של כל ערכי `WorkingSet64` בבתים.
*   **`Property: WorkingSet64`**: שדה זה מלא כעת גם הוא, והוא מודיע לנו איזה מאפיין בדיוק שימש לחישובים.

### 2. משתנים (רגילים ו-`$_` מיוחד)

משתנה הוא מקום אחסון בעל שם בזיכרון, המכיל ערך כלשהו.

ערך זה יכול להיות כל דבר: טקסט, מספר, תאריך, או, וזה החשוב ביותר עבור PowerShell,
אובייקט שלם או אפילו אוסף של אובייקטים. שם המשתנה ב-PowerShell תמיד מתחיל בסימן דולר ($).
דוגמאות: $name, $counter, $processList.

המשתנה המיוחד $_?

$_ הוא קיצור ל"אובייקט הנוכחי" או "הדבר הזה".
תארו לעצמכם צינור במפעל. לאורכו נעים חלקים שונים (אובייקטים).

$_ הוא החלק שנמצא כרגע ממש מולכם (או מול הרובוט המעבד).

מקור (Get-Process) – שופך על הצינור קופסה שלמה של חלקים (כל התהליכים).

צינור (|) – גורם לחלקים אלה לנוע על המסוע אחד אחד.

מעבד (Where-Object או ForEach-Object) – זהו רובוט שמסתכל על כל חלק.

המשתנה $_ – זהו החלק שנמצא כרגע ב"ידיים" של הרובוט.

כאשר הרובוט יסיים עם חלק אחד, הצינור יגיש לו את הבא, ו-`$_` יצביע כעת עליו.

בואו נחשב כמה זיכרון בסך הכל משתמשים תהליכי `svchost`, ונציג את התוצאה על המסך.
```powershell
# 1. מבצעים את הפקודה ושומרים את אובייקט התוצאה המורכב שלה במשתנה $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. כעת אנו יכולים לעבוד עם האובייקט השמור. מוציאים ממנו את המאפיין Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. מציגים את התוצאה על המסך, באמצעות המשתנה החדש
Write-Host "כל תהליכי svchost משתמשים ב-$memoryInMB מגה-בייט זיכרון."
```
!(assets/02/4.png)

*   `Write-Host` – זהו cmdlet מיוחד, שתפקידו היחיד הוא **להציג טקסט ישירות למשתמש בקונסולה**.

*   מחרוזת במרכאות כפולות: `"..."` - מחרוזת טקסט שאנו מעבירים ל-cmdlet `Write-Host` כארגומנט. מדוע מרכאות כפולות ולא בודדות?

    ב-PowerShell יש שני סוגי מרכאות:

    *   **בודדות (`'...'`):** יוצרות **מחרוזת מילולית**. כל מה שבתוכן נתפס כטקסט רגיל, ללא יוצא מן הכלל.
    *   **כפולות (`"..."`):** יוצרות **מחרוזת ניתנת להרחבה (או החלפה)**. PowerShell "סורק" מחרוזת כזו עבור משתנים (המתחילים ב-`$`) ומחליף אותם בערכיהם.

* `$memoryInMB`. זהו משתנה שאליו **בשלב הקודם** של הסקריפט שלנו הכנסנו את תוצאת החישובים. כאשר `Write-Host` מקבל מחרוזת במרכאות כפולות,
מתרחש תהליך הנקרא **"הרחבת מחרוזת" (String Expansion)**:
    1.  PowerShell רואה את הטקסט `"כל תהליכי svchost משתמשים ב-"`.
    2.  לאחר מכן הוא נתקל במבנה `$memoryInMB`. הוא מבין שזה לא סתם טקסט, אלא משתנה.
    3.  הוא מציץ בזיכרון, מוצא את הערך השמור ב-`$memoryInMB` (לדוגמה, `1585.52`).
    4.  הוא **מציב את הערך הזה** ישירות לתוך המחרוזת.
    5.  לאחר מכן הוא מוסיף את שאר הטקסט: `" מגה-בייט זיכרון."`.
    6.  בסופו של דבר, ל-`Write-Host` מועברת מחרוזת מוכנה ומורכבת: `"כל תהליכי svchost משתמשים ב-1585.52 מגה-בייט זיכרון."`.

הפעל את פנקס הרשימות:
1. מוצאים את תהליך פנקס הרשימות ושומרים אותו במשתנה $notepadProcess
```powershell
$notepadProcess = Get-Process -Name notepad
```

2. פונים למאפיין 'Id' של אובייקט זה באמצעות נקודה ומציגים אותו
```powershell
Write-Host "מזהה תהליך 'פנקס רשימות' הוא: $($notepadProcess.Id)"
```
!(assets/02/5.png)

**❗ חשוב:**
`Write-Host` "שובר" את הצינור. טקסט המוצג על ידו אינו יכול להיות מועבר הלאה בצינור לעיבוד. הוא מיועד רק לתצוגה.

### 3. Get-Member (מפקח אובייקטים)

אנו יודעים שאובייקטים "זורמים" בצינור. אבל איך נדע ממה הם מורכבים? אילו מאפיינים יש להם ואילו פעולות (מתודות) ניתן לבצע עליהם?

ה-cmdlet **`Get-Member`** (כינוי: `gm`) הוא הכלי העיקרי לחקירה.
לפני שתעבוד עם אובייקט, העבר אותו דרך `Get-Member` כדי לראות את כל יכולותיו.

בואו ננתח את האובייקטים ש-`Get-Process` יוצר:
```powershell
Get-Process | Get-Member
```
!(assets/02/6.png)

*נפרק כל חלק בפלט של Get-Member.*

`TypeName: System.Diagnostics.Process` - זהו ה"שם המלא" הרשמי של סוג האובייקט מספריית .NET. זהו ה"דרכון" שלו.
שורה זו אומרת לכם שכל האובייקטים ש-Get-Process מחזיר הם אובייקטים מסוג System.Diagnostics.Process.
זה מבטיח שלכולם יהיה אותו סט של מאפיינים ומתודות.
אתם יכולים [לחפש בגוגל](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process" כדי למצוא את התיעוד הרשמי של מיקרוסופט עם מידע מפורט עוד יותר.

- עמודה 1: `Name`

זהו פשוט **שם** קריא לאדם של מאפיין, מתודה או "חבר" אחר של האובייקט. זהו השם שתשתמשו בו בקוד שלכם כדי לגשת לנתונים או לבצע פעולות.

- עמודה 2: `MemberType` (סוג אובייקט)

זוהי העמודה החשובה ביותר להבנה. היא מסווגת **מהו** כל אובייקט. זוהי ה"תפקיד" שלו, שאומר לכם **כיצד** להשתמש בו.

*   **`Property` (מאפיין):** **מאפיין** או **חלק נתונים**, השמור בתוך האובייקט. ניתן "לקרוא" את ערכו.
    *   *דוגמאות בצילום המסך:* `BasePriority`, `HandleCount`, `ExitCode`. אלו פשוט נתונים שניתן לצפות בהם.

*   **`Method` (מתודה):** **פעולה**, שניתן לבצע על אובייקט. מתודות תמיד נקראות עם סוגריים עגולים `()`.
    *   *דוגמאות בצילום המסך:* `Kill`, `Refresh`, `WaitForExit`. הייתם כותבים `$process.Kill()` או `$process.Refresh()`.

*   **`AliasProperty` (כינוי מאפיין):** **כינוי ידידותי** למאפיין אחר, ארוך יותר. PowerShell מוסיף אותם לנוחות וקיצור.
    *   *דוגמאות בצילום המסך:* `WS` – זהו כינוי קצר ל-`WorkingSet64`. `Name` – ל-`ProcessName`. `VM` – ל-`VirtualMemorySize64`.

*   **`Event` (אירוע):** **הודעה** על כך שמשהו קרה, שאליה ניתן "להירשם".
    *   *דוגמה בצילום המסך:* `Exited`. הסקריפט שלכם יכול "להאזין" לאירוע זה כדי לבצע פעולה כלשהי מיד לאחר שהתהליך מסתיים.

*   **`CodeProperty` ו-`NoteProperty`:** סוגים מיוחדים של מאפיינים, המוספים לעיתים קרובות על ידי PowerShell עצמו לנוחות. `CodeProperty` מחשב את ערכו "בזמן אמת", ואילו `NoteProperty` הוא מאפיין-הערה פשוט, שנוסף לאובייקט.

- עמודה 3: `Definition` (הגדרה)

זוהי **ההגדרה הטכנית** או "החתימה" של החבר. היא נותנת לכם פרטים מדויקים לשימוש בו. תוכנה תלוי ב-`MemberType`:

*   **עבור `AliasProperty`:** מראה **למה שווה הכינוי**. זה שימושי להפליא!
    *   *דוגמה בצילום המסך:* `WS = WorkingSet64`. אתם רואים מיד ש-`WS` הוא פשוט קיצור ל-`WorkingSet64`.

*   **עבור `Property`:** מראה **את סוג הנתונים** השמור במאפיין (לדוגמה, `int` למספר שלם, `string` לטקסט, `datetime` לתאריך ושעה), ומה ניתן לעשות איתו (`{get;}` – רק לקרוא, `{get;set;}` – לקרוא ולשנות).
    *   *דוגמה בצילום המסך:* `int BasePriority {get;}`. זהו מאפיין שלם שניתן רק לקרוא.

*   **עבור `Method`:** מראה מה המתודה מחזירה (לדוגמה, `void` – כלום, `bool` – אמת/שקר) ואילו **פרמטרים** (נתוני קלט) היא מקבלת בסוגריים.
    *   *דוגמה בצילום המסך:* `void Kill()`. זה אומר שהמתודה `Kill` לא מחזירה כלום וניתן לקרוא לה ללא פרמטרים. קיימת גם גרסה שנייה `void Kill(bool entireProcessTree)`, שמקבלת ערך בוליאני (אמת/שקר).

#### בטבלה

| עמודה      | מה זה?                             | דוגמה מצילום המסך                  | למה זה משמש?                                                                   |
|--------------|--------------------------------------|--------------------------------------------|-----------------------------------------------------------------------------------------|
| **Name**     | השם שבו אתם משתמשים בקוד.  | `Kill`, `WS`, `Name`                       | לפנות למאפיין או למתודה (`$process.WS`, `$process.Kill()`).    |
| **MemberType**| סוג החבר (נתונים, פעולה וכו'). | `Method`, `Property`, `AliasProperty`      | **כיצד** להשתמש בו (לקרוא ערך או לקרוא עם `()`).              |
| **Definition** | פרטים טכניים.                  | `WS = WorkingSet64`, `void Kill()`           | מה מסתתר מאחורי הכינוי ואילו פרמטרים נדרשים למתודה.                |

#### דוגמה: עבודה עם חלונות תהליכים

##### 1. בעיה:
"פתחתי חלונות פנקס רשימות רבים. איך אוכל לכווץ את כולם באופן תוכנתי, למעט הראשי, ולאחר מכן לסגור רק את זה שבכותרתו מופיעה המילה 'Untitled'?"

##### 2. חקירה עם `Get-Member`:
עלינו למצוא מאפיינים הקשורים לחלון ולכותרתו.

```powershell
Get-Process -Name notepad | Get-Member
```
!(assets/02/7.png)

**ניתוח תוצאת `Get-Member`:**
*   בגלילה בין המאפיינים, אנו מוצאים את `MainWindowTitle`. סוג `string`. מצוין, זו כותרת החלון הראשי!
*   במתודות אנו רואים `CloseMainWindow()`. זו דרך "עדינה" יותר לסגור חלון מאשר `Kill()`.
*   כמו כן, במתודות יש `WaitForInputIdle()`. נשמע מעניין, אולי זה יעזור לחכות עד שהתהליך יהיה מוכן לאינטראקציה.

!(assets/02/7.png)

`Get-Member` הראה לנו את המאפיין `MainWindowTitle`, שהוא המפתח לפתרון הבעיה ומאפשר אינטראקציה עם תהליכים על בסיס מצב החלונות שלהם, ולא רק לפי שם.

##### 3. פתרון:
כעת אנו יכולים לבנות לוגיקה המבוססת על כותרת החלון.

```powershell
# 1. מוצאים את כל תהליכי פנקס הרשימות
$notepads = Get-Process -Name notepad

# 2. עוברים על כל אחד ובודקים את הכותרת
foreach ($pad in $notepads) {
    # עבור כל תהליך ($pad) בודקים את המאפיין MainWindowTitle שלו
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "נמצא פנקס רשימות לא שמור (ID: $($pad.Id)). סוגרים את החלון שלו..."
        # $pad.CloseMainWindow() # הסירו את ההערה כדי לסגור באמת
        Write-Host "החלון '$($pad.MainWindowTitle)' היה נסגר." -ForegroundColor Yellow
    } else {
        Write-Host "מדלגים על פנקס רשימות עם כותרת: $($pad.MainWindowTitle)"
    }
}
```

!(assets/02/8.png)

!(assets/02/9.png)

---

#### דוגמה: מציאת תהליך אב

##### 1. בעיה:
"לפעמים אני רואה במערכת הרבה תהליכי `chrome.exe` צאצאים. איך אוכל לדעת איזה מהם הוא התהליך הראשי, ה'אב', שהפעיל את כולם?"

##### 2. חקירה עם `Get-Member`:
עלינו למצוא משהו שמקשר תהליך אחד לאחר.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
!(assets/02/10.png)

**ניתוח תוצאת `Get-Member`:**
*   בבדיקה מדוקדקת של הרשימה, אנו מוצאים מאפיין מסוג `CodeProperty` בשם `Parent`.
*   ההגדרה שלו (`Definition`) – `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
זהו מאפיין מחושב, אשר כאשר פונים אליו, מחזיר **אובייקט של תהליך האב**.

##### 3. פתרון:
כעת אנו יכולים לכתוב סקריפט, אשר עבור כל תהליך `chrome` יציג מידע על האב שלו.

```powershell
# 1. מקבלים את כל תהליכי chrome
$chromeProcesses = Get-Process -Name chrome

# 2. עבור כל אחד מהם מציגים מידע עליו ועל האב שלו
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # מקבלים את תהליך האב
    $parent = $_.Parent
    
    # יוצרים פלט יפה
    Write-Host "תהליך:" -ForegroundColor Green
    Write-Host "  - שם: $($_.ProcessName), מזהה: $($_.Id)"
    Write-Host "האב שלו:" -ForegroundColor Yellow
    Write-Host "  - שם: $($parent.ProcessName), מזהה: $($parent.Id)"
    Write-Host "-----------------------------"
}
```
!(assets/02/11.png)

!(assets/02/12.png)

אנו רואים מיד שתהליכים עם מזהים 4756, 7936, 8268 ו-9752 הופעלו על ידי תהליך עם מזהה 14908. ניתן גם להבחין במקרה מעניין עם תהליך מזהה: 7252, שתהליך האב שלו לא הוגדר (ייתכן שהאב כבר הספיק להסתיים עד למועד הבדיקה). שינוי הסקריפט עם בדיקת if ($parent) מטפל במקרה זה בעדינות, מבלי לגרום לשגיאה.
Get-Member עזר לנו לגלות את המאפיין "הנסתר" Parent, המספק יכולות עוצמתיות לניתוח היררכיית תהליכים.

#### 4. קובץ \*.ps1 (יצירת סקריפטים)

כאשר שרשרת הפקודות שלכם הופכת לשימושית, תרצו לשמור אותה לשימוש חוזר. לשם כך נועדו **סקריפטים** – קבצי טקסט עם סיומת **`.ps1`**.

##### הרשאה להפעלת סקריפטים
כברירת מחדל, הפעלת סקריפטים מקומיים אסורה ב-Windows. כדי לתקן זאת **עבור המשתמש הנוכחי**, הפעילו פעם אחת ב-PowerShell **כמנהל מערכת**:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
זוהי הגדרה בטוחה המאפשרת להפעיל סקריפטים משלכם וסקריפטים חתומים על ידי מפרסם מהימן.

##### דוגמה לסקריפט `system_monitor.ps1`
צרו קובץ בשם זה והדביקו בו את הקוד שלהלן. סקריפט זה אוסף מידע על המערכת ומייצר דוחות.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    סקריפט ליצירת דוח על מצב המערכת.
.DESCRIPTION
    אוסף מידע על תהליכים, שירותים ושטח דיסק ומייצר דוחות.
.PARAMETER OutputPath
    נתיב לשמירת הדוחות. ברירת מחדל 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- בלוק 1: הכנה ---
Write-Host "מתכונן ליצירת דוח..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- בלוק 2: איסוף נתונים ---
Write-Host "אוסף מידע..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- בלוק 3: קריאה לפונקציה לייצוא (ראה סעיף הבא) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "הדוחות נשמרו בהצלחה בתיקייה $OutputPath" -ForegroundColor Magenta
```
*הערה: הפונקציה `Export-Results` תוגדר בסעיף הבא כדוגמה לפרקטיקה טובה.*

#### 5. ייצוא תוצאות

נתונים נקיים זה טוב, אבל לעיתים קרובות צריך להציג אותם בצורה נוחה לבני אדם או לתוכנות אחרות. PowerShell מציע מגוון רחב של cmdlets לייצוא.

| שיטה                               | פקודה                                            | תיאור                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **טקסט פשוט**                   | `... \| Out-File C:\Temp\data.txt`                 | מפנה ייצוג טקסטואלי לקובץ.                                      |
| **CSV (עבור Excel)**                 | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | מייצא אובייקטים ל-CSV. `-NoTypeInfo` מסיר את השורה הראשונה השירותית.     |
| **דוח HTML**                      | `... \| ConvertTo-Html -Title "דוח"`             | יוצר קוד HTML מאובייקטים.                                                       |
| **JSON (עבור API, אינטרנט)**             | `... \| ConvertTo-Json`                            | ממיר אובייקטים לפורמט JSON.                                                  |
| **XML (פורמט מקורי של PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml`            | שומר אובייקטים עם כל סוגי הנתונים. ניתן לשחזר אותם באופן מושלם באמצעות `Import-Clixml`. |

##### תוספת לסקריפט: פונקציית ייצוא
בואו נוסיף לסקריפט `system_monitor.ps1` שלנו פונקציה שתטפל בייצוא. מקמו את הקוד הזה **לפני** הקריאה ל-`Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # ייצוא ל-CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # יצירת דוח HTML יפה
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>10 התהליכים המובילים לפי מעבד</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>סטטיסטיקת שירותים</h2>"

    ConvertTo-Html -Head "<title>דוח מערכת</title>" -Body "<h1>דוח מערכת מ-$(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
כעת הסקריפט שלנו לא רק אוסף נתונים, אלא גם שומר אותם בצורה מסודרת בשני פורמטים: CSV לניתוח ו-HTML לצפייה מהירה.

#### מסקנה

1.  **צינור (`|`)** – הכלי העיקרי לשילוב פקודות ועיבוד אובייקטים.
2.  **`Get-Member`** – ניתוח אובייקטים, המראה ממה הם מורכבים.
3.  **משתנים (`$var`, `$_`)** מאפשרים לשמור נתונים ולגשת לאובייקט הנוכחי בצינור.
4.  **קבצי `.ps1`** הופכים פקודות לכלי אוטומציה הניתנים לשימוש חוזר.
5.  **cmdlets ייצוא** (`Export-Csv`, `ConvertTo-Html`) מייצאים נתונים בפורמט המתאים.

**בחלק הבא נשתמש בידע זה כדי לנווט ולנהל את מערכת הקבצים, תוך חקירת אובייקטי `System.IO.DirectoryInfo` ו-`System.IO.FileInfo`.**