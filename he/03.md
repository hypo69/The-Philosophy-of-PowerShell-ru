# פילוסופיית PowerShell.

### **חלק 3: ניווט וניהול מערכת קבצים. אופרטורים לוגיים. מבוא לפונקציות.**

ב[חלק הקודם](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md) חקרנו צינורות (pipelines) ואובייקטים מופשטים של תהליכים.
כעת, בואו ניישם את הידע שלנו על צינורות ואובייקטים לאחת המשימות הנפוצות של משתמש או מנהל מערכת – עבודה עם מערכת הקבצים.
ב-PowerShell, עבודה זו בנויה על אותם עקרונות: פקודות מחזירות אובייקטים שניתן להעביר בצינור לעיבוד נוסף.

***

### **1. קונספט כונני PowerShell (PSDrives)**

לפני שנתחיל לעבוד עם קבצים, חשוב להבין את הקונספט של **כונני PowerShell (PSDrives)**. בניגוד ל-`cmd.exe`, שבו כוננים הם רק אותיות `C:`, `D:` וכן הלאה, ב-PowerShell "כונן" הוא הפשטה לגישה לכל אחסון נתונים היררכי.

```powershell
Get-PSDrive
```
התוצאה תציג לא רק כוננים פיזיים, אלא גם כונני פסאודו:

| שם | ספק | שורש | תיאור |
|------|----------|------|----------|
| Alias | Alias | Alias:\ | כינויי פקודות |
| C | FileSystem | C:\ | כונן מקומי C |
| Cert | Certificate | Cert:\ | מאגר אישורים |
| Env | Environment | Env:\ | משתני סביבה |
| Function | Function | Function:\ | פונקציות טעונות |
| HKCU | Registry | HKEY_CURRENT_USER | ענף רישום |
| HKLM | Registry | HKEY_LOCAL_MACHINE | ענף רישום |
| Variable | Variable | Variable:\ | משתני סשן |
| WSMan | WSMan | WSMan:\ | תצורת WinRM |

איחוד זה אומר שאתה יכול "להיכנס" לרישום (`Set-Location HKLM:`) ולקבל רשימה של המפתחות שלו באותה פקודה `Get-ChildItem`, שבה אתה מקבל רשימה של קבצים בכונן C:. זהו קונספט חזק להפליא.

#### **דוגמאות לעבודה עם ספקים שונים**

*   **מאגר אישורים (Cert:)**
    מאפשר לעבוד עם אישורים דיגיטליים כאילו היו קבצים בתיקיות.

    **משימה:** מצא את כל אישורי ה-SSL במחשב המקומי שתוקפם יפוג ב-30 הימים הקרובים.
    ```powershell
    # עוברים למאגר האישורים של המחשב המקומי
    Set-Location Cert:\LocalMachine\My

    # מוצאים אישורים שתאריך התפוגה שלהם קטן מהיום + 30 יום
    Get-ChildItem | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) } | Select-Object Subject, NotAfter, Thumbprint
    ```

*   **משתני סביבה (Env:)**
    מספק גישה למשתני סביבה של Windows (`%PATH%`, `%windir%` וכו') כאל קבצים.

    **משימה:** קבל את הנתיב לתיקיית המערכת של Windows והוסף אליו את הנתיב ל-`System32`.
    ```powershell
    # מקבלים את הערך של המשתנה windir
    $windowsPath = (Get-Item Env:windir).Value
    # או פשוט יותר: $windowsPath = $env:windir

    # מרכיבים בבטחה את הנתיב המלא
    $system32Path = Join-Path -Path $windowsPath -ChildPath "System32"
    Write-Host $system32Path
    # תוצאה: C:\WINDOWS\System32
    ```

*   **רישום Windows (HKCU: ו-HKLM:)**
    דמיין שהרישום הוא פשוט עוד מערכת קבצים. ענפים הם תיקיות, ופרמטרים הם מאפיינים של תיקיות אלה.

    **משימה:** גלה את השם המלא של גרסת Windows המותקנת מהרישום.
    ```powershell
    # עוברים לענף הרישום הרצוי
    Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

    # מקבלים את המאפיין (פרמטר רישום) בשם "ProductName"
    Get-ItemProperty -Path . -Name "ProductName"
    # תוצאה: ProductName : Windows 11 Pro
    ```

*   **פונקציות טעונות (Function:)**
    מציג את כל הפונקציות הזמינות בסשן PowerShell הנוכחי, כאילו היו קבצים.

    **משימה:** מצא את כל הפונקציות הטעונות שבשמן מופיעה המילה "Help", וצפה בקוד של אחת מהן.
    ```powershell
    # מחפשים פונקציות לפי מסכה
    Get-ChildItem Function: | Where-Object { $_.Name -like "*Help*" }

    # מקבלים את הקוד המלא (הגדרה) של הפונקציה Get-Help
    (Get-Item Function:Get-Help).Definition
    ```

*   **משתני סשן (Variable:)**
    מאפשר לנהל את כל המשתנים (`$myVar`, `$PROFILE`, `$Error` וכו') המוגדרים בסשן הנוכחי.

    **משימה:** מצא את כל המשתנים הקשורים לגרסת PowerShell (`$PSVersionTable`, `$PSHOME` וכו').
    ```powershell
    # מוצאים את כל המשתנים שמתחילים ב-"PS"
    Get-ChildItem Variable:PS*

    # מקבלים את הערך של משתנה ספציפי
    Get-Variable -Name "PSVersionTable"
    ```

### 2. **ניווט וניתוח**

#### **יסודות הניווט**

```powershell
# לדעת היכן אנו נמצאים (מחזיר אובייקט PathInfo)
Get-Location          # כינויים: gl, pwd

# מעבר לשורש כונן C:
Set-Location C:\      # כינויים: sl, cd

# מעבר לתיקיית הבית של המשתמש הנוכחי
Set-Location ~

# הצגת תוכן התיקייה הנוכחית (מחזיר אוסף אובייקטים)
Get-ChildItem         # כינויים: gci, ls, dir
```

```powershell
# **חיפוש רקורסיבי**
# מצא את קובץ hosts במערכת, תוך התעלמות משגיאות "גישה נדחתה"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
```
**מפתח `-Recurse` (רקורסיבי):** גורם לפקודה לעבוד לא רק עם הפריט שצוין, אלא גם עם כל תוכנו.

**מפתח `-ErrorAction SilentlyContinue`:** הוראה להתעלם משגיאות ולהמשיך לעבוד בשקט.

##### **ניתוח שטח דיסק**
דוגמה קלאסית לעוצמת הצינור: מצא, מיין, פרמט ובחר.
```powershell
Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue |
    Sort-Object Length -Descending |
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} |
    Select-Object -First 20
```

###### **טיפ כיצד להזין פקודות ארוכות.**
> PowerShell מאפשר לפצל אותן למספר שורות לנוחות הקריאה.
> 
> *   **לאחר אופרטור הצינור (`|`):** זו הדרך הנפוצה והנוחה ביותר. פשוט לחץ `Enter` לאחר הסימן `|`. PowerShell יבין שהפקודה לא הושלמה וימתין להמשך בשורה הבאה.
> *   **בכל מקום אחר:** השתמש בסימן הגרש ההפוך (backtick) `` ` `` בסוף השורה, ולאחר מכן לחץ `Enter`. סימן זה אומר ל-PowerShell: "הפקודה תימשך בשורה הבאה".
> *   **בעורכים (ISE, VS Code):** צירוף המקשים `Shift+Enter` בדרך כלל מכניס אוטומטית מעבר שורה, מבלי להפעיל את הפקודה.

#### **סינון תוכן ואופרטורים לוגיים**

```powershell
# מצא את כל קבצי ה-.exe. הפרמטר -Filter עובד מהר מאוד.
Get-ChildItem C:\Windows | Where-Object { $_.Extension -eq ".exe" }
```

`Get-ChildItem` מחזיר אוסף של אובייקטים. אנו יכולים להעביר אותו בצינור ל-`Where-Object` לסינון נוסף.

```powershell
# הצג רק קבצים
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
```
פקודה זו מציגה לנו אחד מהמושגים הבסיסיים בסקריפטים של PowerShell: **אופרטורי השוואה**.

#### **אופרטורי השוואה ולוגיקה**

אלו הם מפתחות מיוחדים להשוואת ערכים. הם תמיד מתחילים במקף (`-`) ומהווים את הבסיס לסינון נתונים ב-`Where-Object` ובניית לוגיקה ב-`if`.

| אופרטור | תיאור | דוגמה בצינור |
| :--- | :--- | :--- |
| `-eq` | שווה (EQual) | `$_.Name -eq "svchost.exe"` |
| `-ne` | לא שווה (Not Equal) | `$_.Status -ne "Running"` |
| `-gt` | גדול מ- (Greater Than) | `$_.Length -gt 1MB` |
| `-ge` | גדול או שווה ל- (Greater or Equal) | `$_.Handles -ge 500` |
| `-lt` | קטן מ- (Less Than) | `$_.LastWriteTime -lt (Get-Date).AddDays(-30)`|
| `-le` | קטן או שווה ל- (Less or Equal) | `$_.Count -le 1` |
| `-like` | דומה ל- (עם תווים כלליים `*`, `?`)| `$_.Name -like "win*"` |
| `-notlike`| לא דומה ל- | `$_.Name -notlike "*.tmp"` |
| `-in` | הערך כלול באוסף | `$_.Extension -in ".log", ".txt"` |
| `-and` | לוגי וגם (שני התנאים נכונים) | |
| `-or` | לוגי או (לפחות אחד מהתנאים נכון) | |
| `-not` | לוגי לא (הופך את התנאי) | |

נושא אופרטורי הלוגיקה הוא נרחב מאוד ואקדיש לו חלק נפרד (או אפילו שניים). בינתיים, חמושים באופרטורים אלה,
אנו יכולים **לסנן, למיין ולבחור את הקבצים והתיקיות הרצויים לנו**, תוך שימוש בכל עוצמת הצינור האובייקטיבי.

#### **דוגמאות שימוש במערכת הקבצים**

**מצא קובץ לפי שם מדויק (תלוי רישיות):**
```powershell
Get-ChildItem C:\Windows\System32 -Recurse | Where-Object { $_.Name -eq "kernel32.dll" }
```

**מצא את כל הקבצים שמתחילים ב-"host", אך אינם תיקיות:**
```powershell
Get-ChildItem C:\Windows\System32\drivers\etc | Where-Object { ($_.Name -like "host*") -and (-not $_.PSIsContainer) }
```

**מצא את כל קבצי היומן (.log) שגודלם עולה על 50 מגה-בייט:**
```powershell
Get-ChildItem C:\Windows\Logs -Filter "*.log" -Recurse | Where-Object { $_.Length -gt 50MB }
```

**מצא את כל קבצי הזמניים (.tmp) וקבצי הגיבוי (.bak) לניקוי:**
אופרטור `-in` כאן אלגנטי בהרבה מכמה תנאים עם `-or`.
```powershell
$extensionsToDelete = ".tmp", ".bak", ".old"
Get-ChildItem C:\Temp -Recurse | Where-Object { $_.Extension -in $extensionsToDelete }
```

**מצא את כל קבצי Word (.docx) שנוצרו בשבוע האחרון:**
```powershell
$oneWeekAgo = (Get-Date).AddDays(-7)
Get-ChildItem C:\Users\MyUser\Documents -Filter "*.docx" -Recurse | Where-Object { $_.CreationTime -ge $oneWeekAgo }
```

**מצא קבצים ריקים (בגודל 0 בתים) שאינם תיקיות:**
```powershell
Get-ChildItem C:\Downloads -Recurse | Where-Object { ($_.Length -eq 0) -and (-not $_.PSIsContainer) }
```

**מצא את כל קבצי ההפעלה (.exe) ששונו השנה, אך לא בחודש זה:**
דוגמה מורכבת זו מדגימה את עוצמת השילוב של אופרטורים.
```powershell
Get-ChildItem "C:\Program Files" -Filter "*.exe" -Recurse | Where-Object {
    ($_.LastWriteTime.Year -eq (Get-Date).Year) -and ($_.LastWriteTime.Month -ne (Get-Date).Month)
}
```

*(הערה: סוגריים `()` סביב כל תנאי משמשים לקיבוץ ולשיפור הקריאות, במיוחד במקרים מורכבים).*

היזהר עם רקורסיה:
הרבה מאוד קבצים/תיקיות — `-Recurse` יכול להיכנס רקורסיבית לעשרות אלפי פריטים.
קישורים סימבוליים / קישורים מחזוריים — עלולים לגרום לרקורסיה אינסופית.
קבצים ללא הרשאות גישה — עלולים לחסום את הביצוע.

### 4. **יצירה, ניהול ומחיקה בטוחה**

#### **יצירה, העתקה והעברה**

```powershell
New-Item -Path "C:\Temp\MyFolder" -ItemType Directory
Add-Content -Path "C:\Temp\MyFolder\MyFile.txt" -Value "שורה ראשונה"
Copy-Item -Path "C:\Temp\MyFolder" -Destination "C:\Temp\MyFolder_Copy" -Recurse
```

#### **מחיקה בטוחה**
`Remove-Item` – פקודה שעלולה להיות מסוכנת, ולכן ב-PowerShell קיימים מנגנוני הגנה מובנים.
> **מפתח `-WhatIf` (מה אם?):** החבר הטוב ביותר שלך. הוא **לא מבצע** את הפקודה, אלא רק מציג בקונסולה הודעה על **מה היה קורה**.

```powershell
# בדיקה בטוחה לפני מחיקה
Remove-Item C:\Temp\MyFolder -Recurse -Force -WhatIf
# תוצאה: What if: Performing the operation "Remove Directory" on target "C:\Temp\MyFolder".

# רק לאחר שווידאת שהכל נכון, הסר את -WhatIf ובצע את הפקודה
Remove-Item C:\Temp\MyFolder -Recurse -Force
```

### **מבוא לפונקציות**

כאשר שורת קוד אחת הופכת למערך מורכב של פקודות שברצונך להשתמש בהן שוב ושוב, הגיע הזמן ליצור **פונקציות**.

#### **כיצד להשתמש ולשמור פונקציות**

קיימות שלוש דרכים עיקריות להפוך את הפונקציות שלך לזמינות:

**שיטה 1: זמנית (לצורך בדיקות)**
אתה יכול להקליד בקונסולה או פשוט להעתיק ולהדביק את כל קוד הפונקציה לקונסולת PowerShell. הפונקציה תהיה זמינה עד לסגירת חלון זה.

**שיטה 2: קבועה, אך ידנית (באמצעות קובץ `.ps1`)**
זו הדרך הנפוצה ביותר לארגון ושיתוף כלים. אתה שומר את הפונקציה בקובץ `.ps1` וטוען אותה לסשן כאשר אתה זקוק לה.
> **Dot Sourcing (`. .​script.ps1`):** פקודה מיוחדת זו מפעילה את הסקריפט בהקשר *הנוכחי*, מה שהופך את כל הפונקציות והמשתנים שלה לזמינים בקונסולה שלך.

**שיטה 3: אוטומטית (באמצעות פרופיל PowerShell)**
זו הדרך החזקה ביותר עבור הכלים האישיים שלך, הנפוצים בשימוש.
> **מהו פרופיל PowerShell?** זהו סקריפט `.ps1` מיוחד ש-PowerShell מפעיל אוטומטית בכל פעם שהוא מופעל. כל מה שתשים בקובץ זה – כינויים, משתנים, וכמובן, פונקציות – יהיה זמין בכל סשן שלך כברירת מחדל.

##### **דוגמה 1: מציאת קבצים כפולים**

בואו נעבור על כל השלבים בדוגמה של הפונקציה `Find-DuplicateFiles`.

**שלב 1: הגדרת קוד הפונקציה**
```powershell
$functionCode = @'
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )

    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue |
        Group-Object Name, Length |
        Where-Object { $_.Count -gt 1 } |
        ForEach-Object {
            # זו השורה המתוקנת:
            # בתוך אופרטור $() משתנים אינם מוצפנים.
            Write-Host "נמצאו כפילויות: $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
        }
}
'@
```

**שלב 2 (אפשרות א'): שמירה בקובץ נפרד לטעינה ידנית**
```powershell
# שמירה
Set-Content -Path ".\Find-DuplicateFiles.ps1" -Value $functionCode
# טעינה
. .\Find-DuplicateFiles.ps1
```
> Dot Sourcing (. .\Find-DuplicateFiles.ps1): פקודה מיוחדת זו מפעילה את הסקריפט בהקשר הנוכחי, מה שהופך את כל הפונקציות והמשתנים שלה לזמינים בקונסולה שלך.
```powershell
# קריאה
Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Downloads"
```

**שלב 2 (אפשרות ב'): הוספה לפרופיל לטעינה אוטומטית**
נגרום לפונקציה זו להיות זמינה תמיד.
> מהו פרופיל PowerShell? זהו סקריפט `.ps1` מיוחד ש-PowerShell מפעיל אוטומטית בכל פעם שהוא מופעל. כל מה שתשים בקובץ זה – כינויים, משתנים, וכמובן, פונקציות – יהיה זמין בכל סשן שלך כברירת מחדל.
1.  **מצא את הנתיב לקובץ הפרופיל.** PowerShell שומר אותו במשתנה `$PROFILE`.
    ```powershell
    $PROFILE
    ```
2.  **צור את קובץ הפרופיל, אם אינו קיים.**
    ```powershell
    if (-not (Test-Path $PROFILE)) {
        New-Item -Path $PROFILE -Type File -Force
    }
    ```
3.  **הוסף את קוד הפונקציה שלנו לסוף קובץ הפרופיל.**
    ```powershell
    Add-Content -Path $PROFILE -Value $functionCode
    ```
4.  **הפעל מחדש את PowerShell** (או בצע `. $PROFILE`), וכעת הפקודה `Find-DuplicateFiles` שלך תהיה זמינה תמיד, כמו `Get-ChildItem`.

##### **דוגמה 2: יצירת ארכיון ZIP עם גיבוי**

**קוד עבור הקובץ `Backup-FolderToZip.ps1`:**
```powershell
function Backup-FolderToZip {
    param([string]$SourcePath, [string]$DestinationPath)
    if (-not (Test-Path $SourcePath)) { Write-Error "תיקיית המקור לא נמצאה."; return }
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName
    if (-not (Test-Path $DestinationPath)) { New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null }
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force
    Write-Host "גיבוי הושלם: $fullArchivePath" -ForegroundColor Green
}
```

פירוט מעמיק של פונקציות אעשה בחלקים הבאים.

### **מדריך לפקודות PowerShell לעבודה עם מערכת הקבצים**

#### **1. פקודות בסיסיות**
רשימה זו כוללת 12 פקודות חיוניות ביותר, המכסות 90% מהמשימות היומיומיות.

| פקודה | ייעוד עיקרי | דוגמת שימוש |
| :--- | :--- | :--- |
| `Get-ChildItem`| קבלת רשימת קבצים ותיקיות. | `Get-ChildItem C:\Windows` |
| `Set-Location` | מעבר לתיקייה אחרת. | `Set-Location C:\Temp` |
| `Get-Location` | הצגת התיקייה הנוכחית. | `Get-Location` |
| `New-Item` | יצירת קובץ או תיקייה חדשים. | `New-Item "report.docx" -Type File`|
| `Remove-Item` | מחיקת קובץ או תיקייה. | `Remove-Item "old_log.txt"` |
| `Copy-Item` | העתקת קובץ או תיקייה. | `Copy-Item "file.txt" -Dest "D:\"` |
| `Move-Item` | העברת קובץ או תיקייה. | `Move-Item "report.docx" -Dest "C:\Archive"` |
| `Rename-Item` | שינוי שם קובץ או תיקייה. | `Rename-Item "old.txt" -NewName "new.txt"` |
| `Get-Content` | קריאת תוכן קובץ. | `Get-Content "config.ini"` |
| `Set-Content` | כתיבה/שכתוב תוכן קובץ. | `"data" | Set-Content "file.txt"` |
| `Add-Content` | הוספת תוכן לסוף קובץ. | `Get-Date | Add-Content "log.txt"` |
| `Test-Path` | בדיקה אם קובץ או תיקייה קיימים. | `Test-Path "C:\Temp"` |

צריך **לקרוא את תוכן** קובץ טקסט? השתמש ב-`Get-Content`. 
צריך **לשכתב לחלוטין קובץ** עם תוכן חדש? השתמש ב-`Set-Content`.
צריך **להוסיף שורה לקובץ יומן**, מבלי למחוק נתונים ישנים? השתמש ב-`Add-Content`.
צריך **לבדוק אם קובץ קיים** לפני הכתיבה? השתמש ב-`Test-Path`.

#### **2. פקודות מיוחדות למשימות מתקדמות**
כאשר פקודות הבסיס אינן מספיקות, PowerShell מציע כלים מיוחדים יותר. הם אינם משכפלים את פקודות הבסיס, אלא מרחיבים את יכולותיך.

*   **עבודה עם נתיבים (Path)**
    *   **`Join-Path`**: מאחד בבטחה חלקי נתיב, מוסיף אוטומטית `\`.
    *   **`Split-Path`**: מפרק נתיב לחלקים (תיקייה, שם קובץ, סיומת).
    *   **`Resolve-Path`**: ממיר נתיב יחסי (לדוגמה, `.` או `..iles`) לנתיב מלא, מוחלט.

*   **עבודה עם מאפיינים ותוכן (Item Properties and Content)**
    *   **`Get-ItemProperty`**: מקבל מאפיינים של קובץ ספציפי (לדוגמה, `IsReadOnly`, `CreationTime`).
    *   **`Set-ItemProperty`**: משנה מאפיינים של קובץ או תיקייה.
    *   **`Clear-Content`**: מוחק את כל התוכן מקובץ, אך משאיר את הקובץ עצמו ריק.

*   **ניווט מתקדם (Location Stack)**
    *   **`Push-Location`**: "זוכר" את התיקייה הנוכחית ועובר לחדשה.
    *   **`Pop-Location`**: חוזר לתיקייה ש"נזכרה" על ידי `Push-Location`.

*   **ניהול הרשאות גישה (ACL)**
    *   **`Get-Acl`**: מקבל רשימת הרשאות גישה (ACL) לקובץ או תיקייה.
    *   **`Set-Acl`**: מגדיר הרשאות גישה לקובץ או תיקייה (פעולה מורכבת).

צריך **לשנות תכונה של קובץ**, למשל, להפוך אותו ל"קריאה בלבד"? השתמש ב-`Set-ItemProperty`.
צריך **לנקות לחלוטין קובץ יומן**, מבלי למחוק אותו? השתמש ב-`Clear-Content`.
צריך **לעבור זמנית לתיקייה אחרת** בסקריפט, ואז לחזור בוודאות? השתמש ב-`Push-Location` וב-`Pop-Location`.
צריך **לדעת מי מורשה** לגשת לתיקייה? השתמש ב-`Get-Acl`.

בחלק הבא נלמד כיצד לעבוד עם מאגרי נתונים אחרים, כגון רישום Windows,
באותן גישות, נתעמק במושג הפונקציות, נבחן אופרטורים לוגיים ונלמד כיצד לקיים אינטראקציה אינטראקטיבית עם המעטפת.

פילוסופיית PowerShell ב-github:
[היסטוריה ופקודה ראשונה](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md)

חלק 2: [צינור (Pipeline), משתנים, Get-Member, קובץ .ps1 וייצוא תוצאות.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/02.md)
דוגמאות לחלק השני:
[system_monitor.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/02/system_monitor.ps1)

חלק 3: [ניווט וניהול מערכת קבצים.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/03.md)

דוגמאות לחלק השלישי:
[Find-DuplicateFiles.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/03/Find-DuplicateFiles.ps1)
[Backup-FolderToZip]()