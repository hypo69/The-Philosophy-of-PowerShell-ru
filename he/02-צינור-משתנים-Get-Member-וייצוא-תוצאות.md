# הפילוסופיה של PowerShell.
## חלק 2: הצינור (Pipeline), משתנים, Get-Member, קובץ *.ps1* וייצוא תוצאות
**❗ חשוב:**
אני כותב על PS7 (PowerShell 7). הוא שונה מ-PS5 (PowerShell 5). החל מהגרסה השביעית, PS הפך לקרוס-פלטפורמי. בשל כך, התנהגותן של כמה פקודות השתנתה.

בחלק הראשון, קבענו עיקרון מפתח: PowerShell עובד עם **אובייקטים**, לא עם טקסט. פוסט זה מוקדש לכמה כלים חשובים של PowerShell: נלמד להעביר אובייקטים דרך ה**צינור**, לנתח אותם באמצעות **`Get-Member`**, לשמור תוצאות ב**משתנים** ולאטמט את כל זה ב**קבצי סקריפט (`.ps1`)** עם **ייצוא** תוצאות לפורמטים נוחים.

### 1. מהו הצינור (`|`)?
הצינור ב-PowerShell הוא מנגנון להעברת אובייקטים מלאים של .NET (ולא רק טקסט) מפקודה אחת לאחרת, כאשר כל cmdlet עוקב מקבל אובייקטים מובנים עם כל המאפיינים והשיטות שלהם.

הסמל `|` (קו אנכי) הוא אופרטור הצינור. תפקידו לקחת את התוצאה (פלט) של הפקודה שנמצאת משמאלו, ולהעביר אותה כקלט לפקודה שנמצאת מימינו.

`פקודה 1 (יוצרת אובייקטים)` → `|` → `פקודה 2 (מקבלת ומעבדת אובייקטים)` → `|` → `פקודה 3 (מקבלת אובייקטים מעובדים)` → | ...

#### צינור ה-UNIX הקלאסי: זרם של טקסט

ב-`bash`, דרך הצינור מועבר **זרם של בתים**, שבדרך כלל מתפרש כטקסט.

```bash
# מצא את כל תהליכי 'nginx' וספור אותם
ps -ef | grep 'nginx' | wc -l
```
כאן `ps` מוציא טקסט, `grep` מסנן את הטקסט הזה, ו-`wc` סופר את השורות. כל כלי שירות אינו יודע דבר על "תהליכים", הוא עובד רק עם שורות.

#### צינור ה-PowerShell: זרם של אובייקטים
**דוגמה:** בואו נקבל את כל התהליכים, נמיין אותם לפי שימוש במעבד ונבחר את 5 ה"זללנים" ביותר.

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
![1](assets/02/1.png)

כאן `Get-Process` יוצר **אובייקטים** של תהליכים. `Sort-Object` מקבל את ה**אובייקטים** האלה וממיין אותם לפי המאפיין `CPU`. `Select-Object` מקבל את ה**אובייקטים** הממוינים ובוחר את 5 הראשונים.

בוודאי שמתם לב במילים בפקודה שמתחילות במקף (-): -Property, -Descending, -First. אלו הם פרמטרים.
פרמטרים הם הגדרות, מתגים והוראות עבור ה-cmdlet. הם מאפשרים לך לשלוט ב**איך** הפקודה תבצע את עבודתה. ללא פרמטרים, פקודה פועלת במצב ברירת המחדל שלה, אך עם פרמטרים, אתה נותן לה הוראות ספציפיות.

סוגים עיקריים של פרמטרים:

- פרמטר עם ערך: דורש מידע נוסף.

    `-Property CPU`: אנחנו אומרים ל-Sort-Object לפי איזה מאפיין למיין. CPU הוא הערך של הפרמטר.
    
    `-First 5`: אנחנו אומרים ל-Select-Object כמה אובייקטים לבחור. 5 הוא הערך של הפרמטר.

- פרמטר-מתג (דגל): אינו דורש ערך. עצם נוכחותו בפקודה מפעילה או מכבה התנהגות מסוימת.

   `-Descending`: דגל זה אומר ל-Sort-Object לשנות את סדר המיון להפוך (מהגדול לקטן). הוא אינו זקוק לערך נוסף - הוא הוראה בפני עצמה.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
![1](assets/02/2.png)
פקודה זו עונה על שאלה פשוטה מאוד:
**"כמה בדיוק תהליכים בשם `svchost.exe` פועלים כעת במערכת שלי?"**

#### פירוק לפי שלבים

##### **שלב 1: `Get-Process -Name 'svchost'`**

חלק זה של הפקודה פונה למערכת ההפעלה ומבקש למצוא **את כל** התהליכים הפועלים, ללא יוצא מן הכלל, ששם קובץ ההפעלה שלהם הוא `svchost.exe`.
בניגוד לתהליכים מסוג `notepad` (שבדרך כלל יש אחד או שניים מהם), תהליכי `svchost` במערכת הם תמיד **רבים**. הפקודה תחזיר **מערך (אוסף) של אובייקטים**, כאשר כל אובייקט הוא תהליך `svchost` נפרד ומלא עם מזהה ייחודי משלו, שימוש בזיכרון וכו'.
PowerShell מצא במערכת, למשל, 90 תהליכי `svchost` וכעת הוא מחזיק בידיו אוסף של 90 אובייקטים.

##### **שלב 2: `|` (אופרטור הצינור)**

סמל זה לוקח את אוסף 90 אובייקטי ה-`svchost` שהתקבלו בשלב הראשון, ומתחיל להעביר אותם **אחד אחד** לקלט של הפקודה הבאה.

##### **שלב 3: `Measure-Object`**

מכיוון שקראנו ל-`Measure-Object` ללא פרמטרים (כגון `-Property`, `-Sum` וכו'), הוא מבצע את פעולת **ברירת המחדל** שלו - הוא פשוט סופר את מספר ה"פריטים" שהועברו אליו.
אחת, שתיים, שלוש... לאחר שכל האובייקטים נספרו, `Measure-Object` יוצר **אובייקט-תוצאה משלו**, שבו יש מאפיין `Count`, השווה למספר הסופי.


**`Count: 90`** — זו התשובה לשאלתנו. פועלים 90 תהליכי `svchost`.
שאר השדות ריקים, מכיוון שלא ביקשנו מ-`Measure-Object` לבצע חישובים מורכבים יותר.


#### דוגמה עם `svchost` ופרמטרים

בואו נשנה את המשימה שלנו. עכשיו אנחנו לא רוצים רק לספור את תהליכי ה-`svchost`, אלא לגלות **כמה זיכרון RAM כולל (במגה-בייט) הם צורכים יחד**.

לשם כך, נצטרך פרמטרים:
*   `-Property WorkingSet64`: הוראה זו אומרת ל-`Measure-Object`: "מכל אובייקט `svchost` שמגיע אליך, קח את הערך המספרי מהמאפיין `WorkingSet64` (זהו שימוש בזיכרון בבתים)".
*   `-Sum`: הוראת דגל זו אומרת: "סכם את כל הערכים האלה שלקחת מהמאפיין `WorkingSet64`".

הפקודה החדשה שלנו תיראה כך:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
![3](assets/02/3.png)

1.  `Get-Process` ימצא את מספר אובייקטי ה-`svchost`.
2.  הצינור `|` יעביר אותם ל-`Measure-Object`.
3.  אבל עכשיו `Measure-Object` עובד אחרת:
    *   הוא לוקח את אובייקט ה-`svchost` הראשון, מסתכל על מאפיין ה-`.WorkingSet64` שלו (למשל, `25000000` בתים) וזוכר את המספר הזה.
    *   הוא לוקח את האובייקט השני, מסתכל על ה-`.WorkingSet64` שלו (למשל, `15000000` בתים) ומוסיף אותו לקודם.
    *   ...וכן הלאה עבור כל האובייקטים.
4.  בסופו של דבר, `Measure-Object` ייצור אובייקט-תוצאה, אבל עכשיו הוא יהיה שונה.


*   **`Count: 92`**: מספר האובייקטים.
*   **`Sum: 1661890560`**: זהו הסכום הכולל של כל ערכי ה-`WorkingSet64` בבתים.
*   **`Property: WorkingSet64`**: שדה זה כעת גם מלא, הוא מודיע לנו באיזה מאפיין בדיוק נעשה שימוש לחישובים.




### 2. משתנים (רגילים והמיוחד `$_`)

משתנה הוא מאגר בעל שם בזיכרון המכיל ערך כלשהו.

ערך זה יכול להיות כל דבר: טקסט, מספר, תאריך, או, מה שהכי חשוב עבור PowerShell, אובייקט שלם או אפילו אוסף של אובייקטים. שם משתנה ב-PowerShell תמיד מתחיל בסימן דולר ($).
דוגמאות: $name, $counter, $processList.

המשתנה המיוחד $_?

$_ הוא קיצור של "האובייקט הנוכחי" או "הדבר הזה כאן".
דמיינו לעצמכם מסוע במפעל. עליו נעים חלקים שונים (אובייקטים).

$_ הוא אותו החלק שנמצא ממש מולכם (או מול הרובוט המעבד).

המקור (Get-Process) שופך על המסוע קופסה שלמה של חלקים (כל התהליכים).

הצינור (|) גורם לחלקים אלה לנוע על הסרט אחד אחד.

המעבד (Where-Object או ForEach-Object) הוא רובוט שמסתכל על כל חלק.

המשתנה $_ הוא אותו החלק שנמצא כעת ב"ידיים" של הרובוט.

כאשר הרובוט מסיים עם חלק אחד, המסוע מזין לו את הבא, ו-$_ יצביע עליו כעת.



בואו נחשב כמה זיכרון כולל משתמשים תהליכי `svchost`, ונציג את התוצאה על הצג.
```powershell
# 1. בצע את הפקודה ושמור את אובייקט התוצאה המורכב שלה במשתנה $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. עכשיו אנחנו יכולים לעבוד עם האובייקט השמור. בואו נוציא ממנו את מאפיין ה-Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. הצג את התוצאה על המסך, באמצעות המשתנה החדש
Write-Host "כל תהליכי svchost משתמשים ב-$memoryInMB MB של זיכרון."
```
![3](assets/02/4.png)

*   `Write-Host` הוא cmdlet מיוחד שתפקידו היחיד הוא **להציג טקסט ישירות למשתמש בקונסולה**.

*   מחרוזת במרכאות כפולות: `"..."` היא מחרוזת טקסט שאנו מעבירים ל-cmdlet `Write-Host` כארגומנט. מדוע מרכאות כפולות, ולא בודדות?
    
    ב-PowerShell יש שני סוגים של מרכאות:
    
    *   **בודדות (`'...'`)**: יוצרות **מחרוזת מילולית**. כל מה שבתוכן נתפס כטקסט רגיל, ללא יוצאים מן הכלל.
    *   **כפולות (`"..."`)**: יוצרות **מחרוזת ניתנת להרחבה (או להחלפה)**. PowerShell "סורק" מחרוזת כזו בחיפוש אחר משתנים (המתחילים ב-`$`) ומחליף במקומם את ערכיהם.

* `$memoryInMB`. זהו המשתנה שבו **בשלב הקודם** של הסקריפט שלנו שמנו את תוצאת החישובים. כאשר `Write-Host` מקבל מחרוזת במרכאות כפולות, מתרחש תהליך שנקרא **"הרחבת מחרוזות" (String Expansion)**:
    1.  PowerShell רואה את הטקסט `"כל תהליכי svchost משתמשים ב-"`.
    2.  לאחר מכן הוא נתקל במבנה `$memoryInMB`. הוא מבין שזה לא רק טקסט, אלא משתנה.
    3.  הוא מסתכל בזיכרון, מוצא את הערך המאוחסן ב-`$memoryInMB` (למשל, `1585.52`).
    4.  הוא **מחליף את הערך הזה** ישירות במחרוזת.
    5.  לאחר מכן הוא מוסיף את שאר הטקסט: `" MB של זיכרון."`.
    6.  בסופו של דבר, ל-`Write-Host` מועברת המחרוזת המוכנה והמורכבת: `"כל תהליכי svchost משתמשים ב-1585.52 MB של זיכרון."`.



הפעל את פנקס הרשימות:
 1. מצא את תהליך פנקס הרשימות ושמור אותו במשתנה $notepadProcess
 ```powershell
$notepadProcess = Get-Process -Name notepad
```

 2. פנה למאפיין 'Id' של אובייקט זה דרך הנקודה והצג אותו
 ```powershell
Write-Host "מזהה התהליך 'פנקס רשימות' הוא: $($notepadProcess.Id)"
```
![5](assets/02/5.png)

**❗ חשוב:**
    Write-Host "שובר" את הצינור. לא ניתן להעביר את הטקסט שהוצג על ידו הלאה בצינור לעיבוד. הוא מיועד לתצוגה בלבד.

### 3. Get-Member (מפקח האובייקטים)

אנו יודעים שאובייקטים "זורמים" בצינור. אבל איך נדע ממה הם מורכבים? אילו מאפיינים יש להם ואילו פעולות (שיטות) ניתן לבצע עליהם?

ה-cmdlet **`Get-Member`** (כינוי: `gm`) הוא הכלי העיקרי לחקירה.
לפני שתעבוד עם אובייקט, העבר אותו דרך `Get-Member` כדי לראות את כל יכולותיו.

בואו ננתח את האובייקטים ש-`Get-Process` יוצר:
```powershell
Get-Process | Get-Member
```
![6](assets/02/6.png)

*בואו נפרק כל חלק בפלט של Get-Member.*

`TypeName: System.Diagnostics.Process` - זהו "שם הטיפוס" המלא והרשמי של האובייקט מספריית .NET. זהו ה"דרכון" שלו.
שורה זו אומרת לך שכל האובייקטים ש-Get-Process מחזיר הם אובייקטים מסוג System.Diagnostics.Process.
זה מבטיח שלכולם יהיה אותו סט של מאפיינים ושיטות.
אתה יכול [לחפש בגוגל](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process" כדי למצוא את התיעוד הרשמי של מיקרוסופט עם מידע מפורט עוד יותר.



- עמודה 1: `Name`

זהו **שם** פשוט וקריא לאדם של מאפיין, שיטה או "חבר" אחר של אובייקט. זהו השם שתשתמש בו בקוד שלך כדי לגשת לנתונים או לבצע פעולות.



- עמודה 2: `MemberType` (סוג החבר)

זוהי העמודה החשובה ביותר להבנה. היא מסווגת **מהו** כל חבר. זהו "תפקידו" שאומר לך **כיצד** להשתמש בו.

*   **`Property` (מאפיין):** **מאפיין** או **חלק של נתונים** המאוחסן בתוך אובייקט. אתה יכול "לקרוא" את ערכו.
    *   *דוגמאות מהצילום מסך:* `BasePriority`, `HandleCount`, `ExitCode`. אלו פשוט נתונים שניתן להסתכל עליהם.

*   **`Method` (שיטה):** **פעולה** שניתן לבצע על אובייקט. שיטות תמיד נקראות עם סוגריים עגולים `()`.
    *   *דוגמאות מהצילום מסך:* `Kill`, `Refresh`, `WaitForExit`. היית כותב `$process.Kill()` או `$process.Refresh()`.

*   **`AliasProperty` (מאפיין כינוי):** **כינוי ידידותי** למאפיין אחר, ארוך יותר. PowerShell מוסיף אותם לנוחות וקיצור.
    *   *דוגמאות מהצילום מסך:* `WS` הוא כינוי קצר ל-`WorkingSet64`. `Name` הוא ל-`ProcessName`. `VM` הוא ל-`VirtualMemorySize64`.

*   **`Event` (אירוע):** **הודעה** על כך שמשהו קרה, שניתן "להירשם" אליה.
    *   *דוגמה מהצילום מסך:* `Exited`. הסקריפט שלך יכול "להאזין" לאירוע זה כדי לבצע פעולה כלשהי מיד לאחר סיום התהליך.

*   **`CodeProperty` ו-`NoteProperty`:** סוגים מיוחדים של מאפיינים, שלעתים קרובות מתווספים על ידי PowerShell עצמו לנוחות. `CodeProperty` מחשב את ערכו "על הדרך", ו-`NoteProperty` הוא מאפיין-הערה פשוט שנוסף לאובייקט.

- עמודה 3: `Definition` (הגדרה)

זוהי ה**הגדרה הטכנית** או ה"חתימה" של החבר. היא נותנת לך את הפרטים המדויקים לשימוש בו. תוכנה תלוי ב-`MemberType`:

*   **עבור `AliasProperty`:** מראה **למה שווה הכינוי**. זה שימושי להפליא!
    *   *דוגמה מהצילום מסך:* `WS = WorkingSet64`. אתה רואה מיד ש-`WS` הוא פשוט כתיב קצר ל-`WorkingSet64`.

*   **עבור `Property`:** מראה את **סוג הנתונים** המאוחסן במאפיין (למשל, `int` למספר שלם, `string` לטקסט, `datetime` לתאריך ושעה), ומה ניתן לעשות איתו (`{get;}` - רק לקרוא, `{get;set;}` - לקרוא ולשנות).
    *   *דוגמה מהצילום מסך:* `int BasePriority {get;}`. זהו מאפיין מסוג מספר שלם שניתן רק לקרוא.

*   **עבור `Method`:** מראה מה השיטה מחזירה (למשל, `void` - כלום, `bool` - true/false) ואילו **פרמטרים** (נתוני קלט) היא מקבלת בסוגריים.
    *   *דוגמה מהצילום מסך:* `void Kill()`. זה אומר שהשיטה `Kill` אינה מחזירה דבר וניתן לקרוא לה ללא פרמטרים. יש גם גרסה שנייה `void Kill(bool entireProcessTree)` שמקבלת ערך בוליאני (true/false).

#### בצורת טבלה

| עמודה | מה זה? | דוגמה מהצילום מסך | למה זה? |
|---|---|---|---|
| **Name** | השם שבו אתה משתמש בקוד. | `Kill`, `WS`, `Name` | לפנות למאפיין או שיטה (`$process.WS`, `$process.Kill()`). |
| **MemberType**| סוג החבר (נתונים, פעולה וכו'). | `Method`, `Property`, `AliasProperty` | **כיצד** להשתמש בו (לקרוא ערך או לקרוא עם `()`). |
| **Definition** | פרטים טכניים. | `WS = WorkingSet64`, `void Kill()` | מה מסתתר מאחורי כינוי ואילו פרמטרים דרושים לשיטה. |



#### דוגמה: עבודה עם חלונות תהליכים

##### 1. הבעיה:
"פתחתי הרבה חלונות של פנקס רשימות. איך אני יכול למזער באופן תכנותי את כולם מלבד הראשי, ואז לסגור רק את זה שבכותרת שלו יש את המילה 'ללא כותרת'?"

##### 2. חקירה עם `Get-Member`:
עלינו למצוא מאפיינים הקשורים לחלון ולכותרת שלו.

```powershell
Get-Process -Name notepad | Get-Member
```
**ניתוח התוצאה של `Get-Member`:**
*   בגלילה בין המאפיינים, אנו מוצאים את `MainWindowTitle`. הסוג הוא `string`. מצוין, זו הכותרת של החלון הראשי!
*   בשיטות, אנו רואים את `CloseMainWindow()`. זוהי דרך "רכה" יותר לסגור חלון מאשר `Kill()`.
*   כמו כן, בשיטות, יש את `WaitForInputIdle()`. נשמע מעניין, אולי זה יעזור לחכות עד שהתהליך יהיה מוכן לאינטראקציה.

![7](assets/02/7.png)

`Get-Member` הראה לנו את המאפיין `MainWindowTitle`, שהוא המפתח לפתרון הבעיה ומאפשר לנו לתקשר עם תהליכים על בסיס מצב החלונות שלהם, ולא רק לפי שם.

##### 3. הפתרון:
עכשיו אנחנו יכולים לבנות לוגיקה המבוססת על כותרת החלון.

```powershell
# 1. מצא את כל תהליכי פנקס הרשימות
$notepads = Get-Process -Name notepad

# 2. עבור על כל אחד ובדוק את הכותרת
foreach ($pad in $notepads) {
    # עבור כל תהליך ($pad), בדוק את מאפיין ה-MainWindowTitle שלו
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "נמצא פנקס רשימות שלא נשמר (מזהה: $($pad.Id)). סוגר את חלונו..."
        # $pad.CloseMainWindow() # בטל את ההערה כדי לסגור באמת
        Write-Host "החלון '$($pad.MainWindowTitle)' היה נסגר." -ForegroundColor Yellow
    } else {
        Write-Host "מדלג על פנקס רשימות עם כותרת: $($pad.MainWindowTitle)"
    }
}
```

![8](assets/02/8.png)

![9](assets/02/9.png)


---

#### דוגמה: מצא את תהליך האב

##### 1. הבעיה:
"לפעמים אני רואה במערכת הרבה תהליכי `chrome.exe` ילדים. איך אני יכול לדעת איזה מהם הוא התהליך הראשי, ה"אב", שהפעיל את כולם?"

##### 2. חקירה עם `Get-Member`:
עלינו למצוא משהו שמקשר בין תהליך אחד למשנהו.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
![10](assets/02/10.png)

**ניתוח התוצאה של `Get-Member`:**
*   בבחינה מדוקדקת של הרשימה, אנו מוצאים מאפיין מסוג `CodeProperty` בשם `Parent`.
*   ה`Definition` שלו הוא `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
זהו מאפיין מחושב, שכאשר פונים אליו, מחזיר את **אובייקט תהליך האב**.

##### 3. הפתרון:
עכשיו אנחנו יכולים לכתוב סקריפט, שעבור כל תהליך `chrome` יציג מידע על אביו.

```powershell
# 1. קבל את כל תהליכי chrome
$chromeProcesses = Get-Process -Name chrome

# 2. עבור כל אחד מהם, הצג מידע עליו ועל אביו
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # קבל את תהליך האב
    $parent = $_.Parent
    
    # עצב פלט יפה
    Write-Host "תהליך:" -ForegroundColor Green
    Write-Host "  - שם: $($_.ProcessName), מזהה: $($_.Id)"
    Write-Host "אביו:" -ForegroundColor Yellow
    Write-Host "  - שם: $($parent.ProcessName), מזהה: $($parent.Id)"
    Write-Host "-----------------------------"
}
```
![11](assets/02/11.png)

![12](assets/02/12.png)

אנו רואים מיד שהתהליכים עם המזהים 4756, 7936, 8268 ו-9752 הופעלו על ידי התהליך עם המזהה 14908. כמו כן, ניתן להבחין במקרה מעניין עם התהליך מזהה: 7252, שתהליך האב שלו לא זוהה (אולי האב כבר הספיק להסתיים בזמן הבדיקה). שינוי הסקריפט עם בדיקת if ($parent) מטפל במקרה זה בצורה מסודרת, מבלי לגרום לשגיאה.
Get-Member עזר לנו לגלות את המאפיין ה"נסתר" Parent, המספק יכולות חזקות לניתוח היררכיית התהליכים.

#### 4. קובץ *.ps1* (יצירת סקריפטים)

כאשר שרשרת הפקודות שלך הופכת לשימושית, תרצה לשמור אותה לשימוש חוזר. לשם כך נועדו **סקריפטים** — קבצי טקסט עם סיומת **`.ps1`**.

##### הרשאה להרצת סקריפטים
כברירת מחדל, ב-Windows אסור להריץ סקריפטים מקומיים. כדי לתקן זאת **עבור המשתמש הנוכחי**, בצע פעם אחת ב-PowerShell **כמנהל**:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
זוהי הגדרה בטוחה המאפשרת לך להריץ סקריפטים משלך וסקריפטים חתומים על ידי מפרסם מהימן.

##### דוגמה לסקריפט `system_monitor.ps1`
צור קובץ בשם זה והדבק בו את הקוד שלהלן. סקריפט זה אוסף מידע על המערכת ומייצר דוחות.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    סקריפט ליצירת דוח על מצב המערכת.
.DESCRIPTION
    אוסף מידע על תהליכים, שירותים ושטח דיסק ומייצר דוחות.
.PARAMETER OutputPath
    הנתיב לשמירת הדוחות. ברירת המחדל היא 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- בלוק 1: הכנה ---
Write-Host "הכנה ליצירת הדוח..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- בלוק 2: איסוף נתונים ---
Write-Host "איסוף מידע..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- בלוק 3: קריאה לפונקציית הייצוא (ראה סעיף הבא) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "הדוחות נשמרו בהצלחה בתיקייה $OutputPath" -ForegroundColor Magenta
```
*הערה: הפונקציה `Export-Results` תוגדר בסעיף הבא כדוגמה לפרקטיקה טובה.*

#### 5. ייצוא תוצאות

נתונים גולמיים זה טוב, אבל לעתים קרובות צריך להציג אותם בצורה נוחה לאדם או לתוכנה אחרת. PowerShell מציעה הרבה cmdlets לייצוא.

| שיטה | פקודה | תיאור |
|---|---|---|
| **טקסט רגיל** | `... \| Out-File C:\Temp\data.txt` | מפנה את הייצוג הטקסטואלי לקובץ. |
| **CSV (עבור Excel)** | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo` | מייצא אובייקטים ל-CSV. `-NoTypeInfo` מסיר את שורת השירות הראשונה. |
| **דוח HTML** | `... \| ConvertTo-Html -Title "דוח"` | יוצר קוד HTML מאובייקטים. |
| **JSON (עבור API, אינטרנט)** | `... \| ConvertTo-Json` | ממיר אובייקטים לפורמט JSON. |
| **XML (פורמט מקורי של PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml` | שומר אובייקטים עם כל סוגי הנתונים. ניתן לשחזר אותם בצורה מושלמת דרך `Import-Clixml`. |

##### תוספת לסקריפט: פונקציית ייצוא
בואו נוסיף לסקריפט שלנו `system_monitor.ps1` פונקציה שתעסוק בייצוא. מקם את הקוד הזה **לפני** הקריאה ל-`Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # ייצוא ל-CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # יצירת דוח HTML יפה
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>10 התהליכים המובילים לפי מעבד</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>סטטיסטיקות שירותים</h2>"

    ConvertTo-Html -Head "<title>דוח מערכת</title>" -Body "<h1>דוח מערכת מתאריך $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
עכשיו הסקריפט שלנו לא רק אוסף נתונים, אלא גם שומר אותם בצורה מסודרת בשני פורמטים: CSV לניתוח ו-HTML לצפייה מהירה.

#### סיכום

1.  **הצינור (`|`)** — הכלי העיקרי לשילוב פקודות ועיבוד אובייקטים.
2.  **`Get-Member`** — מנתח אובייקטים המראה ממה הם מורכבים.
3.  **משתנים (`$var`, `$_`)** מאפשרים לשמור נתונים ולהתייחס לאובייקט הנוכחי בצינור.
4.  **קבצי `.ps1`** הופכים פקודות לכלי אוטומציה רב-פעמיים.
5.  **cmdlets לייצוא** (`Export-Csv`, `ConvertTo-Html`) מייצאים נתונים בפורמט המתאים.

**בחלק הבא נשתמש בידע זה לניווט וניהול מערכת הקבצים, תוך חקירת האובייקטים `System.IO.DirectoryInfo` ו-`System.IO.FileInfo`.**
