# Filozofia PowerShell.
## Część 0.
Co było przed PowerShell?
W 1981 roku ukazał się MS-DOS 1.0 z interpreterem poleceń `COMMAND.COM`. Do automatyzacji zadań używano **plików wsadowych (`.bat`)** — prostych plików tekstowych z sekwencją poleceń konsoli. Zaskakujący ascetyzm wiersza poleceń na tle systemów zgodnych z POSIX, gdzie już od 1979 roku istniała **powłoka Bourne'a (`sh`)**.



### 📅 Stan rynku powłok w momencie wydania **MS-DOS 1.0** (sierpień 1981)

Poniżej znajduje się tabela podsumowująca popularne systemy operacyjne tamtych czasów i ich obsługę powłok (`sh`, `csh` itp.):

| System operacyjny            | Obsługa powłok (`sh`, `csh`, itp.) | Komentarz                                                  |
| ---------------------------- | ---------------------------------- | ------------------------------------------------------------ |
| **UNIX Version 7 (V7)**      | `sh`                               | Ostatni klasyczny UNIX Bell Labs, szeroko rozpowszechniony   |
| **UNIX/32V**                 | `sh`, `csh`                        | Wersja UNIX dla architektury VAX                             |
| **4BSD / 3BSD**              | `sh`, `csh`                        | Uniwersytecka gałąź UNIX z Berkeley                          |
| **UNIX System III**          | `sh`                               | Pierwsza komercyjna wersja od AT&T, poprzednik System V      |
| **Xenix (od Microsoft)**     | `sh`                               | Licencjonowana wersja UNIX, sprzedawana przez Microsoft od 1980 |
| **IDRIS**                    | `sh`                               | System operacyjny podobny do UNIX dla PDP-11 i Intel        |
| **Coherent (Mark Williams)** | `sh` (podobna)                     | Niedroga alternatywa UNIX dla komputerów PC                  |
| **CP/M (Digital Research)**  | ❌ (Brak `sh`, tylko najprostszy CLI) | Nie UNIX, najpopularniejszy system operacyjny dla 8-bitowych PC |
| **MS-DOS 1.0**               | ❌ (tylko `COMMAND.COM`)            | Minimalna powłoka poleceń, brak skryptów lub potoków         |

---

### 💡 Co to jest `sh`, `csh`

* `sh` — **Bourne Shell**, główny interpreter skryptów UNIX od 1977 roku.
* `csh` — **C Shell**, ulepszona powłoka z składnią podobną do C i udogodnieniami do pracy interaktywnej.
* Te powłoki **obsługiwały przekierowania, potoki, zmienne, funkcje i warunki** — wszystko, co uczyniło UNIX potężnym narzędziem automatyzacji.

---

Microsoft skupiła się na **tanich 16-bitowych komputerach IBM PC**, które miały **mało pamięci** (zazwyczaj 64–256 KB), nie miały wielozadaniowości i były przeznaczone do **użytku domowego i biurowego**, a nie serwerów. UNIX był drogi, wymagał złożonej architektury i doświadczenia, podczas gdy księgowi i inżynierowie, a nie administratorzy systemów, potrzebowali szybkiego i prostego systemu operacyjnego.

Interfejs DOS, zamiast złożonego `sh`, przedstawiał jeden plik command.com z ubogim zestawem wewnętrznych poleceń [ (dir, copy, del itp.)](https://www.techgeekbuzz.com/blog/dos-commands/){:target="_blank"} bez funkcji, pętli czy modułów.

Były też polecenia zewnętrzne — oddzielne pliki wykonywalne (.exe lub .com). Przykłady: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Skrypty wykonywalne zapisywano w pliku tekstowym z rozszerzeniem .bat (plik wsadowy).

Przykłady plików konfiguracyjnych:

- AUTOEXEC.BAT

```bash
:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT — Automatyczna konfiguracja i uruchamianie Windows 3.11
:: Autor: hypo69
:: Rok: około 1993
:: Przeznaczenie: Wykonuje inicjalizację środowiska DOS, ładuje sterowniki sieciowe i uruchamia Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Ustawienie wiersza poleceń
PROMPT $p$g

:: Ustawienie zmiennych środowiskowych
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Ładowanie sterowników i narzędzi do pamięci górnej
LH C:\DOS\SMARTDRV.EXE       :: Pamięć podręczna dysku
LH C:\DOS\MOUSE.COM          :: Sterownik myszy

:: Ładowanie usług sieciowych (istotne dla Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Automatyczne uruchamianie Windows
WIN

```
- CONFIG.SYS
```bash
:: ------------------------------------------------------------------------------
:: CONFIG.SYS — Konfiguracja pamięci i sterowników DOS dla Windows 3.11
:: Autor: hypo69
:: Rok: około 1993
:: Przeznaczenie: Inicjalizacja sterowników pamięci, konfiguracja parametrów systemowych
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE

```

W Microsoft, równolegle do DOS, niemal natychmiast rozpoczęto rozwój zasadniczo nowego jądra.

Jądro [**Windows NT**](https://www.wikiwand.com/ru/articles/Windows_NT){:target="_blank"} (New Technology) pojawiło się po raz pierwszy wraz z wydaniem systemu operacyjnego:

> **Windows NT 3.1 — 27 lipca 1993 roku**

---

* **Rozwój rozpoczął się**: w **1988 roku** pod kierownictwem **Dave'a Cutlera** (byłego inżyniera DEC, twórcy VMS) w celu stworzenia całkowicie nowego, bezpiecznego, przenośnego i wielozadaniowego systemu operacyjnego, niekompatybilnego z MS-DOS na poziomie jądra.
* **NT 3.1** — nazwana tak, aby podkreślić kompatybilność z **Windows 3.1** na poziomie interfejsu, ale miała **zupełnie nową architekturę**.

---

#### 🧠 Co przyniosło jądro NT:

| Cecha                        | Opis                                                              |
| ---------------------------- | --------------------------------------------------------------------- |
| **Architektura 32-bitowa**   | W przeciwieństwie do MS-DOS i Windows 3.x, które były 16-bitowe.      |
| **Wielozadaniowość**         | Prawdziwa wielozadaniowość wywłaszczająca.                            |
| **Pamięć chroniona**         | Programy nie mogły uszkodzić pamięci innych.                          |
| **Modułowość**               | Wielowarstwowa architektura jądra: HAL, Executive, Kernel, sterowniki. |
| **Obsługa wielu platform**   | NT 3.1 działał na x86, MIPS i Alpha.                                  |
| **Zgodność z POSIX**         | NT dostarczany był z **podsystemem POSIX**, certyfikowanym zgodnie z POSIX.1. |

---

#### 📜 Linia produktów NT:

| Wersja NT     | Rok       | Komentarz                          |
| ------------- | --------- | ---------------------------------- |
| NT 3.1        | 1993      | Pierwsze wydanie NT               |
| NT 3.5 / 3.51 | 1994–1995 | Ulepszenia, optymalizacja          |
| NT 4.0        | 1996      | Interfejs Windows 95, ale jądro NT |
| Windows 2000  | 2000      | NT 5.0                             |
| Windows XP    | 2001      | NT 5.1                             |
| Windows Vista | 2007      | NT 6.0                             |
| Windows 10    | 2015      | NT 10.0                            |
| Windows 11    | 2021      | Również NT 10.0 (marketing 😊)      |

---

Różnice w możliwościach systemów operacyjnych:

| Charakterystyka                 | **MS-DOS** (1981)                       | **Windows NT** (1993)                               |
| ------------------------------- | --------------------------------------- | --------------------------------------------------- |
| **Typ systemu**                 | Monolityczny, jednowątkowy              | Mikrojądrowy/hybrydowy, wielozadaniowy              |
| **Bity**                        | 16-bitowy                               | 32-bitowy (z obsługą 64-bitową od NT 5.2 / XP x64)  |
| **Wielozadaniowość**            | ❌ Brak (jeden proces na raz)           | ✅ Wielozadaniowość wywłaszczająca                  |
| **Pamięć chroniona**            | ❌ Brak                                 | ✅ Tak (każdy proces we własnej przestrzeni adresowej) |
| **Tryb wieloużytkownikowy**     | ❌ Brak                                 | ✅ Częściowo (w NT Workstation/Server)              |
| **Zgodność z POSIX**            | ❌ Brak                                 | ✅ Wbudowany podsystem POSIX w NT 3.1–5.2           |
| **Przenośność jądra**           | ❌ Tylko x86                            | ✅ x86, MIPS, Alpha, PowerPC                        |
| **Sterowniki**                  | Bezpośredni dostęp do sprzętu           | Poprzez HAL i sterowniki trybu jądra                |
| **Poziom dostępu aplikacji**    | Aplikacje = poziom systemowy            | Poziom użytkownika / jądra rozdzielone              |
| **Bezpieczeństwo**              | ❌ Brak                                 | ✅ Model bezpieczeństwa: SID, ACL, tokeny dostępu    |
| **Stabilność**                  | ❌ Zależność jednego programu = awaria OS | ✅ Izolacja procesów, ochrona jądra                 |

---

Ale było jedno duże ALE! Narzędziom do automatyzacji i administracji nie poświęcano należytej uwagi aż do 2002 roku.

---

Microsoft stosowała zupełnie inne podejścia, strategie i narzędzia do administracji. Wszystko to było **rozproszone**, często zorientowane na GUI i nie zawsze możliwe do zautomatyzowania.

---

##### 📌 Lista niektórych narzędzi:

| Narzędzie                     | Przeznaczenie                                                   |
| ----------------------------- | --------------------------------------------------------------- |
| `cmd.exe`                     | Ulepszony interpreter poleceń (zamiennik `COMMAND.COM`)         |
| `.bat`, `.cmd`                | Skrypty wiersza poleceń                                         |
| **Windows Script Host (WSH)** | Obsługa VBScript i JScript do automatyzacji                     |
| `reg.exe`                     | Zarządzanie rejestrem z wiersza poleceń                         |
| `net.exe`                     | Praca z użytkownikami, siecią, drukarkami                       |
| `sc.exe`                      | Zarządzanie usługami                                            |
| `tasklist`, `taskkill`        | Zarządzanie procesami                                           |
| `gpedit.msc`                  | Zasady grupy (lokalnie)                                         |
| `MMC`                         | Konsola z przystawkami do zarządzania                           |
| `WMI`                         | Dostęp do informacji systemowych (przez `wmic`, VBScript lub COM) |
| `WbemTest.exe`                | GUI do testowania zapytań WMI                                   |
| `eventvwr`                    | Przeglądarka dzienników zdarzeń                                 |
| `perfmon`                     | Monitorowanie zasobów                                           |

##### 🛠 Przykłady automatyzacji:

* Pliki VBScript (`*.vbs`) do administrowania użytkownikami, sieciami, drukarkami i usługami.
* `WMIC` — interfejs wiersza poleceń do WMI (np.: `wmic process list brief`).
* Skrypty `.cmd` z wywołaniami `net`, `sc`, `reg`, `wmic` itp.

---

### ⚙️ Windows Scripting Host (WSH)

* Po raz pierwszy pojawił się w **Windows 98**, aktywnie używany w **Windows 2000 i XP**.
* Umożliwiał wykonywanie plików VBScript i JScript z wiersza poleceń:

  ```vbscript
  Set objShell = WScript.CreateObject("WScript.Shell")
  objShell.Run "notepad.exe"
  ```

---
## Część 1.

Dopiero w 2002 roku firma sformułowała projekt <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, który później przekształcił się w PowerShell:

Początek rozwoju: około 2002 roku

Publiczne ogłoszenie: 2003 rok, jako "Monad Shell"

Pierwsze wersje beta: pojawiły się do 2005 roku

Ostateczne wydanie (PowerShell 1.0): listopad 2006 roku

Autorem i głównym architektem projektu Monad / PowerShell jest Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a>

Dziś PowerShell Core działa na
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a>

Równolegle rozwijano framework .NET, a PowerShell został w niego głęboko zintegrowany; w kolejnych rozdziałach pokażę przykłady.

A teraz — najważniejsze!

Główną zaletą PowerShell w porównaniu z klasycznymi powłokami poleceń jest to, że pracuje on z *obiektami*, a nie z tekstem. Kiedy wykonujesz polecenie, zwraca ono nie tylko tekst, ale ustrukturyzowany obiekt (lub kolekcję obiektów), który ma jasno zdefiniowane właściwości (Properties) i metody (Methods).

Zobacz, jak PowerShell przewyższa klasyczne powłoki dzięki **pracy z obiektami**.

### 📁 Jak to było: `dir` i ręczne parsowanie

W **CMD** (zarówno w starym `COMMAND.COM`, jak i w `cmd.exe`) polecenie `dir` zwraca wynik jako zwykły tekst. Przykład wyjścia:

```
24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
```

Załóżmy, że chcesz wyodrębnić **nazwę pliku** i **rozmiar** każdego pliku. Będziesz musiał ręcznie parsować wiersze:
```cmd
for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
```

* Jest to strasznie trudne do odczytania, zależy od ustawień regionalnych, formatu daty, czcionki. I psuje się przy spacjach w nazwach.

---

### ✅ PowerShell: obiekty zamiast tekstu

#### ✔ Prosty i czytelny przykład:

```powershell
Get-ChildItem | Select-Object Name, Length
```

**Wynik:**

```
Name          Length
----          ------
my_script.js   1428
report.html    3980
```

* `Get-ChildItem` zwraca **tablicę obiektów plików/folderów**
* `Select-Object` pozwala łatwo uzyskać potrzebne **właściwości**

---

### 🔍 Co tak naprawdę zwraca `Get-ChildItem`?

```powershell
$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
```

**Wynik:**

```
TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
```

PowerShell zwraca **obiekty typu `System.IO.FileInfo`**, które mają:

* 🧱 Właściwości (`Name`, `Length`, `CreationTime`, `Extension`, …)
* 🛠 Metody (`Delete()`, `CopyTo()`, `MoveTo()` itp.)

Pracujesz **z pełnoprawnymi obiektami**, a nie z ciągami znaków.

---

### Składnia "Czasownik-Rzeczownik":

PowerShell używa **ścisłej i logicznej składni poleceń**:
`Czasownik-Rzeczownik` (Verb-Noun)

| Czasownik | Co robi    |
| --------- | ---------- |
| `Get-`    | Pobierz    |
| `Set-`    | Ustaw      |
| `New-`    | Utwórz     |
| `Remove-` | Usuń       |
| `Start-`  | Uruchom    |
| `Stop-`   | Zatrzymaj  |

| Rzeczownik    | Nad czym pracuje |
| ------------- | ---------------- |
| `Process`     | Proces           |
| `Service`     | Usługa           |
| `Item`        | Plik/folder      |
| `EventLog`    | Dzienniki zdarzeń |
| `Computer`    | Komputer         |

#### 🔄 Przykłady:

| Co należy zrobić         | Polecenie         |
| ------------------------ | ----------------- |
| Pobierz procesy          | `Get-Process`     |
| Zatrzymaj usługę         | `Stop-Service`    |
| Utwórz nowy plik         | `New-Item`        |
| Pobierz zawartość folderu | `Get-ChildItem`   |
| Usuń plik                | `Remove-Item`     |

➡ Nawet jeśli **nie znasz dokładnego polecenia**, możesz je **odgadnąć** na podstawie jego znaczenia — i prawie zawsze trafisz.


---

Cmdlet `Get-Help` to Twój główny pomocnik.


1.  **Uzyskaj pomoc na temat samej pomocy:**
    ```powershell
    Get-Help Get-Help
    ```
2.  **Uzyskaj podstawową pomoc na temat polecenia do pracy z procesami:**
    ```powershell
    Get-Help Get-Process
    ```
3.  **Zobacz przykłady użycia tego polecenia:**
    ```powershell
    Get-Help Get-Process -Examples
    ```
    Jest to niezwykle przydatny parametr, który często dostarcza gotowe rozwiązania dla Twoich zadań.
4.  **Uzyskaj najbardziej szczegółowe informacje o poleceniu:**
    ```powershell
    Get-Help Get-Process -Full
    ```
W następnej części: potok lub łańcuch poleceń (PipeLines)