<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Filozofia PowerShell. CzÄ™Å›Ä‡ 4: Praca interaktywna: Out-ConsoleGridView, alerty.</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0 auto;
            max-width: 800px;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
        }
        pre {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: monospace;
        }
        code {
            background-color: #e0e0e0;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        hr {
            border: 0;
            height: 1px;
            background: #ccc;
            margin: 20px 0;
        }
        blockquote {
            border-left: 4px solid #ccc;
            margin: 1.5em 10px;
            padding: 0.5em 10px;
            color: #666;
        }
        .note {
            background-color: #f9f9f9;
            border-left: 5px solid #5cb85c;
            padding: 10px;
            margin: 15px 0;
        }
        video, img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Filozofia PowerShell.</h1>

    <h2>CzÄ™Å›Ä‡ 4: Praca interaktywna: <code>Out-ConsoleGridView</code>, alerty.</h2>

    <ul>
        <li>W <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md">pierwszej czÄ™Å›ci</a> zdefiniowaliÅ›my dwa kluczowe pojÄ™cia PowerShell: potok i obiekt.</li>
        <li>W <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md">drugiej czÄ™Å›ci</a> opowiedziaÅ‚em, czym sÄ… obiekty i potok.</li>
        <li>W <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md">trzeciej czÄ™Å›ci</a> zapoznaliÅ›my siÄ™ z systemem plikÃ³w i dostawcami.</li>
        <li>DziÅ› omÃ³wimy interaktywnÄ… pracÄ™ z danymi w konsoli, a takÅ¼e zapoznamy siÄ™ z alertami i powiadomieniami.</li>
    </ul>

    <h3>RozdziaÅ‚ pierwszy: Interaktywna praca z danymi w konsoli.</h3>

    <h4><code>Out-ConsoleGridView</code>. GUI w konsoli PowerShell.</h4>

    <p><strong>â— WaÅ¼ne:</strong> Wszystkie opisane poniÅ¼ej narzÄ™dzia wymagajÄ… <strong>PowerShell 7.2 lub nowszego</strong>.</p>

    <p><code>Out-ConsoleGridView</code> to interaktywna tabela, bezpoÅ›rednio w konsoli PowerShell, umoÅ¼liwiajÄ…ca:
    - przeglÄ…danie danych w formie tabeli;
    - filtrowanie i sortowanie kolumn;
    - wybieranie wierszy kursorem â€” w celu przekazania ich dalej w potoku.
    - i wiele wiÄ™cej.</p>

    <p><code>Out-ConsoleGridView</code> jest czÄ™Å›ciÄ… moduÅ‚u <code>Microsoft.PowerShell.ConsoleGuiTools</code>.<br>
    Aby go uÅ¼yÄ‡, naleÅ¼y najpierw zainstalowaÄ‡ ten moduÅ‚.</p>

    <p>Aby zainstalowaÄ‡ moduÅ‚, wykonaj nastÄ™pujÄ…ce polecenie w PowerShell:</p>
    <pre><code class="language-powershell">Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
</code></pre>
    <p><img src="assets/04/1.png" alt="Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser"></p>

    <p><code>Install-Module</code> pobiera i instaluje okreÅ›lony moduÅ‚ z repozytorium do systemu.<br>
    Analogi: <code>pip install</code> w <code>Pythonie</code> lub <code>npm install</code> w <code>Node.js</code>.</p>

    <p><strong>ğŸ“ Kluczowe parametry <code>Install-Module</code></strong></p>

    <table>
        <thead>
            <tr>
                <th>Parametr</th>
                <th>Opis</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>-Name</code></td>
                <td>Nazwa moduÅ‚u do zainstalowania.</td>
            </tr>
            <tr>
                <td><code>-Scope</code></td>
                <td>Zakres instalacji: <code>AllUsers</code> (domyÅ›lnie, wymaga uprawnieÅ„ administratora) lub <code>CurrentUser</code> (nie wymaga uprawnieÅ„ administratora).</td>
            </tr>
            <tr>
                <td><code>-Repository</code></td>
                <td>Wskazuje repozytorium, na przykÅ‚ad <code>PSGallery</code>.</td>
            </tr>
            <tr>
                <td><code>-Force</code></td>
                <td>Wymuszona instalacja bez potwierdzenia.</td>
            </tr>
            <tr>
                <td><code>-AllowClobber</code></td>
                <td>Pozwala nadpisaÄ‡ juÅ¼ istniejÄ…ce polecenia.</td>
            </tr>
            <tr>
                <td><code>-AcceptLicense</code></td>
                <td>Automatycznie akceptuje licencjÄ™ moduÅ‚u.</td>
            </tr>
            <tr>
                <td><code>-RequiredVersion</code></td>
                <td>Instaluje konkretnÄ… wersjÄ™ moduÅ‚u.</td>
            </tr>
        </tbody>
    </table>

    <p>Po instalacji moÅ¼esz przekazaÄ‡ dowolne dane wyjÅ›ciowe do <code>Out-ConsoleGridView</code> w celu interaktywnej pracy.</p>

    <pre><code class="language-powershell"># Klasyczny przykÅ‚ad: wyÅ›wietlanie listy procesÃ³w w interaktywnej tabeli
Get-Process | Out-ConsoleGridView
</code></pre>

    <p><a href="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be">1</a></p>

    <video width="600" controls>
      <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
      Your browser does not support the video tag.
    </video>

    <p><strong>Interfejs:</strong></p>
    <ul>
        <li><strong>Filtrowanie:</strong> Po prostu zacznij wpisywaÄ‡ tekst, a lista zostanie przefiltrowana na bieÅ¼Ä…co.</li>
        <li><strong>Nawigacja:</strong> UÅ¼yj klawiszy strzaÅ‚ek do poruszania siÄ™ po liÅ›cie.</li>
        <li><strong>WybÃ³r:</strong> NaciÅ›nij <code>Space</code>, aby wybraÄ‡/odznaczyÄ‡ pojedynczy element.</li>
        <li><strong>Wielokrotny wybÃ³r:</strong> <code>Ctrl+A</code> do wyboru wszystkich elementÃ³w, <code>Ctrl+D</code> do odznaczenia wszystkich.</li>
        <li><strong>Potwierdzenie:</strong> NaciÅ›nij <code>Enter</code>, aby zwrÃ³ciÄ‡ wybrane obiekty.</li>
        <li><strong>Anulowanie:</strong> NaciÅ›nij <code>ESC</code>, aby zamknÄ…Ä‡ okno bez zwracania danych.</li>
    </ul>

    <h2>Co potrafi <code>Out-ConsoleGridView</code>:</h2>

    <ul>
        <li>WyÅ›wietlaÄ‡ dane tabelaryczne bezpoÅ›rednio w konsoli w formie interaktywnej tabeli z nawigacjÄ… po wierszach i kolumnach.</li>
        <li>SortowaÄ‡ kolumny po naciÅ›niÄ™ciu klawiszy.</li>
        <li>FiltrowaÄ‡ dane za pomocÄ… wyszukiwania.</li>
        <li>WybieraÄ‡ jeden lub wiÄ™cej wierszy z zwracaniem wyniku.</li>
        <li>DziaÅ‚aÄ‡ w czystej konsoli bez okien GUI.</li>
        <li>ObsÅ‚ugiwaÄ‡ duÅ¼Ä… liczbÄ™ wierszy z przewijaniem.</li>
        <li>ObsÅ‚ugiwaÄ‡ rÃ³Å¼ne typy danych (ciÄ…gi znakÃ³w, liczby, daty itp.).</li>
    </ul>

    <hr>

    <h2>PrzykÅ‚ady uÅ¼ycia <code>Out-ConsoleGridView</code></h2>

    <h3>Podstawowe uÅ¼ycie â€” pokaÅ¼ tabelÄ™ z moÅ¼liwoÅ›ciÄ… interaktywnego wyboru. (checkbox)</h3>

    <pre><code class="language-powershell">Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# WyÅ›wietl tabelÄ™ z moÅ¼liwoÅ›ciÄ… filtrowania, sortowania i wyboru wierszy
$selected = $data | Out-ConsoleGridView -Title "Select process(es)" -OutputMode Multiple

$selected | Format-Table -AutoSize
</code></pre>

    <p><a href="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356">2</a></p>

    <video>
      <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
      Your browser does not support the video tag.
    </video>

    <p>WyÅ›wietla listÄ™ procesÃ³w w interaktywnej tabeli konsoli.<br>
    MoÅ¼na filtrowaÄ‡ wedÅ‚ug nazwy, sortowaÄ‡ kolumny i wybieraÄ‡ procesy.<br>
    Wybrane procesy sÄ… zwracane do zmiennej <code>$selected</code>.</p>

    <hr>

    <h3>WybÃ³r jednego wiersza z obowiÄ…zkowym zwracaniem wyniku. (radio)</h3>

    <pre><code class="language-powershell">$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Select a service" -OutputMode Single

Write-Host "You selected service: $($choice.Name)"
</code></pre>

    <p><a href="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e"></a></p>

    <video>
      <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
      Your browser does not support the video tag.
    </video>

    <p>UÅ¼ytkownik wybiera jeden wiersz (usÅ‚ugÄ™). <code>-OutputMode Single</code> zabrania wybierania wielu.</p>

    <hr>

    <h3>Filtrowanie i sortowanie duÅ¼ych tablic</h3>

    <pre><code class="language-powershell">$data = 1..1000 | ForEach-Object {
    [PSCustomObject]@{
        Number = $_
        Square = $_ * $_ 
        Cube   = $_ * $_ * $_ 
    }
}

$data | Out-ConsoleGridView -Title "Numbers and powers"  -OutputMode Multiple
</code></pre>

    <p>Pokazuje tabelÄ™ z 1000 wierszy z liczbami i ich potÄ™gami.</p>

    <h3><strong>Interaktywne zarzÄ…dzanie procesami:</strong></h3>

    <p>MoÅ¼esz wybraÄ‡ kilka procesÃ³w do zatrzymania. Parametr <code>-OutputMode Multiple</code> wskazuje, Å¼e chcemy zwrÃ³ciÄ‡ wszystkie wybrane elementy.</p>

    <pre><code class="language-powershell"># Przekazujemy wyniki przez potok.
# Zatrzymujemy wybrane procesy z parametrem -WhatIf dla podglÄ…du.
# W tym celu zdefiniujemy zmiennÄ… $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple
    
# JeÅ›li coÅ› zostaÅ‚o wybrane, przekazujemy obiekty dalej w potoku
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
</code></pre>

    <h3><strong>WybÃ³r plikÃ³w do archiwizacji:</strong></h3>
        
    <p>Znajdziemy wszystkie pliki <code>.log</code> w folderze, wybierzemy potrzebne i utworzymy z nich archiwum.</p>

    <pre><code class="language-powershell">$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
</code></pre>

    <p>â—BÄ…dÅº ostroÅ¼ny z rekurencjÄ…</p>

    <pre><code class="language-powershell">if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip
    
    # Dodajemy komunikat o sukcesie
    Write-Host "âœ… Archiwizacja zakoÅ„czona pomyÅ›lnie!" -ForegroundColor Green
}
</code></pre>

    <h3><strong>WybÃ³r jednego elementu do szczegÃ³Å‚owej analizy:</strong></h3>

    <h4>Wzorzec "Drill-Down" â€” od ogÃ³lnej listy do szczegÃ³Å‚Ã³w z <code>Out-ConsoleGridView</code></h4>

    <p>CzÄ™sto podczas pracy z obiektami systemowymi stajemy przed dylematem:</p>
    <ol>
        <li>JeÅ›li zaÅ¼Ä…damy <strong>wszystkich wÅ‚aÅ›ciwoÅ›ci</strong> dla <strong>wszystkich obiektÃ³w</strong> (<code>Get-NetAdapter | Format-List *</code>), wynik bÄ™dzie ogromny i nieczytelny.</li>
        <li>JeÅ›li pokaÅ¼emy <strong>krÃ³tkÄ… tabelÄ™</strong>, stracimy waÅ¼ne szczegÃ³Å‚y.</li>
        <li>Czasami prÃ³ba uzyskania wszystkich danych naraz moÅ¼e prowadziÄ‡ do bÅ‚Ä™du, jeÅ›li jeden z obiektÃ³w zawiera nieprawidÅ‚owe wartoÅ›ci.</li>
    </ol>

    <p>RozwiÄ…zaniem tego problemu jest wzorzec <strong>"Drill-Down"</strong> (szczegÃ³Å‚owe drÄ…Å¼enie lub "zagÅ‚Ä™bianie siÄ™"). Jego istota jest prosta:</p>
    <ul>
        <li><strong>Krok 1 (PrzeglÄ…d):</strong> PokaÅ¼ uÅ¼ytkownikowi czystÄ…, zwiÄ™zÅ‚Ä… i bezpiecznÄ… listÄ™ elementÃ³w do <strong>wyboru</strong>.</li>
        <li><strong>Krok 2 (SzczegÃ³Å‚y):</strong> Po tym, jak uÅ¼ytkownik wybierze jeden konkretny element, pokaÅ¼ mu <strong>wszystkie dostÄ™pne informacje</strong> dotyczÄ…ce tego elementu.</li>
    </ul>

    <h4>Praktyczny przykÅ‚ad: Tworzenie przeglÄ…darki adapterÃ³w sieciowych</h4>

    <p>Zaimplementujmy ten wzorzec na przykÅ‚adzie polecenia <code>Get-NetAdapter</code>.</p>

    <p><strong>Zadanie:</strong> Najpierw pokaÅ¼ krÃ³tkÄ… listÄ™ adapterÃ³w sieciowych. Po wybraniu jednego z nich, otwÃ³rz drugie okno ze wszystkimi jego wÅ‚aÅ›ciwoÅ›ciami.</p>

    <p><strong>Gotowy kod:</strong></p>
    <pre><code class="language-powershell"># --- Etap 1: WybÃ³r adaptera z krÃ³tkiej listy ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "ETAP 1: Wybierz adapter sieciowy"

# --- Etap 2: Pokazanie szczegÃ³Å‚owych informacji lub komunikatu o anulowaniu ---
if ($null -ne $selectedAdapter) {
    # Pobieramy WSZYSTKIE wÅ‚aÅ›ciwoÅ›ci dla WYBRANEGO adaptera
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # UÅ¼ywamy naszej sztuczki z .psobject.Properties, aby przeksztaÅ‚ciÄ‡ obiekt w wygodnÄ… tabelÄ™ "Nazwa-WartoÅ›Ä‡"
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value

    # Otwieramy DRUGIE okno GridView z peÅ‚nymi informacjami
    $detailedInfoForGrid | Out-ConsoleGridView -Title "ETAP 2: PeÅ‚ne informacje o '$($selectedAdapter.Name)'"
} else {
    Write-Host "Operacja anulowana. Adapter nie zostaÅ‚ wybrany." -ForegroundColor Yellow
}
</code></pre>

    <h4>SzczegÃ³Å‚owa analiza krok po kroku</h4>

    <ol>
        <li><strong>Tworzenie "bezpiecznej" listy:</strong><br>
        <code>$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed</code><br>
        Nie przekazujemy danych wyjÅ›ciowych <code>Get-NetAdapter</code> bezpoÅ›rednio. Zamiast tego tworzymy nowe, "czyste" obiekty za pomocÄ… <code>Select-Object</code>, uwzglÄ™dniajÄ…c tylko te wÅ‚aÅ›ciwoÅ›ci, ktÃ³re sÄ… nam potrzebne do przeglÄ…du. Gwarantuje to, Å¼e problematyczne dane, ktÃ³re spowodowaÅ‚y bÅ‚Ä…d, zostanÄ… odrzucone.</li>
        <li><strong>Pierwsze interaktywne okno:</strong><br>
        <code>$selectedAdapter = $adapterList | Out-ConsoleGridView ...</code><br>
        Skrypt pokazuje pierwsze okno i <strong>zatrzymuje swoje wykonanie</strong>, czekajÄ…c na TwÃ³j wybÃ³r. Gdy tylko wybierzesz wiersz i naciÅ›niesz <code>Enter</code>, obiekt odpowiadajÄ…cy temu wierszowi zostanie zapisany do zmiennej <code>$selectedAdapter</code>.</li>
        <li><strong>Sprawdzenie wyboru:</strong><br>
        <code>if ($null -ne $selectedAdapter)</code><br>
        Jest to krytycznie waÅ¼ne sprawdzenie. JeÅ›li uÅ¼ytkownik naciÅ›nie <code>Esc</code> lub zamknie okno, zmienna <code>$selectedAdapter</code> bÄ™dzie pusta (<code>$null</code>). To sprawdzenie zapobiega wykonaniu reszty kodu i wystÄ…pieniu bÅ‚Ä™dÃ³w.</li>
        <li><strong>Pobieranie peÅ‚nych informacji:</strong><br>
        <code>$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name</code><br>
        To jest kluczowy moment wzorca. Ponownie odwoÅ‚ujemy siÄ™ do <code>Get-NetAdapter</code>, ale tym razem Å¼Ä…damy <strong>tylko jednego</strong> obiektu po jego nazwie, ktÃ³rÄ… wziÄ™liÅ›my z wybranego elementu na pierwszym etapie. Teraz otrzymujemy peÅ‚ny obiekt ze wszystkimi jego wÅ‚aÅ›ciwoÅ›ciami.</li>
        <li><strong>Transformacja dla drugiego okna:</strong><br>
        <code>$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...</code><br>
        UÅ¼ywamy juÅ¼ znanego Ci potÄ™Å¼nego triku, aby "rozwinÄ…Ä‡" ten jeden zÅ‚oÅ¼ony obiekt w dÅ‚ugÄ… listÄ™ par "Nazwa wÅ‚aÅ›ciwoÅ›ci" | "WartoÅ›Ä‡", ktÃ³ra idealnie nadaje siÄ™ do wyÅ›wietlenia w tabeli.</li>
        <li><strong>Drugie interaktywne okno:</strong><br>
        <code>$detailedInfoForGrid | Out-ConsoleGridView ...</code><br>
        Na ekranie pojawia siÄ™ drugie okno, tym razem z wyczerpujÄ…cymi informacjami o tym samym adapterze, ktÃ³ry wybraÅ‚eÅ›.</li>
    </ol>

    <hr>

    <h3>PrzykÅ‚ad z niestandardowym tytuÅ‚em i podpowiedziami</h3>

    <p>WyÅ›wietlanie dziennika zdarzeÅ„ Windows w interaktywnej tabeli z tytuÅ‚em "System Events".</p>

    <pre><code class="language-powershell">Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
</code></pre>
    <p>Ten kod pobiera 50 ostatnich zdarzeÅ„ z systemowego dziennika Windows, wybiera z kaÅ¼dego zdarzenia tylko cztery kluczowe wÅ‚aÅ›ciwoÅ›ci<br>
    (czas, typ, ÅºrÃ³dÅ‚o i wiadomoÅ›Ä‡) i wyÅ›wietla je w oknie Out-ConsoleGridView.</p>

    <hr>

    <h3>Informacje o systemie.</h3>

    <p><a href="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06"></a></p>

    <video width="600" controls>
      <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
      Your browser does not support the video tag.
    </video>

    <p>kod skryptu do pobierania informacji o systemie:<br>
    <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1">Get-SystemMonitor.ps1</a></p>

    <h3>Tworzenie polecenia cmdlet 'Get-SystemMonitor'</h3>

    <h4>Krok 1: Konfiguracja zmiennej <code>PATH</code></h4>

    <ol>
        <li><strong>UtwÃ³rz staÅ‚y folder dla swoich narzÄ™dzi,</strong> jeÅ›li jeszcze tego nie zrobiÅ‚eÅ›. Na przykÅ‚ad:<br>
        <code>C:\PowerShell\Scripts</code></li>
        <li><strong>UmieÅ›Ä‡ swÃ³j plik</strong> <code>Get-SystemMonitor.ps1</code> w tym folderze.</li>
        <li><strong>Dodaj ten folder do zmiennej systemowej <code>PATH</code></strong>,</li>
    </ol>

    <h4>Krok 2: Konfiguracja aliasu w profilu PowerShell</h4>

    <p>Teraz, gdy system wie, gdzie znaleÅºÄ‡ TwÃ³j skrypt po jego peÅ‚nej nazwie, moÅ¼emy utworzyÄ‡ dla niego krÃ³tki alias.</p>

    <ol>
        <li><strong>OtwÃ³rz swÃ³j plik profilu PowerShell</strong>:<br>
        <pre><code class="language-powershell">notepad $PROFILE
</code></pre></li>
        <li><strong>Dodaj do niego nastÄ™pujÄ…cy wiersz:</strong><br>
        <pre><code class="language-powershell"># Alias dla monitora systemowego
Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
</code></pre>
        <p><strong>ZwrÃ³Ä‡ uwagÄ™ na kluczowy moment:</strong> PoniewaÅ¼ folder ze skryptem znajduje siÄ™ juÅ¼ w <code>PATH</code>, **nie musimy juÅ¼ podawaÄ‡ peÅ‚nej Å›cieÅ¼ki** do pliku! Po prostu odwoÅ‚ujemy siÄ™ do jego nazwy. DziÄ™ki temu TwÃ³j profil jest czystszy i bardziej niezawodny. JeÅ›li kiedykolwiek przeniesiesz folder <code>C:\PowerShell\Scripts</code>, bÄ™dziesz musiaÅ‚ zaktualizowaÄ‡ tylko zmiennÄ… <code>PATH</code>, a TwÃ³j plik profilu pozostanie bez zmian.</p></li>
    </ol>

    <h4>Uruchom ponownie PowerShell</h4>

    <p>Zamknij <strong>wszystkie</strong> otwarte okna PowerShell i otwÃ³rz nowe. Jest to konieczne, aby system zastosowaÅ‚ zmiany zarÃ³wno w zmiennej <code>PATH</code>, jak i w Twoim profilu.</p>

    <hr>

    <h3>Podsumowanie: Co zyskujesz</h3>

    <p>Po wykonaniu tych krokÃ³w bÄ™dziesz mÃ³gÅ‚ wywoÅ‚ywaÄ‡ swÃ³j skrypt <strong>na dwa sposoby z dowolnego miejsca w systemie</strong>:</p>

    <ol>
        <li><strong>Po peÅ‚nej nazwie (niezawodnie, do uÅ¼ycia w innych skryptach):</strong><br>
        <pre><code class="language-powershell">Get-SystemMonitor.ps1
Get-SystemMonitor.ps1 -Resource storage
</code></pre></li>
        <li><strong>Po krÃ³tkim aliasie (wygodnie, do pracy interaktywnej):</strong><br>
        <pre><code class="language-powershell">sysmon
sysmon -Resource memory
</code></pre></li>
    </ol>

    <p>PomyÅ›lnie "zarejestrowaÅ‚eÅ›" swÃ³j skrypt w systemie w najbardziej profesjonalny i elastyczny sposÃ³b.</p>

    <p>Pomocne? Subskrybuj.<br>
    PodobaÅ‚o siÄ™ â€” daj â€+â€<br>
    Powodzenia! ğŸš€</p>

    <p>Inne artykuÅ‚y o PowerShell:</p>
</body>
</html>
