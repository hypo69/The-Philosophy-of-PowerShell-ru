# Filozofia PowerShell.
## Część 2: Potok (Pipeline), zmienne, Get-Member, plik *.ps1* i eksport wyników
**❗ Ważne:**
Piszę o PS7 (PowerShell 7). Różni się on od PS5 (PowerShell 5). Od siódmej wersji PowerShell stał się wieloplatformowy. Z tego powodu
zmieniło się zachowanie niektórych poleceń.

W pierwszej części ustaliliśmy kluczową zasadę: PowerShell pracuje z **obiektami**, a nie z tekstem.
Ten post poświęcony jest kilku ważnym narzędziom PowerShell:
nauczymy się przekazywać obiekty przez **potok**, analizować je za pomocą **`Get-Member`**,
zapisywać wyniki w **zmiennych** i automatyzować to wszystko w **plikach skryptów (`.ps1`)** z **eksportem**
wyników do wygodnych formatów.

### 1. Co to jest potok (`|`)?
Potok w PowerShell to mechanizm przekazywania pełnowartościowych obiektów .NET (a nie tylko tekstu) od jednego polecenia
do drugiego, gdzie każdy kolejny cmdlet otrzymuje ustrukturyzowane obiekty ze wszystkimi ich właściwościami i metodami.

Symbol `|` (pionowa kreska) — to operator potoku. Jego zadaniem jest pobranie wyniku (wyjścia) polecenia znajdującego się po jego lewej stronie i przekazanie go jako wejście do polecenia znajdującego się po prawej stronie.

`Polecenie 1 (tworzy obiekty)` → `|` → `Polecenie 2 (otrzymuje i przetwarza obiekty)` → `|` → `Polecenie 3 (otrzymuje przetworzone obiekty)` → | ...

#### Klasyczny potok UNIX: Strumień tekstu

W `bash` przez potok przekazywany jest **strumień bajtów**, który zazwyczaj interpretowany jest jako tekst.

```bash
# Znajdź wszystkie procesy 'nginx' i policz ich liczbę
ps -ef | grep 'nginx' | wc -l
```
Tutaj `ps` wyprowadza tekst, `grep` filtruje ten tekst, a `wc` liczy wiersze. Każde narzędzie nic nie wie o "procesach", pracuje tylko z wierszami.

#### Potok PowerShell: Strumień obiektów
**Przykład:** Pobierzmy wszystkie procesy, posortujmy je według użycia CPU i wybierzmy 5 najbardziej "żarłocznych".

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
!(assets/02/1.png)

Tutaj `Get-Process` tworzy **obiekty** procesów. `Sort-Object` otrzymuje te **obiekty** i sortuje je według właściwości `CPU`. `Select-Object` otrzymuje posortowane **obiekty** i wybiera pierwsze 5.

Z pewnością zauważyliście w poleceniu słowa zaczynające się od myślnika (-): -Property, -Descending, -First. To są parametry.
Parametry — to ustawienia, przełączniki i instrukcje dla cmdletu. Pozwalają one kontrolować, **JAK** polecenie będzie wykonywać swoją pracę.
Bez parametrów polecenie działa w trybie domyślnym, a z parametrami dajesz mu konkretne wskazówki.

Główne typy parametrów:

- Parametr z wartością: wymaga dodatkowych informacji.

    `-Property CPU`: Mówimy Sort-Object, według jakiej właściwości sortować. CPU — to wartość parametru.

    `-First 5`: Mówimy Select-Object, ile obiektów wybrać. 5 — to wartość parametru.

- Parametr-przełącznik (flaga): Nie wymaga wartości. Sama jego obecność w poleceniu włącza lub wyłącza określone zachowanie.

   `-Descending`: Ta flaga mówi Sort-Object, aby zmienić kolejność sortowania na odwrotną (od większej do mniejszej). Nie potrzebuje dodatkowej wartości — sama w sobie jest instrukcją.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
!(assets/02/2.png)
To polecenie odpowiada na bardzo proste pytanie:
**"Ile dokładnie procesów o nazwie `svchost.exe` jest obecnie uruchomionych w moim systemie?"**

#### Analiza krok po kroku

##### **Krok 1: `Get-Process -Name 'svchost'`**

Ta część polecenia zwraca się do systemu operacyjnego i prosi o znalezienie **wszystkich bez wyjątku** uruchomionych procesów, których nazwa pliku wykonywalnego to `svchost.exe`.
W przeciwieństwie do procesów typu `notepad` (których zazwyczaj jest jeden lub dwa), procesów `svchost` w systemie zawsze jest **wiele**. Polecenie zwróci **tablicę (kolekcję) obiektów**,
gdzie każdy obiekt — to oddzielny, pełnowartościowy proces `svchost` z własnym unikalnym ID, użyciem pamięci itd.
PowerShell znalazł w systemie, na przykład, 90 procesów `svchost` i teraz trzyma w ręku kolekcję 90 obiektów.

##### **Krok 2: `|` (Operator potoku)**

Ten symbol pobiera kolekcję 90 obiektów `svchost`, otrzymaną w pierwszym kroku, i zaczyna przekazywać je **po jednym** na wejście do następnego polecenia.

##### **Krok 3: `Measure-Object`**

Ponieważ wywołaliśmy `Measure-Object` bez parametrów (takich jak `-Property`, `-Sum` itd.), wykonuje on swoją operację **domyślną** — po prostu liczy liczbę "przedmiotów", które mu przekazano.
Raz, dwa, trzy ... Po policzeniu wszystkich obiektów, `Measure-Object` tworzy **swój własny obiekt-wynik**, w którym znajduje się właściwość `Count`, równa końcowej liczbie.

**`Count: 90`** — to jest odpowiedź na nasze pytanie. Uruchomionych jest 90 procesów `svchost`.
Pozostałe pola są puste, ponieważ nie prosiliśmy `Measure-Object` o wykonywanie bardziej złożonych obliczeń.

#### Przykład z `svchost` i parametrami

Zmieńmy nasze zadanie. Teraz chcemy nie tylko policzyć procesy `svchost`,
ale dowiedzieć się, **ile całkowitej pamięci RAM (w megabajtach) zużywają razem**.

Do tego potrzebne będą nam parametry:
*   `-Property WorkingSet64`: Ta instrukcja mówi `Measure-Object`: "Z każdego obiektu `svchost`, który do ciebie przyjdzie, weź wartość liczbową z właściwości `WorkingSet64` (to jest użycie pamięci w bajtach)".
*   `-Sum`: Ta instrukcja-flaga mówi: "Zsumuj wszystkie te wartości, które wziąłeś z właściwości `WorkingSet64`".

Nasze nowe polecenie będzie wyglądać tak:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
!(assets/02/3.png)

1.  `Get-Process` znajdzie liczbę obiektów `svchost`.
2.  Potok `|` przekaże je do `Measure-Object`.
3.  Ale teraz `Measure-Object` działa inaczej:
    *   Bierze pierwszy obiekt `svchost`, sprawdza jego właściwość `.WorkingSet64` (na przykład `25000000` bajtów) i zapamiętuje tę liczbę.
    *   Bierze drugi obiekt, sprawdza jego `.WorkingSet64` (na przykład `15000000` bajtów) i dodaje do poprzedniego.
    *   ...i tak dalej dla wszystkich obiektów.
4.  W rezultacie `Measure-Object` utworzy obiekt-wynik, ale tym razem będzie on inny.

*   **`Count: 92`**: Liczba obiektów.
*   **`Sum: 1661890560`**: To jest całkowita suma wszystkich wartości `WorkingSet64` w bajtach.
*   **`Property: WorkingSet64`**: To pole jest teraz również wypełnione, informuje nas, która właściwość została użyta do obliczeń.

### 2. Zmienne (Zwykłe i specjalna `$_`)

Zmienna — to nazwane miejsce w pamięci, które zawiera jakąś wartość.

Tą wartością może być cokolwiek: tekst, liczba, data lub, co najważniejsze dla PowerShell,
cały obiekt, a nawet kolekcja obiektów. Nazwa zmiennej w PowerShell zawsze zaczyna się od znaku dolara ($).
Przykłady: $name, $counter, $processList.

Specjalna zmienna `$_`?

`$_` — to skrót od "bieżący obiekt" lub "ta rzecz".
Wyobraź sobie potok w fabryce. Przez niego przejeżdżają różne części (obiekty).

`$_` — to ta sama część, która znajduje się teraz przed tobą (lub przed robotem-przetwarzającym).

Źródło (`Get-Process`) — wysypuje na potok całe pudełko części (wszystkich procesów).

Potok (`|`) — sprawia, że te części poruszają się po taśmie pojedynczo.

Przetwarzający (`Where-Object` lub `ForEach-Object`) — to robot, który patrzy na każdą część.

Zmienna `$_` — to ta sama część, która znajduje się teraz w "rękach" robota.

Kiedy robot skończy z jedną częścią, potok podaje mu następną, a `$_` będzie teraz wskazywać już na nią.

Policzmy, ile całkowitej pamięci zużywają procesy `svchost`, i wyświetlmy wynik na monitorze.
```powershell
# 1. Wykonujemy polecenie i zapisujemy jego złożony obiekt-wynik do zmiennej $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Teraz możemy pracować z zapisanym obiektem. Pobieramy z niego właściwość Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Wyświetlamy wynik na ekranie, używając nowej zmiennej
Write-Host "Wszystkie procesy svchost używają $memoryInMB MB pamięci."
```
!(assets/02/4.png)

*   `Write-Host` — to specjalistyczny cmdlet, którego jedynym zadaniem jest **pokazanie tekstu bezpośrednio użytkownikowi w konsoli**.

*   Ciąg znaków w podwójnych cudzysłowach: `"..."` - to ciąg tekstowy, który przekazujemy cmdletowi `Write-Host` jako argument. Dlaczego podwójne, a nie pojedyncze cudzysłowy?

    W PowerShell istnieją dwa typy cudzysłowów:

    *   **Pojedyncze (`'...'`):** Tworzą **dosłowny ciąg znaków**. Wszystko, co się w nich znajduje, jest traktowane jako zwykły tekst, bez wyjątków.
    *   **Podwójne (`"..."`):** Tworzą **rozszerzalny (lub podstawialny) ciąg znaków**. PowerShell "skanuje" taki ciąg w poszukiwaniu zmiennych (zaczynających się od `$`) i podstawia w ich miejsce ich wartości.

* `$memoryInMB`. To zmienna, do której **w poprzednim kroku** naszego skryptu włożyliśmy wynik obliczeń. Kiedy `Write-Host` otrzymuje ciąg znaków w podwójnych cudzysłowach,
następuje proces zwany **"rozszerzaniem zmiennych" (String Expansion)**:
    1.  PowerShell widzi tekst `"Wszystkie procesy svchost używają "`.
    2.  Następnie natrafia na konstrukcję `$memoryInMB`. Rozumie, że to nie jest zwykły tekst, ale zmienna.
    3.  Zagłębia się w pamięć, znajduje wartość przechowywaną w `$memoryInMB` (na przykład `1585.52`).
    4.  **Podstawia tę wartość** bezpośrednio do ciągu.
    5.  Następnie dodaje pozostałą część tekstu: `" MB pamięci."`.
    6.  W rezultacie do `Write-Host` przekazywany jest już gotowy, złożony ciąg: `"Wszystkie procesy svchost używają 1585.52 MB pamięci."`.

Uruchom notatnik:
 1. Znajdujemy proces Notatnika i zapisujemy go do zmiennej `$notepadProcess`
 ```powershell
$notepadProcess = Get-Process -Name notepad
```

 2. Odwołujemy się do właściwości 'Id' tego obiektu za pomocą kropki i wyświetlamy ją
 ```powershell
Write-Host "ID procesu 'Notatnik' wynosi: $($notepadProcess.Id)"
```
!(assets/02/5.png)

**❗ Ważne:**
    `Write-Host` "łamie" potok. Tekst przez niego wyświetlony nie może być dalej przekazywany w potoku do przetwarzania. Jest przeznaczony tylko do wyświetlania.

### 3. Get-Member (Inspektor obiektów)

Wiemy, że przez potok "płyną" obiekty. Ale jak dowiedzieć się, z czego się składają? Jakie mają właściwości i jakie działania (metody) można na nich wykonywać?

Cmdlet **`Get-Member`** (alias: `gm`) to główne narzędzie do badania.
Zanim zaczniesz pracować z obiektem, przepuść go przez `Get-Member`, aby zobaczyć wszystkie jego możliwości.

Przeanalizujmy obiekty, które tworzy `Get-Process`:
```powershell
Get-Process | Get-Member
```
!(assets/02/6.png)

*Przeanalizujmy każdą część wyjścia Get-Member.*

`TypeName: System.Diagnostics.Process` - To pełna, oficjalna "nazwa typu" obiektu z biblioteki .NET. To jego "paszport".
Ten wiersz mówi ci, że wszystkie obiekty zwracane przez Get-Process są obiektami typu System.Diagnostics.Process.
Gwarantuje to, że wszystkie będą miały ten sam zestaw właściwości i metod.
Możesz [wyszukać w Google](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process", aby znaleźć oficjalną dokumentację Microsoft z jeszcze bardziej szczegółowymi informacjami.

- Kolumna 1: `Name`

To prosta, czytelna dla człowieka **nazwa** właściwości, metody lub innego "członka" obiektu. Właśnie tej nazwy będziesz używać w swoim kodzie do dostępu do danych lub wykonywania działań.

- Kolumna 2: `MemberType` (Typ obiektu)

To najważniejsza kolumna do zrozumienia. Klasyfikuje ona, **czym jest** każdy obiekt. To jego "stanowisko", które mówi ci, **JAK** go używać.

*   **`Property` (Właściwość):** **charakterystyka** lub **część danych**, przechowywana wewnątrz obiektu. Możesz "odczytać" jej wartość.
    *   *Przykłady na zrzucie ekranu:* `BasePriority`, `HandleCount`, `ExitCode`. To po prostu dane, które można obejrzeć.

*   **`Method` (Metoda):** **DZIAŁANIE**, które można wykonać na obiekcie. Metody zawsze wywoływane są z nawiasami `()`.
    *   *Przykłady na zrzucie ekranu:* `Kill`, `Refresh`, `WaitForExit`. Napisałbyś `$process.Kill()` lub `$process.Refresh()`.

*   **`AliasProperty` (Właściwość aliasu):** **przyjazny alias** dla innej, dłuższej właściwości. PowerShell dodaje je dla wygody i zwięzłości.
    *   *Przykłady na zrzucie ekranu:* `WS` — to krótki alias dla `WorkingSet64`. `Name` — dla `ProcessName`. `VM` — dla `VirtualMemorySize64`.

*   **`Event` (Zdarzenie):** **POWIADOMIENIE** o tym, że coś się stało, na które można "subskrybować".
    *   *Przykład na zrzucie ekranu:* `Exited`. Twój skrypt może "nasłuchiwać" tego zdarzenia, aby wykonać jakieś działanie natychmiast po zakończeniu procesu.

*   **`CodeProperty` i `NoteProperty`:** specjalne typy właściwości, często dodawane przez sam PowerShell dla wygody. `CodeProperty` oblicza swoją wartość "na bieżąco", a `NoteProperty` — to prosta właściwość-notatka, dodana do obiektu.

- Kolumna 3: `Definition` (Definicja)

To **techniczna definicja** lub "podpis" członka. Daje ona dokładne szczegóły dotyczące jego użycia. Jej zawartość zależy od `MemberType`:

*   **Dla `AliasProperty`:** Pokazuje, **czemu równa się alias**. To niezwykle przydatne!
    *   *Przykład na zrzucie ekranu:* `WS = WorkingSet64`. Od razu widać, że `WS` — to po prostu krótki zapis dla `WorkingSet64`.

*   **Dla `Property`:** Pokazuje **typ danych**, który jest przechowywany we właściwości (na przykład `int` dla liczby całkowitej, `string` dla tekstu, `datetime` dla daty i czasu), i co można z nim robić (`{get;}` — tylko odczyt, `{get;set;}` — odczyt i modyfikacja).
    *   *Przykład na zrzucie ekranu:* `int BasePriority {get;}`. To właściwość całkowita, którą można tylko odczytać.

*   **Dla `Method`:** Pokazuje, co metoda zwraca (na przykład `void` — nic, `bool` — true/false) i jakie **parametry** (dane wejściowe) przyjmuje w nawiasach.
    *   *Przykład na zrzucie ekranu:* `void Kill()`. Oznacza to, że metoda `Kill` nic nie zwraca i może być wywołana bez parametrów. Istnieje również druga wersja `void Kill(bool entireProcessTree)`, która przyjmuje wartość logiczną (true/false).

#### W formie tabeli

| Kolumna      | Co to jest?                             | Przykład ze zrzutu ekranu                  | Do czego służy?                                                                   |
|--------------|--------------------------------------|--------------------------------------------|-----------------------------------------------------------------------------------------|
| **Name**     | Nazwa, której używasz w kodzie.  | `Kill`, `WS`, `Name`                       | odwołanie do właściwości lub metody (`$process.WS`, `$process.Kill()`).    |
| **MemberType**| Typ członka (dane, działanie itp.). | `Method`, `Property`, `AliasProperty`      | **jak** go używać (odczytać wartość lub wywołać z `()`).              |
| **Definition** | Szczegóły techniczne.                  | `WS = WorkingSet64`, `void Kill()`           | co kryje się za aliasem i jakie parametry są potrzebne metodzie.                |

#### Przykład: Praca z oknami procesów

##### 1. Problem:
"Otworzyłem wiele okien Notatnika. Jak programowo zminimalizować wszystkie oprócz głównego, a następnie zamknąć tylko to, które ma w tytule słowo 'Untitled'?"

##### 2. Badanie z `Get-Member`:
Musimy znaleźć właściwości związane z oknem i jego tytułem.

```powershell
Get-Process -Name notepad | Get-Member
```
!(assets/02/7.png)

**Analiza wyniku `Get-Member`:**
*   Przeglądając właściwości, znajdujemy `MainWindowTitle`. Typ `string`. Świetnie, to tytuł głównego okna!
*   W metodach widzimy `CloseMainWindow()`. To "łagodniejszy" sposób zamknięcia okna niż `Kill()`.
*   Również w metodach jest `WaitForInputIdle()`. Brzmi interesująco, być perhaps pomoże to poczekać, aż proces będzie gotowy do interakcji.

!(assets/02/7.png)

`Get-Member` pokazał nam właściwość `MainWindowTitle`, która jest kluczem do rozwiązania zadania i pozwala na interakcję z procesami na podstawie stanu ich okien, a nie tylko nazwy.

##### 3. Rozwiązanie:
Teraz możemy zbudować logikę opartą na tytule okna.

```powershell
# 1. Znajdujemy wszystkie procesy Notatnika
$notepads = Get-Process -Name notepad

# 2. Przechodzimy przez każdy i sprawdzamy tytuł
foreach ($pad in $notepads) {
    # Dla każdego procesu ($pad) sprawdzamy jego właściwość MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Znaleziono niezapisany Notatnik (ID: $($pad.Id)). Zamykam jego okno..."
        # $pad.CloseMainWindow() # Odkomentuj, aby faktycznie zamknąć
        Write-Host "Okno '$($pad.MainWindowTitle)' zostałoby zamknięte." -ForegroundColor Yellow
    } else {
        Write-Host "Pomijam Notatnik z tytułem: $($pad.MainWindowTitle)"
    }
}
```

!(assets/02/8.png)

!(assets/02/9.png)

---

#### Przykład: Znajdź proces nadrzędny

##### 1. Problem:
"Czasami widzę w systemie wiele procesów potomnych `chrome.exe`. Jak mogę dowiedzieć się, który z nich jest głównym, "nadrzędnym" procesem, który je wszystkie uruchomił?"

##### 2. Badanie z `Get-Member`:
Musimy znaleźć coś, co łączy jeden proces z drugim.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
!(assets/02/10.png)

**Analiza wyniku `Get-Member`:**
*   Uważnie przeglądając listę, znajdujemy właściwość typu `CodeProperty` o nazwie `Parent`.
*   Jej definicja (`Definition`) — `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
To właściwość obliczeniowa, która po odwołaniu się do niej zwraca **obiekt procesu nadrzędnego**.

##### 3. Rozwiązanie:
Teraz możemy napisać skrypt, który dla każdego procesu `chrome` wyświetli informacje o jego rodzicu.

```powershell
# 1. Pobieramy wszystkie procesy chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Dla każdego z nich wyświetlamy informacje o nim i jego rodzicu
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Pobieramy proces nadrzędny
    $parent = $_.Parent
    
    # Tworzymy ładne wyjście
    Write-Host "Proces:" -ForegroundColor Green
    Write-Host "  - Nazwa: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Jego rodzic:" -ForegroundColor Yellow
    Write-Host "  - Nazwa: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
```
!(assets/02/11.png)

!(assets/02/12.png)

Od razu widzimy, że procesy o ID 4756, 7936, 8268 i 9752 zostały uruchomione przez proces o ID 14908. Można również zauważyć ciekawy przypadek z procesem ID: 7252, którego proces nadrzędny nie został zidentyfikowany (możliwe, że rodzic zdążył się już zakończyć do momentu sprawdzenia). Modyfikacja skryptu z sprawdzeniem `if ($parent)` elegancko obsługuje ten przypadek, nie powodując błędu.
`Get-Member` pomógł nam odkryć "ukrytą" właściwość `Parent`, która zapewnia potężne możliwości analizy hierarchii procesów.

#### 4. Plik *.ps1* (Tworzenie skryptów)

Gdy twój łańcuch poleceń staje się użyteczny, będziesz chciał go zapisać do wielokrotnego użytku. Do tego właśnie służą **skrypty** — pliki tekstowe z rozszerzeniem **`.ps1`**.

##### Zezwolenie na uruchamianie skryptów
Domyślnie w systemie Windows uruchamianie lokalnych skryptów jest zabronione. Aby to naprawić **dla bieżącego użytkownika**, wykonaj jednorazowo w PowerShell **jako administrator**:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
To bezpieczne ustawienie, które pozwala uruchamiać własne skrypty i skrypty podpisane przez zaufanego wydawcę.

##### Przykład skryptu `system_monitor.ps1`
Utwórz plik o tej nazwie i wklej do niego poniższy kod. Ten skrypt zbiera informacje o systemie i generuje raporty.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Skrypt do tworzenia raportu o stanie systemu.
.DESCRIPTION
    Zbiera informacje o procesach, usługach i przestrzeni dyskowej oraz generuje raporty.
.PARAMETER OutputPath
    Ścieżka do zapisywania raportów. Domyślnie 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Blok 1: Przygotowanie ---
Write-Host "Przygotowanie do tworzenia raportu..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Blok 2: Zbieranie danych ---
Write-Host "Zbieranie informacji..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Blok 3: Wywołanie funkcji do eksportu (patrz następna sekcja) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Raporty pomyślnie zapisano w folderze $OutputPath" -ForegroundColor Magenta
```
*Uwaga: funkcja `Export-Results` zostanie zdefiniowana w następnej sekcji jako przykład dobrej praktyki.*

#### 5. Eksport wyników

Czyste dane są dobre, ale często trzeba je przedstawić w formie wygodnej dla człowieka lub innego programu. PowerShell oferuje wiele cmdletów do eksportu.

| Metoda                               | Polecenie                                            | Opis                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Zwykły tekst**                   | `... \| Out-File C:\Temp\data.txt`                 | Przekierowuje tekstową reprezentację do pliku.                                      |
| **CSV (dla Excela)**                 | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | Eksportuje obiekty do CSV. `-NoTypeInfo` usuwa służbowy pierwszy wiersz.     |
| **Raport HTML**                      | `... \| ConvertTo-Html -Title "Raport"`             | Tworzy kod HTML z obiektów.                                                       |
| **JSON (dla API, web)**             | `... \| ConvertTo-Json`                            | Konwertuje obiekty do formatu JSON.                                                  |
| **XML (natywny format PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml`            | Zapisuje obiekty ze wszystkimi typami danych. Można je idealnie przywrócić za pomocą `Import-Clixml`. |

##### Uzupełnienie skryptu: funkcja eksportu
Dodajmy do naszego skryptu `system_monitor.ps1` funkcję, która będzie zajmować się eksportem. Umieść ten kod **przed** wywołaniem `Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Eksport do CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Tworzenie ładnego raportu HTML
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Top 10 procesów według CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Statystyki usług</h2>"

    ConvertTo-Html -Head "<title>Raport systemowy</title>" -Body "<h1>Raport systemowy z dnia $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
Teraz nasz skrypt nie tylko zbiera dane, ale także starannie zapisuje je w dwóch formatach: CSV do analizy i HTML do szybkiego przeglądania.

#### Zakończenie

1.  **Potok (`|`)** — główne narzędzie do łączenia poleceń i przetwarzania obiektów.
2.  **`Get-Member`** — analiza obiektów, która pokazuje, z czego się składają.
3.  **Zmienne (`$var`, `$_`)** pozwalają zapisywać dane i odwoływać się do bieżącego obiektu w potoku.
4.  **Pliki `.ps1`** przekształcają polecenia w narzędzia automatyzacji wielokrotnego użytku.
5.  **Cmdlety eksportu** (`Export-Csv`, `ConvertTo-Html`) eksportują dane w odpowiednim formacie.

**W następnej części zastosujemy tę wiedzę do nawigacji i zarządzania systemem plików, badając obiekty `System.IO.DirectoryInfo` i `System.IO.FileInfo`.**