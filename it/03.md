# Filosofia di PowerShell.

### **Parte 3: Navigazione e gestione del file system. Operatori logici. Introduzione alle funzioni.**

Nella [parte precedente](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md) abbiamo esplorato le pipeline e gli oggetti astratti dei processi.
Ora applichiamo le nostre conoscenze sulla pipeline e sugli oggetti a uno dei compiti più comuni per un utente o un amministratore: lavorare con il file system.
In PowerShell, questo lavoro si basa sugli stessi principi: i comandi restituiscono oggetti che possono essere passati attraverso la pipeline per ulteriori elaborazioni.

***

### **1. Concetto di PowerShell Drives (PSDrives)**

Prima di iniziare a lavorare con i file, è importante comprendere il concetto di **PowerShell-drives (PSDrives)**. A differenza di `cmd.exe`, dove i drive sono solo le lettere `C:`, `D:` e così via, in PowerShell un "drive" è un'astrazione per accedere a qualsiasi archivio dati gerarchico.

```powershell
Get-PSDrive
```
Il risultato mostrerà non solo i drive fisici, ma anche gli pseudo-drive:

| Nome | Provider | Root | Descrizione |
|------|----------|------|----------|
| Alias | Alias | Alias:\ | Alias dei comandi |
| C | FileSystem | C:\ | Disco locale C |
| Cert | Certificate | Cert:\ | Archivio certificati |
| Env | Environment | Env:\ | Variabili d'ambiente |
| Function | Function | Function:\ | Funzioni caricate |
| HKCU | Registry | HKEY_CURRENT_USER | Chiave di registro |
| HKLM | Registry | HKEY_LOCAL_MACHINE | Chiave di registro |
| Variable | Variable | Variable:\ | Variabili di sessione |
| WSMan | WSMan | WSMan:\ | Configurazione WinRM |

Questa unificazione significa che è possibile "entrare" nel registro (`Set-Location HKLM:`) e ottenere un elenco delle sue chiavi con lo stesso comando `Get-ChildItem` con cui si ottiene un elenco di file sul disco C:. Questo è un concetto incredibilmente potente.

#### **Esempi di lavoro con diversi provider**

*   **Archivio certificati (Cert:)**
    Consente di lavorare con i certificati digitali come se fossero file in cartelle.

    **Compito:** Trovare tutti i certificati SSL sulla macchina locale che scadono nei prossimi 30 giorni.
    ```powershell
    # Passiamo all'archivio certificati del computer locale
    Set-Location Cert:\LocalMachine\My

    # Troviamo i certificati la cui data di scadenza è inferiore a oggi + 30 giorni
    Get-ChildItem | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) } | Select-Object Subject, NotAfter, Thumbprint
    ```

*   **Variabili d'ambiente (Env:)**
    Fornisce accesso alle variabili d'ambiente di Windows (`%PATH%`, `%windir%` ecc.) come se fossero file.

    **Compito:** Ottenere il percorso della cartella di sistema di Windows e aggiungervi il percorso di `System32`.
    ```powershell
    # Otteniamo il valore della variabile windir
    $windowsPath = (Get-Item Env:windir).Value
    # O più semplicemente: $windowsPath = $env:windir

    # Costruiamo in modo sicuro il percorso completo
    $system32Path = Join-Path -Path $windowsPath -ChildPath "System32"
    Write-Host $system32Path
    # Risultato: C:\WINDOWS\System32
    ```

*   **Registro di Windows (HKCU: e HKLM:)**
    Immaginate che il registro sia semplicemente un altro file system. Le chiavi sono cartelle e i parametri sono proprietà di queste cartelle.

    **Compito:** Scoprire il nome completo della versione installata di Windows dal registro.
    ```powershell
    # Passiamo alla chiave di registro desiderata
    Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

    # Otteniamo la proprietà (parametro di registro) con il nome "ProductName"
    Get-ItemProperty -Path . -Name "ProductName"
    # Risultato: ProductName : Windows 11 Pro
    ```

*   **Funzioni caricate (Function:)**
    Mostra tutte le funzioni disponibili nella sessione PowerShell corrente, come se fossero file.

    **Compito:** Trovare tutte le funzioni caricate che contengono la parola "Help" nel nome e visualizzare il codice di una di esse.
    ```powershell
    # Cerchiamo funzioni per maschera
    Get-ChildItem Function: | Where-Object { $_.Name -like "*Help*" }

    # Otteniamo il codice completo (definizione) della funzione Get-Help
    (Get-Item Function:Get-Help).Definition
    ```

*   **Variabili di sessione (Variable:)**
    Consente di gestire tutte le variabili (`$myVar`, `$PROFILE`, `$Error` ecc.) definite nella sessione corrente.

    **Compito:** Trovare tutte le variabili relative alla versione di PowerShell (`$PSVersionTable`, `$PSHOME` e altre).
    ```powershell
    # Troviamo tutte le variabili che iniziano con "PS"
    Get-ChildItem Variable:PS*

    # Otteniamo il valore di una variabile specifica
    Get-Variable -Name "PSVersionTable"
    ```
---

### 2. **Navigazione e analisi**

#### **Nozioni di base sulla navigazione**

```powershell
# Scoprire dove ci troviamo (restituisce un oggetto PathInfo)
Get-Location          # Alias: gl, pwd

# Passare alla radice del disco C:
Set-Location C:\      # Alias: sl, cd

# Passare alla cartella home dell'utente corrente
Set-Location ~

# Mostrare il contenuto della cartella corrente (restituisce una collezione di oggetti)
Get-ChildItem         # Alias: gci, ls, dir
```

```powershell
# **Ricerca ricorsiva**
# Trovare il file hosts nel sistema, ignorando gli errori "Accesso negato"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
```
**Chiave `-Recurse` (Ricorsivo):** Fa sì che il cmdlet lavori non solo con l'elemento specificato, ma anche con tutto il suo contenuto.

**Chiave `-ErrorAction SilentlyContinue`:** Istruzione per ignorare gli errori e continuare a lavorare silenziosamente.

##### **Analisi dello spazio su disco**
Un classico esempio della potenza della pipeline: trovare, ordinare, formattare e selezionare.
```powershell
Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue |
    Sort-Object Length -Descending |
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} |
    Select-Object -First 20
```

###### **Suggerimento su come inserire comandi lunghi.**
> PowerShell consente di dividerli su più righe per una migliore leggibilità.
> 
> *   **Dopo l'operatore pipeline (`|`):** Questo è il modo più comune e conveniente. Basta premere `Invio` dopo il simbolo `|`. PowerShell capirà che il comando non è completo e attenderà la continuazione sulla riga successiva.
> *   **In qualsiasi altro punto:** Utilizzare il carattere di backtick (`) alla fine della riga, quindi premere `Invio`. Questo carattere dice a PowerShell: "Il comando continuerà sulla riga successiva".
> *   **Negli editor (ISE, VS Code):** La combinazione di tasti `Shift+Invio` di solito inserisce automaticamente un'interruzione di riga senza eseguire il comando.

#### **Filtrare il contenuto e gli operatori logici**

```powershell
# Trova tutti i file .exe. Il parametro -Filter funziona molto velocemente.
Get-ChildItem C:\Windows | Where-Object { $_.Extension -eq ".exe" }
```

`Get-ChildItem` restituisce una collezione di oggetti. Possiamo passarla attraverso la pipeline a `Where-Object` per un'ulteriore filtrazione.

```powershell
# Mostra solo i file
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
```
Questo comando ci introduce a uno dei concetti fondamentali negli script PowerShell: gli **operatori di confronto**. 

#### **Operatori di confronto e logici**

Sono chiavi speciali per confrontare i valori. Iniziano sempre con un trattino (`-`) e sono la base per filtrare i dati in `Where-Object` e costruire la logica in `if`.

| Operatore | Descrizione | Esempio nella pipeline |
| :--- | :--- | :--- |
| `-eq` | Uguale (EQual) | `$_.Name -eq "svchost.exe"` |
| `-ne` | Non uguale (Not Equal) | `$_.Status -ne "Running"` |
| `-gt` | Maggiore di (Greater Than) | `$_.Length -gt 1MB` |
| `-ge` | Maggiore o uguale (Greater or Equal) | `$_.Handles -ge 500` |
| `-lt` | Minore di (Less Than) | `$_.LastWriteTime -lt (Get-Date).AddDays(-30)`|
| `-le` | Minore o uguale (Less or Equal) | `$_.Count -le 1` |
| `-like` | Simile a (con caratteri jolly `*`, `?`)| `$_.Name -like "win*"` |
| `-notlike`| Non simile a | `$_.Name -notlike "*.tmp"` |
| `-in` | Il valore è contenuto nella collezione | `$_.Extension -in ".log", ".txt"` |
| `-and` | Logico E (entrambe le condizioni sono vere) | |
| `-or` | Logico O (almeno una condizione è vera) | |
| `-not` | Logico NON (inverte la condizione) | |

L'argomento degli operatori logici è molto vasto e gli dedicherò una parte separata (o anche due). Nel frattempo, armati di questi operatori,
possiamo **filtrare, ordinare e selezionare i file e le cartelle di cui abbiamo bisogno**, utilizzando tutta la potenza della pipeline di oggetti.

#### **Esempi di utilizzo nel file system**

**Trovare un file per nome esatto (sensibile alle maiuscole/minuscole):**
```powershell
Get-ChildItem C:\Windows\System32 -Recurse | Where-Object { $_.Name -eq "kernel32.dll" }
```

**Trovare tutti i file che iniziano con "host", ma non sono cartelle:**
```powershell
Get-ChildItem C:\Windows\System32\drivers\etc | Where-Object { ($_.Name -like "host*") -and (-not $_.PSIsContainer) }
```

**Trovare tutti i file di log (.log) la cui dimensione supera i 50 megabyte:**
```powershell
Get-ChildItem C:\Windows\Logs -Filter "*.log" -Recurse | Where-Object { $_.Length -gt 50MB }
```

**Trovare tutti i file temporanei (.tmp) e i file di backup (.bak) per la pulizia:**
L'operatore `-in` qui è molto più elegante di diverse condizioni con `-or`.
```powershell
$extensionsToDelete = ".tmp", ".bak", ".old"
Get-ChildItem C:\Temp -Recurse | Where-Object { $_.Extension -in $extensionsToDelete }
```

**Trovare tutti i file Word (.docx) creati nell'ultima settimana:**
```powershell
$oneWeekAgo = (Get-Date).AddDays(-7)
Get-ChildItem C:\Users\MyUser\Documents -Filter "*.docx" -Recurse | Where-Object { $_.CreationTime -ge $oneWeekAgo }
```

**Trovare file vuoti (dimensione 0 byte) che non sono cartelle:**
```powershell
Get-ChildItem C:\Downloads -Recurse | Where-Object { ($_.Length -eq 0) -and (-not $_.PSIsContainer) }
```

**Trovare tutti i file eseguibili (.exe) che sono stati modificati quest'anno, ma NON questo mese:**
Questo esempio complesso dimostra la potenza della combinazione di operatori.
```powershell
Get-ChildItem "C:\Program Files" -Filter "*.exe" -Recurse | Where-Object {
    ($_.LastWriteTime.Year -eq (Get-Date).Year) -and ($_.LastWriteTime.Month -ne (Get-Date).Month)
}
```

*(Nota: le parentesi `()` attorno a ogni condizione sono usate per raggruppare e migliorare la leggibilità, specialmente in casi complessi).*

Fai attenzione alla ricorsione:
Molti file/cartelle — `-Recurse` può entrare ricorsivamente in decine di migliaia di elementi.
Collegamenti simbolici / collegamenti ciclici — possono causare ricorsioni infinite.
File senza permessi di accesso — possono bloccare l'esecuzione.

### 4. **Creazione, gestione ed eliminazione sicura**

#### **Creazione, copia e spostamento**

```powershell
New-Item -Path "C:\Temp\MyFolder" -ItemType Directory
Add-Content -Path "C:\Temp\MyFolder\MyFile.txt" -Value "Prima riga"
Copy-Item -Path "C:\Temp\MyFolder" -Destination "C:\Temp\MyFolder_Copy" -Recurse
```

#### **Eliminazione sicura**
`Remove-Item` è un cmdlet potenzialmente pericoloso, quindi PowerShell ha meccanismi di protezione integrati.
> **Chiave `-WhatIf` (Cosa succederebbe se?):** Il tuo migliore amico. **Non esegue** il comando, ma visualizza solo un messaggio nella console su **cosa succederebbe**.

```powershell
# CONTROLLO sicuro prima dell'eliminazione
Remove-Item C:\Temp\MyFolder -Recurse -Force -WhatIf
# Risultato: What if: Performing the operation "Remove Directory" on target "C:\Temp\MyFolder".

# Solo dopo essersi assicurati che tutto sia corretto, rimuovere -WhatIf ed ESEGUIRE il comando
Remove-Item C:\Temp\MyFolder -Recurse -Force
```
---

### **Introduzione alle funzioni**

Quando una singola riga di codice si trasforma in un complesso set di comandi che si desidera utilizzare più e più volte, è il momento di creare **funzioni**.

#### **Come usare e salvare le funzioni**

Esistono tre modi principali per rendere disponibili le tue funzioni:

**Metodo 1: Temporaneo (per i test)**
Puoi digitare nella console o semplicemente copiare e incollare l'intero codice della funzione nella console di PowerShell. La funzione sarà disponibile fino alla chiusura di questa finestra.

**Metodo 2: Permanente, ma manuale (tramite file `.ps1`)**
Questo è il modo più comune per organizzare e condividere gli strumenti. Salvi la funzione in un file `.ps1` e la carichi nella sessione quando ne hai bisogno.
> **Dot Sourcing (`. .
script.ps1`):** Questo comando speciale esegue lo script nel contesto *corrente*, rendendo tutte le sue funzioni e variabili disponibili nella tua console.

**Metodo 3: Automatico (tramite il profilo PowerShell)**
Questo è il modo più potente per i tuoi strumenti personali, usati frequentemente.
> **Cos'è il profilo PowerShell?** È uno script speciale `.ps1` che PowerShell esegue automaticamente ogni volta che si avvia. Tutto ciò che inserisci in questo file — alias, variabili e, naturalmente, funzioni — sarà disponibile in ogni tua sessione per impostazione predefinita.

##### **Esempio 1: Trovare file duplicati**

Vediamo tutti i passaggi con l'esempio della funzione `Find-DuplicateFiles`.

**Passo 1: Definiamo il codice della funzione**
```powershell
$functionCode = @'
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )

    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue |
        Group-Object Name, Length |
        Where-Object { $_.Count -gt 1 } |
        ForEach-Object {
            # QUESTA È LA RIGA CORRETTA:
            # All'interno dell'operatore $() le variabili non vengono escape.
            Write-Host "Duplicati trovati: $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
        }
}
'@
```

**Passo 2 (Opzione A): Salviamo in un file separato per il caricamento manuale**
```powershell
# Salviamo
Set-Content -Path ".\Find-DuplicateFiles.ps1" -Value $functionCode
# Carichiamo
. .\Find-DuplicateFiles.ps1
```
> **Dot Sourcing (. .\Find-DuplicateFiles.ps1):** Questo comando speciale esegue lo script nel contesto corrente, rendendo tutte le sue funzioni e variabili disponibili nella tua console.
```powershell
# Chiamiamo
Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Downloads"
```

**Passo 2 (Opzione B): Aggiungiamo al profilo per il caricamento automatico**
Rendiamo questa funzione sempre disponibile.
> **Cos'è il profilo PowerShell?** È uno script speciale .ps1 che PowerShell esegue automaticamente ogni volta che si avvia. Tutto ciò che inserisci in questo file — alias, variabili e, naturalmente, funzioni — sarà disponibile in ogni tua sessione per impostazione predefinita.
1.  **Troviamo il percorso del file di profilo.** PowerShell lo memorizza nella variabile `$PROFILE`.
    ```powershell
    $PROFILE
    ```
2.  **Creiamo il file di profilo, se non esiste.**
    ```powershell
    if (-not (Test-Path $PROFILE)) {
        New-Item -Path $PROFILE -Type File -Force
    }
    ```
3.  **Aggiungiamo il codice della nostra funzione alla fine del file di profilo.**
    ```powershell
    Add-Content -Path $PROFILE -Value $functionCode
    ```
4.  **Riavvia PowerShell** (o esegui `. $PROFILE`), e ora il tuo comando `Find-DuplicateFiles` sarà sempre disponibile, proprio come `Get-ChildItem`.

##### **Esempio 2: Creazione di un archivio ZIP con backup**

**Codice per il file `Backup-FolderToZip.ps1`:**
```powershell
function Backup-FolderToZip {
    param([string]$SourcePath, [string]$DestinationPath)
    if (-not (Test-Path $SourcePath)) { Write-Error "Cartella sorgente non trovata."; return }
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName
    if (-not (Test-Path $DestinationPath)) { New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null }
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force
    Write-Host "Backup completato: $fullArchivePath" -ForegroundColor Green
}
```

Un'analisi dettagliata delle funzioni sarà fatta nelle prossime parti.

---

### **Riferimento ai cmdlet per la gestione del file system**

#### **1. Cmdlet di base**
Questo elenco include i 12 cmdlet più essenziali, che coprono il 90% delle attività quotidiane.

| Cmdlet | Scopo principale | Esempio di utilizzo |
| :--- | :--- | :--- |
| `Get-ChildItem`| Ottenere un elenco di file e cartelle. | `Get-ChildItem C:\Windows` |
| `Set-Location` | Spostarsi in un'altra directory. | `Set-Location C:\Temp` |
| `Get-Location` | Mostrare la directory corrente. | `Get-Location` |
| `New-Item` | Creare un nuovo file o cartella. | `New-Item "report.docx" -Type File`|
| `Remove-Item` | Eliminare un file o una cartella. | `Remove-Item "old_log.txt"` |
| `Copy-Item` | Copiare un file o una cartella. | `Copy-Item "file.txt" -Dest "D:\"` |
| `Move-Item` | Spostare un file o una cartella. | `Move-Item "report.docx" -Dest "C:\Archive"` |
| `Rename-Item` | Ridenominare un file o una cartella. | `Rename-Item "old.txt" -NewName "new.txt"` |
| `Get-Content` | Leggere il contenuto di un file. | `Get-Content "config.ini"` |
| `Set-Content` | Scrivere/sovrascrivere il contenuto di un file. | `"data" | Set-Content "file.txt"`|
| `Add-Content` | Aggiungere contenuto alla fine di un file. | `Get-Date | Add-Content "log.txt"` |
| `Test-Path` | Verificare se un file o una cartella esiste. | `Test-Path "C:\Temp"` |

Hai bisogno di **leggere il contenuto** di un file di testo? Usa `Get-Content`.
Hai bisogno di **sovrascrivere completamente un file** con un nuovo contenuto? Usa `Set-Content`.
Hai bisogno di **aggiungere una riga a un file di log**, senza cancellare i dati precedenti? Usa `Add-Content`.
Hai bisogno di **verificare se un file esiste** prima di scriverci? Usa `Test-Path`.

#### **2. Cmdlet specializzati per attività avanzate**
Quando i cmdlet di base non sono sufficienti, PowerShell offre strumenti più specializzati. Non duplicano quelli di base, ma estendono le tue capacità.

*   **Lavorare con i percorsi (Path)**
    *   **`Join-Path`**: Unisce in modo sicuro le parti di un percorso, inserendo automaticamente `\`.
    *   **`Split-Path`**: Divide un percorso in parti (cartella, nome file, estensione).
    *   **`Resolve-Path`**: Converte un percorso relativo (ad esempio, `.` o `..iles`) in un percorso completo e assoluto.

*   **Lavorare con proprietà e contenuto (Item Properties and Content)**
    *   **`Get-ItemProperty`**: Ottiene le proprietà di un file specifico (ad esempio, `IsReadOnly`, `CreationTime`).
    *   **`Set-ItemProperty`**: Modifica le proprietà di un file o di una cartella.
    *   **`Clear-Content`**: Elimina tutto il contenuto da un file, ma lascia il file stesso vuoto.

*   **Navigazione avanzata (Location Stack)**
    *   **`Push-Location`**: "Memorizza" la directory corrente e si sposta in una nuova.
    *   **`Pop-Location`**: Torna alla directory che `Push-Location` aveva "memorizzato".

*   **Gestione dei permessi di accesso (ACL)**
    *   **`Get-Acl`**: Ottiene l'elenco dei permessi di accesso (ACL) per un file o una cartella.
    *   **`Set-Acl`**: Imposta i permessi di accesso per un file o una cartella (operazione complessa).

Hai bisogno di **modificare un attributo di un file**, ad esempio, renderlo "sola lettura"? Usa `Set-ItemProperty`.
Hai bisogno di **svuotare completamente un file di log**, senza eliminarlo? Usa `Clear-Content`.
Hai bisogno di **spostarti temporaneamente in un'altra cartella** in uno script, e poi tornare indietro in modo garantito? Usa `Push-Location` e `Pop-Location`.
Hai bisogno di **sapere chi ha i permessi** di accesso a una cartella? Usa `Get-Acl`.

Nella prossima parte impareremo come lavorare con altri archivi dati, come il registro di Windows,
utilizzando gli stessi approcci, approfondiremo il concetto di funzioni, esamineremo gli operatori logici e impareremo a interagire in modo interattivo con la shell.

Filosofia di PowerShell su GitHub:
[Storia e primo cmdlet](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md)

Parte 2: [Pipeline, variabili, Get-Member, file .ps1 ed esportazione dei risultati.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/02.md)
Esempi per la seconda parte:
[system_monitor.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/02/system_monitor.ps1)

Parte 3: [Navigazione e gestione del file system.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/03.md)

Esempi per la terza parte:
[Find-DuplicateFiles.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/03/Find-DuplicateFiles.ps1)
[Backup-FolderToZip]()