# Filosofia di PowerShell.

## Parte 4: Lavoro interattivo: `Out-ConsoleGridView`, avvisi.

- Nella [prima parte](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md) abbiamo definito due concetti chiave di PowerShell: la pipeline e l'oggetto.

- Nella [seconda parte](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md) ho spiegato cosa sono gli oggetti e la pipeline.

- Nella [terza](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md) parte abbiamo familiarizzato con il file system e i provider.

- Oggi esamineremo il lavoro interattivo con i dati nella console, e conosceremo anche gli avvisi e le notifiche.

### Capitolo primo: Lavoro interattivo con i dati nella console.

#### `Out-ConsoleGridView`. GUI nella console di PowerShell.

**‚ùó Importante:** Tutti gli strumenti descritti di seguito richiedono **PowerShell 7.2 o versioni successive**.

Out-ConsoleGridView √® una tabella interattiva, direttamente nella console di PowerShell, che consente di:
- visualizzare i dati in formato tabellare;
- filtrare e ordinare le colonne;
- selezionare le righe con il cursore ‚Äî per passarle ulteriormente nella pipeline.
- e molto altro.

`Out-ConsoleGridView` fa parte del modulo `Microsoft.PowerShell.ConsoleGuiTools`.
Per utilizzarlo, √® necessario prima installare questo modulo.

Per installare il modulo, esegui il seguente comando in PowerShell:
```powershell
Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
```
![Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser](assets/04/1.png)

*Install-Module* scarica e installa il modulo specificato dal repository nel sistema.
Analoghi: `pip install` in `Python` o `npm install` in `Node.js`.

üìé Parametri chiave di *Install-Module*

------------------------------------------------------------------------------------------------------------------------------------------------------
| Parametro          | Descrizione                                                                                                                   |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------- |
| `-Name`            | Nome del modulo da installare.                                                                                                |
| `-Scope`           | Ambito di installazione: `AllUsers` (predefinito, richiede diritti di amministratore) o `CurrentUser` (non richiede diritti di amministratore). |
| `-Repository`      | Specifica il repository, ad esempio `PSGallery`.                                                                              |
| `-Force`           | Installazione forzata senza conferma.                                                                                         |
| `-AllowClobber`    | Consente di sovrascrivere comandi gi√† esistenti.                                                                              |
| `-AcceptLicense`   | Accetta automaticamente la licenza del modulo.                                                                                |
| `-RequiredVersion` | Installa una versione specifica del modulo.                                                                                   |

Dopo l'installazione, puoi passare qualsiasi output a `Out-ConsoleGridView` per un lavoro interattivo.

```powershell
# Esempio classico: visualizzazione dell'elenco dei processi in una tabella interattiva
Get-Process | Out-ConsoleGridView
```

(https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>

**Interfaccia:**
*   **Filtro:** Inizia semplicemente a digitare il testo e l'elenco verr√† filtrato al volo.
*   **Navigazione:** Usa i tasti freccia per spostarti nell'elenco.
*   **Selezione:** Premi `Spazio` per selezionare/deselezionare un elemento.
*   **Selezione multipla:** `Ctrl+A` per selezionare tutti gli elementi, `Ctrl+D` per deselezionare tutto.
*   **Conferma:** Premi `Invio` per restituire gli oggetti selezionati.
*   **Annulla:** Premi `ESC` per chiudere la finestra senza restituire dati.

## Cosa pu√≤ fare `Out-ConsoleGridView`:

* Visualizzare dati tabellari direttamente nella console come una tabella interattiva con navigazione per righe e colonne.
* Ordinare le colonne premendo i tasti.
* Filtrare i dati tramite la ricerca.
* Selezionare una o pi√π righe con restituzione del risultato.
* Funzionare in una console pulita senza finestre GUI.
* Supportare un gran numero di righe con scorrimento.
* Supportare vari tipi di dati (stringhe, numeri, date, ecc.).

---

## Esempi di utilizzo di `Out-ConsoleGridView`

### Uso base ‚Äî mostra una tabella con possibilit√† di selezione interattiva. (checkbox)

```powershell
Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Visualizza la tabella con possibilit√† di filtro, ordinamento e selezione delle righe
$selected = $data | Out-ConsoleGridView -Title "Seleziona processo/i" -OutputMode Multiple

$selected | Format-Table -AutoSize
```

(https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356)

<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>

Viene visualizzato un elenco di processi in una tabella interattiva della console.
√à possibile filtrare per nome, ordinare le colonne e selezionare i processi.
I processi selezionati vengono restituiti nella variabile `$selected`.

---

### Selezione di una singola riga con restituzione obbligatoria del risultato. (radio)

```powershell
$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Seleziona un servizio" -OutputMode Single

Write-Host "Hai selezionato il servizio: $($choice.Name)"
```

[](https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e)

<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>

L'utente seleziona una riga (servizio). `-OutputMode Single` impedisce la selezione multipla.

---

### Filtro e ordinamento di grandi array

```powershell
$data = 1..1000 | ForEach-Object {
    [PSCustomObject]@{
        Number = $_
        Square = $_ * $_
        Cube    = $_ * $_ * $_
    }
}

$data | Out-ConsoleGridView -Title "Numeri e potenze"  -OutputMode Multiple
```

Mostra una tabella di 1000 righe con numeri e le loro potenze.

### **Gestione interattiva dei processi:**

Puoi selezionare pi√π processi da arrestare. Il parametro `-OutputMode Multiple` indica che vogliamo restituire tutti gli elementi selezionati.

```powershell
# Passiamo i risultati attraverso la pipeline.
# Arrestiamo i processi selezionati con il parametro -WhatIf per un'anteprima.
# A tale scopo, definiamo la variabile $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple

# Se qualcosa √® stato selezionato, passiamo gli oggetti ulteriormente nella pipeline
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
```

### **Selezione di file per l'archiviazione:**

Troviamo tutti i file `.log` in una cartella, selezioniamo quelli necessari e creiamo un archivio da essi.

```powershell
$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
```

    ‚ùóFai attenzione con la ricorsione

```powershell
if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip

    # Aggiungiamo un messaggio di successo
    Write-Host "‚úÖ Archiviazione completata con successo!" -ForegroundColor Green
}
```

### **Selezione di un singolo elemento per un'analisi dettagliata:**

#### Pattern "Drill-Down" ‚Äî da un elenco generale ai dettagli con `Out-ConsoleGridView`

Spesso, quando si lavora con oggetti di sistema, ci troviamo di fronte a un dilemma:
1.  Se si richiedono **tutte le propriet√†** per **tutti gli oggetti** (`Get-NetAdapter | Format-List *`), l'output sar√† enorme e illeggibile.
2.  Se si mostra una **tabella concisa**, perderemo dettagli importanti.
3.  A volte, il tentativo di ottenere tutti i dati contemporaneamente pu√≤ portare a un errore se uno degli oggetti contiene valori non validi.

La soluzione a questo problema √® il pattern **"Drill-Down"** (dettaglio o "approfondimento"). La sua essenza √® semplice:

*   **Passo 1 (Panoramica):** Mostrare all'utente un elenco pulito, conciso e sicuro di elementi per la **selezione**.
*   **Passo 2 (Dettaglio):** Dopo che l'utente ha selezionato un elemento specifico, mostrargli **tutte le informazioni disponibili** proprio per quell'elemento.

#### Esempio pratico: Creazione di un visualizzatore di schede di rete

Implementiamo questo pattern utilizzando il comando `Get-NetAdapter`.

**Compito:** Mostrare prima un breve elenco di schede di rete. Dopo averne selezionata una, aprire una seconda finestra con tutte le sue propriet√†.

**Codice pronto:**
```powershell
# --- Fase 1: Selezione dell'adattatore da un elenco breve ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "FASE 1: Seleziona una scheda di rete"

# --- Fase 2: Visualizzazione delle informazioni dettagliate o del messaggio di annullamento ---
if ($null -ne $selectedAdapter) {
    # Otteniamo TUTTE le propriet√† per l'adattatore SELEZIONATO
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Usiamo il nostro trucco con .psobject.Properties, ◊õ◊ì◊ô ◊ú◊î◊§◊ï◊ö ◊ê◊™ ◊î◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊ú◊ò◊ë◊ú◊™ "◊©◊ù-◊¢◊®◊ö" ◊†◊ï◊ó◊î
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value

    # Apriamo una SECONDA finestra GridView con le informazioni complete
    $detailedInfoForGrid | Out-ConsoleGridView -Title "FASE 2: Informazioni complete su '$($selectedAdapter.Name)'"
} else {
    Write-Host "Operazione annullata. Nessun adattatore √® stato selezionato." -ForegroundColor Yellow
}
```

#### Analisi passo-passo

1.  **Creazione di un elenco "sicuro":**
    `$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed`
    Non passiamo l'output di `Get-NetAdapter` direttamente. Invece, creiamo nuovi oggetti "puliti" usando `Select-Object`, includendo solo le propriet√† di cui abbiamo bisogno per la panoramica. Questo garantisce che i dati problematici che hanno causato un errore vengano scartati.

2.  **Prima finestra interattiva:**
    `$selectedAdapter = $adapterList | Out-ConsoleGridView ...`
    Lo script mostra la prima finestra e **interrompe la sua esecuzione**, in attesa della tua selezione. Non appena selezioni una riga e premi `Invio`, l'oggetto corrispondente a quella riga verr√† scritto nella variabile `$selectedAdapter`.

3.  **Verifica della selezione:**
    `if ($null -ne $selectedAdapter)`
    Questa √® una verifica di importanza critica. Se l'utente preme `Esc` o chiude la finestra, la variabile `$selectedAdapter` sar√† vuota (`$null`). Questa verifica impedisce l'esecuzione del resto del codice e l'insorgere di errori.

4.  **Ottenimento delle informazioni complete:**
    `$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name`
    Questo √® il punto chiave del pattern. Ci rivolgiamo di nuovo a `Get-NetAdapter`, ma questa volta richiediamo **un solo** oggetto per il suo nome, che abbiamo preso dall'elemento selezionato nella prima fase. Ora otteniamo l'oggetto completo con all le sue propriet√†.

5.  **Trasformazione per la seconda finestra:**
    `$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...`
    Usiamo il trucco potente che gi√† conosci per "espandere" questo singolo oggetto complesso in un lungo elenco di coppie "Nome propriet√†" | "Valore", che √® ideale per la visualizzazione in una tabella.

6.  **Seconda finestra interattiva:**
    `$detailedInfoForGrid | Out-ConsoleGridView ...`
    Appare una seconda finestra sullo schermo, questa volta con informazioni complete sull'adattatore che hai selezionato.

---

### Esempio con titolo e suggerimenti personalizzati

Visualizzazione del registro eventi di Windows in una tabella interattiva con il titolo "System Events".

```powershell
Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "Eventi di sistema"  -OutputMode Multiple
```
Questo codice ottiene gli ultimi 50 eventi dal registro di sistema di Windows, seleziona per ogni evento solo quattro propriet√† chiave (ora, tipo, origine e messaggio) e li visualizza nella finestra Out-ConsoleGridView.

----

### Informazioni sul sistema.

(https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>

codice dello script per ottenere informazioni sul sistema:
[Get-SystemMonitor.ps1](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1)

### Creazione del cmdlet 'Get-SystemMonitor'

#### Passo 1: Configurazione della variabile `PATH`

1.  **Crea una cartella permanente per i tuoi strumenti,** se non l'hai ancora fatto. Ad esempio:
    `C:\PowerShell\Scripts`

2.  **Posiziona il tuo file** `Get-SystemMonitor.ps1` in questa cartella.

3.  **Aggiungi questa cartella alla variabile di sistema `PATH`**,

#### Passo 2: Configurazione dell'alias nel profilo di PowerShell

Ora che il sistema sa dove trovare il tuo script con il suo nome completo, possiamo creare un alias breve per esso.

1.  **Apri il tuo file di profilo di PowerShell**:
    ```powershell
    notepad $PROFILE
    ```

2.  **Aggiungi la seguente riga:**
    ```powershell
    # Alias per il monitor di sistema
    Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
    ```

    **Nota il punto chiave:** Poich√© la cartella con lo script √® gi√† in `PATH`, **non √® pi√π necessario specificare il percorso completo** del file! Ci riferiamo semplicemente al suo nome. Questo rende il tuo profilo pi√π pulito e affidabile. Se mai dovessi spostare la cartella `C:\PowerShell\Scripts`, dovrai aggiornare solo la variabile `PATH`, e il tuo file di profilo rimarr√† invariato.

#### Riavvia PowerShell

Chiudi **tutte** le finestre di PowerShell aperte e aprine una nuova. Questo √® necessario affinch√© il sistema applichi le modifiche sia nella variabile `PATH` che nel tuo profilo.

---

### Risultato: Cosa ottieni

Dopo aver eseguito questi passaggi, sarai in grado di richiamare il tuo script **in due modi da qualsiasi punto del sistema**:

1.  **Per nome completo (affidabile, per l'uso in altri script):**
    ```powershell
    Get-SystemMonitor.ps1
    Get-SystemMonitor.ps1 -Resource storage
    ```

2.  **Per alias breve (comodo, per il lavoro interattivo):**
    ```powershell
    sysmon
    sysmon -Resource memory
    ```

Hai "registrato" con successo il tuo script nel sistema nel modo pi√π professionale e flessibile.

Utile? Iscriviti.
Ti √® piaciuto ‚Äî metti un "+"
Buona fortuna! üöÄ

Altri articoli su PowerShell: