# Filosofia di PowerShell.
## Parte 2: Pipeline, variabili, Get-Member, file *.ps1* ed esportazione dei risultati
**❗ Importante:**
Sto scrivendo di PS7 (PowerShell 7). È diverso da PS5 (PowerShell 5). A partire dalla settima versione, PowerShell è diventato multipiattaforma. Per questo motivo, il comportamento di alcuni comandi è cambiato.

Nella prima parte abbiamo stabilito un principio chiave: PowerShell lavora con gli **oggetti**, non con il testo.
Questo post è dedicato ad alcuni importanti strumenti di PowerShell: impareremo a passare gli oggetti tramite la **pipeline**, ad analizzarli con **`Get-Member`**, a salvare i risultati nelle **variabili** e ad automatizzare tutto questo nei **file di script (`.ps1`)** con l'**esportazione** dei risultati in formati convenienti.

### 1. Cos'è la pipeline (`|`)?
La pipeline in PowerShell è un meccanismo per passare oggetti .NET completi (e non solo testo) da un comando all'altro, dove ogni cmdlet successivo riceve oggetti strutturati con all le loro proprietà e metodi.

Il simbolo `|` (barra verticale) è l'operatore di pipeline. Il suo compito è prendere il risultato (output) del comando alla sua sinistra e passarlo come input al comando alla sua destra.

`Comando 1 (crea oggetti)` → `|` → `Comando 2 (riceve ed elabora oggetti)` → `|` → `Comando 3 (riceve oggetti elaborati)` → | ...

#### Pipeline UNIX classica: Flusso di testo

In `bash`, la pipeline passa un **flusso di byte**, che di solito viene interpretato come testo.

```bash
# Trova tutti i processi 'nginx' e conta il loro numero
ps -ef | grep 'nginx' | wc -l
```
Qui `ps` produce testo, `grep` filtra questo testo e `wc` conta le righe. Ogni utility non sa nulla dei "processi", lavora solo con le stringhe.

#### Pipeline PowerShell: Flusso di oggetti
**Esempio:** Otteniamo tutti i processi, li ordiniamo per utilizzo della CPU e selezioniamo i 5 più "golosi".

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
!(assets/02/1.png)

Qui `Get-Process` crea **oggetti** processo. `Sort-Object` riceve questi **oggetti** e li ordina in base alla proprietà `CPU`. `Select-Object` riceve gli **oggetti** ordinati e seleziona i primi 5.

Avrete sicuramente notato nella riga di comando parole che iniziano con un trattino (-): -Property, -Descending, -First. Questi sono parametri.
I parametri sono impostazioni, interruttori e istruzioni per un cmdlet. Permettono di controllare **COME** il comando eseguirà il suo lavoro.
Senza parametri, il comando funziona in modalità predefinita, mentre con i parametri gli si danno istruzioni specifiche.

Tipi principali di parametri:

- Parametro con valore: richiede informazioni aggiuntive.

    `-Property CPU`: Diciamo a Sort-Object su quale proprietà ordinare. CPU è il valore del parametro.

    `-First 5`: Diciamo a Select-Object quanti oggetti selezionare. 5 è il valore del parametro.

- Parametro interruttore (flag): Non richiede un valore. La sua sola presenza nel comando abilita o disabilita un certo comportamento.

   `-Descending`: Questo flag dice a Sort-Object di cambiare l'ordine di ordinamento in inverso (dal più grande al più piccolo). Non ha bisogno di un valore aggiuntivo - è di per sé un'istruzione.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
!(assets/02/2.png)
Questo comando risponde a una domanda molto semplice:
**"Quanti processi con il nome `svchost.exe` sono attualmente in esecuzione nel mio sistema?"**

#### Analisi passo dopo passo

##### **Passo 1: `Get-Process -Name 'svchost'`**

Questa parte del comando si rivolge al sistema operativo e chiede di trovare **tutti senza eccezione** i processi in esecuzione il cui nome del file eseguibile è `svchost.exe`.
A differenza dei processi come `notepad` (di solito uno o due), i processi `svchost` sono sempre **molti** nel sistema. Il comando restituirà un **array (collezione) di oggetti**,
dove ogni oggetto è un processo `svchost` separato e completo con il suo ID unico, l'utilizzo della memoria, ecc.
PowerShell ha trovato nel sistema, ad esempio, 90 processi `svchost` e ora ha in mano una collezione di 90 oggetti.

##### **Passo 2: `|` (Operatore di pipeline)**

Questo simbolo prende la collezione di 90 oggetti `svchost`, ottenuta nel primo passo, e inizia a passarli **uno per uno** come input al comando successivo.

##### **Passo 3: `Measure-Object`**

Poiché abbiamo chiamato `Measure-Object` senza parametri (come `-Property`, `-Sum`, ecc.), esso esegue la sua operazione **predefinita** - semplicemente conta il numero di "elementi" che gli sono stati passati.
Uno, due, tre... Dopo che tutti gli oggetti sono stati contati, `Measure-Object` crea il **suo proprio oggetto risultato**, che ha una proprietà `Count` uguale al numero totale.

**`Count: 90`** - questa è la risposta alla nostra domanda. Sono in esecuzione 90 processi `svchost`.
Gli altri campi sono vuoti, perché non abbiamo chiesto a `Measure-Object` di eseguire calcoli più complessi.

#### Esempio con `svchost` e parametri

Cambiamo il nostro compito. Ora non vogliamo solo contare i processi `svchost`,
ma scoprire **quanta memoria RAM (in megabyte) consumano insieme**.

Per questo avremo bisogno di parametri:
*   `-Property WorkingSet64`: Questa istruzione dice a `Measure-Object`: "Da ogni oggetto `svchost` che ti arriva, prendi il valore numerico dalla proprietà `WorkingSet64` (questo è l'utilizzo della memoria in byte)".
*   `-Sum`: Questa istruzione-flag dice: "Somma tutti questi valori che hai preso dalla proprietà `WorkingSet64`".

Il nostro nuovo comando sarà così:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
!(assets/02/3.png)

1.  `Get-Process` troverà il numero di oggetti `svchost`.
2.  La pipeline `|` li passerà a `Measure-Object`.
3.  Ma ora `Measure-Object` funziona in un modo nuovo:
    *   Prende il primo oggetto `svchost`, guarda la sua proprietà `.WorkingSet64` (ad esempio, `25000000` byte) e memorizza questo numero.
    *   Prende il secondo oggetto, guarda il suo `.WorkingSet64` (ad esempio, `15000000` byte) e lo aggiunge al precedente.
    *   ...e così via per tutti gli oggetti.
4.  Alla fine, `Measure-Object` creerà un oggetto risultato, ma ora sarà diverso.

*   **`Count: 92`**: Numero di oggetti.
*   **`Sum: 1661890560`**: Questa è la somma totale di tutti i valori `WorkingSet64` in byte.
*   **`Property: WorkingSet64`**: Questo campo è ora anch'esso compilato, ci informa quale proprietà è stata utilizzata per i calcoli.

### 2. Variabili (Normali e speciale `$_`)

Una variabile è un'area di memoria nominata che contiene un valore.

Questo valore può essere qualsiasi cosa: testo, numero, data o, cosa più importante per PowerShell,
un intero oggetto o persino una collezione di oggetti. Il nome di una variabile in PowerShell inizia sempre con il segno del dollaro ($).
Esempi: $name, $counter, $processList.

Variabile speciale $_?

$_ è l'abbreviazione di "oggetto corrente" o "questa cosa qui".
Immaginate una catena di montaggio in una fabbrica. Su di essa viaggiano diversi pezzi (oggetti).

$_ è quel pezzo che si trova proprio ora davanti a voi (o davanti al robot di elaborazione).

Sorgente (Get-Process) - riversa sulla catena di montaggio un'intera scatola di pezzi (tutti i processi).

Pipeline (|) - fa muovere questi pezzi lungo il nastro uno per uno.

Elaboratore (Where-Object o ForEach-Object) - è un robot che guarda ogni pezzo.

La variabile $_ - è quel pezzo che si trova attualmente nelle "mani" del robot.

Quando il robot avrà finito con un pezzo, la catena di montaggio gli fornirà il successivo, e $_ ora punterà a quello.

Contiamo quanta memoria totale utilizzano i processi `svchost` e visualizziamo il risultato sul monitor.
```powershell
# 1. Eseguiamo il comando e salviamo il suo complesso oggetto risultato nella variabile $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Ora possiamo lavorare con l'oggetto salvato. Estraiamo la sua proprietà Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Visualizziamo il risultato sullo schermo, usando la nuova variabile
Write-Host "Tutti i processi svchost utilizzano $memoryInMB MB di memoria."
```
!(assets/02/4.png)

*   `Write-Host` - è un cmdlet specializzato il cui unico compito è **mostrare il testo direttamente all'utente nella console**.

*   Stringa tra virgolette doppie: `"..."` - una stringa di testo che passiamo al cmdlet `Write-Host` come argomento. Perché virgolette doppie e non singole?

    In PowerShell ci sono due tipi di virgolette:

    *   **Singole (`'...'`):** Creano una **stringa letterale**. Tutto ciò che è al loro interno viene interpretato come testo normale, senza eccezioni.
    *   **Doppie (`"..."`):** Creano una **stringa espandibile (o di sostituzione)**. PowerShell "scansiona" tale stringa alla ricerca di variabili (che iniziano con `$`) e sostituisce i loro valori al loro posto.

* `$memoryInMB`. Questa è la variabile in cui abbiamo **nel passaggio precedente** del nostro script inserito il risultato dei calcoli. Quando `Write-Host` riceve una stringa tra virgolette doppie,
si verifica un processo chiamato **"espansione delle variabili" (String Expansion)**:
    1.  PowerShell vede il testo `"Tutti i processi svchost utilizzano "`.
    2.  Poi incontra la costruzione `$memoryInMB`. Capisce che non è solo testo, ma una variabile.
    3.  Cerca nella memoria, trova il valore memorizzato in `$memoryInMB` (ad esempio, `1585.52`).
    4.  **Sostituisce questo valore** direttamente nella stringa.
    5.  Poi aggiunge la parte rimanente del testo: `" MB di memoria."`.
    6.  Di conseguenza, a `Write-Host` viene passata una stringa già pronta e assemblata: `"Tutti i processi svchost utilizzano 1585.52 MB di memoria."`.

Avviare il Blocco Note:
 1. Troviamo il processo del Blocco Note e lo salviamo nella variabile $notepadProcess
 ```powershell
$notepadProcess = Get-Process -Name notepad
```

 2. Accediamo alla proprietà 'Id' di questo oggetto tramite il punto e la visualizziamo
 ```powershell
Write-Host "L'ID del processo 'Blocco Note' è: $($notepadProcess.Id)"
```
!(assets/02/5.png)

**❗ Importante:**
    Write-Host "rompe" la pipeline. Il testo da esso prodotto non può essere passato ulteriormente nella pipeline per l'elaborazione. È destinato solo alla visualizzazione.

### 3. Get-Member (Ispezionatore di oggetti)

Sappiamo che gli oggetti "fluono" attraverso la pipeline. Ma come si fa a sapere di cosa sono fatti? Quali proprietà hanno e quali azioni (metodi) si possono eseguire su di essi?

Il cmdlet **`Get-Member`** (alias: `gm`) è lo strumento principale per l'esplorazione.
Prima di lavorare con un oggetto, passatelo attraverso `Get-Member` per vederne tutte le capacità.

Analizziamo gli oggetti creati da `Get-Process`:
```powershell
Get-Process | Get-Member
```
!(assets/02/6.png)

*Analizziamo ogni parte dell'output di Get-Member.*

`TypeName: System.Diagnostics.Process` - Questo è il "nome del tipo" completo e ufficiale dell'oggetto dalla libreria .NET. È il suo "passaporto".
Questa riga ti dice che tutti gli oggetti restituiti da Get-Process sono oggetti di tipo System.Diagnostics.Process.
Questo garantisce che tutti avranno lo stesso set di proprietà e metodi.
Puoi [cercare su Google](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process" per trovare la documentazione ufficiale Microsoft con informazioni ancora più dettagliate.

- Colonna 1: `Name`

Questo è il **nome** semplice e leggibile dall'uomo di una proprietà, un metodo o un altro "membro" dell'oggetto. È esattamente questo nome che userete nel vostro codice per accedere ai dati o eseguire azioni.

- Colonna 2: `MemberType` (Tipo di membro)

Questa è la colonna più importante per la comprensione. Classifica **cosa** è ogni oggetto. È il suo "ruolo", che ti dice **COME** usarlo.

*   **`Property` (Proprietà):** **Caratteristica** o **parte di dati** memorizzata all'interno dell'oggetto. Puoi "leggere" il suo valore.
    *   *Esempi nello screenshot:* `BasePriority`, `HandleCount`, `ExitCode`. Questi sono semplicemente dati che si possono visualizzare.

*   **`Method` (Metodo):** **AZIONE** che può essere eseguita con l'oggetto. I metodi vengono sempre chiamati con parentesi tonde `()`.
    *   *Esempi nello screenshot:* `Kill`, `Refresh`, `WaitForExit`. Scriveresti `$process.Kill()` o `$process.Refresh()`.

*   **`AliasProperty` (Proprietà alias):** **alias amichevole** per un'altra proprietà più lunga. PowerShell li aggiunge per comodità e brevità.
    *   *Esempi nello screenshot:* `WS` — è un alias breve per `WorkingSet64`. `Name` — per `ProcessName`. `VM` — per `VirtualMemorySize64`.

*   **`Event` (Evento):** **NOTIFICA** che qualcosa è accaduto, a cui ci si può "iscrivere".
    *   *Esempio nello screenshot:* `Exited`. Il tuo script può "ascoltare" questo evento per eseguire un'azione non appena il processo termina.

*   **`CodeProperty` e `NoteProperty`:** Tipi di proprietà speciali, spesso aggiunti da PowerShell stesso per comodità. `CodeProperty` calcola il suo valore "al volo", mentre `NoteProperty` — è una semplice proprietà nota aggiunta a un oggetto.

- Colonna 3: `Definition` (Definizione)

Questa è la **definizione tecnica** o "firma" del membro. Ti fornisce i dettagli esatti per il suo utilizzo. Il suo contenuto dipende dal `MemberType`:

*   **Per `AliasProperty`:** Indica **a cosa è uguale l'alias**. Questo è incredibilmente utile!
    *   *Esempio nello screenshot:* `WS = WorkingSet64`. Vedete subito che `WS` — è semplicemente una forma abbreviata di `WorkingSet64`.

*   **Per `Property`:** Mostra il **tipo di dati** memorizzato nella proprietà (ad esempio `int` per un numero intero, `string` per testo, `datetime` per data e ora), e cosa si può fare con esso (`{get;}` – solo lettura, `{get;set;}` – lettura e modifica).
    *   *Esempio nello screenshot:* `int BasePriority {get;}`. Questa è una proprietà intera che può essere solo letta.

*   **Per `Method`:** Indica cosa restituisce il metodo (ad esempio `void` – niente, `bool` – true/false) e quali **parametri** (dati di input) accetta tra parentesi.
    *   *Esempio nello screenshot:* `void Kill()`. Questo significa che il metodo `Kill` non restituisce nulla e può essere chiamato senza parametri. Esiste anche una seconda versione `void Kill(bool entireProcessTree)`, che accetta un valore booleano (true/false).

#### In forma tabellare

| Colonna      | Cos'è?                                   | Esempio dallo screenshot        | A cosa serve?                                                                   |
|--------------|------------------------------------------|------------------------------------|--------------------------------------------------------------------------|
| **Nome**    | Il nome che usi nel codice.              | `Kill`, `WS`, `Name`               | per accedere a una proprietà o un metodo (`$process.WS`, `$process.Kill()`). |
| **MemberType**| Il tipo di membro (dati, azione, ecc.). | `Method`, `Property`, `AliasProperty` | **come** usarlo (leggere un valore o chiamare con `()`).              |
| **Definizione**| Dettagli tecnici.                        | `WS = WorkingSet64`, `void Kill()` | cosa si nasconde dietro l'alias e quali parametri richiede il metodo. |

#### Esempio: Lavorare con le finestre dei processi

##### 1. Problema:
"Ho molte finestre di Editor aperte. Come posso minimizzare programmaticamente tutte tranne la finestra principale e poi chiudere solo quella il cui titolo contiene la parola 'Untitled'?"

##### 2. Indagine con `Get-Member`:
Dobbiamo trovare proprietà che siano correlate alla finestra e al suo titolo.

```powershell
Get-Process -Name notepad | Get-Member
```
**Analisi del risultato di `Get-Member`:**
*   Scorrendo le proprietà, troviamo `MainWindowTitle`. Tipo `string`. Ottimo, questo è il titolo della finestra principale!
*   Nei metodi vediamo `CloseMainWindow()`. Questo è un metodo più "delicato" per chiudere una finestra rispetto a `Kill()`.
*   Anche nei metodi c'è `WaitForInputIdle()`. Sembra interessante, forse aiuta ad aspettare che il processo sia pronto per l'interazione.

!(assets/02/7.png)

`Get-Member` ci ha mostrato la proprietà `MainWindowTitle`, che è la chiave per risolvere il compito e permette di interagire con i processi in base allo stato delle loro finestre, e non solo per nome.

##### 3. Soluzione:
Ora possiamo costruire una logica basata sul titolo della finestra.

```powershell
# 1. Trova tutti i processi di Blocco Note
$notepads = Get-Process -Name notepad

# 2. Scorri ognuno di essi e controlla il titolo
foreach ($pad in $notepads) {
    # Per ogni processo ($pad) controlla la sua proprietà MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Trovato Blocco Note non salvato (ID: $($pad.Id)). Chiudo la sua finestra..."
        # $pad.CloseMainWindow() # Decommentare per chiudere effettivamente
        Write-Host "La finestra '$($pad.MainWindowTitle)' sarebbe stata chiusa." -ForegroundColor Yellow
    } else {
        Write-Host "Salto Blocco Note con titolo: $($pad.MainWindowTitle)"
    }
}
```

!(assets/02/8.png)

!(assets/02/9.png)

---

#### Esempio: Trovare il processo padre

##### 1. Problema:
"A volte vedo molti processi `chrome.exe` figli nel sistema. Come faccio a scoprire quale di essi è il processo principale, "padre", che li ha avviati tutti?"

##### 2. Indagine con `Get-Member`:
Dobbiamo trovare qualcosa che colleghi un processo a un altro.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
!(assets/02/10.png)

**Analisi del risultato di `Get-Member`:**
*   Scorrendo attentamente l'elenco, troviamo una proprietà di tipo `CodeProperty` con il nome `Parent`.
*   La sua definizione (`Definition`) — `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
Questa è una proprietà calcolata che, quando viene acceduta, restituisce un **oggetto del processo padre**.

##### 3. Soluzione:
Ora possiamo scrivere uno script che, per ogni processo `chrome`, visualizza informazioni sul suo processo padre.

```powershell
# 1. Recupera tutti i processi Chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Per ognuno di essi, visualizza informazioni su se stesso e sul suo processo padre
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Recupera il processo padre
    $parent = $_.Parent
    
    # Formatta l'output in modo gradevole
    Write-Host "Processo:" -ForegroundColor Green
    Write-Host "  - Nome: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Il suo processo padre:" -ForegroundColor Yellow
    Write-Host "  - Nome: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
```

!(assets/02/11.png)

!(assets/02/12.png)

Vediamo subito che i processi con ID 4756, 7936, 8268 e 9752 sono stati avviati dal processo con ID 14908. Si può anche notare un caso interessante con il processo ID: 7252, il cui processo padre non è stato possibile determinare (probabilmente il processo padre si era già terminato al momento del controllo). Una modifica dello script con il controllo `if ($parent)` gestisce elegantemente questo caso, senza causare un errore.
`Get-Member` ci ha aiutato a scoprire la proprietà "nascosta" `Parent`, che offre potenti possibilità per analizzare la gerarchia dei processi.

#### 4. File *.ps1* (Creazione di script)

Quando la vostra catena di comandi diventa utile, vorrete salvarla per un uso ripetuto. A questo servono gli **script** – file di testo con estensione **`.ps1`**.

##### Autorizzazione all'esecuzione di script
Per impostazione predefinita, l'esecuzione di script locali è vietata su Windows. Per risolvere questo problema **per l'utente corrente**, eseguire una volta in PowerShell **come amministratore**:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
Questa è un'impostazione sicura che consente di eseguire i propri script e gli script firmati da un editore attendibile.

##### Esempio di script `system_monitor.ps1`
Crea un file con questo nome e incolla il seguente codice. Questo script raccoglie informazioni di sistema e genera report.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Script per la creazione di un report sullo stato del sistema.
.DESCRIPTION
    Raccoglie informazioni su processi, servizi e spazio su disco e genera report.
.PARAMETER OutputPath
    Percorso per salvare i report. Il valore predefinito è 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Blocco 1: Preparazione ---
Write-Host "Preparazione per la creazione del report..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Blocco 2: Raccolta dati ---
Write-Host "Raccolta informazioni..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Blocco 3: Chiamata alla funzione per l'esportazione (vedi sezione successiva) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Report salvati con successo nella cartella $OutputPath" -ForegroundColor Magenta
```
*Nota: La funzione `Export-Results` sarà definita nella prossima sezione come esempio di buone pratiche.*

#### 5. Esportazione dei risultati

I dati puri sono buoni, ma spesso devono essere presentati in un formato adatto agli esseri umani o ad altri programmi. PowerShell offre molti cmdlet per l'esportazione.

| Metodo                               | Comando                                            | Descrizione                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Testo semplice**                   | `... \| Out-File C:\Temp\data.txt`                 | Reindirizza la rappresentazione testuale in un file.                                      |
| **CSV (per Excel)**                 | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | Esporta oggetti in CSV. `-NoTypeInfo` rimuove la prima riga di servizio.     |
| **Report HTML**                      | `... \| ConvertTo-Html -Title "Report"`             | Crea codice HTML da oggetti.                                                       |
| **JSON (per API, Web)**             | `... \| ConvertTo-Json`                            | Converte oggetti nel formato JSON.                                                  |
| **XML (formato nativo PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml`            | Salva oggetti con tutti i tipi di dati. Possono essere ripristinati perfettamente tramite `Import-Clixml`. |

##### Aggiunta allo script: Funzione di esportazione
Aggiungiamo una funzione al nostro script `system_monitor.ps1` che si occupa dell'esportazione. Posiziona questo codice **prima** della chiamata a `Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Esportazione in CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Creazione di un bel report HTML
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Top 10 Processi per CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Statistiche dei Servizi</h2>"

    ConvertTo-Html -Head "<title>Report di Sistema</title>" -Body "<h1>Report di Sistema del $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
Ora il nostro script non solo raccoglie dati, ma li salva anche in modo pulito in due formati: CSV per l'analisi e HTML per una rapida visualizzazione.

#### Conclusione

1.  **Pipeline (`|`)** – lo strumento principale per combinare comandi ed elaborare oggetti.
2.  **`Get-Member`** – analisi degli oggetti, che mostra di cosa sono composti.
3.  **Variabili (`$var`, `$_`)** consentono di memorizzare dati e accedere all'oggetto corrente nella pipeline.
4.  I **file `.ps1`** trasformano i comandi in strumenti di automazione riutilizzabili.
5.  I **cmdlet di esportazione** (`Export-Csv`, `ConvertTo-Html`) esportano i dati nel formato appropriato.

**Nella prossima parte, applicheremo questa conoscenza per navigare e gestire i file system, esaminando gli oggetti `System.IO.DirectoryInfo` e `System.IO.FileInfo`.**