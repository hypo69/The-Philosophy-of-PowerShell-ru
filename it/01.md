# Filosofia di PowerShell.
## Parte 0.
Cosa c'era prima di PowerShell?
Nel 1981 fu rilasciato MS-DOS 1.0 con l'interprete di comandi `COMMAND.COM`. Per l'automazione delle attivit√† venivano utilizzati i **file batch (`.bat`)** ‚Äî semplici file di testo con una sequenza di comandi della console. Un'incredibile ascesi della riga di comando rispetto ai sistemi compatibili POSIX dove gi√† dal 1979 esisteva la **shell Bourne (`sh`)**.

### üìÖ Stato del mercato delle shell al momento del rilascio di **MS-DOS 1.0** (agosto 1981)

Ecco una tabella riassuntiva dei sistemi operativi popolari dell'epoca e del loro supporto per le shell (`sh`, `csh`, ecc.):

| Sistema Operativo            | Supporto shell (`sh`, `csh`, ecc.) | Commento                                                              |
| :--------------------------- | :--------------------------------- | :-------------------------------------------------------------------- |
| **UNIX Version 7 (V7)**      | `sh`                               | L'ultimo UNIX classico di Bell Labs, ampiamente diffuso               |
| **UNIX/32V**                 | `sh`, `csh`                        | Versione di UNIX per l'architettura VAX                               |
| **4BSD / 3BSD**              | `sh`, `csh`                        | Ramo universitario di UNIX da Berkeley                                |
| **UNIX System III**          | `sh`                               | La prima versione commerciale di AT&T, predecessore di System V       |
| **Xenix (di Microsoft)**     | `sh`                               | Versione di UNIX con licenza, venduta da Microsoft dal 1980           |
| **IDRIS**                    | `sh`                               | OS simile a UNIX per PDP-11 e Intel                                   |
| **Coherent (Mark Williams)** | `sh` (simile)                      | Alternativa economica a UNIX per PC                                   |
| **CP/M (Digital Research)**  | ‚ùå (No `sh`, solo CLI semplicissimo) | Non UNIX, il sistema operativo pi√π popolare per PC a 8 bit            |
| **MS-DOS 1.0**               | ‚ùå (solo `COMMAND.COM`)            | Shell a riga di comando minima, nessun script o pipe                  |

---

### üí° Cosa sono `sh`, `csh`

* `sh` ‚Äî **Bourne Shell**, l'interprete di script principale di UNIX dal 1977.
* `csh` ‚Äî **C Shell**, una shell migliorata con una sintassi simile a C e comodit√† per il lavoro interattivo.
* Queste shell **supportavano reindirizzamenti, pipe, variabili, funzioni e condizioni** ‚Äî tutto ci√≤ che ha reso UNIX un potente strumento di automazione.

---

Microsoft si concentrava sui **PC IBM a 16 bit economici**, che avevano **poca memoria** (solitamente 64‚Äì256 KB), non avevano multitasking ed erano destinati all'**uso domestico e d'ufficio**, non ai server. UNIX era a pagamento, richiedeva un'architettura complessa e esperienza, mentre contabili e ingegneri, non amministratori di sistema, avevano bisogno di un sistema operativo rapido e semplice.

L'interfaccia DOS, invece della complessa `sh`, presentava un singolo file command.com con un set scarso di comandi interni [(dir, copy, del e simili)](https://www.techgeekbuzz.com/blog/dos-commands/){:target="_blank"} senza funzioni, cicli o moduli.

C'erano anche comandi esterni ‚Äî file eseguibili separati (.exe o .com). Esempi: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Gli script di esecuzione venivano salvati in un file di testo con estensione .bat (batch file).

Esempi di file di configurazione:

- AUTOEXEC.BAT

```bash
:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Configurazione automatica e avvio di Windows 3.11
:: Autore: hypo69
:: Anno: circa 1993
:: Scopo: Esegue l'inizializzazione dell'ambiente DOS, il caricamento dei driver di rete e l'avvio di Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Impostazione del prompt della riga di comando
PROMPT $p$g

:: Impostazione delle variabili d'ambiente
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Caricamento di driver e utility nella memoria superiore
LH C:\DOS\SMARTDRV.EXE       :: Cache del disco
LH C:\DOS\MOUSE.COM          :: Driver del mouse

:: Caricamento dei servizi di rete (rilevante per Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Avvio automatico di Windows
WIN

```
- CONFIG.SYS
```bash
:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî Configurazione della memoria e dei driver DOS per Windows 3.11
:: Autore: hypo69
:: Anno: circa 1993
:: Scopo: Inizializzazione dei driver di memoria, impostazione dei parametri di sistema
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE

```

In Microsoft, parallelamente a DOS, quasi subito iniziarono a sviluppare un kernel fondamentalmente nuovo.

Il kernel [**Windows NT**](https://www.wikiwand.com/ru/articles/Windows_NT){:target="_blank"} (New Technology) apparve per la prima volta con il rilascio del sistema operativo:

> **Windows NT 3.1 ‚Äî 27 luglio 1993**

---

*   **Sviluppo iniziato**: nel **1988** sotto la guida di **Dave Cutler** (ex ingegnere DEC, creatore di VMS) con l'obiettivo di creare un sistema operativo completamente nuovo, protetto, portabile e multitasking, non compatibile con MS-DOS a livello di kernel.
*   **NT 3.1** ‚Äî chiamato cos√¨ per sottolineare la compatibilit√† con **Windows 3.1** a livello di interfaccia, ma era un'**architettura completamente nuova**.

---

#### üß† Cosa ha portato il kernel NT:

| Caratteristica                     | Descrizione                                                               |
| :--------------------------------- | :------------------------------------------------------------------------ |
| **Architettura a 32 bit**          | A differenza di MS-DOS e Windows 3.x, che erano a 16 bit.                 |
| **Multitasking**                   | Vero multitasking preemptive.                                             |
| **Memoria protetta**               | I programmi non potevano danneggiare la memoria l'uno dell'altro.         |
| **Modularit√†**                     | Architettura del kernel a pi√π livelli: HAL, Executive, Kernel, driver.    |
| **Supporto multipiattaforma**      | NT 3.1 funzionava su x86, MIPS e Alpha.                                   |
| **Compatibilit√† con POSIX**        | NT era fornito con un **sottosistema POSIX**, certificato POSIX.1.        |

---

#### üìú Linea NT:

| Versione NT   | Anno       | Commento                               |
| :------------ | :--------- | :------------------------------------- |
| NT 3.1        | 1993       | Primo rilascio di NT                   |
| NT 3.5 / 3.51 | 1994‚Äì1995  | Miglioramenti, ottimizzazione          |
| NT 4.0        | 1996       | Interfaccia Windows 95, ma kernel NT   |
| Windows 2000  | 2000       | NT 5.0                                 |
| Windows XP    | 2001       | NT 5.1                                 |
| Windows Vista | 2007       | NT 6.0                                 |
| Windows 10    | 2015       | NT 10.0                                |
| Windows 11    | 2021       | Anche NT 10.0 (marketing üòä)           |

---

Differenza nelle capacit√† dei sistemi operativi:

| Caratteristica                  | **MS-DOS** (1981)                       | **Windows NT** (1993)                               |
| :------------------------------ | :-------------------------------------- | :-------------------------------------------------- |
| **Tipo di sistema**             | Monolitico, monotasking                 | Microkernel/ibrido, multitasking                    |
| **Architettura**                | 16-bit                                  | 32-bit (con supporto 64-bit da NT 5.2 / XP x64)     |
| **Multitasking**                | ‚ùå Assente (un processo alla volta)     | ‚úÖ Multitasking preemptive                          |
| **Memoria protetta**            | ‚ùå No                                   | ‚úÖ S√¨ (ogni processo nel proprio spazio di indirizzi) |
| **Modalit√† multiutente**        | ‚ùå No                                   | ‚úÖ Parzialmente (in NT Workstation/Server)          |
| **Compatibilit√† con POSIX**     | ‚ùå No                                   | ‚úÖ Sottosistema POSIX integrato in NT 3.1‚Äì5.2       |
| **Portabilit√† del kernel**      | ‚ùå Solo x86                             | ‚úÖ x86, MIPS, Alpha, PowerPC                        |
| **Driver**                      | Accesso diretto all'hardware            | Tramite HAL e driver in modalit√† kernel             |
| **Livello di accesso delle applicazioni** | Applicazioni = livello di sistema       | Livello utente / kernel separati                    |
| **Sicurezza**                   | ‚ùå Assente                              | ‚úÖ Modello di sicurezza: SID, ACL, token di accesso |
| **Stabilit√†**                   | ‚ùå Dipendenza di un programma = crash del SO | ‚úÖ Isolamento dei processi, protezione del kernel   |

---

Ma c'era un grande MA! I mezzi di automazione e amministrazione non ricevettero la dovuta attenzione fino al 2002.

---

Microsoft utilizzava approcci, strategie e strumenti completamente diversi per l'amministrazione. Tutto ci√≤ era **frammentato**, spesso orientato alla GUI e non sempre automatizzabile.

---

##### üìå Elenco di alcuni strumenti:

| Strumento                     | Scopo                                                           |
| :---------------------------- | :-------------------------------------------------------------- |
| `cmd.exe`                     | Interprete di comandi migliorato (sostituzione di `COMMAND.COM`) |
| `.bat`, `.cmd`                | Script della riga di comando                                    |
| **Windows Script Host (WSH)** | Supporto VBScript e JScript per l'automazione                   |
| `reg.exe`                     | Gestione del registro dalla riga di comando                     |
| `net.exe`                     | Lavoro con utenti, rete, stampanti                              |
| `sc.exe`                      | Gestione dei servizi                                            |
| `tasklist`, `taskkill`        | Gestione dei processi                                           |
| `gpedit.msc`                  | Criteri di gruppo (locale)                                      |
| `MMC`                         | Console con snap-in per la gestione                             |
| `WMI`                         | Accesso alle informazioni di sistema (tramite `wmic`, VBScript, o COM) |
| `WbemTest.exe`                | GUI per il test delle query WMI                                 |
| `eventvwr`                    | Visualizzatore di eventi                                        |
| `perfmon`                     | Monitoraggio delle risorse                                      |

##### üõ† Esempi di automazione:

*   File VBScript (`*.vbs`) per l'amministrazione di utenti, reti, stampanti e servizi.
*   `WMIC` ‚Äî interfaccia a riga di comando per WMI (ad esempio: `wmic process list brief`).
*   Script `.cmd` con chiamate a `net`, `sc`, `reg`, `wmic`, ecc.

---

### ‚öôÔ∏è Windows Scripting Host (WSH)

*   Apparve per la prima volta in **Windows 98**, fu ampiamente utilizzato in **Windows 2000 e XP**.
*   Permetteva di eseguire file VBScript e JScript dalla riga di comando:

    ```vbscript
    Set objShell = WScript.CreateObject("WScript.Shell")
    objShell.Run "notepad.exe"
    ```

---
## Parte 1.

Solo nel 2002 l'azienda formul√≤ il progetto <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, che in seguito si trasform√≤ in PowerShell:

Inizio dello sviluppo: indicativamente nel 2002

Annuncio pubblico: 2003, come "Monad Shell"

Prime versioni beta: apparse entro il 2005

Rilascio finale (PowerShell 1.0): novembre 2006

L'autore e architetto capo del progetto Monad / PowerShell √® Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a>

Oggi PowerShell Core funziona su
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a>

Parallelamente, era in corso lo sviluppo del framework .NET e PowerShell vi fu profondamente integrato; nei capitoli successivi mostrer√≤ degli esempi.

E ora ‚Äî la cosa pi√π importante!

Il principale vantaggio di PowerShell rispetto alle shell di comando classiche √® che lavora con gli *oggetti*, non con il testo. Quando si esegue un comando, esso non restituisce semplicemente testo, ma un oggetto strutturato (o una collezione di oggetti), che ha propriet√† (Properties) e metodi (Methods) chiaramente definiti.

Guarda come PowerShell supera le shell classiche grazie al **lavoro con gli oggetti**.

### üìÅ Come era: `dir` e parsing manuale

In **CMD** (sia nel vecchio `COMMAND.COM` che in `cmd.exe`) il comando `dir` restituisce il risultato come testo normale. Esempio di output:

```
24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
```

Supponiamo di voler estrarre il **nome del file** e la **dimensione** di ogni file. Dovrai analizzare le righe manualmente:
```cmd
for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
```

*   Questo √® terribilmente difficile da leggere, dipende dalla locale, dal formato della data, dal font. E si rompe con gli spazi nei nomi.

---

### ‚úÖ PowerShell: oggetti invece di testo

#### ‚úî Esempio semplice e leggibile:

```powershell
Get-ChildItem | Select-Object Name, Length
```

**Risultato:**

```
Name          Length
----          ------
my_script.js   1428
report.html    3980
```

*   `Get-ChildItem` restituisce un **array di oggetti file/cartelle**
*   `Select-Object` permette di ottenere facilmente le **propriet√†** desiderate

---

### üîç Cosa restituisce realmente `Get-ChildItem`?

```powershell
$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
```

**Risultato:**

```
TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
```

PowerShell restituisce **oggetti di tipo `System.IO.FileInfo`**, che hanno:

*   üß± Propriet√† (`Name`, `Length`, `CreationTime`, `Extension`, ‚Ä¶)
*   üõ† Metodi (`Delete()`, `CopyTo()`, `MoveTo()` e cos√¨ via)

Si lavora **con oggetti completi**, non con stringhe.

---

### Sintassi "Verbo-Nome":

PowerShell utilizza una **sintassi di comando rigorosa e logica**:
`Verbo-Nome` (Verb-Noun)

| Verbo     | Cosa fa      |
| :-------- | :----------- |
| `Get-`    | Ottenere     |
| `Set-`    | Impostare    |
| `New-`    | Creare       |
| `Remove-` | Rimuovere    |
| `Start-`  | Avviare      |
| `Stop-`   | Arrestare    |

| Nome          | Su cosa opera    |
| :------------ | :--------------- |
| `Process`     | Processo         |
| `Service`     | Servizio         |
| `Item`        | File/cartella    |
| `EventLog`    | Log eventi       |
| `Computer`    | Computer         |

#### üîÑ Esempi:

| Cosa fare                 | Comando         |
| :------------------------ | :-------------- |
| Ottenere processi         | `Get-Process`   |
| Arrestare un servizio     | `Stop-Service`  |
| Creare un nuovo file      | `New-Item`      |
| Ottenere il contenuto di una cartella | `Get-ChildItem` |
| Rimuovere un file         | `Remove-Item`   |

‚û° Anche se **non conosci il comando esatto**, puoi **presumerlo** dal significato ‚Äî e quasi sempre indovinerai.

---

Il cmdlet `Get-Help` ‚Äî il tuo principale assistente.

1.  **Ottieni aiuto sull'aiuto stesso:**
    ```powershell
    Get-Help Get-Help
    ```
2.  **Ottieni aiuto di base su un comando per lavorare con i processi:**
    ```powershell
    Get-Help Get-Process
    ```
3.  **Guarda esempi di utilizzo di questo comando:**
    ```powershell
    Get-Help Get-Process -Examples
    ```
    Questo √® un parametro incredibilmente utile che spesso fornisce soluzioni pronte per i tuoi compiti.
4.  **Ottieni le informazioni pi√π dettagliate sul comando:**
    ```powershell
    Get-Help Get-Process -Full
    ```
Nella prossima parte: pipeline o catena di comandi (PipeLines)