### **Часть 7: Логические конструкции и циклы.**

В предыдущей главе мы научились сохранять наши команды в `.ps1` файлы и запускать их. Но пока наши скрипты были "линейными" — они выполняли команды строго одну за другой. Чтобы создавать по-настоящему полезные и "умные" сценарии, нам нужно научить их принимать решения и повторять действия. Для этого в PowerShell, как и в любом языке программирования, существуют условные конструкции и циклы.

#### **Делаем скрипты умнее: Условия (`If / ElseIf / Else`)**

Конструкция `If` — это основной способ заставить скрипт выполнять разные действия в зависимости от того, истинно (`$true`) или ложно (`$false`) определенное условие.

**Базовый синтаксис:**

```powershell
if ( <условие> ) {
    # Блок кода, который выполнится, если условие истинно
}```
**Расширенный синтаксис:**

```powershell
if ( <условие1> ) {
    # Выполнится, если условие1 истинно
}
elseif ( <условие2> ) {
    # Выполнится, если условие1 ложно, а условие2 истинно
}
else {
    # Выполнится, если все предыдущие условия ложны
}
```

**Что может быть условием?**
Условием может быть любое выражение, которое PowerShell может привести к булевому значению (`$true` или `$false`). Это может быть:
*   Результат оператора сравнения (`-eq`, `-gt`, `-like` и т.д.).
*   Переменная, содержащая `$true` или `$false`.
*   Вызов команды. Например, `Test-Path C:\file.txt` возвращает `$true`, если файл существует, и `$false`, если нет.

**Практический пример: Скрипт проверки состояния службы.**
Давайте напишем скрипт, который проверяет, запущена ли служба "Spooler" (Диспетчер печати), и в зависимости от ее состояния выводит разные сообщения.

```powershell
# Получаем объект службы
$serviceName = "Spooler"
$serviceObject = Get-Service -Name $serviceName -ErrorAction SilentlyContinue

# -ErrorAction SilentlyContinue нужен, чтобы скрипт не остановился с ошибкой, если служба вообще не найдена

if ($serviceObject -eq $null) {
    # Условие 1: Служба не существует
    Write-Host "Служба '$serviceName' не найдена на этом компьютере." -ForegroundColor Red
}
elseif ($serviceObject.Status -eq "Running") {
    # Условие 2: Служба найдена и запущена
    Write-Host "Служба '$serviceName' находится в состоянии: $($serviceObject.Status)." -ForegroundColor Green
}
else {
    # Условие 3: Служба найдена, но не запущена (Stopped, Paused и т.д.)
    Write-Host "ВНИМАНИЕ! Служба '$serviceName' не запущена. Текущий статус: $($serviceObject.Status)." -ForegroundColor Yellow
}
```Этот скрипт демонстрирует полноценную логическую проверку с тремя возможными исходами.

#### **Оператор выбора: `Switch`**

Когда у вас есть много возможных вариантов для одной переменной, использовать длинную цепочку `If/ElseIf` становится неудобно. Для таких случаев в PowerShell есть более элегантное решение — оператор `Switch`. Он берет переменную и сравнивает ее значение с несколькими вариантами.

**Синтаксис:**

```powershell
switch ( <проверяемое_значение> ) {
    <вариант1> { # Блок кода для варианта1 }
    <вариант2> { # Блок кода для варианта2 }
    <вариант3> { # Блок кода для варианта3 }
    default    { # Выполнится, если ни один из вариантов не подошел }
}
```

**Практический пример: Анализ событий из журнала.**
Давайте получим последнее событие из системного журнала и выведем разное сообщение в зависимости от его уровня.

```powershell
$latestEvent = Get-WinEvent -LogName System -MaxEvents 1

switch ($latestEvent.LevelDisplayName) {
    "Information" {
        Write-Host "Последнее событие - информационное. Все в порядке." -ForegroundColor Gray
    }
    "Warning" {
        Write-Host "Последнее событие - предупреждение. Стоит обратить внимание." -ForegroundColor Yellow
    }
    "Error" {
        Write-Host "КРИТИЧЕСКАЯ ОШИБКА! Последнее событие - ошибка!" -ForegroundColor Red
    }
    default {
        Write-Host "Последнее событие имеет уровень: $($latestEvent.LevelDisplayName)"
    }
}
```
`Switch` также поддерживает продвинутые опции, такие как `-Wildcard` для сравнения с использованием `*` и `?`, или `-Regex` для использования регулярных выражений.

#### **Циклы: Повторяем действия**

Циклы позволяют выполнять один и тот же блок кода многократно, что является основой автоматизации.

*   **`ForEach-Object` (псевдоним: `foreach`)**
    Это **цикл для конвейера**. Он принимает объекты по конвейеру и выполняет для каждого из них указанный блок кода. Переменная `$_` так же представляет текущий объект.

    **Пример:** Остановить все процессы "Блокнота".
    ```powershell
    Get-Process -Name "notepad" | ForEach-Object {
        Write-Host "Останавливаю процесс с ID: $($_.Id)..."
        # $_.Stop() - это вызов метода Stop() для текущего объекта процесса
        # В реальном скрипте лучше использовать Stop-Process -Id $_.Id
        Stop-Process -Id $_.Id
    }
    ```

*   **Конструкция `foreach ($item in $collection)`**
    Это более классическая конструкция цикла, которая не работает в конвейере, но часто более читаема в скриптах. Она перебирает элементы коллекции, которую вы заранее сохранили в переменную.

    **Пример:** Пингуем список серверов из массива.
    ```powershell
    $serverList = @("google.com", "yandex.ru", "non-existent-host")

    foreach ($server in $serverList) {
        if (Test-Connection -ComputerName $server -Count 1 -Quiet) {
            Write-Host "$server - доступен" -ForegroundColor Green
        }
        else {
            Write-Host "$server - НЕ доступен" -ForegroundColor Red
        }
    }
    ```

*   **`For`**
    Классический цикл со счетчиком, знакомый по многим другим языкам. Используется, когда нужно выполнить код строго определенное количество раз.

    **Синтаксис:** `for (<инициализация>; <условие_продолжения>; <шаг>)`

    **Пример:** Создать 5 пронумерованных файлов.
    ```powershell
    for ($i = 1; $i -le 5; $i++) {
        New-Item -Path "C:\Temp\File$i.txt" -ItemType File
        Write-Host "Создан файл File$i.txt"
    }
    ```

*   **`While` и `Do-While / Do-Until`**
    Эти циклы выполняются до тех пор, пока истинно (или ложно) определенное условие.
    *   `While`: Сначала проверяет условие, потом выполняет тело цикла. Может не выполниться ни разу.
    *   `Do-While` / `Do-Until`: Сначала выполняет тело цикла, потом проверяет условие. Выполнится как минимум один раз.

    **Пример:** Ожидание завершения процесса.
    ```powershell
    # Запускаем Блокнот
    $process = Start-Process notepad -PassThru # -PassThru возвращает объект запущенного процесса

    Write-Host "Ожидаю, пока пользователь закроет Блокнот (PID: $($process.Id))..."

    while (-not $process.HasExited) {
        # Делаем паузу на 1 секунду, чтобы не нагружать процессор
        Start-Sleep -Seconds 1
    }

    Write-Host "Блокнот был закрыт. Скрипт продолжает работу."
    ```


**В следующей части мы поднимемся на новый уровень абстракции и научимся создавать свои собственные многоразовые команды с помощью функций.**