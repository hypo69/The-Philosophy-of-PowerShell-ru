
### **Часть 14: Проект "CPU-монитор" — Сбор данных и логика.**

На этом этапе мы превратим наше статичное окно в настоящий работающий инструмент. Мы будем использовать командлет `Get-Counter` для получения метрик производительности системы и объект `Timer` из .NET для создания цикла обновления нашего интерфейса.

#### **Шаг 1: Получение данных о загрузке CPU с помощью `Get-Counter`**

**Счетчики производительности (Performance Counters)** — это стандартный механизм в Windows для получения сотен системных метрик в реальном времени: от загрузки процессора и использования памяти до скорости дисковых операций и количества сетевых пакетов.

Командлет `Get-Counter` — это интерфейс PowerShell для доступа к этим счетчикам.

**Как найти нужный счетчик?**
Путь к счетчику имеет строгую структуру: `\Категория(экземпляр)\Счетчик`.
Чтобы посмотреть доступные категории, можно выполнить `Get-Counter -ListSet *`.
Нас интересует загрузка процессора. Нужный нам счетчик: `\Processor(_Total)\% Processor Time`.
*   `Processor`: Категория счетчиков.
*   `(_Total)`: Экземпляр. В данном случае — суммарное значение по всем ядрам.
*   `% Processor Time`: Имя самого счетчика.

**Практика: Тестируем получение данных**
Давайте попробуем получить одно значение в консоли:

```powershell
Get-Counter -Counter "\Processor(_Total)\% Processor Time"
```
Результат будет примерно таким:
```
Timestamp                 CounterSamples
---------                 --------------
25.07.2025 10:30:15       \\my-pc\processor(_total)\% processor time :
                          2.5416348163
```
Как видите, команда возвращает объект, у которого есть свойство `CounterSamples`, а уже внутри него — `CookedValue` с нужным нам числовым значением.

#### **Шаг 2: Создание таймера для периодического опроса**

Чтобы наш график обновлялся автоматически, нам нужен механизм, который будет выполнять определенный блок кода каждые N секунд. Для этого в Windows Forms идеально подходит класс `System.Windows.Forms.Timer`.

**Как работает таймер:**
1.  Мы создаем экземпляр таймера.
2.  Задаем ему свойство `Interval` (интервал в миллисекундах).
3.  "Подписываемся" на его событие `Tick`, которое срабатывает каждый раз, когда истекает заданный интервал.
4.  Запускаем таймер методом `Start()` и останавливаем методом `Stop()`.

#### **Шаг 3: Объединяем все вместе. Программируем логику**

Теперь давайте возьмем наш код из предыдущей главы и добавим в него новую логику.

```powershell
# --- Код из Части 13 (создание формы и элементов) ---
# ... (весь код по созданию $mainForm, $chart, $labels, $buttons) ...

# --- НОВАЯ ЧАСТЬ: Логика приложения ---

# 1. Создание таймера
$timer = New-Object -TypeName System.Windows.Forms.Timer
$timer.Interval = 1000 # Интервал в миллисекундах (1000 мс = 1 секунда)

# 2. Создание обработчика события Tick для таймера
$timer.add_Tick({
    # Этот блок кода будет выполняться каждую секунду, пока таймер запущен

    # 2.1 Получаем текущее значение загрузки CPU
    $cpuValue = (Get-Counter -Counter "\Processor(_Total)\% Processor Time").CounterSamples.CookedValue
    # Округляем до целого числа
    $cpuValue = [math]::Round($cpuValue)

    # 2.2 Обновляем большую текстовую метку
    $cpuLabel.Text = "$cpuValue %"

    # 2.3 Добавляем новую точку на график
    # .Points - это коллекция точек данных для нашего ряда
    $chart.Series["CPU"].Points.AddY($cpuValue)

    # 2.4 Управляем количеством точек на графике, чтобы он не переполнялся
    # Если точек стало больше 60, удаляем самую старую (первую)
    if ($chart.Series["CPU"].Points.Count -gt 60) {
        $chart.Series["CPU"].Points.RemoveAt(0)
    }
})

# 3. Программирование логики кнопки "Старт"
$startButton.add_Click({
    # Запускаем таймер
    $timer.Start()

    # Обновляем состояние интерфейса
    $startButton.Enabled = $false
    $stopButton.Enabled = $true
    $statusLabel.Text = "Мониторинг запущен..."
})

# 4. Программирование логики кнопки "Стоп"
$stopButton.add_Click({
    # Останавливаем таймер
    $timer.Stop()

    # Обновляем состояние интерфейса
    $startButton.Enabled = $true
    $stopButton.Enabled = $false
    $statusLabel.Text = "Остановлено. Готов к запуску..."
})

# 5. Дополнительная логика: что делать при закрытии окна?
# Если пользователь закроет окно, а таймер будет работать,
# процесс PowerShell может остаться "висеть" в памяти.
# Поэтому при закрытии формы нам нужно убедиться, что таймер остановлен.
$mainForm.add_FormClosing({
    $timer.Stop()
})

# --- Конец новой части ---

# --- Отображение окна ---
[void]$mainForm.ShowDialog()
```
#### **Разбор ключевых моментов логики**

*   **`$timer.add_Tick({ ... })`**: Мы привязываем к событию `Tick` таймера скриптблок. Этот код — сердце нашего приложения, он будет выполняться снова и снова.
*   **`[math]::Round($cpuValue)`**: `Get-Counter` возвращает очень точное значение типа `[double]`. Для отображения мы округляем его до целого числа с помощью статического метода `Round` класса `.NET [math]`.
*   **`$chart.Series["CPU"]`**: Мы обращаемся к нашему ряду данных на графике по имени, которое мы задали в предыдущей главе (`$chartSeries.Name = "CPU"`).
*   **`.Points.AddY($cpuValue)`**: Это основной метод для добавления данных на график. Он добавляет новую точку по оси Y (значение загрузки). Ось X (время) в данном случае генерируется автоматически.
*   **`.Points.RemoveAt(0)`**: Эта строка реализует "скользящее окно". Чтобы график не уезжал бесконечно вправо, мы поддерживаем на нем не более 60 точек. Как только их становится 61, мы удаляем самую первую (самую старую) точку с индексом 0.
*   **Управление `Enabled`**: Мы управляем свойством `Enabled` кнопок, чтобы пользователь не мог нажать "Старт", когда мониторинг уже идет, или "Стоп", когда он уже остановлен. Это делает интерфейс более логичным и защищает от ошибок.
*   **`add_FormClosing`**: Подписка на событие закрытия формы — это хорошая практика для "очистки" ресурсов. В нашем случае мы гарантируем остановку таймера.



**В последней главе мы наведем финальные штрихи: добавим обработку ошибок и обсудим, как можно развить этот проект дальше.**