### **Часть 4: Фильтрация, сортировка и выборка данных.**

В предыдущей части мы научились получать коллекции объектов. Но что делать, когда этих объектов тысячи? Просматривать их вручную — не вариант. На этом этапе в игру вступают три ключевых командлета-фильтра, которые являются основой практически любого сложного скрипта в PowerShell: `Where-Object`, `Sort-Object` и `Select-Object`. Эти инструменты позволяют вам, подобно скульптору, отсекать все лишнее от глыбы данных, оставляя только ценную информацию.

#### **Фильтрация объектов с помощью `Where-Object` (псевдонимы: `where`, `?`)**

Представьте, что у вас есть сито. Вы высыпаете на него песок с золотыми крупицами, и сито пропускает только золото. `Where-Object` — это такое же "сито" для объектов PowerShell. Он получает объекты по конвейеру и пропускает дальше только те, которые соответствуют заданному вами условию.

**Как это работает:**
`Where-Object` принимает на вход **блок кода (ScriptBlock)**, который заключается в фигурные скобки `{}`. Этот блок выполняется для **каждого** объекта, пришедшего по конвейеру. Внутри этого блока специальная автоматическая переменная `$_` представляет текущий обрабатываемый объект. Если блок кода возвращает значение, которое PowerShell может интерпретировать как `$true` (истина), объект проходит дальше по конвейеру. Если `$false` или `null` — отбрасывается.

**Операторы сравнения:**
PowerShell использует уникальные операторы сравнения, которые начинаются с дефиса. Они нечувствительны к регистру по умолчанию (чтобы сделать их чувствительными, добавьте `c` в начало, например, `-ceq`).

| Оператор | Описание | Пример |
| :--- | :--- | :--- |
| `-eq` | Равно (Equal) | `($_.Name -eq "svchost")` |
| `-ne` | Не равно (Not Equal) | `($_.Status -ne "Running")`|
| `-gt` | Больше чем (Greater Than)| `($_.Length -gt 10MB)` |
| `-ge` | Больше или равно (Greater or Equal)| `($_.Handles -ge 500)` |
| `-lt` | Меньше чем (Less Than) | `($_.CPU -lt 10)` |
| `-le` | Меньше или равно (Less or Equal)| `($_.Id -le 1000)` |
| `-like`| Похоже на (с использованием `*` и `?`)| `($_.Name -like "sql*")` |
| `-notlike`| Не похоже на | `($_.Path -notlike "*\System32\*")`|
| `-match`| Соответствует регулярному выражению| `($_.Name -match "^svc")` |
| `-notmatch`| Не соответствует регулярному выражению| `($_.Message -notmatch "Error")`|
| `-contains`| Коллекция содержит значение| `($array -contains "value")`|
| `-in`| Значение содержится в коллекции| `("value" -in $array)` |

**Логические операторы:** `-and`, `-or`, `-xor`, `-not`.

**Практические примеры:**

1.  **Найти все службы, имя которых начинается с "Win", и которые при этом остановлены:**

    ```powershell
    Get-Service | Where-Object { ($_.Name -like "Win*") -and ($_.Status -eq "Stopped") }
    ```2.  **Найти все события в журнале "Система" за последний день, которые не являются информационными:**

    ```powershell
    $yesterday = (Get-Date).AddDays(-1)
    Get-WinEvent -LogName System | Where-Object { ($_.TimeCreated -ge $yesterday) -and ($_.LevelDisplayName -ne "Information") }
    ```

#### **Сортировка вывода с помощью `Sort-Object` (псевдоним: `sort`)**

Этот командлет делает ровно то, что обещает его название — сортирует коллекцию объектов по одному или нескольким свойствам.

**Практические примеры:**

1.  **Вывести список процессов, отсортированный сначала по имени, а затем по ID процесса внутри групп с одинаковыми именами:**
    `Sort-Object` может принимать массив свойств для многоуровневой сортировки.

    ```powershell
    Get-Process | Sort-Object -Property ProcessName, Id
    ```
2.  **Вывести список файлов, отсортированный по расширению, а затем по размеру (по убыванию) внутри каждой группы расширений:**

    ```powershell
    Get-ChildItem -File | Sort-Object -Property Extension, @{Expression="Length"; Descending=$true}
    ```
    Здесь мы снова видим использование хеш-таблицы, но уже для задания сложных правил сортировки для одного из свойств.

3.  **Параметр `-Unique`**: Позволяет получить только уникальные значения после сортировки. Например, получить список уникальных имен запущенных процессов:

    ```powershell
    Get-Process | Sort-Object -Property ProcessName -Unique | Select-Object -Property ProcessName
    ```

#### **Выборка конкретных свойств: `Select-Object` (псевдоним: `select`)**

Часто объекты содержат гораздо больше информации, чем нам нужно для конкретной задачи. `Select-Object` позволяет "вырезать" из объекта только нужные нам свойства, создавая на лету новый, упрощенный объект (`PSCustomObject`). Также он умеет выбирать определенное количество объектов из начала или конца коллекции.

**Практические примеры:**

1.  **Показать только имя и ID для всех процессов:**

    ```powershell
    Get-Process | Select-Object -Property ProcessName, Id
    ```
2.  **Выбрать 5 самых "старых" файлов из папки:**
    `Select-Object` имеет парный параметр к `-First` — это `-Last`.

    ```powershell
    # Сначала сортируем по возрастанию времени создания, затем берем последние 5
    Get-ChildItem -File | Sort-Object -Property CreationTime | Select-Object -Last 5
    ```
3.  **Создание вычисляемых свойств "на лету" (Calculated Properties):**
    Это одна из самых мощных возможностей `Select-Object`. Вы можете создавать новые свойства, значения которых вычисляются на основе существующих. Для этого используется специальный синтаксис с хеш-таблицей.

    **Задача:** Показать список процессов, их ID и потребление памяти в мегабайтах (свойство `WS` хранит значение в байтах), округлив до двух знаков после запятой.

    ```powershell
    Get-Process | Select-Object -Property ProcessName, Id, @{Name="MemoryMB"; Expression={[math]::Round($_.WS / 1MB, 2)}}
    ```
    *   `@{...}`: Создаем хеш-таблицу.
    *   `Name="MemoryMB"` (или `Label`, `l`): Задаем имя нашего нового свойства.
    *   `Expression={...}` (или `e`): Задаем блок кода, который вычислит значение. Здесь мы обращаемся к статическому методу `Round` класса `[math]` из .NET для округления.

#### **Собираем все вместе: Практический пример**

Теперь давайте решим задачу из начала главы, используя все три командлета.

**Задача: Найти 5 самых ресурсоемких по использованию процессора (CPU) процессов, которые были запущены более часа назад, и вывести их имя, ID и время запуска в удобном формате.**

```powershell
Get-Process |
    Where-Object { $_.StartTime -lt (Get-Date).AddHours(-1) } |
    Sort-Object -Property CPU -Descending |
    Select-Object -First 5 -Property ProcessName, Id, StartTime, CPU```
**Разберем по шагам:**

1.  `Get-Process`: Получаем **все** объекты процессов.
2.  `|`: Передаем их по конвейеру.
3.  `Where-Object { $_.StartTime -lt (Get-Date).AddHours(-1) }`: Отсеиваем все процессы, которые были запущены в течение последнего часа.
4.  `|`: Передаем отфильтрованную коллекцию дальше.
5.  `Sort-Object -Property CPU -Descending`: Сортируем оставшиеся процессы по свойству `CPU` в порядке убывания.
6.  `|`: Передаем отсортированную коллекцию дальше.
7.  `Select-Object -First 5 -Property ProcessName, Id, StartTime, CPU`:
    *   `-First 5`: Берем только первые 5 объектов из отсортированного списка.
    *   `-Property ...`: Для этих пяти объектов выбираем только четыре интересующих нас свойства.

**Итог главы:**
Вы освоили три кита обработки данных в PowerShell: `Where-Object` для сложной фильтрации с использованием различных операторов, `Sort-Object` для многоуровневой сортировки и `Select-Object` для выборки и создания вычисляемых свойств. Научившись комбинировать эти командлеты в конвейере, вы сможете извлекать практически любую информацию из системы и представлять ее в нужном вам виде. Это основа для создания отчетов, мониторинга и анализа.

**В следующей части мы перейдем от обработки данных к их хранению, познакомившись с переменными и базовыми типами данных в PowerShell.**