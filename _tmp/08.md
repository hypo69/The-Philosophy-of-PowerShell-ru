### **Часть 8: Функции — создаем свои командлеты.**

До сих пор мы комбинировали существующие командлеты для решения наших задач. Это мощно, но что, если определенная последовательность из 10-20 команд нужна нам в десятках разных скриптов? Копировать и вставлять код — плохая практика. Она ведет к ошибкам, дублированию и сложностям в поддержке. Решение — инкапсулировать эту логику в многоразовый блок, который можно вызывать по имени. Этот блок и есть **функция**.

Создавая функции, вы фактически расширяете язык PowerShell, добавляя в него свои собственные "командлеты".

#### **Анатомия функции: от простого к сложному**

В своей простейшей форме функция — это просто именованный блок кода.

**Простейшая функция:**
```powershell
function Show-Greeting {
    Write-Host "Hello from my first function!"
}

# Вызов функции
Show-Greeting
```
Такая функция полезна, но не очень гибка. Настоящая сила раскрывается, когда мы добавляем параметры.

#### **Добавление параметров: Блок `param()`**

Чтобы сделать функцию гибкой, ей нужно передавать данные извне. Для этого используется блок `param()`, который должен быть первым исполняемым элементом внутри функции.

```powershell
function Show-Greeting {
    param (
        $Name # Простейшее объявление параметра
    )
    Write-Host "Hello, $Name!"
}

# Вызов функции с параметром
Show-Greeting -Name "Alex"
```
Теперь наша функция может приветствовать кого угодно. Но что, если мы хотим сделать ее более "профессиональной", похожей на настоящий командлет?

#### **Расширенные функции: Атрибуты и валидация**

Чтобы превратить простую функцию в "продвинутую" (Advanced Function), которая ведет себя как скомпилированный командлет (поддерживает общие параметры `-Verbose`, `-Debug`, `-ErrorAction` и т.д.), нужно добавить атрибут `[CmdletBinding()]`.

**Атрибут `[Parameter()]`**: Этот атрибут, размещенный перед объявлением параметра, позволяет детально настроить его поведение.

Давайте напишем более сложную функцию, которая подключается к удаленному компьютеру и получает информацию о службе.

```powershell
function Get-RemoteServiceStatus {
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]
    <#
    .SYNOPSIS
        Получает статус службы на удаленном или локальном компьютере.
    .DESCRIPTION
        Эта функция использует Invoke-Command для подключения к удаленной машине и
        получения информации о конкретной службе.
    .PARAMETER ComputerName
        Имя компьютера, к которому нужно подключиться. По умолчанию - локальный компьютер.
    .PARAMETER ServiceName
        Имя службы, статус которой нужно проверить.
    .EXAMPLE
        Get-RemoteServiceStatus -ComputerName SERVER01 -ServiceName Spooler
    .EXAMPLE
        'SERVER01', 'SERVER02' | Get-RemoteServiceStatus -ServiceName WinRM
    #>
    param (
        [Parameter(ValueFromPipeline = $true,
                   ValueFromPipelineByPropertyName = $true,
                   Position = 0)]
        [string]$ComputerName = $env:COMPUTERNAME,

        [Parameter(Mandatory = $true,
                   Position = 1)]
        [string]$ServiceName
    )

    # Блоки Begin, Process, End
    begin {
        Write-Verbose "Начинаем обработку. Целевая служба: $ServiceName"
    }

    process {
        foreach ($computer in $ComputerName) {
            Write-Verbose "Подключаемся к $computer..."

            if ($PSCmdlet.ShouldProcess($computer, "Получение статуса службы '$ServiceName'")) {
                try {
                    $result = Invoke-Command -ComputerName $computer -ScriptBlock {
                        # $using:ServiceName - передача локальной переменной в удаленный сеанс
                        Get-Service -Name $using:ServiceName -ErrorAction Stop
                    }
                    # Возвращаем кастомный объект с нужной информацией
                    [PSCustomObject]@{
                        ComputerName = $computer
                        ServiceName  = $result.Name
                        Status       = $result.Status
                        DisplayName  = $result.DisplayName
                    }
                }
                catch {
                    Write-Error "Не удалось получить статус службы на $computer. Ошибка: $_"
                }
            }
        }
    }

    end {
        Write-Verbose "Обработка завершена."
    }
}
```

**Разберем этот сложный пример по частям:**

1.  **`[CmdletBinding(...)]`**: Превращает нашу функцию в продвинутую.
    *   `SupportsShouldProcess = $true`: Включает поддержку параметров `-WhatIf` и `-Confirm`. Это критически важно для функций, которые вносят изменения в систему.
    *   `ConfirmImpact`: Задает "уровень опасности" операции. Если он выше, чем у переменной `$ConfirmPreference`, PowerShell будет запрашивать подтверждение.

2.  **Справка на основе комментариев (Comment-Based Help)**: Блок `<# ... #>` перед `param()` позволяет создать полноценную справку для вашей функции. `Get-Help Get-RemoteServiceStatus` теперь будет работать так же, как и для встроенных командлетов!

3.  **`[Parameter(...)]`**:
    *   `Mandatory = $true`: Делает параметр обязательным. Если его не указать при вызове, PowerShell запросит его.
    *   `Position = 0`: Позволяет передавать значение параметра без указания его имени, по позиции. `Get-RemoteServiceStatus "SERVER01" "Spooler"`.
    *   `ValueFromPipeline = $true`: Позволяет функции принимать значения для этого параметра из конвейера. ` "SERVER01" | Get-RemoteServiceStatus -ServiceName Spooler `.
    *   `ValueFromPipelineByPropertyName = $true`: Более сложный вариант, который позволяет конвейеру автоматически сопоставлять свойства входящего объекта с именами параметров функции.

4.  **Валидация параметров**: Вы можете добавить атрибуты для проверки входных данных еще до выполнения тела функции.
    *   `[ValidateNotNullOrEmpty()]`: Убеждается, что параметр не пустой.
    *   `[ValidateSet('Running', 'Stopped')]`: Позволяет выбрать значение только из предопределенного набора.
    *   `[ValidateScript({Test-Path $_ -PathType Container})]`: Выполняет скрипт для проверки значения.

5.  **Блоки `begin`, `process`, `end`**:
    Эти блоки необходимы для правильной обработки данных из конвейера.
    *   `begin { ... }`: Выполняется **один раз** перед обработкой первого объекта из конвейера. Идеальное место для инициализации.
    *   `process { ... }`: Выполняется **для каждого** объекта, пришедшего по конвейеру. Это основное тело функции. Цикл `foreach ($computer in $ComputerName)` здесь нужен, чтобы обработать как одиночное значение, так и массив, пришедший по конвейеру.
    *   `end { ... }`: Выполняется **один раз** после обработки последнего объекта. Идеальное место для очистки ресурсов или вывода итоговой статистики.

6.  **`$PSCmdlet.ShouldProcess(...)`**: Это метод, который реализует логику `-WhatIf` и `-Confirm`. Код внутри `if` выполнится только если пользователь не указал `-WhatIf` или подтвердил действие.

7.  **Возврат значений:** Функция возвращает все, что не "перехвачено" другими командами. В нашем случае мы явно создаем и возвращаем кастомный объект `[PSCustomObject]`, чтобы результат был структурированным и его можно было дальше обрабатывать в конвейере. Использование `Write-Output` имеет тот же эффект. `return` также возвращает значение, но при этом немедленно прекращает выполнение функции.


**В следующей части мы рассмотрим, как наши скрипты и функции могут взаимодействовать с внешним миром, обмениваясь данными в стандартных форматах, таких как CSV и JSON.**