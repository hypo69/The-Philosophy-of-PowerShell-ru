
### **Часть 11: Удаленное управление и фоновые задачи.**

До этой главы мы работали с командами на нашем локальном компьютере. Но истинная сила PowerShell для системного администратора раскрывается тогда, когда нужно управлять не одной машиной, а десятками, сотнями или даже тысячами серверов одновременно. PowerShell позволяет делать это элегантно и эффективно, не вставая со своего рабочего места, благодаря встроенным механизмам удаленного взаимодействия.

#### **Технологическая основа: WinRM и PowerShell Remoting**

В основе удаленного управления в PowerShell (на Windows) лежит технология **WinRM (Windows Remote Management)**. Это реализация протокола **WS-Management (WS-Man)** от Microsoft — стандартного, основанного на SOAP, протокола для удаленного управления оборудованием и операционными системами.

**Как это работает "под капотом":**
1.  Ваша локальная машина (клиент) отправляет команды по HTTP/HTTPS (по умолчанию порты 5985/5986) на службу WinRM, работающую на удаленной машине (сервер).
2.  Служба WinRM на сервере принимает запрос, аутентифицирует вас (обычно через Kerberos в домене или другими методами) и создает специальный хост-процесс PowerShell (`wsmprovhost.exe`).
3.  Ваши команды выполняются внутри этого изолированного процесса.
4.  Результаты выполнения (объекты) сериализуются в специальный формат XML (на основе стандарта CLIXML), передаются по сети обратно на вашу машину.
5.  Ваша локальная сессия PowerShell десериализует этот XML обратно в "живые" объекты.

**Важный нюанс:** Хотя объекты выглядят как настоящие, они являются "обезвоженными" копиями. У них есть все свойства, которые были на удаленной машине, но нет методов (кроме базовых). Если вы попробуете выполнить `Get-Process -ComputerName SERVER01 | Get-Member`, вы увидите, что у десериализованных объектов нет метода `Kill()`. Чтобы выполнить метод, его нужно вызывать на удаленной машине внутри `Invoke-Command`.

**Включение Remoting:**
На современных версиях Windows Server WinRM обычно включен по умолчанию. На клиентских ОС его может потребоваться включить командой, запущенной от имени администратора:
`Enable-PSRemoting -Force`

#### **1. Интерактивная сессия: `Enter-PSSession`**

Представьте, что вы используете "Удаленный рабочий стол" (RDP), но только в виде командной строки. Командлет `Enter-PSSession` делает именно это — он создает **постоянное интерактивное подключение** к хост-процессу PowerShell на удаленном компьютере.

**Практика:**
```powershell
# Создаем сессию с удаленным сервером
Enter-PSSession -ComputerName SERVER01```
После этого приглашение в вашей консоли изменится, показывая, что вы теперь находитесь на удаленной машине:
`[SERVER01]: PS C:\Users\Admin\Documents>`

Теперь все команды, которые вы вводите (`Get-Process`, `Get-Service`, `Get-ChildItem`), будут выполняться **нативно на SERVER01**, а их форматированный текстовый вывод будет передаваться в вашу локальную консоль. Это невероятно удобно для диагностики, изучения конфигурации или выполнения последовательности команд на одной конкретной машине.

Чтобы завершить сессию и вернуться на свой локальный компьютер, достаточно ввести команду `Exit-PSSession` или просто `exit`.

#### **2. Выполнение команд "один ко многим": `Invoke-Command`**

Это "рабочая лошадка" для массового управления. `Invoke-Command` позволяет выполнить блок кода (скрипт) сразу на нескольких компьютерах и получить обратно **структурированные объекты**.

**Как это работает:**
Основной синтаксис включает два ключевых параметра:
*   `-ComputerName`: Массив имен или IP-адресов компьютеров.
*   `-ScriptBlock`: Блок кода в фигурных скобках `{}`, который будет выполнен на каждой машине.

**Практические примеры:**

1.  **Узнаем версию PowerShell и ОС на трех серверах:**
    `Invoke-Command` по умолчанию добавляет к каждому возвращаемому объекту свойство `PSComputerName`, чтобы вы знали, откуда он пришел.
    ```powershell
    $computers = "SERVER01", "SERVER02", "LAB03"
    Invoke-Command -ComputerName $computers -ScriptBlock {
        [PSCustomObject]@{
            OS = (Get-CimInstance Win32_OperatingSystem).Caption
            PSVersion = $PSVersionTable.PSVersion.ToString()
        }
    } | Select-Object PSComputerName, OS, PSVersion
    ```
    Эта команда параллельно подключится ко всем машинам и вернет сводную таблицу.

2.  **Использование локальных переменных в удаленной сессии (префикс `$using:`)**:
    Очень часто нужно передать значение с локальной машины в удаленный скрипт. Просто использовать переменную не получится, так как скриптблок не знает о переменных вашей локальной сессии. Для этого используется специальный префикс `$using:`.
    ```powershell
    $serviceName = "WinRM"
    $computers = "SERVER01", "SERVER02"

    Invoke-Command -ComputerName $computers -ScriptBlock {
        Get-Service -Name $using:serviceName
    }
    ```
    Здесь значение локальной переменной `$serviceName` будет передано на каждую удаленную машину и подставлено в команду `Get-Service`.

#### **Управление сессиями: `New-PSSession`, `Get-PSSession`, `Remove-PSSession`**

Каждый раз, когда вы выполняете `Invoke-Command`, PowerShell создает новую сессию, выполняет команду и закрывает ее. Это может быть неэффективно, если нужно выполнить много команд подряд. Для таких случаев можно создать **постоянную сессию (PSSession)**.

```powershell
# Создаем и сохраняем сессии в переменную
$mySessions = New-PSSession -ComputerName "SERVER01", "SERVER02"

# Теперь можно многократно использовать эти готовые сессии
Invoke-Command -Session $mySessions -ScriptBlock { Get-EventLog -LogName System -Newest 5 }
Invoke-Command -Session $mySessions -ScriptBlock { Restart-Service -Name Spooler -WhatIf }

# По завершении работы сессии нужно закрыть, чтобы освободить ресурсы на серверах
Remove-PSSession -Session $mySessions
```

#### **Запуск длительных операций в фоне: `Start-Job`**

Что делать, если команда выполняется очень долго? Например, вы копируете большой файл или запускаете сложный скрипт, который будет работать несколько часов. Не сидеть же все это время, глядя на мигающий курсор.

Для этого в PowerShell существуют **фоновые задачи (Jobs)**. Командлет `Start-Job` запускает блок кода в отдельном фоновом процессе (`powershell.exe`) на **вашей локальной машине**. Вы сразу же получаете управление консолью обратно и можете продолжать работать.

**Жизненный цикл фоновой задачи:**
1.  **Запуск (`Start-Job`):**
    ```powershell
    Start-Job -ScriptBlock {
        # Симулируем очень долгую операцию
        Start-Sleep -Seconds 60
        # Сохраняем результат в файл
        Get-Process | Out-File -FilePath "C:\Temp\proclist.txt"
    }
    ```
2.  **Проверка состояния (`Get-Job`):**
    `Get-Job` покажет список всех фоновых задач и их статус (`Running`, `Completed`, `Failed`, `Stopped`).
3.  **Получение результата (`Receive-Job`):**
    Когда задача завершится (статус `Completed`), вы можете забрать ее результат.
    ```powershell
    # Получаем результат задачи с ID 1
    $jobResult = Receive-Job -Id 1

    # Важно: по умолчанию после получения результат удаляется из кэша.
    # Чтобы посмотреть его, но оставить для будущего использования:
    Receive-Job -Id 1 -Keep
    ```
4.  **Остановка и удаление (`Stop-Job`, `Remove-Job`):**
    Если задача "зависла" или больше не нужна, ее можно принудительно остановить и удалить из списка.

**Комбинация: Удаленные фоновые задачи**
`Invoke-Command` имеет параметр `-AsJob`, который позволяет запустить команду на удаленных машинах и сразу же превратить ее в фоновую задачу на вашей локальной машине. Это невероятно мощно для запуска длительных операций на целой ферме серверов.
```powershell
$job = Invoke-Command -ComputerName (Get-Content C:\servers.txt) -ScriptBlock {
    # Запускаем сложный скрипт на каждой машине
    C:\Scripts\Defrag-And-Cleanup.ps1
} -AsJob

# Вы можете закрыть консоль, а задача продолжит выполняться
# Позже вы можете снова открыть PowerShell и проверить ее результат
$jobResult = Receive-Job -Id $job.Id```

**Итог главы:**
В этой главе мы вышли за пределы одного компьютера. Вы глубоко разобрали технологию PowerShell Remoting, научились управлять удаленными машинами с помощью интерактивных сессий (`Enter-PSSession`) и массово выполнять команды (`Invoke-Command`), передавая в них локальные переменные. Также вы освоили фоновые задачи (`Start-Job`) и их комбинацию с удаленным выполнением, что позволяет запускать и контролировать длительные операции на всей вашей IT-инфраструктуре.

**Это была последняя теоретическая глава. Теперь, вооружившись всем этим багажом знаний, мы готовы приступить к нашему практическому проекту — созданию графического приложения "CPU-монитор".**