
### **Часть 15: Проект "CPU-монитор" — Финальная сборка и дальнейшие шаги.**

Наш проект почти готов. Он выполняет свою основную функцию. Теперь давайте подумаем как инженер, а не просто как программист. Что может пойти не так? Как сделать приложение более отказоустойчивым? И какие горизонты открываются для его дальнейшего развития?

#### **Шаг 1: Добавление обработки ошибок с помощью `Try...Catch`**

Что произойдет в нашем коде, если по какой-то причине командлет `Get-Counter` не сможет получить данные? Например, если служба счетчиков производительности остановлена или повреждена. В текущей реализации наш скрипт просто аварийно завершится с ошибкой, что не очень хорошо для пользовательского приложения.

Давайте обернем "опасный" код в блок `Try...Catch`. Это стандартный механизм обработки исключений в PowerShell и многих других языках.

**Как это работает:**
*   Код внутри блока `try { ... }` выполняется в обычном режиме.
*   Если внутри `try` происходит **завершающая (terminating)** ошибка, выполнение блока `try` немедленно прекращается, и управление передается в блок `catch { ... }`.
*   Блок `catch` выполняется только в том случае, если произошла ошибка. Внутри него автоматическая переменная `$_` содержит объект с подробной информацией об ошибке.

**Практика: Делаем наш таймер отказоустойчивым**
Найдите обработчик события `$timer.add_Tick({ ... })` в вашем коде и измените его следующим образом:

```powershell
# Обновленный обработчик события Tick для таймера
$timer.add_Tick({
    try {
        # Код, который может вызвать ошибку, помещаем в блок try
        $cpuValue = (Get-Counter -Counter "\Processor(_Total)\% Processor Time" -ErrorAction Stop).CounterSamples.CookedValue
        $cpuValue = [math]::Round($cpuValue)

        # Обновляем интерфейс только если данные успешно получены
        $cpuLabel.Text = "$cpuValue %"
        $chart.Series["CPU"].Points.AddY($cpuValue)

        if ($chart.Series["CPU"].Points.Count -gt 60) {
            $chart.Series["CPU"].Points.RemoveAt(0)
        }
        # Если все хорошо, убедимся, что статус-метка не показывает ошибку
        if ($statusLabel.ForeColor -eq "Red") {
             $statusLabel.Text = "Мониторинг запущен..."
             $statusLabel.ForeColor = "Black"
        }
    }
    catch {
        # Этот блок выполнится, если Get-Counter выдаст ошибку
        $statusLabel.Text = "Ошибка: Не удалось получить данные счетчика CPU. ($_)"
        $statusLabel.ForeColor = [System.Drawing.Color]::Red # Выделяем ошибку красным цветом
    }
})
```
**Разбор ключевых моментов:**

*   **`-ErrorAction Stop`**: Это очень важный параметр. По умолчанию, многие ошибки в PowerShell (включая `Get-Counter`, если счетчик не найден) являются **незавершающими**. Они просто выводят ошибку в консоль, но не останавливают выполнение скрипта. Блок `try...catch` перехватывает только **завершающие** ошибки. Параметр `-ErrorAction Stop` "повышает" статус любой ошибки до завершающей, заставляя `catch` сработать.
*   **`$statusLabel.ForeColor`**: Мы используем свойство `ForeColor` у метки, чтобы визуально выделить сообщение об ошибке, покрасив его в красный цвет.
*   **`$_.ToString()`**: Внутри `catch` переменная `$_` содержит полноценный объект ошибки. Чтобы вывести краткое сообщение, мы преобразуем его в строку.

Теперь, если со счетчиками производительности возникнет проблема, наше приложение не "упадет", а вежливо сообщит об этом пользователю в строке состояния.

#### **Шаг 2: Советы по улучшению и дальнейшие шаги**

Наш проект — это отличная база, которую можно и нужно развивать. Вот несколько идей, которые вы можете реализовать самостоятельно, используя полученные за курс знания:

1.  **Мониторинг других параметров:**
    *   Добавьте на форму `CheckBox` для включения/отключения мониторинга других метрик.
    *   **Память:** Счетчик `\Memory\Available MBytes` (доступная память в МБ).
    *   **Диск:** Счетчик `\LogicalDisk(C:)\% Free Space` (процент свободного места на диске C:).
    *   Для каждой новой метрики создавайте свой `Series` на графике (`$chart.Series.Add(...)`) с разным цветом.

2.  **Сохранение графика в файл:**
    *   Добавьте на форму кнопку "Сохранить отчет".
    *   В обработчике ее нажатия используйте метод объекта `Chart`: `$chart.SaveImage("C:\Temp\cpu_report.png", "Png")`.

3.  **Логирование данных в CSV:**
    *   Внутри таймера, помимо добавления точки на график, можно дописывать данные в CSV-файл с помощью `Export-Csv -Append`. Это позволит позже анализировать производительность за длительный период.

4.  **Выбор компьютера для удаленного мониторинга:**
    *   Добавьте на форму текстовое поле `TextBox` для ввода имени удаленного компьютера.
    *   Передавайте это имя в `Get-Counter` с помощью параметра `-ComputerName`. `Get-Counter` отлично работает по сети!

#### **Подведение итогов курса. Куда двигаться дальше?**

Поздравляем! Вы прошли полный путь от ввода первой команды до создания полноценного графического приложения. Давайте вспомним, чему вы научились:

*   Вы поняли **фундаментальную философию PowerShell** — работу с объектами, а не с текстом.
*   Вы освоили **конвейер**, научились фильтровать, сортировать и выбирать данные.
*   Вы научились писать **логику** с помощью условий и циклов.
*   Вы перешли на новый уровень, создавая свои **функции** и упаковывая их в **модули**.
*   Вы научились взаимодействовать с внешним миром через **CSV и JSON**.
*   Вы освоили **удаленное управление** и **фоновые задачи**.
*   И, наконец, вы научились создавать **графические интерфейсы** на Windows Forms.

**Куда теперь?**

Мир PowerShell огромен, и ваше путешествие только началось. Вот возможные направления для дальнейшего роста:

*   **WPF (Windows Presentation Foundation):** Изучите более современную технологию для создания GUI. WPF позволяет создавать красивые, масштабируемые интерфейсы с помощью языка разметки XAML, отделяя логику от представления.
*   **Создание профессиональных модулей:** Изучите Pester (фреймворк для тестирования PowerShell), CI/CD для автоматической сборки и публикации ваших модулей в PowerShell Gallery.
*   **Интеграция с облаком и DevOps:** PowerShell является ключевым инструментом для автоматизации в **Azure**. Изучите модули `Az`. PowerShell также незаменим в сценариях DevOps для работы с такими инструментами, как Docker, Kubernetes, Ansible, Terraform.
*   **PowerShell для кросс-платформенной автоматизации:** Попробуйте использовать PowerShell на Linux или macOS для управления смешанными средами.

Вы получили прочный фундамент, продолжайте практиковаться, автоматизируйте рутинные задачи, и PowerShell станет вашим самым мощным союзником в мире IT. 

Удачи