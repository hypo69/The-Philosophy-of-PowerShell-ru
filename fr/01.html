<h2>Philosophie PowerShell.</h2>
<h2>Partie 0.</h2>
<p>Qu'y avait-il avant PowerShell ?
En 1981, MS-DOS 1.0 est sorti avec l'interpr√©teur de commandes <code>COMMAND.COM</code>. Pour l'automatisation des t√¢ches, on utilisait des <strong>fichiers batch (<code>.bat</code>)</strong> ‚Äî de simples fichiers texte avec une s√©quence de commandes console. L'asc√©tisme √©tonnant de la ligne de commande par rapport aux syst√®mes compatibles POSIX o√π le <strong>shell Bourne (<code>sh</code>)</strong> existait d√©j√† depuis 1979.</p>

<h3>üìÖ √âtat du march√© des shells au moment de la sortie de **MS-DOS 1.0** (ao√ªt 1981)</h3>

<p>Voici un tableau r√©capitulatif des syst√®mes d'exploitation populaires de l'√©poque et de leur support de shell (<code>sh</code>, <code>csh</code>, etc.) :</p>

<table>
<thead>
<tr>
<th>Syst√®me d'exploitation</th>
<th>Support de shell (<code>sh</code>, <code>csh</code>, etc.)</th>
<th>Commentaire</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UNIX Version 7 (V7)</strong></td>
<td><code>sh</code></td>
<td>Dernier UNIX classique de Bell Labs, largement distribu√©</td>
</tr>
<tr>
<td><strong>UNIX/32V</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>Version UNIX pour l'architecture VAX</td>
</tr>
<tr>
<td><strong>4BSD / 3BSD</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>Branche universitaire d'UNIX de Berkeley</td>
</tr>
<tr>
<td><strong>UNIX System III</strong></td>
<td><code>sh</code></td>
<td>Premi√®re version commerciale d'AT&amp;T, pr√©d√©cesseur de System V</td>
</tr>
<tr>
<td><strong>Xenix (de Microsoft)</strong></td>
<td><code>sh</code></td>
<td>Version UNIX sous licence, vendue par Microsoft depuis 1980</td>
</tr>
<tr>
<td><strong>IDRIS</strong></td>
<td><code>sh</code></td>
<td>OS de type UNIX pour PDP-11 et Intel</td>
</tr>
<tr>
<td><strong>Coherent (Mark Williams)</strong></td>
<td><code>sh</code> (similaire)</td>
<td>Alternative UNIX peu co√ªteuse pour PC</td>
</tr>
<tr>
<td><strong>CP/M (Digital Research)</strong></td>
<td>‚ùå (Pas de <code>sh</code>, seulement CLI simple)</td>
<td>Pas UNIX, OS le plus populaire pour les PC 8 bits</td>
</tr>
<tr>
<td><strong>MS-DOS 1.0</strong></td>
<td>‚ùå (seulement <code>COMMAND.COM</code>)</td>
<td>Shell de commande minimale, pas de scripts ni de pipes</td>
</tr>
</tbody>
</table>

<hr />

<h3>üí° Qu'est-ce que <code>sh</code>, <code>csh</code></h3>

<ul>
<li><code>sh</code> ‚Äî <strong>Bourne Shell</strong>, l'interpr√©teur de scripts UNIX principal depuis 1977.</li>
<li><code>csh</code> ‚Äî <strong>C Shell</strong>, un shell am√©lior√© avec une syntaxe similaire √† C et des commodit√©s pour le travail interactif.</li>
<li>Ces shells <strong>supportaient les redirections, les pipes, les variables, les fonctions et les conditions</strong> ‚Äî tout ce qui a fait d'UNIX un outil d'automatisation puissant.</li>
</ul>

<hr />

<p>Microsoft s'est concentr√© sur les <strong>PC IBM 16 bits bon march√©</strong>, qui avaient <strong>peu de m√©moire</strong> (g√©n√©ralement 64‚Äì256 Ko), manquaient de multit√¢che et √©taient destin√©s √† un <strong>usage domestique et bureautique</strong>, et non √† des serveurs. UNIX √©tait cher, n√©cessitait une architecture complexe et de l'expertise, tandis que les comptables et les ing√©nieurs, et non les administrateurs syst√®me, avaient besoin d'un syst√®me d'exploitation rapide et simple.</p>

<p>L'interface DOS, au lieu du <code>sh</code> complexe, pr√©sentait un seul fichier command.com avec un ensemble maigre de commandes internes (<a href="https://www.techgeekbuzz.com/blog/dos-commands/" target="_blank">dir, copy, del, etc.</a>) sans fonctions, boucles ou modules.</p>

<p>Il y avait aussi des commandes externes ‚Äî des fichiers ex√©cutables s√©par√©s (.exe ou .com). Exemples : FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Les scripts d'ex√©cution √©taient √©crits dans un fichier texte avec l'extension .bat (fichier batch).</p>

<p>Exemples de fichiers de configuration :</p>

<ul>
<li>AUTOEXEC.BAT</li>
</ul>

<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Configuration automatique et lancement de Windows 3.11
:: Auteur : hypo69
:: Ann√©e : environ 1993
:: Objectif : Effectue l'initialisation de l'environnement DOS, charge les pilotes r√©seau et lance Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Configuration de l'invite de commande
PROMPT $p$g

:: Configuration des variables d'environnement
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Chargement des pilotes et utilitaires en m√©moire sup√©rieure
LH C:\DOS\SMARTDRV.EXE       :: Cache disque
LH C:\DOS\MOUSE.COM          :: Pilote de souris

:: Chargement des services r√©seau (pertinent pour Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Lancement automatique de Windows
WIN

</code></pre>

<ul>
<li>CONFIG.SYS</li>
</ul>

<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî Configuration de la m√©moire et des pilotes DOS pour Windows 3.11
:: Auteur : hypo69
:: Ann√©e : environ 1993
:: Objectif : Initialise les pilotes de m√©moire, configure les param√®tres syst√®me
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE

</code></pre>

<p>Chez Microsoft, parall√®lement √† DOS, un nouveau noyau a commenc√© √† √™tre d√©velopp√© presque imm√©diatement.</p>

<p>Le noyau <a href="https://www.wikiwand.com/ru/articles/Windows_NT" target="_blank"><strong>Windows NT</strong></a> (New Technology) est apparu pour la premi√®re fois avec la sortie du syst√®me d'exploitation :

<blockquote>
<p><strong>Windows NT 3.1 ‚Äî 27 juillet 1993</strong></p>
</blockquote>

<hr />

<ul>
<li><strong>Le d√©veloppement a commenc√©</strong> : en <strong>1988</strong> sous la direction de <strong>Dave Cutler</strong> (ancien ing√©nieur de DEC, cr√©ateur de VMS) dans le but de cr√©er un syst√®me d'exploitation enti√®rement nouveau, s√©curis√©, portable et multit√¢che, non compatible avec MS-DOS au niveau du noyau.</li>
<li><strong>NT 3.1</strong> ‚Äî a √©t√© nomm√© ainsi pour souligner la compatibilit√© avec <strong>Windows 3.1</strong> au niveau de l'interface, mais avait une <strong>architecture compl√®tement nouvelle</strong>.</li>
</ul>

<hr />

<h4>üß† Ce qu'a apport√© le noyau NT :</h4>

<table>
<thead>
<tr>
<th>Caract√©ristique</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Architecture 32 bits</strong></td>
<td>Contrairement √† MS-DOS et Windows 3.x, qui √©taient en 16 bits.</td>
</tr>
<tr>
<td><strong>Multit√¢che</strong></td>
<td>V√©ritable multit√¢che pr√©emptif.</td>
</tr>
<tr>
<td><strong>M√©moire prot√©g√©e</strong></td>
<td>Les programmes ne pouvaient pas corrompre la m√©moire les uns des autres.</td>
</tr>
<tr>
<td><strong>Modularit√©</strong></td>
<td>Architecture de noyau multicouche : HAL, Executive, Kernel, pilotes.</td>
</tr>
<tr>
<td><strong>Support multiplateforme</strong></td>
<td>NT 3.1 fonctionnait sur x86, MIPS et Alpha.</td>
</tr>
<tr>
<td><strong>Compatibilit√© POSIX</strong></td>
<td>NT √©tait livr√© avec un <strong>sous-syst√®me POSIX</strong>, certifi√© POSIX.1.</td>
</tr>
</tbody>
</table>

<hr />

<h4>üìú Ligne de produits NT :</h4>

<table>
<thead>
<tr>
<th>Version NT</th>
<th>Ann√©e</th>
<th>Commentaire</th>
</tr>
</thead>
<tbody>
<tr>
<td>NT 3.1</td>
<td>1993</td>
<td>Premi√®re version de NT</td>
</tr>
<tr>
<td>NT 3.5 / 3.51</td>
<td>1994‚Äì1995</td>
<td>Am√©liorations, optimisation</td>
</tr>
<tr>
<td>NT 4.0</td>
<td>1996</td>
<td>Interface Windows 95, mais noyau NT</td>
</tr>
<tr>
<td>Windows 2000</td>
<td>2000</td>
<td>NT 5.0</td>
</tr>
<tr>
<td>Windows XP</td>
<td>2001</td>
<td>NT 5.1</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>2007</td>
<td>NT 6.0</td>
</tr>
<tr>
<td>Windows 10</td>
<td>2015</td>
<td>NT 10.0</td>
</tr>
<tr>
<td>Windows 11</td>
<td>2021</td>
<td>Aussi NT 10.0 (marketing üòä)</td>
</tr>
</tbody>
</table>

<hr />

<p>Diff√©rence de capacit√©s des syst√®mes d'exploitation :</p>

<table>
<thead>
<tr>
<th>Caract√©ristique</th>
<th><strong>MS-DOS</strong> (1981)</th>
<th><strong>Windows NT</strong> (1993)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Type de syst√®me</strong></td>
<td>Monolithique, monot√¢che</td>
<td>Micro-noyau/hybride, multit√¢che</td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td>16 bits</td>
<td>32 bits (avec support 64 bits √† partir de NT 5.2 / XP x64)</td>
</tr>
<tr>
<td><strong>Multit√¢che</strong></td>
<td>‚ùå Absent (un processus √† la fois)</td>
<td>‚úÖ Multit√¢che pr√©emptif</td>
</tr>
<tr>
<td><strong>M√©moire prot√©g√©e</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Oui (chaque processus dans son propre espace d'adressage)</td>
</tr>
<tr>
<td><strong>Mode multi-utilisateur</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Partiellement (dans NT Workstation/Server)</td>
</tr>
<tr>
<td><strong>Compatibilit√© POSIX</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Sous-syst√®me POSIX int√©gr√© dans NT 3.1‚Äì5.2</td>
</tr>
<tr>
<td><strong>Portabilit√© du noyau</strong></td>
<td>‚ùå x86 uniquement</td>
<td>‚úÖ x86, MIPS, Alpha, PowerPC</td>
</tr>
<tr>
<td><strong>Pilotes</strong></td>
<td>Acc√®s direct au mat√©riel</td>
<td>Via HAL et pilotes en mode noyau</td>
</tr>
<tr>
<td><strong>Niveau d'acc√®s des applications</strong></td>
<td>Applications = niveau syst√®me</td>
<td>Niveau utilisateur / noyau s√©par√©s</td>
</tr>
<tr>
<td><strong>S√©curit√©</strong></td>
<td>‚ùå Absent</td>
<td>‚úÖ Mod√®le de s√©curit√© : SID, ACL, jetons d'acc√®s</td>
</tr>
<tr>
<td><strong>Stabilit√©</strong></td>
<td>‚ùå D√©pendance d'un programme = crash OS</td>
<td>‚úÖ Isolation des processus, protection du noyau</td>
</tr>
</tbody>
</table>

<hr />

<p>Mais il y avait un grand MAIS ! Les outils d'automatisation et d'administration n'ont pas re√ßu l'attention voulue avant 2002.</p>

<hr />

<p>Microsoft a utilis√© des approches, des strat√©gies et des outils compl√®tement diff√©rents pour l'administration. Tout cela √©tait <strong>d√©cousu</strong>, souvent orient√© GUI et pas toujours automatisable.</p>

<hr />

<h5>üìå Liste de quelques outils :</h5>

<table>
<thead>
<tr>
<th>Outil</th>
<th>Objectif</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmd.exe</code></td>
<td>Interpr√©teur de commandes am√©lior√© (remplacement de <code>COMMAND.COM</code>)</td>
</tr>
<tr>
<td><code>.bat</code>, <code>.cmd</code></td>
<td>Scripts de ligne de commande</td>
</tr>
<tr>
<td><strong>Windows Script Host (WSH)</strong></td>
<td>Support de VBScript et JScript pour l'automatisation</td>
</tr>
<tr>
<td><code>reg.exe</code></td>
<td>Gestion du registre depuis la ligne de commande</td>
</tr>
<tr>
<td><code>net.exe</code></td>
<td>Travailler avec les utilisateurs, le r√©seau, les imprimantes</td>
</tr>
<tr>
<td><code>sc.exe</code></td>
<td>Gestion des services</td>
</tr>
<tr>
<td><code>tasklist</code>, <code>taskkill</code></td>
<td>Gestion des processus</td>
</tr>
<tr>
<td><code>gpedit.msc</code></td>
<td>Strat√©gie de groupe (locale)</td>
</tr>
<tr>
<td><code>MMC</code></td>
<td>Console avec des snap-ins pour la gestion</td>
</tr>
<tr>
<td><code>WMI</code></td>
<td>Acc√®s aux informations syst√®me (via <code>wmic</code>, VBScript ou COM)</td>
</tr>
<tr>
<td><code>WbemTest.exe</code></td>
<td>GUI pour tester les requ√™tes WMI</td>
</tr>
<tr>
<td><code>eventvwr</code></td>
<td>Visionneuse des journaux d'√©v√©nements</td>
</tr>
<tr>
<td><code>perfmon</code></td>
<td>Surveillance des ressources</td>
</tr>
</tbody>
</table>

<h5>üõ† Exemples d'automatisation :</h5>

<ul>
<li>Fichiers VBScript (`*.vbs`) pour l'administration des utilisateurs, des r√©seaux, des imprimantes et des services.</li>
<li><code>WMIC</code> ‚Äî interface en ligne de commande pour WMI (par exemple : `wmic process list brief`).
<li>Scripts <code>.cmd</code> avec des appels √† <code>net</code>, <code>sc</code>, <code>reg</code>, <code>wmic</code>, etc.</li>
</ul>

<hr />

<h3>‚öôÔ∏è Windows Scripting Host (WSH)</h3>

<ul>
<li>Apparu pour la premi√®re fois dans <strong>Windows 98</strong>, activement utilis√© dans <strong>Windows 2000 et XP</strong>.</li>
<li>Permettait d'ex√©cuter des fichiers VBScript et JScript depuis la ligne de commande :

  ```vbscript
  Set objShell = WScript.CreateObject("WScript.Shell")
  objShell.Run "notepad.exe"
  ```

<hr />
<h2>Partie 1.</h2>

<p>Ce n'est qu'en 2002 que la soci√©t√© a formul√© le projet <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, qui a ensuite √©volu√© en PowerShell :</p>

<p>D√©but du d√©veloppement : environ en 2002</p>

<p>Annonce publique : 2003, sous le nom de "Monad Shell"</p>

<p>Premi√®res versions b√™ta : apparues en 2005</p>

<p>Version finale (PowerShell 1.0) : novembre 2006</p>

<p>L'auteur et architecte en chef du projet Monad / PowerShell est Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a></p>

<p>Aujourd'hui, PowerShell Core fonctionne sur
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a></p>

<p>Parall√®lement, le framework .NET √©tait en cours de d√©veloppement, et PowerShell y a √©t√© profond√©ment int√©gr√© ; dans les chapitres suivants, je montrerai des exemples.</p>

<p>Et maintenant ‚Äî le plus important !</p>

<p>Le principal avantage de PowerShell par rapport aux shells de commande classiques est qu'il fonctionne avec des <em>objets</em>, et non du texte. Lorsque vous ex√©cutez une commande, elle ne vous renvoie pas seulement du texte, mais un objet structur√© (ou une collection d'objets) qui a des propri√©t√©s et des m√©thodes clairement d√©finies.</p>

<p>Voyez comment PowerShell surpasse les shells classiques gr√¢ce au **travail avec des objets**.</p>

<h3>üìÅ Comment c'√©tait : <code>dir</code> et analyse manuelle</h3>

<p>Dans **CMD** (√† la fois dans l'ancien <code>COMMAND.COM</code> et dans <code>cmd.exe</code>), la commande <code>dir</code> renvoie le r√©sultat sous forme de texte brut. Exemple de sortie :

```
24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
```

<p>Supposons que vous vouliez extraire le **nom de fichier** et la **taille** de chaque fichier. Vous devrez analyser les lignes manuellement :
<pre class="line-numbers"><code class="language-cmd">for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
</code></pre>

<ul>
<li>C'est terriblement difficile √† lire, d√©pend de la locale, du format de date, de la police. Et se casse avec des espaces dans les noms.</li>
</ul>

<hr />

<h3>‚úÖ PowerShell : des objets au lieu du texte</h3>

<h4>‚úî Exemple simple et lisible :</h4>

<pre class="line-numbers"><code class="language-powershell">Get-ChildItem | Select-Object Name, Length
</code></pre>

<p><strong>R√©sultat :</strong></p>

<pre class="line-numbers"><code class="language-text">Name          Length
----          ------
my_script.js   1428
report.html    3980
</code></pre>

<ul>
<li><code>Get-ChildItem</code> renvoie un **tableau d'objets fichier/dossier**</li>
<li><code>Select-Object</code> vous permet d'obtenir facilement les **propri√©t√©s** n√©cessaires</li>
</ul>

<hr />

<h3>üîç Que renvoie r√©ellement <code>Get-ChildItem</code> ?</h3>

<pre class="line-numbers"><code class="language-powershell">$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
</code></pre>

<p><strong>R√©sultat :</strong></p>

<pre class="line-numbers"><code class="language-text">TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
</code></pre>

<p>PowerShell renvoie des **objets de type <code>System.IO.FileInfo</code>**, qui ont :

<ul>
<li>üß± Propri√©t√©s (<code>Name</code>, <code>Length</code>, <code>CreationTime</code>, <code>Extension</code>, ‚Ä¶)</li>
<li>üõ† M√©thodes (<code>Delete()</code>, <code>CopyTo()</code>, <code>MoveTo()</code> etc.)</li>
</ul>

<p>Vous travaillez **avec des objets √† part enti√®re**, pas avec des cha√Ænes de caract√®res.</p>

<hr />

<p>### Syntaxe "Verbe-Nom" :</p>

<p>PowerShell utilise une **syntaxe de commande stricte et logique** :
<code>Verbe-Nom</code></p>

<table>
<thead>
<tr>
<th>Verbe</th>
<th>Ce qu'il fait</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Get-</code></td>
<td>Obtenir</td>
</tr>
<tr>
<td><code>Set-</code></td>
<td>D√©finir</td>
</tr>
<tr>
<td><code>New-</code></td>
<td>Cr√©er</td>
</tr>
<tr>
<td><code>Remove-</code></td>
<td>Supprimer</td>
</tr>
<tr>
<td><code>Start-</code></td>
<td>D√©marrer</td>
</tr>
<tr>
<td><code>Stop-</code></td>
<td>Arr√™ter</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Nom</th>
<th>Sur quoi il travaille</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Process</code></td>
<td>Processus</td>
</tr>
<tr>
<td><code>Service</code></td>
<td>Service</td>
</tr>
<tr>
<td><code>Item</code></td>
<td>Fichier/dossier</td>
</tr>
<tr>
<td><code>EventLog</code></td>
<td>Journaux d'√©v√©nements</td>
</tr>
<tr>
<td><code>Computer</code></td>
<td>Ordinateur</td>
</tr>
</tbody>
</table>

<h4>üîÑ Exemples:</h4>

<table>
<thead>
<tr>
<th>Ce qu'il faut faire</th>
<th>Commande</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obtenir les processus</td>
<td><code>Get-Process</code></td>
</tr>
<tr>
<td>Arr√™ter le service</td>
<td><code>Stop-Service</code></td>
</tr>
<tr>
<td>Cr√©er un nouveau fichier</td>
<td><code>New-Item</code></td>
</tr>
<tr>
<td>Obtenir le contenu du dossier</td>
<td><code>Get-ChildItem</code></td>
</tr>
<tr>
<td>Supprimer le fichier</td>
<td><code>Remove-Item</code></td>
</tr>
</tbody>
</table>

<p>‚û° M√™me si vous <strong>ne connaissez pas la commande exacte</strong>, vous pouvez la **deviner** par son sens ‚Äî et vous aurez presque toujours raison.</p>

<hr />

<p>Le cmdlet <code>Get-Help</code> est votre principal assistant.</p>

<ol>
<li><strong>Obtenir de l'aide sur l'aide elle-m√™me :</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Help
</code></pre>
</li>
<li><strong>Obtenir de l'aide de base sur la commande pour travailler avec les processus :</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process
</code></pre>
</li>
<li><strong>Voir des exemples d'utilisation de cette commande :</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Examples
</code></pre>
<p>C'est un param√®tre incroyablement utile qui fournit souvent des solutions pr√™tes √† l'emploi pour vos t√¢ches.</p>
</li>
<li><strong>Obtenir les informations les plus d√©taill√©es sur la commande :</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Full
</code></pre>
</li>
</ol>

<p>Dans la partie suivante : pipeline ou cha√Æne de commandes (PipeLines)</p>