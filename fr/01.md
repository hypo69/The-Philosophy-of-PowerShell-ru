# Philosophie PowerShell.
## Partie 0.
Qu'y avait-il avant PowerShell ?
En 1981, MS-DOS 1.0 est sorti avec l'interpr√©teur de commandes `COMMAND.COM`. Pour l'automatisation des t√¢ches, on utilisait des **fichiers batch (`.bat`)** ‚Äî de simples fichiers texte avec une s√©quence de commandes console. L'asc√©tisme √©tonnant de la ligne de commande par rapport aux syst√®mes compatibles POSIX o√π le **shell Bourne (`sh`)** existait d√©j√† depuis 1979.



### üìÖ √âtat du march√© des shells au moment de la sortie de **MS-DOS 1.0** (ao√ªt 1981)

Voici un tableau r√©capitulatif des syst√®mes d'exploitation populaires de l'√©poque et de leur support de shell (`sh`, `csh`, etc.) :

| Syst√®me d'exploitation         | Support de shell (`sh`, `csh`, etc.) | Commentaire                                                  |
| ---------------------------- | ------------------------------------ | ------------------------------------------------------------ |
| **UNIX Version 7 (V7)**      | `sh`                                 | Dernier UNIX classique de Bell Labs, largement distribu√©    |
| **UNIX/32V**                 | `sh`, `csh`                          | Version UNIX pour l'architecture VAX                         |
| **4BSD / 3BSD**              | `sh`, `csh`                          | Branche universitaire d'UNIX de Berkeley                     |
| **UNIX System III**          | `sh`                                 | Premi√®re version commerciale d'AT&T, pr√©d√©cesseur de System V |
| **Xenix (de Microsoft)**     | `sh`                                 | Version UNIX sous licence, vendue par Microsoft depuis 1980 |
| **IDRIS**                    | `sh`                                 | OS de type UNIX pour PDP-11 et Intel                         |
| **Coherent (Mark Williams)** | `sh` (similaire)                     | Alternative UNIX peu co√ªteuse pour PC                        |
| **CP/M (Digital Research)**  | ‚ùå (Pas de `sh`, seulement CLI simple) | Pas UNIX, OS le plus populaire pour les PC 8 bits            |
| **MS-DOS 1.0**               | ‚ùå (seulement `COMMAND.COM`)          | Shell de commande minimale, pas de scripts ni de pipes       |

---

### üí° Qu'est-ce que `sh`, `csh`

* `sh` ‚Äî **Bourne Shell**, l'interpr√©teur de scripts UNIX principal depuis 1977.
* `csh` ‚Äî **C Shell**, un shell am√©lior√© avec une syntaxe similaire √† C et des commodit√©s pour le travail interactif.
* Ces shells **supportaient les redirections, les pipes, les variables, les fonctions et les conditions** ‚Äî tout ce qui a fait d'UNIX un outil d'automatisation puissant.

---

Microsoft s'est concentr√© sur les **PC IBM 16 bits bon march√©**, qui avaient **peu de m√©moire** (g√©n√©ralement 64‚Äì256 Ko), manquaient de multit√¢che et √©taient destin√©s √† un **usage domestique et bureautique**, et non √† des serveurs. UNIX √©tait cher, n√©cessitait une architecture complexe et de l'expertise, tandis que les comptables et les ing√©nieurs, et non les administrateurs syst√®me, avaient besoin d'un syst√®me d'exploitation rapide et simple.

L'interface DOS, au lieu du `sh` complexe, pr√©sentait un seul fichier command.com avec un ensemble maigre de commandes internes [ (dir, copy, del, etc.)](https://www.techgeekbuzz.com/blog/dos-commands/){:target="_blank"} sans fonctions, boucles ou modules.

Il y avait aussi des commandes externes ‚Äî des fichiers ex√©cutables s√©par√©s (.exe ou .com). Exemples : FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Les scripts d'ex√©cution √©taient √©crits dans un fichier texte avec l'extension .bat (fichier batch).

Exemples de fichiers de configuration :

- AUTOEXEC.BAT

```bash
:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Configuration automatique et lancement de Windows 3.11
:: Auteur : hypo69
:: Ann√©e : environ 1993
:: Objectif : Effectue l'initialisation de l'environnement DOS, charge les pilotes r√©seau et lance Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Configuration de l'invite de commande
PROMPT $p$g

:: Configuration des variables d'environnement
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Chargement des pilotes et utilitaires en m√©moire sup√©rieure
LH C:\DOS\SMARTDRV.EXE       :: Cache disque
LH C:\DOS\MOUSE.COM          :: Pilote de souris

:: Chargement des services r√©seau (pertinent pour Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Lancement automatique de Windows
WIN

```
- CONFIG.SYS
```bash
:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî Configuration de la m√©moire et des pilotes DOS pour Windows 3.11
:: Auteur : hypo69
:: Ann√©e : environ 1993
:: Objectif : Initialise les pilotes de m√©moire, configure les param√®tres syst√®me
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE

```

Chez Microsoft, parall√®lement √† DOS, un nouveau noyau a commenc√© √† √™tre d√©velopp√© presque imm√©diatement.

Le noyau [**Windows NT**](https://www.wikiwand.com/ru/articles/Windows_NT){:target="_blank"} (New Technology) est apparu pour la premi√®re fois avec la sortie du syst√®me d'exploitation :

> **Windows NT 3.1 ‚Äî 27 juillet 1993**

---

* **Le d√©veloppement a commenc√©** : en **1988** sous la direction de **Dave Cutler** (ancien ing√©nieur de DEC, cr√©ateur de VMS) dans le but de cr√©er un syst√®me d'exploitation enti√®rement nouveau, s√©curis√©, portable et multit√¢che, non compatible avec MS-DOS au niveau du noyau.
* **NT 3.1** ‚Äî a √©t√© nomm√© ainsi pour souligner la compatibilit√© avec **Windows 3.1** au niveau de l'interface, mais avait une **architecture compl√®tement nouvelle**.

---

#### üß† Ce qu'a apport√© le noyau NT :

| Caract√©ristique                    | Description                                                           |
| ---------------------------------- | --------------------------------------------------------------------- |
| **Architecture 32 bits**           | Contrairement √† MS-DOS et Windows 3.x, qui √©taient en 16 bits.        |
| **Multit√¢che**                     | V√©ritable multit√¢che pr√©emptif.                                       |
| **M√©moire prot√©g√©e**              | Les programmes ne pouvaient pas corrompre la m√©moire les uns des autres. |
| **Modularit√©**                     | Architecture de noyau multicouche : HAL, Executive, Kernel, pilotes.  |
| **Support multiplateforme**        | NT 3.1 fonctionnait sur x86, MIPS et Alpha.                           |
| **Compatibilit√© POSIX**            | NT √©tait livr√© avec un **sous-syst√®me POSIX**, certifi√© POSIX.1.      |

---

#### üìú Ligne de produits NT :

| Version NT    | Ann√©e       | Commentaire                          |
| ------------- | ----------- | ------------------------------------ |
| NT 3.1        | 1993        | Premi√®re version de NT               |
| NT 3.5 / 3.51 | 1994‚Äì1995   | Am√©liorations, optimisation          |
| NT 4.0        | 1996        | Interface Windows 95, mais noyau NT  |
| Windows 2000  | 2000        | NT 5.0                               |
| Windows XP    | 2001        | NT 5.1                               |
| Windows Vista | 2007        | NT 6.0                               |
| Windows 10    | 2015        | NT 10.0                              |
| Windows 11    | 2021        | Aussi NT 10.0 (marketing üòä)         |

---

Diff√©rence de capacit√©s des syst√®mes d'exploitation :

| Caract√©ristique                 | **MS-DOS** (1981)                       | **Windows NT** (1993)                               |
| ------------------------------- | --------------------------------------- | --------------------------------------------------- |
| **Type de syst√®me**             | Monolithique, monot√¢che                 | Micro-noyau/hybride, multit√¢che                     |
| **Bits**                        | 16 bits                                 | 32 bits (avec support 64 bits √† partir de NT 5.2 / XP x64) |
| **Multit√¢che**                  | ‚ùå Absent (un processus √† la fois)      | ‚úÖ Multit√¢che pr√©emptif                             |
| **M√©moire prot√©g√©e**           | ‚ùå Non                                  | ‚úÖ Oui (chaque processus dans son propre espace d'adressage) |
| **Mode multi-utilisateur**      | ‚ùå Non                                  | ‚úÖ Partiellement (dans NT Workstation/Server)       |
| **Compatibilit√© POSIX**         | ‚ùå Non                                  | ‚úÖ Sous-syst√®me POSIX int√©gr√© dans NT 3.1‚Äì5.2       |
| **Portabilit√© du noyau**        | ‚ùå x86 uniquement                       | ‚úÖ x86, MIPS, Alpha, PowerPC                        |
| **Pilotes**                     | Acc√®s direct au mat√©riel                | Via HAL et pilotes en mode noyau                    |
| **Niveau d'acc√®s des applications** | Applications = niveau syst√®me           | Niveau utilisateur / noyau s√©par√©s                  |
| **S√©curit√©**                    | ‚ùå Absent                               | ‚úÖ Mod√®le de s√©curit√© : SID, ACL, jetons d'acc√®s    |
| **Stabilit√©**                   | ‚ùå D√©pendance d'un programme = crash OS | ‚úÖ Isolation des processus, protection du noyau     |

---

Mais il y avait un grand MAIS ! Les outils d'automatisation et d'administration n'ont pas re√ßu l'attention voulue avant 2002.

---

Microsoft a utilis√© des approches, des strat√©gies et des outils compl√®tement diff√©rents pour l'administration. Tout cela √©tait **d√©cousu**, souvent orient√© GUI et pas toujours automatisable.

---

##### üìå Liste de quelques outils :

| Outil                         | Objectif                                                        |
| ----------------------------- | --------------------------------------------------------------- |
| `cmd.exe`                     | Interpr√©teur de commandes am√©lior√© (remplacement de `COMMAND.COM`) |
| `.bat`, `.cmd`                | Scripts de ligne de commande                                    |
| **Windows Script Host (WSH)** | Support de VBScript et JScript pour l'automatisation            |
| `reg.exe`                     | Gestion du registre depuis la ligne de commande                  |
| `net.exe`                     | Travailler avec les utilisateurs, le r√©seau, les imprimantes    |
| `sc.exe`                      | Gestion des services                                            |
| `tasklist`, `taskkill`        | Gestion des processus                                           |
| `gpedit.msc`                  | Strat√©gie de groupe (locale)                                    |
| `MMC`                         | Console avec des snap-ins pour la gestion                       |
| `WMI`                         | Acc√®s aux informations syst√®me (via `wmic`, VBScript ou COM)    |
| `WbemTest.exe`                | GUI pour tester les requ√™tes WMI                                |
| `eventvwr`                    | Visionneuse des journaux d'√©v√©nements                           |
| `perfmon`                     | Surveillance des ressources                                     |

##### üõ† Exemples d'automatisation :

* Fichiers VBScript (`*.vbs`) pour l'administration des utilisateurs, des r√©seaux, des imprimantes et des services.
* `WMIC` ‚Äî interface en ligne de commande pour WMI (par exemple : `wmic process list brief`).
* Scripts `.cmd` avec des appels √† `net`, `sc`, `reg`, `wmic`, etc.

---

### ‚öôÔ∏è Windows Scripting Host (WSH)

* Apparu pour la premi√®re fois dans **Windows 98**, activement utilis√© dans **Windows 2000 et XP**.
* Permettait d'ex√©cuter des fichiers VBScript et JScript depuis la ligne de commande :

  ```vbscript
  Set objShell = WScript.CreateObject("WScript.Shell")
  objShell.Run "notepad.exe"
  ```

---
## Partie 1.

Ce n'est qu'en 2002 que la soci√©t√© a formul√© le projet <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, qui a ensuite √©volu√© en PowerShell :

D√©but du d√©veloppement : environ en 2002

Annonce publique : 2003, sous le nom de "Monad Shell"

Premi√®res versions b√™ta : apparues en 2005

Version finale (PowerShell 1.0) : novembre 2006

L'auteur et architecte en chef du projet Monad / PowerShell est Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a>

Aujourd'hui, PowerShell Core fonctionne sur
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a>

Parall√®lement, le framework .NET √©tait en cours de d√©veloppement, et PowerShell y a √©t√© profond√©ment int√©gr√© ; dans les chapitres suivants, je montrerai des exemples.

Et maintenant ‚Äî le plus important !

Le principal avantage de PowerShell par rapport aux shells de commande classiques est qu'il fonctionne avec des *objets*, et non du texte. Lorsque vous ex√©cutez une commande, elle ne vous renvoie pas seulement du texte, mais un objet structur√© (ou une collection d'objets) qui a des propri√©t√©s et des m√©thodes clairement d√©finies.

Voyez comment PowerShell surpasse les shells classiques gr√¢ce au **travail avec des objets**.

### üìÅ Comment c'√©tait : `dir` et analyse manuelle

Dans **CMD** (√† la fois dans l'ancien `COMMAND.COM` et dans `cmd.exe`), la commande `dir` renvoie le r√©sultat sous forme de texte brut. Exemple de sortie :

```
24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
```

Supposons que vous vouliez extraire le **nom de fichier** et la **taille** de chaque fichier. Vous devrez analyser les lignes manuellement :
```cmd
for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
```

* C'est terriblement difficile √† lire, d√©pend de la locale, du format de date, de la police. Et se casse avec des espaces dans les noms.

---

### ‚úÖ PowerShell : des objets au lieu du texte

#### ‚úî Exemple simple et lisible :

```powershell
Get-ChildItem | Select-Object Name, Length
```

**R√©sultat :**

```
Name          Length
----          ------
my_script.js   1428
report.html    3980
```

* `Get-ChildItem` renvoie un **tableau d'objets fichier/dossier**
* `Select-Object` vous permet d'obtenir facilement les **propri√©t√©s** n√©cessaires

---

### üîç Que renvoie r√©ellement `Get-ChildItem` ?

```powershell
$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
```

**R√©sultat :**

```
TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
```

PowerShell renvoie des **objets de type `System.IO.FileInfo`**, qui ont :

* üß± Propri√©t√©s (`Name`, `Length`, `CreationTime`, `Extension`, ‚Ä¶)
* üõ† M√©thodes (`Delete()`, `CopyTo()`, `MoveTo()` etc.)

Vous travaillez **avec des objets √† part enti√®re**, pas avec des cha√Ænes de caract√®res.

---

### Syntaxe "Verbe-Nom" :

PowerShell utilise une **syntaxe de commande stricte et logique** :
`Verbe-Nom`

| Verbe     | Ce qu'il fait |
| --------- | ------------- |
| `Get-`    | Obtenir       |
| `Set-`    | D√©finir       |
| `New-`    | Cr√©er         |
| `Remove-` | Supprimer     |
| `Start-`  | D√©marrer      |
| `Stop-`   | Arr√™ter       |

| Nom           | Sur quoi il travaille |
| ------------- | --------------------- |
| `Process`     | Processus             |
| `Service`     | Service               |
| `Item`        | Fichier/dossier       |
| `EventLog`    | Journaux d'√©v√©nements |
| `Computer`    | Ordinateur            |

#### üîÑ Exemples :

| Ce qu'il faut faire         | Commande         |
| --------------------------- | ---------------- |
| Obtenir les processus       | `Get-Process`    |
| Arr√™ter le service          | `Stop-Service`   |
| Cr√©er un nouveau fichier    | `New-Item`       |
| Obtenir le contenu du dossier | `Get-ChildItem`  |
| Supprimer le fichier        | `Remove-Item`    |

‚û° M√™me si vous **ne connaissez pas la commande exacte**, vous pouvez la **deviner** par son sens ‚Äî et vous aurez presque toujours raison.


---

Le cmdlet `Get-Help` est votre principal assistant.


1.  **Obtenir de l'aide sur l'aide elle-m√™me :**
    ```powershell
    Get-Help Get-Help
    ```
2.  **Obtenir de l'aide de base sur la commande pour travailler avec les processus :**
    ```powershell
    Get-Help Get-Process
    ```
3.  **Voir des exemples d'utilisation de cette commande :**
    ```powershell
    Get-Help Get-Process -Examples
    ```
    C'est un param√®tre incroyablement utile qui fournit souvent des solutions pr√™tes √† l'emploi pour vos t√¢ches.
4.  **Obtenir les informations les plus d√©taill√©es sur la commande :**
    ```powershell
    Get-Help Get-Process -Full
    ```
Dans la partie suivante : pipeline ou cha√Æne de commandes (PipeLines)