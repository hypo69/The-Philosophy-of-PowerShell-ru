<h1>La Philosophie de PowerShell.</h1>
<h2>Partie 0.</h2>
<p>Qu'y avait-il avant PowerShell ?
En 1981, MS-DOS 1.0 est sorti avec l'interpr√©teur de commandes <code>COMMAND.COM</code>. Pour l'automatisation des t√¢ches, on utilisait des <strong>fichiers batch (<code>.bat</code>)</strong> ‚Äî de simples fichiers texte contenant une s√©quence de commandes de console. C'√©tait un asc√©tisme surprenant pour la ligne de commande par rapport aux syst√®mes compatibles POSIX o√π le <strong>shell Bourne (<code>sh</code>)</strong> existait d√©j√† depuis 1979.</p>
<h3>üìÖ √âtat du march√© des shells au moment de la sortie de MS-DOS 1.0 (ao√ªt 1981)</h3>
<p>Voici un tableau r√©capitulatif des syst√®mes d'exploitation populaires de l'√©poque et de leur prise en charge des shells (<code>sh</code>, <code>csh</code>, etc.) :</p>
<table>
<thead>
<tr>
<th>Syst√®me d'exploitation</th>
<th>Prise en charge des shells (<code>sh</code>, <code>csh</code>, etc.)</th>
<th>Commentaire</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UNIX Version 7 (V7)</strong></td>
<td><code>sh</code></td>
<td>Le dernier UNIX classique de Bell Labs, largement r√©pandu</td>
</tr>
<tr>
<td><strong>UNIX/32V</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>Version d'UNIX pour l'architecture VAX</td>
</tr>
<tr>
<td><strong>4BSD / 3BSD</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>Branche universitaire d'UNIX de Berkeley</td>
</tr>
<tr>
<td><strong>UNIX System III</strong></td>
<td><code>sh</code></td>
<td>La premi√®re version commerciale d'AT&amp;T, pr√©d√©cesseur de System V</td>
</tr>
<tr>
<td><strong>Xenix (de Microsoft)</strong></td>
<td><code>sh</code></td>
<td>Une version sous licence d'UNIX, vendue par Microsoft depuis 1980</td>
</tr>
<tr>
<td><strong>IDRIS</strong></td>
<td><code>sh</code></td>
<td>Un syst√®me d'exploitation de type UNIX pour PDP-11 et Intel</td>
</tr>
<tr>
<td><strong>Coherent (Mark Williams)</strong></td>
<td><code>sh</code> (similaire)</td>
<td>Une alternative peu co√ªteuse √† UNIX pour les PC</td>
</tr>
<tr>
<td><strong>CP/M (Digital Research)</strong></td>
<td>‚ùå (Pas de <code>sh</code>, seulement une CLI tr√®s basique)</td>
<td>Pas UNIX, le syst√®me d'exploitation le plus populaire pour les PC 8 bits</td>
</tr>
<tr>
<td><strong>MS-DOS 1.0</strong></td>
<td>‚ùå (seulement <code>COMMAND.COM</code>)</td>
<td>Shell de commande minimal, pas de scripts ni de pipes</td>
</tr>
</tbody>
</table>
<hr>
<h3>üí° Que sont <code>sh</code>, <code>csh</code></h3>
<ul>
<li><code>sh</code> ‚Äî <strong>Bourne Shell</strong>, le principal interpr√©teur de scripts pour UNIX depuis 1977.</li>
<li><code>csh</code> ‚Äî <strong>C Shell</strong>, un shell am√©lior√© avec une syntaxe de type C et des fonctionnalit√©s pratiques pour le travail interactif.</li>
<li>Ces shells <strong>prenaient en charge les redirections, les pipes, les variables, les fonctions et les conditions</strong> ‚Äî tout ce qui a fait d'UNIX un outil d'automatisation puissant.</li>
</ul>
<hr>
<p>Microsoft ciblait les <strong>PC IBM 16 bits bon march√©</strong>, qui avaient <strong>peu de m√©moire</strong> (g√©n√©ralement 64 √† 256 Ko), pas de multit√¢che et √©taient destin√©s √† un <strong>usage domestique et de bureau</strong>, et non √† des serveurs. UNIX √©tait payant, n√©cessitait une architecture complexe et de l'expertise, tandis que les comptables et les ing√©nieurs, qui n'√©taient pas des administrateurs syst√®me, avaient besoin d'un syst√®me d'exploitation simple et rapide.</p>
<p>Au lieu du complexe <code>sh</code>, l'interface DOS fournissait un seul fichier, command.com, avec un maigre ensemble de commandes internes [ (dir, copy, del, etc.)]<a href="https://www.techgeekbuzz.com/blog/dos-commands/" target="_blank">(dir, copy, del, etc.)</a> sans fonctions, boucles ou modules.</p>
<p>Il y avait aussi des commandes externes ‚Äî des fichiers ex√©cutables distincts (.exe ou .com). Exemples : FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Les scripts d'ex√©cution √©taient √©crits dans un fichier texte avec l'extension .bat (fichier batch).</p>
<p>Exemples de fichiers de configuration :</p>
<ul>
<li>AUTOEXEC.BAT</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Configuration et d√©marrage automatiques de Windows 3.11
:: Auteur : hypo69
:: Ann√©e : environ 1993
:: Objectif : Initialise l'environnement DOS, charge les pilotes r√©seau et d√©marre Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: D√©finir l'invite de commande
PROMPT $p$g

:: D√©finir les variables d'environnement
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Charger les pilotes et les utilitaires en m√©moire haute
LH C:\DOS\SMARTDRV.EXE       :: Cache de disque
LH C:\DOS\MOUSE.COM          :: Pilote de la souris

:: Charger les services r√©seau (pertinent pour Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: D√©marrer automatiquement Windows
WIN
</code></pre>
<ul>
<li>CONFIG.SYS</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî Configuration de la m√©moire et des pilotes DOS pour Windows 3.11
:: Auteur : hypo69
:: Ann√©e : environ 1993
:: Objectif : Initialise les pilotes de m√©moire, configure les param√®tres syst√®me
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE
</code></pre>
<p>Parall√®lement √† DOS, Microsoft a presque imm√©diatement commenc√© √† d√©velopper un noyau fondamentalement nouveau.</p>
<p>Le noyau <a href="https://www.wikiwand.com/ru/articles/Windows_NT" target="_blank"><strong>Windows NT</strong></a> (New Technology) est apparu pour la premi√®re fois avec la sortie du syst√®me d'exploitation :</p>
<blockquote>
<p><strong>Windows NT 3.1 ‚Äî 27 juillet 1993</strong></p>
</blockquote>
<hr>
<ul>
<li><strong>Le d√©veloppement a commenc√©</strong> : en <strong>1988</strong> sous la direction de <strong>Dave Cutler</strong> (un ancien ing√©nieur de DEC et cr√©ateur de VMS) dans le but de cr√©er un syst√®me d'exploitation enti√®rement nouveau, s√©curis√©, portable et multit√¢che, non compatible avec MS-DOS au niveau du noyau.</li>
<li><strong>NT 3.1</strong> ‚Äî a √©t√© nomm√© ainsi pour souligner la compatibilit√© avec <strong>Windows 3.1</strong> au niveau de l'interface, mais il s'agissait d'une <strong>architecture compl√®tement nouvelle</strong>.</li>
</ul>
<hr>
<h4>üß† Ce que le noyau NT a apport√© :</h4>
<table>
<thead>
<tr>
<th>Fonctionnalit√©</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Architecture 32 bits</strong></td>
<td>Contrairement √† MS-DOS et Windows 3.x, qui √©taient en 16 bits.</td>
</tr>
<tr>
<td><strong>Multit√¢che</strong></td>
<td>V√©ritable multit√¢che pr√©emptif.</td>
</tr>
<tr>
<td><strong>M√©moire prot√©g√©e</strong></td>
<td>Les programmes ne pouvaient pas corrompre la m√©moire des autres.</td>
</tr>
<tr>
<td><strong>Modularit√©</strong></td>
<td>Architecture du noyau √† plusieurs couches : HAL, Executive, Kernel, pilotes.</td>
</tr>
<tr>
<td><strong>Prise en charge multi-plateforme</strong></td>
<td>NT 3.1 fonctionnait sur x86, MIPS et Alpha.</td>
</tr>
<tr>
<td><strong>Compatibilit√© POSIX</strong></td>
<td>NT √©tait livr√© avec un <strong>sous-syst√®me POSIX</strong>, certifi√© POSIX.1.</td>
</tr>
</tbody>
</table>
<hr>
<h4>üìú La lign√©e NT :</h4>
<table>
<thead>
<tr>
<th>Version NT</th>
<th>Ann√©e</th>
<th>Commentaire</th>
</tr>
</thead>
<tbody>
<tr>
<td>NT 3.1</td>
<td>1993</td>
<td>Premi√®re version de NT</td>
</tr>
<tr>
<td>NT 3.5 / 3.51</td>
<td>1994‚Äì1995</td>
<td>Am√©liorations, optimisation</td>
</tr>
<tr>
<td>NT 4.0</td>
<td>1996</td>
<td>Interface de Windows 95, mais noyau NT</td>
</tr>
<tr>
<td>Windows 2000</td>
<td>2000</td>
<td>NT 5.0</td>
</tr>
<tr>
<td>Windows XP</td>
<td>2001</td>
<td>NT 5.1</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>2007</td>
<td>NT 6.0</td>
</tr>
<tr>
<td>Windows 10</td>
<td>2015</td>
<td>NT 10.0</td>
</tr>
<tr>
<td>Windows 11</td>
<td>2021</td>
<td>√âgalement NT 10.0 (marketing üòä)</td>
</tr>
</tbody>
</table>
<hr>
<p>Diff√©rence dans les capacit√©s du syst√®me d'exploitation :</p>
<table>
<thead>
<tr>
<th>Caract√©ristique</th>
<th><strong>MS-DOS</strong> (1981)</th>
<th><strong>Windows NT</strong> (1993)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Type de syst√®me</strong></td>
<td>Monolithique, monot√¢che</td>
<td>Micro-noyau/hybride, multit√¢che</td>
</tr>
<tr>
<td><strong>Nombre de bits</strong></td>
<td>16 bits</td>
<td>32 bits (avec prise en charge 64 bits depuis NT 5.2 / XP x64)</td>
</tr>
<tr>
<td><strong>Multit√¢che</strong></td>
<td>‚ùå Absent (un processus √† la fois)</td>
<td>‚úÖ Multit√¢che pr√©emptif</td>
</tr>
<tr>
<td><strong>M√©moire prot√©g√©e</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Oui (chaque processus dans son propre espace d'adressage)</td>
</tr>
<tr>
<td><strong>Mode multi-utilisateur</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Partiellement (dans NT Workstation/Server)</td>
</tr>
<tr>
<td><strong>Compatibilit√© POSIX</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Sous-syst√®me POSIX int√©gr√© dans NT 3.1‚Äì5.2</td>
</tr>
<tr>
<td><strong>Portabilit√© du noyau</strong></td>
<td>‚ùå x86 uniquement</td>
<td>‚úÖ x86, MIPS, Alpha, PowerPC</td>
</tr>
<tr>
<td><strong>Pilotes</strong></td>
<td>Acc√®s direct au mat√©riel</td>
<td>Via HAL et pilotes en mode noyau</td>
</tr>
<tr>
<td><strong>Niveau d'acc√®s des applications</strong></td>
<td>Applications = niveau syst√®me</td>
<td>Niveaux utilisateur/noyau s√©par√©s</td>
</tr>
<tr>
<td><strong>S√©curit√©</strong></td>
<td>‚ùå Absente</td>
<td>‚úÖ Mod√®le de s√©curit√© : SID, ACL, jetons d'acc√®s</td>
</tr>
<tr>
<td><strong>Stabilit√©</strong></td>
<td>‚ùå La d√©pendance d'un programme = crash de l'OS</td>
<td>‚úÖ Isolation des processus, protection du noyau</td>
</tr>
</tbody>
</table>
<hr>
<p>Mais il y avait un gros MAIS ! Les outils d'automatisation et d'administration n'ont pas re√ßu l'attention voulue avant 2002.</p>
<hr>
<p>Microsoft a utilis√© des approches, des strat√©gies et des outils compl√®tement diff√©rents pour l'administration. Tout cela √©tait <strong>disparate</strong>, souvent orient√© GUI, et pas toujours automatisable.</p>
<hr>
<h5>üìå Liste de quelques outils :</h5>
<table>
<thead>
<tr>
<th>Outil</th>
<th>Objectif</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmd.exe</code></td>
<td>Interpr√©teur de commandes am√©lior√© (remplacement de <code>COMMAND.COM</code>)</td>
</tr>
<tr>
<td><code>.bat</code>, <code>.cmd</code></td>
<td>Scripts de ligne de commande</td>
</tr>
<tr>
<td><strong>Windows Script Host (WSH)</strong></td>
<td>Prise en charge de VBScript et JScript pour l'automatisation</td>
</tr>
<tr>
<td><code>reg.exe</code></td>
<td>G√©rer le registre depuis la ligne de commande</td>
</tr>
<tr>
<td><code>net.exe</code></td>
<td>Travailler avec les utilisateurs, le r√©seau, les imprimantes</td>
</tr>
<tr>
<td><code>sc.exe</code></td>
<td>G√©rer les services</td>
</tr>
<tr>
<td><code>tasklist</code>, <code>taskkill</code></td>
<td>G√©rer les processus</td>
</tr>
<tr>
<td><code>gpedit.msc</code></td>
<td>Strat√©gie de groupe (locale)</td>
</tr>
<tr>
<td><code>MMC</code></td>
<td>Console avec des composants logiciels enfichables pour la gestion</td>
</tr>
<tr>
<td><code>WMI</code></td>
<td>Acc√©der aux informations syst√®me (via <code>wmic</code>, VBScript ou COM)</td>
</tr>
<tr>
<td><code>WbemTest.exe</code></td>
<td>GUI pour tester les requ√™tes WMI</td>
</tr>
<tr>
<td><code>eventvwr</code></td>
<td>Afficher les journaux d'√©v√©nements</td>
</tr>
<tr>
<td><code>perfmon</code></td>
<td>Surveiller les ressources</td>
</tr>
</tbody>
</table>
<h5>üõ† Exemples d'automatisation :</h5>
<ul>
<li>Fichiers VBScript (<code>*.vbs</code>) pour l'administration des utilisateurs, des r√©seaux, des imprimantes et des services.</li>
<li><code>WMIC</code> ‚Äî interface de ligne de commande pour WMI (par exemple : <code>wmic process list brief</code>).</li>
<li>Scripts <code>.cmd</code> avec des appels √† <code>net</code>, <code>sc</code>, <code>reg</code>, <code>wmic</code>, etc.</li>
</ul>
<hr>
<h3>‚öôÔ∏è Windows Scripting Host (WSH)</h3>
<ul>
<li>Apparu pour la premi√®re fois dans <strong>Windows 98</strong>, activement utilis√© dans <strong>Windows 2000 et XP</strong>.</li>
<li>Permettait d'ex√©cuter des fichiers VBScript et JScript depuis la ligne de commande :</li>
</ul>
<pre class="line-numbers"><code class="language-vbscript">  Set objShell = WScript.CreateObject("WScript.Shell")
  objShell.Run "notepad.exe"
</code></pre>
<hr>
<h2>Partie 1.</h2>
<p>Ce n'est qu'en 2002 que l'entreprise a formul√© le projet <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, qui a ensuite √©volu√© pour devenir PowerShell :</p>
<p>D√©but du d√©veloppement : environ 2002</p>
<p>Annonce publique : 2003, sous le nom de "Monad Shell"</p>
<p>Premi√®res versions b√™ta : apparues en 2005</p>
<p>Version finale (PowerShell 1.0) : novembre 2006</p>
<p>L'auteur et architecte en chef du projet Monad / PowerShell est Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a></p>
<p>Aujourd'hui, PowerShell Core fonctionne sur
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a></p>
<p>En parall√®le, le framework .NET √©tait en cours de d√©veloppement, et PowerShell y √©tait profond√©ment int√©gr√©. Dans les chapitres suivants, je montrerai des exemples.</p>
<p>Et maintenant ‚Äî le plus important !</p>
<p>Le principal avantage de PowerShell par rapport aux shells de commande classiques est qu'il fonctionne avec des <em>objets</em>, et non avec du texte. Lorsque vous ex√©cutez une commande, elle ne renvoie pas seulement du texte, mais un objet structur√© (ou une collection d'objets) avec des propri√©t√©s et des m√©thodes clairement d√©finies.</p>
<p>Voyez comment PowerShell surpasse les shells classiques gr√¢ce au <strong>travail avec des objets</strong></p>
<h3>üìÅ L'ancienne m√©thode : <code>dir</code> et l'analyse manuelle</h3>
<p>Dans <strong>CMD</strong> (√† la fois dans l'ancien <code>COMMAND.COM</code> et dans <code>cmd.exe</code>), la commande <code>dir</code> renvoie le r√©sultat sous forme de texte brut. Exemple de sortie :</p>
<pre class="line-numbers"><code>24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
</code></pre>
<p>Supposons que vous souhaitiez extraire le <strong>nom de fichier</strong> et la <strong>taille</strong> de chaque fichier. Vous devriez analyser les cha√Ænes manuellement :
<pre class="line-numbers"><code class="language-cmd">for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
</code></pre>
</p>
<ul>
<li>C'est terriblement difficile √† lire, cela d√©pend des param√®tres r√©gionaux, du format de la date et de la police. Et cela ne fonctionne pas avec les espaces dans les noms.</li>
</ul>
<hr>
<h3>‚úÖ PowerShell : des objets au lieu du texte</h3>
<h4>‚úî Exemple simple et lisible :</h4>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem | Select-Object Name, Length
</code></pre>
<p><strong>R√©sultat :</strong></p>
<pre class="line-numbers"><code>Name          Length
----          ------
my_script.js   1428
report.html    3980
</code></pre>
<ul>
<li><code>Get-ChildItem</code> renvoie un <strong>tableau d'objets fichier/dossier</strong></li>
<li><code>Select-Object</code> vous permet d'obtenir facilement les <strong>propri√©t√©s</strong> requises</li>
</ul>
<hr>
<h3>üîç Que renvoie r√©ellement <code>Get-ChildItem</code> ?</h3>
<pre class="line-numbers"><code class="language-powershell">$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
</code></pre>
<p><strong>R√©sultat :</strong></p>
<pre class="line-numbers"><code>TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
</code></pre>
<p>PowerShell renvoie des <strong>objets <code>System.IO.FileInfo</code></strong>, qui ont :</p>
<ul>
<li>üß± Propri√©t√©s (<code>Name</code>, <code>Length</code>, <code>CreationTime</code>, <code>Extension</code>, ‚Ä¶)</li>
<li>üõ† M√©thodes (<code>Delete()</code>, <code>CopyTo()</code>, <code>MoveTo()</code>, etc.)</li>
</ul>
<p>Vous travaillez <strong>avec des objets √† part enti√®re</strong>, et non avec des cha√Ænes de caract√®res.</p>
<hr>
<h3>Syntaxe "Verbe-Nom" :</h3>
<p>PowerShell utilise une <strong>syntaxe de commande stricte et logique</strong> :
<code>Verbe-Nom</code></p>
<table>
<thead>
<tr>
<th>Verbe</th>
<th>Ce qu'il fait</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Get-</code></td>
<td>Obtenir</td>
</tr>
<tr>
<td><code>Set-</code></td>
<td>D√©finir</td>
</tr>
<tr>
<td><code>New-</code></td>
<td>Cr√©er</td>
</tr>
<tr>
<td><code>Remove-</code></td>
<td>Supprimer</td>
</tr>
<tr>
<td><code>Start-</code></td>
<td>D√©marrer</td>
</tr>
<tr>
<td><code>Stop-</code></td>
<td>Arr√™ter</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Nom</th>
<th>Sur quoi il travaille</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Process</code></td>
<td>Processus</td>
</tr>
<tr>
<td><code>Service</code></td>
<td>Service</td>
</tr>
<tr>
<td><code>Item</code></td>
<td>Fichier/dossier</td>
</tr>
<tr>
<td><code>EventLog</code></td>
<td>Journaux d'√©v√©nements</td>
</tr>
<tr>
<td><code>Computer</code></td>
<td>Ordinateur</td>
</tr>
</tbody>
</table>
<h4>üîÑ Exemples :</h4>
<table>
<thead>
<tr>
<th>Ce qu'il faut faire</th>
<th>Commande</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obtenir les processus</td>
<td><code>Get-Process</code></td>
</tr>
<tr>
<td>Arr√™ter un service</td>
<td><code>Stop-Service</code></td>
</tr>
<tr>
<td>Cr√©er un nouveau fichier</td>
<td><code>New-Item</code></td>
</tr>
<tr>
<td>Obtenir le contenu d'un dossier</td>
<td><code>Get-ChildItem</code></td>
</tr>
<tr>
<td>Supprimer un fichier</td>
<td><code>Remove-Item</code></td>
</tr>
</tbody>
</table>
<p>‚û° M√™me si vous <strong>ne connaissez pas la commande exacte</strong>, vous pouvez la <strong>deviner</strong> √† partir du sens ‚Äî et vous aurez presque toujours raison.</p>
<hr>
<p>Le cmdlet <code>Get-Help</code> est votre principal assistant.</p>
<ol>
<li><strong>Obtenir de l'aide sur l'aide elle-m√™me :</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Help
</code></pre>
</li>
<li><strong>Obtenir de l'aide de base sur la commande pour travailler avec les processus :</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Process
</code></pre>
</li>
<li><strong>Voir des exemples d'utilisation de cette commande :</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Process -Examples
</code></pre>
<p>C'est un param√®tre incroyablement utile qui fournit souvent des solutions pr√™tes √† l'emploi pour vos t√¢ches.</p>
</li>
<li><strong>Obtenir les informations les plus d√©taill√©es sur la commande :</strong>
<pre class="line-numbers"><code class="language-powershell">    Get-Help Get-Process -Full
</code></pre>
</li>
</ol>
<p>Dans la partie suivante : le pipeline ou la cha√Æne de commandes (PipeLines)</p>