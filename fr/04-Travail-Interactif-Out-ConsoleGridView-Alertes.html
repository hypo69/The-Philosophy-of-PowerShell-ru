<h2>Philosophie PowerShell.</h2>
<h2>Partie 4 : Travail interactif : <code>Out-ConsoleGridView</code>, alertes.</h2>
<p>
- Dans la <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md">premi√®re partie</a>, nous avons d√©fini deux concepts cl√©s de PowerShell : le pipeline et l'objet.
</p>
<p>
- Dans la <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md">deuxi√®me partie</a>, j'ai expliqu√© ce que sont les objets et le pipeline.
</p>
<p>
- Dans la <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md">troisi√®me partie</a>, nous avons d√©couvert le syst√®me de fichiers et les fournisseurs.
</p>
<p>
- Aujourd'hui, nous allons examiner le travail interactif avec les donn√©es dans la console, ainsi que les alertes et les notifications.
</p>
<h3>Chapitre un : Travail interactif avec les donn√©es dans la console.</h3>
<h4><code>Out-ConsoleGridView</code>. Interface graphique dans la console PowerShell.</h4>
<p>
<b>‚ùó Important :</b> Tous les outils d√©crits ci-dessous n√©cessitent <b>PowerShell 7.2 ou plus r√©cent</b>.
</p>
<p>
Out-ConsoleGridView est un tableau interactif, directement dans la console PowerShell, permettant de :
</p>
<ul>
<li>visualiser les donn√©es sous forme de tableau ;</li>
<li>filtrer et trier les colonnes ;</li>
<li>s√©lectionner des lignes avec le curseur ‚Äî pour les transmettre plus loin dans le pipeline ;</li>
<li>et bien plus encore.</li>
</ul>
<p>
<code>Out-ConsoleGridView</code> fait partie du module <code>Microsoft.PowerShell.ConsoleGuiTools</code>. Pour l'utiliser, vous devez d'abord installer ce module.
</p>
<p>
Pour installer le module, ex√©cutez la commande suivante dans PowerShell :
</p>
<pre class="line-numbers"><code class="language-powershell">Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
</code></pre>
<p><img src="assets/04/1.png" alt="Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser"></p>
<p>
<i>Install-Module</i> t√©l√©charge et installe le module sp√©cifi√© depuis le r√©f√©rentiel dans le syst√®me. Analogues : <code>pip install</code> en <code>Python</code> ou <code>npm install</code> en <code>Node.js</code>.
</p>
<p>
üìé Param√®tres cl√©s de <i>Install-Module</i>
</p>
<table>
<thead>
<tr>
<th>Param√®tre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Name</code></td>
<td>Nom du module √† installer.</td>
</tr>
<tr>
<td><code>--Scope</code></td>
<td>Port√©e de l'installation : <code>AllUsers</code> (par d√©faut, n√©cessite des droits d'administrateur) ou <code>CurrentUser</code> (ne n√©cessite pas de droits d'administrateur).</td>
</tr>
<tr>
<td><code>-Repository</code></td>
<td>Sp√©cifie le r√©f√©rentiel, par exemple <code>PSGallery</code>.</td>
</tr>
<tr>
<td><code>-Force</code></td>
<td>Installation forc√©e sans confirmation.</td>
</tr>
<tr>
<td><code>-AllowClobber</code></td>
<td>Autorise l'√©crasement des commandes existantes.</td>
</tr>
<tr>
<td><code>-AcceptLicense</code></td>
<td>Accepte automatiquement la licence du module.</td>
</tr>
<tr>
<td><code>-RequiredVersion</code></td>
<td>Installe une version sp√©cifique du module.</td>
</tr>
</tbody>
</table>
<p>
Apr√®s l'installation, vous pouvez transmettre n'importe quelle sortie √† <code>Out-ConsoleGridView</code> pour un travail interactif.
</p>
<pre class="line-numbers"><code class="language-powershell"># Exemple classique : affichage de la liste des processus dans un tableau interactif
Get-Process | Out-ConsoleGridView
</code></pre>
<p>
<a href="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be">1</a>
</p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>
<b>Interface :</b>
</p>
<ul>
<li><b>Filtrage :</b> Commencez simplement √† taper du texte, et la liste sera filtr√©e √† la vol√©e.</li>
<li><b>Navigation :</b> Utilisez les touches fl√©ch√©es pour vous d√©placer dans la liste.</li>
<li><b>S√©lection :</b> Appuyez sur <code>Espace</code> pour s√©lectionner/d√©s√©lectionner un √©l√©ment.</li>
<li><b>S√©lection multiple :</b> <code>Ctrl+A</code> pour s√©lectionner tous les √©l√©ments, <code>Ctrl+D</code> pour d√©s√©lectionner tout.</li>
<li><b>Confirmation :</b> Appuyez sur <code>Entr√©e</code> pour renvoyer les objets s√©lectionn√©s.</li>
<li><b>Annulation :</b> Appuyez sur <code>√âchap</code> pour fermer la fen√™tre sans renvoyer de donn√©es.</li>
</ul>
<h2>Ce que <code>Out-ConsoleGridView</code> peut faire :</h2>
<ul>
<li>Afficher des donn√©es tabulaires directement dans la console sous forme de tableau interactif avec navigation par lignes et colonnes.</li>
<li>Trier les colonnes en appuyant sur les touches.</li>
<li>Filtrer les donn√©es √† l'aide de la recherche.</li>
<li>S√©lectionner une ou plusieurs lignes avec retour du r√©sultat.</li>
<li>Travailler dans une console propre sans fen√™tres GUI.</li>
<li>Supporter un grand nombre de lignes avec d√©filement.</li>
<li>Supporter diff√©rents types de donn√©es (cha√Ænes, nombres, dates, etc.).</li>
</ul>
<hr>
<h2>Exemples d'utilisation de <code>Out-ConsoleGridView</code></h2>
<h3>Utilisation de base ‚Äî afficher un tableau avec possibilit√© de s√©lection interactive. (case √† cocher)</h3>
<pre class="line-numbers"><code class="language-powershell">Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Afficher le tableau avec possibilit√© de filtrage, de tri et de s√©lection de lignes
$selected = $data | Out-ConsoleGridView -Title "Select process(es)" -OutputMode Multiple

$selected | Format-Table -AutoSize
</code></pre>
<p>
<a href="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356">2</a>
</p>
<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>
Affiche une liste de processus dans un tableau de console interactif. Vous pouvez filtrer par nom, trier les colonnes et s√©lectionner des processus. Les processus s√©lectionn√©s sont renvoy√©s dans la variable <code>$selected</code>.
</p>
<hr>
<h3>S√©lection d'une seule ligne avec retour obligatoire du r√©sultat. (radio)</h3>
<pre class="line-numbers"><code class="language-powershell">$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Select a service" -OutputMode Single

Write-Host "You selected service: $($choice.Name)"
</code></pre>
<p>
<a href="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e"></a>
</p>
<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>
L'utilisateur s√©lectionne une seule ligne (service). <code>-OutputMode Single</code> interdit la s√©lection multiple.
</p>
<hr>
<h3>Filtrage et tri de grands tableaux</h3>
<pre class="line-numbers"><code class="language-powershell">$data = 1..1000 | ForEach-Object {
    [PSCustomObject]@{
        Number = $_
        Square = $_ * $_
        Cube   = $_ * $_ * $_
    }
}

$data | Out-ConsoleGridView -Title "Numbers and powers"  -OutputMode Multiple
</code></pre>
<p>
Affiche un tableau de 1000 lignes avec des nombres et leurs puissances.
</p>
<h3><b>Gestion interactive des processus :</b></h3>
<p>
Vous pouvez s√©lectionner plusieurs processus √† arr√™ter. Le param√®tre <code>-OutputMode Multiple</code> indique que nous voulons renvoyer tous les √©l√©ments s√©lectionn√©s.
</p>
<pre class="line-numbers"><code class="language-powershell"># Transf√©rer les r√©sultats via le pipeline.
# Arr√™ter les processus s√©lectionn√©s avec le param√®tre -WhatIf pour un aper√ßu.
# Pour cela, d√©finissons la variable $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple

# Si quelque chose a √©t√© s√©lectionn√©, transf√©rer les objets plus loin dans le pipeline
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
</code></pre>
<h3><b>S√©lection de fichiers pour l'archivage :</b></h3>
<p>
Trouvons tous les fichiers <code>.log</code> dans le dossier, s√©lectionnons ceux dont nous avons besoin et cr√©ons une archive √† partir d'eux.
</p>
<pre class="line-numbers"><code class="language-powershell">$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
</code></pre>
<p>
‚ùó Soyez prudent avec la r√©cursion
</p>
<pre class="line-numbers"><code class="language-powershell">if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip

    # Ajouter un message de succ√®s
    Write-Host "‚úÖ Archivage termin√© avec succ√®s !" -ForegroundColor Green
}
</code></pre>
<h3><b>S√©lection d'un √©l√©ment pour une analyse d√©taill√©e :</b></h3>
<h4>Mod√®le "Drill-Down" ‚Äî du g√©n√©ral au d√©tail avec <code>Out-ConsoleGridView</code></h4>
<p>
Souvent, lorsque nous travaillons avec des objets syst√®me, nous sommes confront√©s √† un dilemme :
</p>
<ol>
<li>Si nous demandons <b>toutes les propri√©t√©s</b> pour <b>tous les objets</b> (<code>Get-NetAdapter | Format-List *</code>), la sortie sera √©norme et illisible.</li>
<li>Si nous affichons un <b>tableau concis</b>, nous perdrons des d√©tails importants.</li>
<li>Parfois, tenter d'obtenir toutes les donn√©es en une seule fois peut entra√Æner une erreur si l'un des objets contient des valeurs incorrectes.</li>
</ol>
<p>
La solution √† ce probl√®me est le mod√®le <b>"Drill-Down"</b> (d√©tail ou "plong√©e en profondeur"). Son essence est simple :
</p>
<ul>
<li><b>√âtape 1 (Aper√ßu) :</b> Afficher √† l'utilisateur une liste d'√©l√©ments propre, concise et s√ªre pour la <b>s√©lection</b>.</li>
<li><b>√âtape 2 (D√©tail) :</b> Une fois que l'utilisateur a s√©lectionn√© un √©l√©ment sp√©cifique, lui montrer <b>toutes les informations disponibles</b> pour cet √©l√©ment.</li>
</ul>
<h4>Exemple pratique : Cr√©ation d'un explorateur d'adaptateurs r√©seau</h4>
<p>
Impl√©mentons ce mod√®le en utilisant la commande <code>Get-NetAdapter</code>.
</p>
<p>
<b>T√¢che :</b> Afficher d'abord une liste concise des adaptateurs r√©seau. Apr√®s en avoir s√©lectionn√© un, ouvrir une deuxi√®me fen√™tre avec toutes ses propri√©t√©s.
</p>
<p>
<b>Code pr√™t √† l'emploi :</b>
</p>
<pre class="line-numbers"><code class="language-powershell"># --- √âtape 1 : S√©lection de l'adaptateur dans la liste concise ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "√âTAPE 1 : S√©lectionnez un adaptateur r√©seau"

# --- √âtape 2 : Affichage des informations d√©taill√©es ou du message d'annulation ---
if ($null -ne $selectedAdapter) {
    # Obtenir TOUTES les propri√©t√©s pour l'adaptateur S√âLECTIONN√â
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Utiliser notre astuce avec .psobject.Properties pour transformer l'objet en un tableau "Nom-Valeur" pratique
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value

    # Ouvrir la DEUXI√àME fen√™tre GridView avec toutes les informations
    $detailedInfoForGrid | Out-ConsoleGridView -Title "√âTAPE 2 : Informations compl√®tes sur '$($selectedAdapter.Name)'"
} else {
    Write-Host "Op√©ration annul√©e. Aucun adaptateur n'a √©t√© s√©lectionn√©." -ForegroundColor Yellow
}
</code></pre>
<h4>Analyse √©tape par √©tape</h4>
<ol>
<li><b>Cr√©ation d'une liste "s√ªre" :</b>
    <code>$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed</code>
    Nous ne transmettons pas la sortie de <code>Get-NetAdapter</code> directement. Au lieu de cela, nous cr√©ons de nouveaux objets "propres" √† l'aide de <code>Select-Object</code>, en n'incluant que les propri√©t√©s dont nous avons besoin pour l'aper√ßu. Cela garantit que les donn√©es probl√©matiques qui ont caus√© l'erreur seront ignor√©es.
</li>
<li><b>Premi√®re fen√™tre interactive :</b>
    <code>$selectedAdapter = $adapterList | Out-ConsoleGridView ...</code>
    Le script affiche la premi√®re fen√™tre et <b>arr√™te son ex√©cution</b>, attendant votre s√©lection. D√®s que vous s√©lectionnez une ligne et appuyez sur <code>Entr√©e</code>, l'objet correspondant √† cette ligne sera enregistr√© dans la variable <code>$selectedAdapter</code>.
</li>
<li><b>V√©rification de la s√©lection :</b>
    <code>if ($null -ne $selectedAdapter)</code>
    C'est une v√©rification cruciale. Si l'utilisateur appuie sur <code>√âchap</code> ou ferme la fen√™tre, la variable <code>$selectedAdapter</code> sera vide (<code>$null</code>). Cette v√©rification emp√™che l'ex√©cution du reste du code et l'apparition d'erreurs.
</li>
<li><b>Obtention des informations compl√®tes :</b>
    <code>$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name</code>
    C'est le point cl√© du mod√®le. Nous nous adressons √† nouveau √† <code>Get-NetAdapter</code>, mais cette fois, nous demandons <b>un seul</b> objet par son nom, que nous avons pris de l'√©l√©ment s√©lectionn√© √† la premi√®re √©tape. Nous obtenons maintenant l'objet complet avec toutes ses propri√©t√©s.
</li>
<li><b>Transformation pour la deuxi√®me fen√™tre :</b>
    <code>$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...</code>
    Nous utilisons une astuce puissante que vous connaissez d√©j√† pour "d√©rouler" cet objet complexe en une longue liste de paires "Nom de la propri√©t√©" | "Valeur", ce qui est id√©al pour l'affichage dans un tableau.
</li>
<li><b>Deuxi√®me fen√™tre interactive :</b>
    <code>$detailedInfoForGrid | Out-ConsoleGridView ...</code>
    Une deuxi√®me fen√™tre appara√Æt √† l'√©cran, cette fois avec des informations exhaustives sur l'adaptateur que vous avez s√©lectionn√©.
</li>
</ul>
<hr>
<h3>Exemple avec un titre personnalis√© et des astuces</h3>
<p>
Affichage du journal des √©v√©nements Windows dans un tableau interactif avec le titre "System Events".
</p>
<pre class="line-numbers"><code class="language-powershell">Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
</code></pre>
<p>
Ce code r√©cup√®re les 50 derniers √©v√©nements du journal syst√®me Windows, s√©lectionne quatre propri√©t√©s cl√©s pour chaque √©v√©nement (heure, type, source et message) et les affiche dans la fen√™tre Out-ConsoleGridView.
</p>
<hr>
<h3>Informations syst√®me.</h3>
<p>
<a href="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06">1</a>
</p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>
code du script pour obtenir des informations syst√®me :
<a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1">Get-SystemMonitor.ps1</a>
</p>
<h3>Cr√©ation du cmdlet 'Get-SystemMonitor'</h3>
<h4>√âtape 1 : Configuration de la variable <code>PATH</code></h4>
<ol>
<li><b>Cr√©ez un dossier permanent pour vos outils,</b> si ce n'est pas d√©j√† fait. Par exemple :
    <code>C:\PowerShell\Scripts</code>
</li>
<li><b>Placez votre fichier</b> <code>Get-SystemMonitor.ps1</code> dans ce dossier.
</li>
<li><b>Ajoutez ce dossier √† la variable syst√®me <code>PATH</code></b>,
</li>
</ol>
<h4>√âtape 2 : Configuration de l'alias dans le profil PowerShell</h4>
<p>
Maintenant que le syst√®me sait o√π trouver votre script par son nom complet, nous pouvons cr√©er un alias court pour celui-ci.
</p>
<ol>
<li><b>Ouvrez votre fichier de profil PowerShell</b> :
    <pre class="line-numbers"><code class="language-powershell">notepad $PROFILE
</code></pre>
</li>
<li><b>Ajoutez la ligne suivante :</b>
    <pre class="line-numbers"><code class="language-powershell"># Alias pour le moniteur syst√®me
Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
</code></pre>
    <b>Notez le point cl√© :</b> Puisque le dossier avec le script est d√©j√† dans <code>PATH</code>, nous n'avons plus <b>besoin de sp√©cifier le chemin complet</b> vers le fichier ! Nous nous r√©f√©rons simplement √† son nom. Cela rend votre profil plus propre et plus fiable. Si jamais vous d√©placez le dossier <code>C:\PowerShell\Scripts</code>, vous n'aurez qu'√† mettre √† jour la variable <code>PATH</code>, et votre fichier de profil restera inchang√©.
</li>
</ol>
<h4>Red√©marrez PowerShell</h4>
<p>
Fermez <b>toutes</b> les fen√™tres PowerShell ouvertes et ouvrez-en une nouvelle. Cela est n√©cessaire pour que le syst√®me applique les modifications √† la variable <code>PATH</code> et √† votre profil.
</p>
<hr>
<h3>R√©sultat : Ce que vous obtenez</h3>
<p>
Apr√®s avoir suivi ces √©tapes, vous pourrez appeler votre script <b>de deux mani√®res depuis n'importe quel endroit du syst√®me</b> :
</p>
<ol>
<li><b>Par son nom complet (fiable, pour une utilisation dans d'autres scripts) :</b>
    <pre class="line-numbers"><code class="language-powershell">Get-SystemMonitor.ps1
Get-SystemMonitor.ps1 -Resource storage
</code></pre>
</li>
<li><b>Par un alias court (pratique, pour un travail interactif) :</b>
    <pre class="line-numbers"><code class="language-powershell">sysmon
sysmon -Resource memory
</code></pre>
</li>
</ol>
<p>
Vous avez r√©ussi √† "enregistrer" votre script dans le syst√®me de la mani√®re la plus professionnelle et la plus flexible.
</p>
<p>
Utile ? Abonnez-vous.
Aim√© ‚Äî mettez un "+"
Bonne chance ! üöÄ
</p>
<p>
Autres articles sur PowerShell:
</p>