# Philosophie PowerShell.
## Partie 2 : Pipeline, variables, Get-Member, fichier *.ps1* et exportation des résultats
**❗ Important :**
J'écris sur PS7 (PowerShell 7). Il diffère de PS5 (PowerShell 5). À partir de la septième version, PowerShell est devenu multiplateforme. Pour cette raison, le comportement de certaines commandes a changé.

Dans la première partie, nous avons établi le principe clé : PowerShell travaille avec des **objets**, et non pas du texte.
Ce billet est consacré à quelques outils PowerShell importants : nous apprendrons à passer des objets via le **pipeline**, à les analyser avec **`Get-Member`**, à enregistrer les résultats dans des **variables** et à automatiser tout cela dans des **fichiers de script (`.ps1`)** avec **exportation** des résultats dans des formats pratiques.

### 1. Qu'est-ce qu'un pipeline (`|`) ?
Un pipeline dans PowerShell est un mécanisme de transfert d'objets .NET complets (et pas seulement de texte) d'une commande à l'autre, où chaque cmdlet suivant reçoit des objets structurés avec toutes leurs propriétés et méthodes.

Le symbole `|` (barre verticale) — est l'opérateur de pipeline. Sa tâche est de prendre le résultat (sortie) de la commande située à sa gauche et de le transmettre en entrée à la commande située à sa droite.

`Commande 1 (crée des objets)` → `|` → `Commande 2 (reçoit et traite des objets)` → `|` → `Commande 3 (reçoit des objets traités)` → | ...

#### Pipeline UNIX classique : Flux de texte

Dans `bash`, le pipeline transmet un **flux d'octets**, qui est généralement interprété comme du texte.

```bash
# Trouver tous les processus 'nginx' et compter leur nombre
ps -ef | grep 'nginx' | wc -l
```
Ici, `ps` affiche du texte, `grep` filtre ce texte, et `wc` compte les lignes. Chaque utilitaire ne sait rien des "processus", il ne travaille qu'avec des chaînes de caractères.

#### Pipeline PowerShell : Flux d'objets
**Exemple :** Obtenons tous les processus, trions-les par utilisation du CPU et sélectionnons les 5 les plus "gourmands".

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
![1](assets/02/1.png)

Ici, `Get-Process` crée des **objets** de processus. `Sort-Object` reçoit ces **objets** et les trie par la propriété `CPU`. `Select-Object` reçoit les **objets** triés et sélectionne les 5 premiers.

Vous avez sûrement remarqué dans la commande des mots commençant par un tiret (-) : -Property, -Descending, -First. Ce sont des paramètres.
Les paramètres sont des réglages, des commutateurs et des instructions pour le cmdlet. Ils permettent de contrôler **COMMENT** la commande effectuera son travail.
Sans paramètres, la commande fonctionne en mode par défaut, et avec des paramètres, vous lui donnez des instructions spécifiques.

Types de paramètres principaux :

- Paramètre avec valeur : nécessite des informations supplémentaires.

    `-Property CPU` : Nous disons à Sort-Object par quelle propriété trier. CPU est la valeur du paramètre.
    
    `-First 5` : Nous disons à Select-Object combien d'objets sélectionner. 5 est la valeur du paramètre.

- Paramètre-commutateur (flag) : Ne nécessite pas de valeur. Sa seule présence dans la commande active ou désactive un comportement spécifique.

   `-Descending` : Ce flag indique à Sort-Object de changer l'ordre de tri en ordre inverse (du plus grand au plus petit). Il n'a pas besoin de valeur supplémentaire — c'est une instruction en soi.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
![1](assets/02/2.png)
Cette commande répond à une question très simple :
**"Combien de processus nommés `svchost.exe` sont actuellement en cours d'exécution sur mon système ?"**

#### Analyse étape par étape

##### **Étape 1 : `Get-Process -Name 'svchost'`**

Cette partie de la commande s'adresse au système d'exploitation et lui demande de trouver **tous sans exception** les processus en cours d'exécution dont le nom de fichier exécutable est `svchost.exe`.
Contrairement aux processus de type `notepad` (qui sont généralement un ou deux), les processus `svchost` sont toujours **nombreux** dans le système. La commande renverra un **tableau (collection) d'objets**, où chaque objet — est un processus `svchost` distinct et complet avec son ID unique, son utilisation de la mémoire et etc.
PowerShell a trouvé dans le système, par exemple, 90 processus `svchost` et détient maintenant une collection de 90 objets.

##### **Étape 2 : `|` (Opérateur de pipeline)**

Ce symbole prend la collection de 90 objets `svchost`, obtenue à la première étape, et commence à les transmettre **un par un** à la commande suivante.

##### **Étape 3 : `Measure-Object`**

Puisque nous avons appelé `Measure-Object` sans paramètres (tels que `-Property`, `-Sum` et etc.), il effectue son opération **par défaut** — il compte simplement le nombre d'"éléments" qui lui ont été transmis.
Un, deux, trois ... Après que tous les objets soient comptés, `Measure-Object` crée **son propre objet-résultat**, qui a une propriété `Count`, égale au nombre total.


**`Count: 90`** — c'est la réponse à notre question. 90 processus `svchost` sont en cours d'exécution.
Les autres champs sont vides, parce que nous n'avons pas demandé à `Measure-Object` d'effectuer des calculs plus complexes.


#### Exemple avec `svchost` et paramètres

Changeons notre tâche. Maintenant, nous ne voulons plus simplement compter les processus `svchost`, mais savoir, **combien de mémoire vive (en mégaoctets) ils consomment ensemble**.

Pour cela, nous aurons besoin de paramètres :
*   `-Property WorkingSet64` : Cette instruction dit à `Measure-Object` : "De chaque objet `svchost`, qui te parviendra, prends la valeur numérique de la propriété `WorkingSet64` (c'est l'utilisation de la mémoire en octets)".
*   `-Sum` : Cette instruction-flag dit : "Additionne toutes ces valeurs, que tu as prises de la propriété `WorkingSet64`".

Notre nouvelle commande ressemblera à ceci :
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
![3](assets/02/3.png)

1.  `Get-Process` trouvera le nombre d'objets `svchost`.
2.  Le pipeline `|` les transmettra à `Measure-Object`.
3.  Mais maintenant, `Measure-Object` fonctionne différemment :
    *   Il prend le premier objet `svchost`, regarde sa propriété `.WorkingSet64` (par exemple, `25000000` octets) et mémorise ce nombre.
    *   Il prend le deuxième objet, regarde son `.WorkingSet64` (par exemple, `15000000` octets) et l'ajoute au précédent.
    *   ...et ainsi de suite pour tous les objets.
4.  Au final, `Measure-Object` créera un objet-résultat, mais il sera différent.


*   **`Count: 92`** : Nombre d'objets.
*   **`Sum: 1661890560`** : C'est la somme totale de toutes les valeurs `WorkingSet64` en octets.
*   **`Property: WorkingSet64`** : Ce champ est maintenant également rempli, il nous informe quelle propriété a été utilisée pour les calculs.




### 2. Variables (Normales et la spéciale `$_`)

Une variable — est un emplacement de stockage nommé en mémoire, qui contient une valeur.

Cette valeur peut être n'importe quoi : du texte, un nombre, une date ou, ce qui est le plus important pour PowerShell,
 un objet entier ou même une collection d'objets. Le nom d'une variable dans PowerShell commence toujours par un signe dollar ($).
Exemples : $name, $counter, $processList.

Variable spéciale `$_` ?

`$_` — est l'abréviation de "objet actuel" ou "cette chose".
Imaginez une chaîne de montage dans une usine. Par elle circulent différentes pièces (objets).

`$_` — c'est la pièce qui se trouve juste devant vous (ou devant le robot de traitement).

Source (Get-Process) — déverse sur la chaîne de montage une boîte entière de pièces (tous les processus).

Pipeline (|) — fait avancer ces pièces une par une sur le tapis.

Processeur (Where-Object ou ForEach-Object) — est un robot qui regarde chaque pièce.

La variable `$_` — c'est la pièce qui est actuellement dans les "mains" du robot.

Quand le robot aura terminé avec une pièce, le pipeline lui en donnera une autre, et `$_` pointera alors vers celle-ci.



Calculez la quantité totale de mémoire utilisée par les processus `svchost`, et affichez le résultat à l'écran.
```powershell
# 1. Exécutons la commande et enregistrons son objet-résultat complexe dans la variable $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Maintenant, nous pouvons travailler avec l'objet enregistré. Extrayons sa propriété Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Affichons le résultat à l'écran en utilisant la nouvelle variable
Write-Host "Tous les processus svchost utilisent $memoryInMB Mo de mémoire."
```
![3](assets/02/4.png)

*   `Write-Host` — est un cmdlet spécialisé, dont la seule tâche — **afficher du texte directement à l'utilisateur dans la console**.

*   Chaîne entre guillemets doubles : `"..."` - chaîne de texte, que nous passons au cmdlet `Write-Host` comme argument. Pourquoi doubles, et non simples ?
    
    Dans PowerShell, il existe deux types de guillemets :
    
    *   **Simples (`'...'`):** Créent une **chaîne littérale**. Tout ce qui est à l'intérieur d'eux, est perçu comme du texte ordinaire, sans exceptions.
    *   **Doubles (`"..."`):** Créent une **chaîne extensible (ou de substitution)**. PowerShell "scanne" une telle chaîne à la recherche de variables (commençant par `$`) et substitue à leur place leurs valeurs.

* `$memoryInMB`. C'est la variable, dans laquelle nous **à l'étape précédente** de notre script avons placé le résultat des calculs. Quand `Write-Host` reçoit une chaîne entre guillemets doubles,
 un processus appelé **"expansion de chaîne" (String Expansion)** se produit :
    1.  PowerShell voit le texte `"Tous les processus svchost utilisent "`.
    2.  Ensuite, il rencontre la construction `$memoryInMB`. Il comprend, que ce n'est pas seulement du texte, mais une variable.
    3.  Il regarde dans la mémoire, trouve la valeur, stockée dans `$memoryInMB` (par exemple, `1585.52`).
    4.  Il **substitue cette valeur** directement dans la chaîne.
    5.  Ensuite, il ajoute la partie restante du texte : `" Mo de mémoire."`. 
    6.  Au final, à `Write-Host` est transmise la chaîne déjà prête, assemblée : `"Tous les processus svchost utilisent 1585.52 Mo de mémoire."`. 



Lancez le bloc-notes :
 1. Trouvons le processus du Bloc-notes et enregistrons-le dans la variable $notepadProcess
 ```powershell
$notepadProcess = Get-Process -Name notepad
```

 2. Accédons à la propriété 'Id' de cet objet via un point et affichons-la
 ```powershell
Write-Host "L'ID du processus 'Bloc-notes' est : $($notepadProcess.Id)"
```
![5](assets/02/5.png)

**❗ Important:** 
    Write-Host "casse" le pipeline. Le texte, affiché par lui, ne peut pas être transmis plus loin dans le pipeline pour traitement. Il est destiné uniquement à l'affichage.

### 3. Get-Member (Inspecteur d'objets)

Nous savons, que par le pipeline "circulent" des objets. Mais comment savoir, de quoi ils sont faits ? Quelles propriétés et quelles actions (méthodes) avec eux peuvent être effectuées ?

Le cmdlet **`Get-Member`** (alias : `gm`) — est l'outil principal pour l'exploration.
Avant de travailler avec un objet, passez-le par `Get-Member`, pour voir toutes ses capacités.

Analysons les objets, que crée `Get-Process` :
```powershell
Get-Process | Get-Member
```
![6](assets/02/6.png)

*Décomposons chaque partie de la sortie Get-Member.*

`TypeName: System.Diagnostics.Process` - C'est le nom de type complet, officiel de l'objet de la bibliothèque .NET. C'est son "passeport".
Cette ligne vous dit, que tous les objets, que retourne Get-Process, sont des objets de type System.Diagnostics.Process.
Cela garantit, que chez eux tous sera le même ensemble de propriétés et de méthodes.
Vous pouvez [rechercher sur Google](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process", pour trouver la documentation officielle de Microsoft avec des informations encore plus détaillées.



- Colonne 1 : `Name`

C'est le **nom** simple, lisible par l'homme de la propriété, de la méthode ou d'un autre "membre" de l'objet. C'est ce nom, que vous utiliserez dans votre code pour accéder aux données ou effectuer des actions.



- Colonne 2 : `MemberType` (Type de membre)

C'est la colonne la plus importante pour la compréhension. Elle classe, **ce qu'est** chaque objet. C'est son "rôle", qui vous dit, **COMMENT** l'utiliser.

*   **`Property` (Propriété):** **caractéristique** ou **portion de données**, stockée à l'intérieur de l'objet. Vous pouvez "lire" sa valeur.
    *   *Exemples sur la capture d'écran:* `BasePriority`, `HandleCount`, `ExitCode`. Ce sont simplement des données, que l'on peut consulter.

*   **`Method` (Méthode):** **ACTION**, que l'on peut effectuer avec l'objet. Les méthodes sont toujours appelées avec des parenthèses `()`.
    *   *Exemples sur la capture d'écran:* `Kill`, `Refresh`, `WaitForExit`. Vous écririez `$process.Kill()` ou `$process.Refresh()`.

*   **`AliasProperty` (Propriété d'alias):** **alias convivial** pour une autre, plus longue propriété. PowerShell les ajoute pour la commodité et la concision.
    *   *Exemples sur la capture d'écran:* `WS` — est un alias court pour `WorkingSet64`. `Name` — pour `ProcessName`. `VM` — pour `VirtualMemorySize64`.

*   **`Event` (Événement):** **NOTIFICATION** que quelque chose s'est produit, à laquelle on peut "s'abonner".
    *   *Exemple sur la capture d'écran:* `Exited`. Votre script peut "écouter" cet événement, pour effectuer une action juste après que le processus se termine.

*   **`CodeProperty` et `NoteProperty`:** types de propriétés spéciaux, souvent ajoutés par PowerShell lui-même pour la commodité. `CodeProperty` calcule sa valeur "à la volée", et `NoteProperty` — c'est une simple propriété-note, ajoutée à l'objet.

- Colonne 3 : `Definition` (Définition)

C'est la **définition technique** ou "signature" du membre. Elle vous donne les détails exacts pour son utilisation. Son contenu dépend du `MemberType` :

*   **Pour `AliasProperty`:** Montre, **à quoi l'alias est égal**. C'est incroyablement utile !
    *   *Exemple sur la capture d'écran:* `WS = WorkingSet64`. Vous voyez immédiatement, que `WS` — c'est simplement une forme abrégée de `WorkingSet64`.

*   **Pour `Property`:** Montre le **type de données**, qui est stocké dans la propriété (par exemple, `int` pour un entier, `string` pour du texte, `datetime` pour une date et une heure), et ce que l'on peut faire avec (`{get;}` — seulement lire, `{get;set;}` — lire et modifier).
    *   *Exemple sur la capture d'écran:* `int BasePriority {get;}`. C'est une propriété entière, que l'on peut seulement lire.

*   **Pour `Method`:** Montre, ce que la méthode retourne (par exemple, `void` — rien, `bool` — true/false) et quels **paramètres** (données d'entrée) elle accepte entre parenthèses.
    *   *Exemple sur la capture d'écran:* `void Kill()`. Cela signifie, que la méthode `Kill` ne retourne rien et peut être appelée sans paramètres. Il existe aussi une deuxième version `void Kill(bool entireProcessTree)`, qui accepte une valeur logique (true/false).

#### Sous forme de tableau

| Colonne      | Qu'est-ce que c'est ?                             | Exemple de capture d'écran                  | À quoi ça sert ?                                                                   |
|--------------|--------------------------------------|--------------------------------------------|-----------------------------------------------------------------------------------------|
| **Name**     | Nom, que vous utilisez dans le code.  | `Kill`, `WS`, `Name`                       | accéder à la propriété ou à la méthode (`$process.WS`, `$process.Kill()`).    |
| **MemberType**| Type de membre (données, action, etc.). | `Method`, `Property`, `AliasProperty`      | **comment** l'utiliser (lire la valeur ou appeler avec `()`).              |
| **Definition** | Détails techniques.                  | `WS = WorkingSet64`, `void Kill()`           | ce qui se cache derrière l'alias et quels paramètres sont nécessaires à la méthode.                |



#### Exemple : Travailler avec les fenêtres de processus

##### 1. Problème:
"J'ai ouvert beaucoup de fenêtres du Bloc-notes. Comment puis-je réduire toutes, sauf la principale, et ensuite fermer seulement celle, qui a dans le titre le mot 'Untitled' ?"

##### 2. Recherche avec `Get-Member`:
Nous devons trouver des propriétés, liées à la fenêtre et à son titre.

```powershell
Get-Process -Name notepad | Get-Member
```
**Analyse du résultat `Get-Member`:**
*   En parcourant les propriétés, nous trouvons `MainWindowTitle`. Type `string`. Excellent, c'est le titre de la fenêtre principale !
*   Dans les méthodes, nous voyons `CloseMainWindow()`. C'est une façon plus "douce" de fermer une fenêtre, que `Kill()`.
*   Aussi dans les méthodes il y a `WaitForInputIdle()`. Cela semble intéressant, peut-être cela aidera à attendre, que le processus soit prêt à interagir.

![7](assets/02/7.png)

`Get-Member` nous a montré la propriété `MainWindowTitle`, qui est la clé pour résoudre le problème et permet d'interagir avec les processus sur la base de l'état de leurs fenêtres, et non seulement par le nom.

##### 3. Solution:
Maintenant, nous pouvons construire la logique, basée sur le titre de la fenêtre.

```powershell
# 1. Trouver tous les processus du Bloc-notes
$notepads = Get-Process -Name notepad

# 2. Parcourir chacun et vérifier le titre
foreach ($pad in $notepads) {
    # Pour chaque processus ($pad), vérifier sa propriété MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Bloc-notes non enregistré trouvé (ID: $($pad.Id)). Fermeture de sa fenêtre..."
        # $pad.CloseMainWindow() # Décommenter, pour vraiment fermer
        Write-Host "La fenêtre '$($pad.MainWindowTitle)' aurait été fermée." -ForegroundColor Yellow
    } else {
        Write-Host "Ignorer le Bloc-notes avec le titre : $($pad.MainWindowTitle)"
    }
}
```

![8](assets/02/8.png)

![9](assets/02/9.png)


---

#### Exemple : Trouver le processus parent

##### 1. Problème:
"Parfois, je vois dans le système beaucoup de processus enfants `chrome.exe`. Comment savoir, lequel d'entre eux est le principal, le processus "parent", qui les a tous lancés ?"

##### 2. Recherche avec `Get-Member`:
Nous devons trouver quelque chose, qui relie un processus à un autre.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
![10](assets/02/10.png)

**Analyse du résultat `Get-Member`:**
*   En examinant attentivement la liste, nous trouvons une propriété de type `CodeProperty` avec le nom `Parent`.
*   Sa définition (`Definition`) — `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
C'est une propriété calculée, qui, lors de l'accès à elle, retourne **l'objet du processus parent**.

##### 3. Solution:
Maintenant, nous pouvons écrire un script, qui pour chaque processus `chrome` affichera des informations sur son parent.

```powershell
# 1. Obtenir tous les processus chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Pour chacun d'eux, afficher des informations sur lui et son parent
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Obtenir le processus parent
    $parent = $_.Parent
    
    # Formater une belle sortie
    Write-Host "Processus:" -ForegroundColor Green
    Write-Host "  - Nom: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Son parent:" -ForegroundColor Yellow
    Write-Host "  - Nom: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
```
![11](assets/02/11.png)

![12](assets/02/12.png)

Nous voyons immédiatement, que les processus avec les ID 4756, 7936, 8268 et 9752 ont été lancés par le processus avec l'ID 14908. On peut aussi remarquer un cas intéressant avec le processus ID : 7252, chez lequel le processus parent ne s'est pas défini (peut-être, le parent a déjà eu le temps de se terminer au moment de la vérification). La modification du script avec la vérification if ($parent) gère ce cas proprement, sans provoquer d'erreur.
Get-Member nous a aidés à découvrir la propriété "cachée" Parent, qui offre de puissantes capacités d'analyse de la hiérarchie des processus.

#### 4. Fichier *.ps1* (Création de scripts)

Quand votre chaîne de commandes devient utile, vous voudrez la sauvegarder pour une utilisation répétée. C'est à cela que servent les **scripts** — des fichiers texte avec l'extension **`.ps1`**.

##### Autorisation d'exécution des scripts
Par défaut, l'exécution des scripts locaux est interdite sous Windows. Pour corriger cela **pour l'utilisateur actuel**, exécutez une fois dans PowerShell **en tant qu'administrateur** :
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
C'est un paramètre sûr, qui permet d'exécuter vos propres scripts et les scripts, signés par un éditeur de confiance.

##### Exemple de script `system_monitor.ps1`
Créez un fichier avec ce nom et insérez le code ci-dessous. Ce script collecte des informations sur le système et génère des rapports.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Script pour créer un rapport sur l'état du système.
.DESCRIPTION
    Collecte des informations sur les processus, les services et l'espace disque et génère des rapports.
.PARAMETER OutputPath
    Chemin pour enregistrer les rapports. Par défaut 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Bloc 1 : Préparation ---
Write-Host "Préparation de la création du rapport..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Bloc 2 : Collecte de données ---
Write-Host "Collecte d'informations..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Bloc 3 : Appel de la fonction d'exportation (voir section suivante) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Rapports enregistrés avec succès dans le dossier $OutputPath" -ForegroundColor Magenta
```
*Note : la fonction `Export-Results` sera définie dans la section suivante comme un exemple de bonne pratique.*

#### 5. Exportation des résultats

Les données brutes — c'est bien, mais souvent, il faut les présenter sous une forme pratique pour l'homme ou un autre programme. PowerShell offre beaucoup de cmdlets pour l'exportation.

| Méthode                               | Commande                                            | Description                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Texte simple**                   | `... \| Out-File C:\Temp\data.txt`                 | Redirige la représentation textuelle vers un fichier.                                      |
| **CSV (pour Excel)**                 | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | Exporte les objets au format CSV. `-NoTypeInfo` supprime la première ligne de service.     |
| **Rapport HTML**                      | `... \| ConvertTo-Html -Title "Rapport"`             | Crée du code HTML à partir d'objets.                                                       |
| **JSON (pour API, web)**             | `... \| ConvertTo-Json`                            | Convertit les objets au format JSON.                                                  |
| **XML (format natif PowerShell)** | `... \| Export-Clixml C:\Temp\data.xml`            | Enregistre les objets avec tous les types de données. Ils peuvent être parfaitement restaurés via `Import-Clixml`. |

##### Ajout au script : fonction d'exportation
Ajoutons à notre script `system_monitor.ps1` une fonction, qui s'occupera de l'exportation. Placez ce code **avant** l'appel à `Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Exportation en CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Création d'un beau rapport HTML
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Top 10 des processus par CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Statistiques des services</h2>"

    ConvertTo-Html -Head "<title>Rapport système</title>" -Body "<h1>Rapport système du $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
Maintenant, notre script ne se contente pas de collecter des données, mais les enregistre aussi soigneusement dans deux formats : CSV pour l'analyse et HTML pour une visualisation rapide.

#### Conclusion

1.  **Pipeline (`|`)** — l'outil principal pour combiner les commandes et traiter les objets.
2.  **`Get-Member`** — analyse des objets, qui montre de quoi ils sont faits.
3.  **Variables (`$var`, `$_`)** permettent de stocker des données et d'accéder à l'objet actuel dans le pipeline.
4.  **Fichiers `.ps1`** transforment les commandes en outils d'automatisation réutilisables.
5.  **Cmdlets d'exportation** (`Export-Csv`, `ConvertTo-Html`) exportent les données dans le format approprié.

**Dans la prochaine partie, nous appliquerons ces connaissances pour naviguer et gérer le système de fichiers, en explorant les objets `System.IO.DirectoryInfo` et `System.IO.FileInfo`.**