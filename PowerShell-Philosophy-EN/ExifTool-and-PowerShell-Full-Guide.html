<h2>Full Guide to ExifTool and PowerShell</h2>
<p>Every time you take a photo, your camera records not only the image itself but also service information into the file: camera and lens model, date and time of shooting, shutter speed, aperture, <code>ISO</code>, <code>GPS</code> coordinates. This data is called **<code>EXIF</code> (<code>Exchangeable Image File Format</code>)**.</p>
<p>While <code>PowerShell</code> has built-in tools for reading some metadata, they are limited. To access **all** information, a specialized tool is needed. In this article, I use **<code>ExifTool</code>**.</p>
<p><strong><code>ExifTool</code></strong> â€” is a free, cross-platform, open-source utility written by Phil Harvey. It is the gold standard for reading, writing, and editing metadata in a wide variety of file formats (images, audio, video, <code>PDF</code>, etc.). <code>ExifTool</code> knows thousands of tags from hundreds of device manufacturers, making it the most comprehensive tool in its class.</p>
<h3>Downloading and Correct Setup</h3>
<p>Before writing any code, you need to prepare the utility itself.</p>
<ol>
<li>Go to the **official <code>ExifTool</code> website: <a href="https://exiftool.org/">https://exiftool.org/</a>**. On the main page, find and download **"<code>Windows Executable</code>"**.</li>
<li>
<p><strong>Renaming (Critically Important Step!):</strong> The downloaded file will be named <code>exiftool(-k).exe</code>. This is not accidental.</p>
<p>Rename it to **<code>exiftool.exe</code>**, to **disable the "pause" mode**, which is intended for users who launch the program by double-clicking.</p>
</li>
<li>
<p><strong>Storage:</strong> You have two main options for where to store <code>exiftool.exe</code>.</p>
<ul>
<li><strong>Option 1 (Simple): In the same folder as your script.</strong> This is the easiest way. Your <code>PowerShell</code> script will always be able to find the utility because it's located nearby. Ideal for portable scripts that you move from computer to computer.</li>
<li><strong>Option 2 (Recommended for frequent use): In a folder from the system <code>PATH</code> variable.</strong> The <code>PATH</code> variable â€” is a list of directories where <code>Windows</code> and <code>PowerShell</code> automatically search for executable files.
You can create a folder (e.g., <code>C:\Tools</code>), put <code>exiftool.exe</code> there, and add <code>C:\Tools</code> to the system <code>PATH</code> variable.
After that, you can call <code>exiftool.exe</code> from any folder in any console.</li>
</ul>
</li>
</ol>
<p>Scripts for adding to <code>$PATH</code>:
Adding a directory to <code>PATH</code> for the CURRENT USER
Adding a directory to the SYSTEM <code>PATH</code> for ALL USERS</p>
<hr>
<h2><code>PowerShell</code> and External Programs</h2>
<p>To effectively use <code>ExifTool</code>, you need to know how <code>PowerShell</code> launches external <code>.exe</code> files.
The correct and most reliable way to run external programs is the **call operator <code>&amp;</code> (ampersand)**.
<code>PowerShell</code> will throw an error in case the program path contains spaces. For example, <code>C:\My Tools\exiftool.exe</code>.
<code>&amp;</code> (ampersand)** tells <code>PowerShell</code>: "The text that follows me in quotes, â€” is the path to the executable file. Run it, and everything that follows, â€” is its arguments".</p>
<pre class="line-numbers"><code class="language-powershell"># Correct syntax
&amp; "C:\Path With Spaces\program.exe" "argument 1" "argument 2"
</code></pre>
<p>Always use <code>&amp;</code>, when working with program paths in variables or paths that may contain spaces.</p>
<hr>
<h2>Practical Tricks: <code>ExifTool</code> + <code>PowerShell</code></h2>
<p>Now let's combine our knowledge.</p>
<h3>Example #1: Basic Extraction and Interactive Viewing</h3>
<p>The simplest way to get all data from a photo and examine it â€” is to request it in <code>JSON</code> format and pass it to <code>Out-ConsoleGridView</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$photoPath = "D:\Photos\IMG_1234.JPG"

# 1. Run exiftool with the -json flag for structured output
# 2. Convert JSON text to a PowerShell object
#    Call exiftool.exe directly, without a variable and the call operator &amp;.
$exifObject = exiftool.exe -json $photoPath | ConvertFrom-Json

# 3. Transform the "wide" object into a convenient "Parameter-Value" table
$reportData = $exifObject.psobject.Properties | Select-Object Name, Value

# 4. Output the result to an interactive window for analysis
$reportData | Out-ConsoleGridView -Title "File Metadata: $($photoPath | Split-Path -Leaf)"
</code></pre>
<p>This code will open an interactive window where you can sort data by parameter name or value, and filter it, simply by starting to type text. This is incredibly convenient for quickly finding the necessary information.</p>
<h3>Example #2: Creating a Clean Report and Sending to Different "Devices"</h3>
<p><code>Out-ConsoleGridView</code> â€” is just the beginning. You can direct processed data anywhere, using other <code>Out-*</code> cmdlets.</p>
<p>Suppose we have data in the <code>$reportData</code> variable from the previous example.</p>
<h4>**A) Sending to a <code>CSV</code> file for <code>Excel</code>**</h4>
<pre class="line-numbers"><code class="language-powershell">$reportData | Export-Csv -Path "C:\Reports\photo_exif.csv" -NoTypeInformation -Encoding UTF8
</code></pre>
<p>Command <code>Export-Csv</code> creates a perfectly structured file that can be opened in <code>Excel</code> or <code>Google Sheets</code>.</p>
<h4>**B) Sending to a Text File**</h4>
<pre class="line-numbers"><code class="language-powershell"># For nice formatting, first use Format-Table
$reportData | Format-Table -AutoSize | Out-File -FilePath "C:\Reports\photo_exif.txt"
</code></pre>
<p>Command <code>Out-File</code> will save to file the exact text copy of what you see in the console.</p>
<h4>**C) Sending to Clipboard**</h4>
<p>Want to quickly paste data into an email or chat? Use <code>Out-Clipboard</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$reportData | Format-Table -AutoSize | Out-String | Out-Clipboard
</code></pre>
<p>Now you can press <code>Ctrl+V</code> in any text editor and paste a neatly formatted table.</p>
<h3>Example #3: Getting Specific Data for Use in a Script</h3>
<p>Often you don't need the entire report, but just one or two values. Since <code>$exifObject</code> â€” is a regular <code>PowerShell</code> object, you can easily access its properties.</p>
<pre class="line-numbers"><code class="language-powershell">
$photoPath = "D:\Photos\IMG_1234.JPG"

# Call exiftool.exe directly by name.
# PowerShell will automatically find it in one of the folders, listed in PATH.
$exifObject = exiftool.exe -json $photoPath | ConvertFrom-Json

# 1. Create one PowerShell-object with understandable property names.
#    This is similar to creating a structured record.
$reportObject = [PSCustomObject]@{ 
    "Camera"           = $exifObject.Model
    "Date Taken"       = $exifObject.DateTimeOriginal
    "Sensitivity"      = $exifObject.ISO
    "File Name"        = $exifObject.FileName # Add file name for context
}

# 2. Output this object to an interactive window.
#    Out-GridView will automatically create columns from property names.
$reportObject | Out-ConsoleGridView -Title "File Metadata: $(Split-Path $photoPath -Leaf)"
</code></pre>
<p>This approach is the basis for any serious automation, such as renaming files based on the date taken, sorting photos by camera model, or adding watermarks with exposure information.</p>
<h3>Example #4: Batch Extraction of Metadata from a Folder</h3>
<p>Sometimes you need to analyze not one photo, but an entire folder with images.</p>
<pre class="line-numbers"><code class="language-powershell"># Specify only the photo folder.
$photoFolder = "D:\Photos"

# Call exiftool.exe directly. Variable for the path and operator &amp; are not needed.
$allExif = exiftool.exe -json "$photoFolder\*.jpg" | ConvertFrom-Json

# Transform into a convenient view 
$report = foreach ($photo in $allExif) {
    [PSCustomObject]@{
        # --- Basic file and camera data ---
        FileName       = $photo.FileName
        DateTime       = $photo.DateTimeOriginal
        CameraMake     = $photo.Make                 # Manufacturer (e.g., "Canon", "SONY")
        CameraModel    = $photo.Model                 # Camera model (e.g., "EOS R5")
        LensModel      = $photo.LensID                # Full name of the lens model
        
        # --- Shooting parameters (exposure) ---
        ISO            = $photo.ISO
        ShutterSpeed   = $photo.ShutterSpeed
        Aperture       = $photo.Aperture
        FocalLength    = $photo.FocalLength           # Focal length (e.g., "50.0 mm")
        ExposureMode   = $photo.ExposureProgram       # Shooting mode (e.g., "Manual", "Aperture Priority")
        Flash          = $photo.Flash                 # Information about whether the flash fired
        
        # --- GPS and image data ---
        GPSPosition    = $photo.GPSPosition           # GPS coordinates as a single string (if available)
        Dimensions     = "$($photo.ImageWidth)x$($photo.ImageHeight)" # Image dimensions in pixels
    }
}

# Output data to an interactive table in the CONSOLE
$report | Out-ConsoleGridView -Title "Summary Report for Folder: $photoFolder"
</code></pre>
<p>ðŸ’¡ You get a neat table for the entire folder at once.</p>
<hr>
<h3>Example #5: Recursive Search in Subfolders</h3>
<p><code>ExifTool</code> can search for files in all subfolders itself when using the key <code>-r</code>.</p>
<pre class="line-numbers"><code class="language-powershell">&amp; $exifToolPath -r -json "D:\Photos" | ConvertFrom-Json |
    Select-Object FileName, Model, DateTimeOriginal |
    Export-Csv "C:\Reports\all_photos_recursive.csv" -NoTypeInformation -Encoding UTF8
</code></pre>
<hr>
<h3>Example #6: Renaming Files by Date Taken</h3>
<p>This is one of the most popular automation scenarios â€” files get names by the date/time of shooting.</p>
<pre class="line-numbers"><code class="language-powershell">$exifToolPath = "C:\Tools\exiftool.exe"
$photoFolder = "D:\Photos"

# Rename to YYYY-MM-DD_HH-MM-SS.jpg format
&amp; $exifToolPath -r -d "%Y-%m-%d_%H-%M-%S.%%e" "-FileName&lt;DateTimeOriginal" $photoFolder
</code></pre>
<p>ðŸ’¡ <em><code>ExifTool</code> will automatically insert the original file extension via <code>%%e</code>.</em></p>
<hr>
<h3>Example #7: Extracting Only <code>GPS</code> Coordinates</h3>
<p>Useful if you want to build a map from your photos.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Specify the path to the folder with your photos
$photoFolder = "E:\DCIM\Camera"

# 2. List the tags we need: file name and three GPS-tags.
#    This makes the query much faster than if we were retrieving all tags.
$tagsToExtract = @(
    "-SourceFile", # SourceFile is better than FileName, as it usually contains the full path
    "-GPSLatitude",
    "-GPSLongitude",
    "-GPSAltitude"
)

# 3. Call exiftool.exe directly (since it's in PATH).
#    The -r flag searches for files in all subfolders.
#    The result is immediately converted from JSON.
$allExifData = exiftool.exe -r -json $tagsToExtract $photoFolder | ConvertFrom-Json

# 4. Filter the results: keep ONLY those objects that have latitude and longitude.
$filesWithGps = $allExifData | Where-Object { $_.GPSLatitude -and $_.GPSLongitude }

# 5. Check if any files with GPS-data were found at all
if ($filesWithGps) {
    # 6. Create a nice report from the filtered data.
    #    Use Select-Object for renaming columns and formatting.
    $report = $filesWithGps | Select-Object @{Name="File Name"; Expression={Split-Path $_.SourceFile -Leaf}},
                                             @{Name="Latitude"; Expression={$_.GPSLatitude}},
                                             @{Name="Longitude"; Expression={$_.GPSLongitude}},
                                             @{Name="Altitude"; Expression={if ($_.GPSAltitude) { "$($_.GPSAltitude) m" } else { "N/A" }}}
    
    # 7. Output the final report to an interactive console table.
    $report | Out-ConsoleGridView -Title "Files with GPS-data in folder: $photoFolder"

} else {
    # If nothing is found, politely inform the user.
    Write-Host "Files with GPS-data in folder '$photoFolder' not found." -ForegroundColor Yellow
}
</code></pre>
<hr>
<h3>Example #8: Bulk Deletion of All <code>GPS</code> Data (for privacy)</h3>
<pre class="line-numbers"><code class="language-powershell"># Delete all GPS-tags from JPG and PNG
&amp; $exifToolPath -r -overwrite_original -gps:all= "D:\Photos"
</code></pre>
<p>ðŸ’¡ <em>This action is irreversible, so do a backup before executing.</em></p>
<hr>
<h3>Example #9: Converting Shooting Time to Local Time</h3>
<p>Sometimes photos are taken in a different time zone. <code>ExifTool</code> can shift the date.</p>
<pre class="line-numbers"><code class="language-powershell"># Shift time by +3 hours
&amp; $exifToolPath "-AllDates+=3:0:0" "D:\Photos\IMG_*.JPG"
</code></pre>
<hr>
<h3>Example #10: Getting a List of All Unique Camera Models in a Folder</h3>
<pre class="line-numbers"><code class="language-powershell">$models = &amp; $exifToolPath -r -Model -s3 "D:\Photos" | Sort-Object -Unique
$models | ForEach-Object { Write-Host "Model: $_" }
</code></pre>
<hr>
<h3>Example #11: Outputting Only Necessary Tags in Tabular Form</h3>
<pre class="line-numbers"><code class="language-powershell">&amp; $exifToolPath -T -Model -DateTimeOriginal -ISO -Aperture -ShutterSpeed "D:\Photos\IMG_1234.JPG"
</code></pre>
<p><code>-T</code> outputs in a tabular format, separated by tabs â€” convenient for further processing.</p>
<hr>
<h3>Example #12: Checking for <code>GPS</code> in a Large Array of Files</h3>
<pre class="line-numbers"><code class="language-powershell">$files = &amp; $exifToolPath -r -if "$gpslatitude" -p '$FileName' "D:\Photos"
Write-Host "Files with GPS:"
$files
</code></pre>
<hr>
<h3>Example #13: Copying Metadata from One File to Another</h3>
<pre class="line-numbers"><code class="language-powershell"># 1. Select the reference file
$sourceFile = Get-ChildItem "D:\Photos" -Filter "*.jpg" | Out-ConsoleGridView -Title "Select REFERENCE file"

# 2. If a reference is selected, select target files
if ($sourceFile) {
    $targetFiles = Get-ChildItem "D:\Photos\New" -Filter "*.jpg" | Out-ConsoleGridView -Title "Select TARGET files for metadata copying" -OutputMode Multiple
    
    # 3. If targets are selected, perform the copy
    if ($targetFiles) {
        &amp; exiftool.exe -TagsFromFile $sourceFile.FullName ($targetFiles.FullName)
        Write-Host "Metadata copied from $($sourceFile.Name) to $($targetFiles.Count) files."
    }
}
</code></pre>
<hr>
<h3>Example #14: Saving Original Metadata to a Separate <code>JSON</code> Before Modification</h3>
<pre class="line-numbers"><code class="language-powershell">$backupPath = "C:\Reports\metadata_backup.json"
&amp; $exifToolPath -r -json "D:\Photos" | Out-File -Encoding UTF8 $backupPath
</code></pre>
<hr>
<h3>Example #15: Using <code>PowerShell</code> for Automatic Photo Sorting by Date</h3>
<pre class="line-numbers"><code class="language-powershell">$photos = Get-ChildItem "D:\Photos" -Filter *.jpg -Recurse
foreach ($photo in $photos) {
    $meta = &amp; $exifToolPath -json $photo.FullName | ConvertFrom-Json
    $date = Get-Date $meta.DateTimeOriginal -ErrorAction SilentlyContinue
    if ($date) {
        $targetFolder = "D:\Sorted\{0:yyyy}\{0:MM}" -f $date
        if (-not (Test-Path $targetFolder)) { New-Item -Path $targetFolder -ItemType Directory }
        Move-Item $photo.FullName -Destination $targetFolder
    }
}
</code></pre>
<hr>
<h3>Example 16: Finding All Unique Camera Models in a Collection</h3>
<p>While this can be done in one line, outputting to <code>GridView</code> allows you to immediately copy the desired model name.</p>
<pre class="line-numbers"><code class="language-powershell"># The -s3 flag outputs only values, -Model - the tag name
$uniqueModels = &amp; exiftool.exe -r -Model -s3 "D:\Photos" | Sort-Object -Unique

# Output to GridView for easy viewing and copying
$uniqueModels | Out-ConsoleGridView -Title "Unique camera models in collection"
</code></pre>