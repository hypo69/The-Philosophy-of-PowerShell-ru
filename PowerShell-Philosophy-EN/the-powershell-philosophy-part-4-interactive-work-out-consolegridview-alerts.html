<h2>The PowerShell Philosophy.</h2>
<h3>Part 4: Interactive work: <code>Out-ConsoleGridView</code>, alerts.</h3>
<ul>
<li>In <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md">the first part</a>, we defined two key concepts of PowerShell: the pipeline and the object.</li>
<li>In <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md">the second part</a>, I explained what objects and the pipeline are.</li>
<li>In <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md">the third part</a>, we got acquainted with the file system and providers.</li>
<li>Today we will look at interactive work with data in the console, and also get acquainted with alerts and notifications.</li>
</ul>
<h3>Chapter One: Interactive work with data in the console.</h3>
<h4><code>Out-ConsoleGridView</code>. GUI in the PowerShell console.</h4>
<p><strong>‚ùó Important:</strong> All the tools described below require <strong>PowerShell 7.2 or newer</strong>.</p>
<p>Out-ConsoleGridView is an interactive table, right in the PowerShell console, that allows you to:
- view data in a table format;
- filter and sort columns;
- select rows with the cursor ‚Äî to pass them further down the pipeline.
- and much more.</p>
<p><code>Out-ConsoleGridView</code> is part of the <code>Microsoft.PowerShell.ConsoleGuiTools</code> module.
To use it, you first need to install this module.</p>
<p>To install the module, run the following command in PowerShell:
```powershell
Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
```
<img src="assets/04/1.png" alt="Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser"></p>
<p><em>Install-Module</em> downloads and installs the specified module from the repository into the system.
Analogues: `pip install` in `Python` or `npm install` in `Node.js`.</p>
<p>üìé Key parameters of <em>Install-Module</em></p>
<hr>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Name</code></td>
<td>The name of the module to be installed.</td>
</tr>
<tr>
<td><code>-Scope</code></td>
<td>The installation scope: `AllUsers` (default, requires administrator rights) or `CurrentUser` (does not require administrator rights).</td>
</tr>
<tr>
<td><code>-Repository</code></td>
<td>Specifies the repository, for example `PSGallery`.</td>
</tr>
<tr>
<td><code>-Force</code></td>
<td>Forced installation without confirmation.</td>
</tr>
<tr>
<td><code>-AllowClobber</code></td>
<td>Allows overwriting existing commands.</td>
</tr>
<tr>
<td><code>-AcceptLicense</code></td>
<td>Automatically accepts the module license.</td>
</tr>
<tr>
<td><code>-RequiredVersion</code></td>
<td>Installs a specific version of the module.</td>
</tr>
</tbody>
</table>
<p>After installation, you can pass any output to `Out-ConsoleGridView` for interactive work.</p>
<pre class="line-numbers"><code class="language-powershell"># Classic example: output a list of processes to an interactive table
Get-Process | Out-ConsoleGridView
</code></pre>
<p><a href="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be">1</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p><strong>Interface:</strong>
*   <strong>Filtering:</strong> Just start typing, and the list will be filtered on the fly.
*   <strong>Navigation:</strong> Use the arrow keys to move through the list.
*   <strong>Selection:</strong> Press `Space` to select/deselect a single item.
*   <strong>Multiple selection:</strong> `Ctrl+A` to select all items, `Ctrl+D` to deselect all.
*   <strong>Confirmation:</strong> Press `Enter` to return the selected objects.
*   <strong>Cancellation:</strong> Press `ESC` to close the window without returning data.</p>
<h2>What `Out-ConsoleGridView` can do:</h2>
<ul>
<li>Display tabular data directly in the console in the form of an interactive table with navigation through rows and columns.</li>
<li>Sort columns by pressing keys.</li>
<li>Filter data using search.</li>
<li>Select one or more rows with the result returned.</li>
<li>Work in a clean console without GUI windows.</li>
<li>Support a large number of rows with scrolling.</li>
<li>Support various data types (strings, numbers, dates, etc.).</li>
</ul>
<hr>
<h2>Examples of using `Out-ConsoleGridView`</h2>
<h3>Basic usage ‚Äî show a table with the ability to interactively select. (checkbox)</h3>
<pre class="line-numbers"><code class="language-powershell">Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Display a table with the ability to filter, sort, and select rows
$selected = $data | Out-ConsoleGridView -Title "Select process(es)" -OutputMode Multiple

$selected | Format-Table -AutoSize
</code></pre>
<p><a href="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356">2</a></p>
<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>A list of processes is displayed in an interactive console table.
You can filter by name, sort columns, and select processes.
The selected processes are returned to the `$selected` variable.</p>
<hr>
<h3>Select one row with mandatory result return. (radio)</h3>
<pre class="line-numbers"><code class="language-powershell">$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Select a service" -OutputMode Single

Write-Host "You selected service: $($choice.Name)"
</code></pre>
<p><a href="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e"></a></p>
<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>The user selects one row (service). `-OutputMode Single` prohibits selecting multiple.</p>
<hr>
<h3>Filtering and sorting large arrays</h3>
<pre class="line-numbers"><code class="language-powershell">$data = 1..1000 | ForEach-Object { 
    [PSCustomObject]@{ 
        Number = $_ 
        Square = $_ * $_ 
        Cube   = $_ * $_ * $_ 
    } 
}

$data | Out-ConsoleGridView -Title "Numbers and powers"  -OutputMode Multiple
</code></pre>
<p>Shows a table of 1000 rows with numbers and their powers.</p>
<h3><strong>Interactive process management:</strong></h3>
<p>You can select multiple processes to stop. The `-OutputMode Multiple` parameter indicates that we want to return all selected items.</p>
<pre class="line-numbers"><code class="language-powershell"># Pass the results through the pipeline.
# Stop the selected processes with the -WhatIf parameter for a preview.
# To do this, we will define the $procsToStop variable
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple
    
# If something was selected, pass the objects further down the pipeline
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
</code></pre>
<h3><strong>Selecting files for archiving:</strong></h3>
<p>Find all `.log` files in a folder, select the necessary ones, and create an archive from them.</p>
<pre class="line-numbers"><code class="language-powershell">$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
</code></pre>
<p>‚ùóBe careful with recursion</p>
<pre class="line-numbers"><code class="language-powershell">if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip
    
    # Add a success message
    Write-Host "‚úÖ Archiving completed successfully!" -ForegroundColor Green
}
</code></pre>
<h3><strong>Selecting a single item for detailed analysis:</strong></h3>
<h4>The "Drill-Down" pattern ‚Äî from a general list to details with `Out-ConsoleGridView`</h4>
<p>Often, when working with system objects, we face a dilemma:
1.  If you request <strong>all properties</strong> for <strong>all objects</strong> (`Get-NetAdapter | Format-List *`), the output will be huge and unreadable.
2.  If you show a <strong>short table</strong>, you will lose important details.
3.  Sometimes, trying to get all the data at once can lead to an error if one of the objects contains incorrect values.</p>
<p>The solution to this problem is the <strong>"Drill-Down"</strong> pattern. Its essence is simple:</p>
<ul>
<li><strong>Step 1 (Overview):</strong> Show the user a clean, concise, and safe list of items for <strong>selection</strong>.</li>
<li><strong>Step 2 (Drill-Down):</strong> After the user has selected one specific item, show them <strong>all available information</strong> for that particular item.</li>
</ul>
<h4>Practical example: Creating a network adapter explorer</h4>
<p>Let's implement this pattern using the `Get-NetAdapter` command as an example.</p>
<p><strong>Task:</strong> First, show a short list of network adapters. After selecting one of them, open a second window with all its properties.</p>
<p><strong>Ready-made code:</strong>
```powershell
# --- Stage 1: Selecting an adapter from a short list ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "STAGE 1: Select a network adapter"

# --- Stage 2: Showing detailed information or a cancellation message ---
if ($null -ne $selectedAdapter) {
    # Get ALL properties for the SELECTED adapter
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Use our trick with .psobject.Properties to turn the object into a convenient "Name-Value" table
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value
    
    # Open a SECOND GridView window with full information
    $detailedInfoForGrid | Out-ConsoleGridView -Title "STAGE 2: Full information for '$($selectedAdapter.Name)'"
} else {
    Write-Host "Operation canceled. An adapter was not selected." -ForegroundColor Yellow
}
```</p>
<h4>Step-by-step breakdown</h4>
<ol>
<li>
<p><strong>Creating a "safe" list:</strong>
`$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed`
We are not passing the output of `Get-NetAdapter` directly. Instead, we are creating new, "clean" objects using `Select-Object`, including only the properties we need for the overview. This ensures that problematic data that caused an error will be discarded.</p>
</li>
<li>
<p><strong>First interactive window:</strong>
`$selectedAdapter = $adapterList | Out-ConsoleGridView ...`
The script shows the first window and <strong>stops its execution</strong>, waiting for your choice. As soon as you select a row and press `Enter`, the object corresponding to that row will be written to the `$selectedAdapter` variable.</p>
</li>
<li>
<p><strong>Checking the selection:</strong>
`if ($null -ne $selectedAdapter)`
This is a critically important check. If the user presses `Esc` or closes the window, the `$selectedAdapter` variable will be empty (`$null`). This check prevents the rest of the code from being executed and errors from occurring.</p>
</li>
<li>
<p><strong>Getting full information:</strong>
`$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name`
This is the key point of the pattern. We are again accessing `Get-NetAdapter`, but this time we are requesting <strong>only one</strong> object by its name, which we took from the item selected in the first stage. Now we get the full object with all its properties.</p>
</li>
<li>
<p><strong>Converting for the second window:</strong>
`$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...`
We use the powerful technique you are already familiar with to "expand" this one complex object into a long list of "Property Name" | "Value" pairs, which is ideal for display in a table.</p>
</li>
<li>
<p><strong>Second interactive window:</strong>
`$detailedInfoForGrid | Out-ConsoleGridView ...`
A second window appears on the screen, this time with comprehensive information about the very adapter you selected.</p>
</li>
</ol>
<hr>
<h3>Example with a custom title and hints</h3>
<p>Showing the Windows event log in an interactive table with the title "System Events".</p>
<pre class="line-numbers"><code class="language-powershell">Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
</code></pre>
<p>This code gets the 50 most recent events from the Windows system log, selects only four key properties from each event
(time, type, source, and message) and displays them in the Out-ConsoleGridView window.</p>
<hr>
<h3>System Information.</h3>
<p><a href="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06">1</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>script code for getting system information:
<a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1">Get-SystemMonitor.ps1</a></p>
<h3>Creating the 'Get-SystemMonitor' cmdlet</h3>
<h4>Step 1: Setting up the `PATH` variable</h4>
<ol>
<li>
<p><strong>Create a permanent folder for your tools,</strong> if you haven't already. For example:
`C:\PowerShell\Scripts`</p>
</li>
<li>
<p><strong>Place your `Get-SystemMonitor.ps1` file</strong> in this folder.</p>
</li>
<li>
<p><strong>Add this folder to the system `PATH` variable</strong>,</p>
</li>
</ol>
<h4>Step 2: Setting up an alias in the PowerShell profile</h4>
<p>Now that the system knows where to find your script by its full name, we can create a short alias for it.</p>
<ol>
<li>
<p><strong>Open your PowerShell profile file</strong>:
```powershell
notepad $PROFILE
```</p>
</li>
<li>
<p><strong>Add the following line to it:</strong>
```powershell
# Alias for the system monitor
Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
```</p>
<p><strong>Pay attention to the key point:</strong> Since the folder with the script is already in the `PATH`, we <strong>no longer need to specify the full path</strong> to the file! We just refer to its name. This makes your profile cleaner and more reliable. If you ever move the `C:\PowerShell\Scripts` folder, you will only need to update the `PATH` variable, and your profile file will remain unchanged.</p>
</li>
</ol>
<h4>Restart PowerShell</h4>
<p>Close <strong>all</strong> open PowerShell windows and open a new one. This is necessary for the system to apply the changes to both the `PATH` variable and your profile.</p>
<hr>
<h3>Summary: What you get</h3>
<p>After completing these steps, you will be able to call your script <strong>in two ways from anywhere in the system</strong>:</p>
<ol>
<li>
<p><strong>By full name (reliable, for use in other scripts):</strong>
```powershell
Get-SystemMonitor.ps1
Get-SystemMonitor.ps1 -Resource storage
```</p>
</li>
<li>
<p><strong>By short alias (convenient, for interactive work):</strong>
```powershell
sysmon
sysmon -Resource memory
```</p>
</li>
</ol>
<p>You have successfully "registered" your script in the system in the most professional and flexible way.</p>
<p>Useful? Subscribe.
Liked it ‚Äî give it a "+"
Good luck! üöÄ</p>
<p>Other articles about PowerShell:</p>
