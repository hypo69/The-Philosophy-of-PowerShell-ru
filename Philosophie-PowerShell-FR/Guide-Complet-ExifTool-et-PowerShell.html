<h2>Guide Complet d'ExifTool et PowerShell</h2>
<p>Chaque fois que vous prenez une photo, votre appareil photo enregistre dans le fichier non seulement l'image elle-même, mais aussi des informations de service : le modèle de l'appareil photo et de l'objectif, la date et l'heure de la prise de vue, la vitesse d'obturation, l'ouverture, l'<code>ISO</code>, les coordonnées <code>GPS</code>. Ces données sont appelées **<code>EXIF</code> (<code>Exchangeable Image File Format</code>)**.</p>
<p>Bien que <code>PowerShell</code> dispose d'outils intégrés pour lire certaines métadonnées, ils sont limités. Pour accéder à **toutes** les informations, un outil spécialisé est nécessaire. Dans cet article, j'utilise **<code>ExifTool</code>**.</p>
<p><strong><code>ExifTool</code></strong> est un utilitaire gratuit, multiplateforme et open source, écrit par Phil Harvey. C'est la référence pour la lecture, l'écriture et l'édition de métadonnées dans une grande variété de formats de fichiers (images, audio, vidéo, <code>PDF</code>, etc.). <code>ExifTool</code> connaît des milliers de balises de centaines de fabricants d'appareils, ce qui en fait l'outil le plus complet de sa catégorie.</p>
<h3>Téléchargement et configuration correcte</h3>
<p>Avant d'écrire du code, vous devez préparer l'utilitaire lui-même.</p>
<ol>
<li>Rendez-vous sur le **site officiel d'<code>ExifTool</code> : <a href="https://exiftool.org/">https://exiftool.org/</a>**. Sur la page principale, trouvez et téléchargez **"<code>Windows Executable</code>"**.</li>
<li>
<p><strong>Renommage (Étape cruciale !) :</strong> Le fichier téléchargé sera nommé <code>exiftool(-k).exe</code>. Ce n'est pas un hasard.</p>
<p>Renommez-le en **<code>exiftool.exe</code>** pour **désactiver le mode "pause"**, qui est destiné aux utilisateurs qui lancent le programme en double-cliquant.</p>
</li>
<li>
<p><strong>Stockage :</strong> Vous avez deux options principales pour stocker <code>exiftool.exe</code>.</p>
<ul>
<li><strong>Option 1 (Simple) : Dans le même dossier que votre script.</strong> C'est le moyen le plus simple. Votre script <code>PowerShell</code> pourra toujours trouver l'utilitaire, car il se trouve à proximité. Idéal pour les scripts portables que vous déplacez d'un ordinateur à l'autre.</li>
<li><strong>Option 2 (Recommandée pour une utilisation fréquente) : Dans un dossier de la variable système <code>PATH</code>.</strong> La variable <code>PATH</code> est une liste de répertoires où <code>Windows</code> et <code>PowerShell</code> recherchent automatiquement les fichiers exécutables.<br>
Vous pouvez créer un dossier (par exemple, <code>C:\Tools</code>), y placer <code>exiftool.exe</code> et ajouter <code>C:\Tools</code> à la variable système <code>PATH</code>.<br>
Après cela, vous pourrez appeler <code>exiftool.exe</code> depuis n'importe quel dossier dans n'importe quelle console.</li>
</ul>
</li>
</ol>
<p>Scripts à ajouter à <code>$PATH</code> :<br>
Ajout d'un répertoire au <code>PATH</code> pour l utilisateur ACTUEL<br>
Ajout d un répertoire au <code>PATH</code> SYSTÈME pour TOUS LES UTILISATEURS</p>
<hr>
<h2><code>PowerShell</code> et programmes externes</h2>
<p>Pour utiliser efficacement <code>ExifTool</code>, vous devez savoir comment <code>PowerShell</code> lance les fichiers <code>.exe</code> externes.<br>
La méthode la plus correcte et la plus fiable pour exécuter des programmes externes est l<span>opérateur d appel <code>&amp;</code> (esperluette)</span>.<br>
<code>PowerShell</code> générera une erreur si le chemin du programme contient des espaces. Par exemple, <code>C:\My Tools\exiftool.exe</code>.<br>
<code>&amp;</code> (esperluette) indique à <code>PowerShell</code> : "Le texte qui me suit entre guillemets est le chemin du fichier exécutable. Exécutez-le, et tout ce qui suit est ses arguments".</p>
<pre class="line-numbers"><code class="language-powershell"># Syntaxe correcte
&amp; "C:\Path With Spaces\program.exe" "argument 1" "argument 2"
</code></pre>
<p>Utilisez toujours <code>&amp;</code> lorsque vous travaillez avec des chemins de programmes dans des variables ou des chemins qui peuvent contenir des espaces.</p>
<hr>
<h2>Astuces pratiques : <code>ExifTool</code> + <code>PowerShell</code></h2>
<p>Maintenant, combinons nos connaissances.</p>
<h3>Exemple n°1 : Extraction de base et visualisation interactive</h3>
<p>Le moyen le plus simple d'obtenir toutes les données d'une photo et de les examiner est de les demander au format <code>JSON</code> et de les transmettre à <code>Out-ConsoleGridView</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$photoPath = "D:\Photos\IMG_1234.JPG"

# 1. Lancer exiftool avec l option -json pour une sortie structurée
# 2. Convertir le texte JSON en objet PowerShell
#    Appeler exiftool.exe directement, sans variable et sans opérateur d appel &amp;.
$exifObject = exiftool.exe -json $photoPath | ConvertFrom-Json

# 3. Transformer l objet "large" en un tableau pratique "Paramètre-Valeur"
$reportData = $exifObject.psobject.Properties | Select-Object Name, Value

# 4. Afficher le résultat dans une fenêtre interactive pour analyse
$reportData | Out-ConsoleGridView -Title "Métadonnées du fichier : $($photoPath | Split-Path -Leaf)"
</code></pre>
<p>Ce code ouvrira une fenêtre interactive où vous pourrez trier les données par nom de paramètre ou valeur, et les filtrer en commençant simplement à taper du texte. C est incroyablement pratique pour trouver rapidement les informations nécessaires.</p>
<h3>Exemple n°2 : Création d un rapport propre et envoi à différents "appareils"</h3>
<p><code>Out-ConsoleGridView</code> n est que le début. Vous pouvez diriger les données traitées n importe où en utilisant d autres cmdlets <code>Out-*</code>.</p>
<p>Supposons que nous ayons des données dans la variable <code>$reportData</code> de l exemple précédent.</p>
<h4>**A) Envoi vers un fichier <code>CSV</code> pour <code>Excel</code>**</h4>
<pre class="line-numbers"><code class="language-powershell">$reportData | Export-Csv -Path "C:\Reports\photo_exif.csv" -NoTypeInformation -Encoding UTF8
</code></pre>
<p>La commande <code>Export-Csv</code> crée un fichier parfaitement structuré qui peut être ouvert dans <code>Excel</code> ou <code>Google Sheets</code>.</p>
<h4>**B) Envoi vers un fichier texte**</h4>
<pre class="line-numbers"><code class="language-powershell"># Pour un formatage agréable, utilisez d abord Format-Table
$reportData | Format-Table -AutoSize | Out-File -FilePath "C:\Reports\photo_exif.txt"
</code></pre>
<p>La commande <code>Out-File</code> enregistrera dans un fichier une copie texte exacte de ce que vous voyez dans la console.</p>
<h4>**C) Envoi vers le presse-papiers**</h4>
<p>Vous voulez coller rapidement des données dans un e-mail ou un chat ? Utilisez <code>Out-Clipboard</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$reportData | Format-Table -AutoSize | Out-String | Out-Clipboard
</code></pre>
<p>Vous pouvez maintenant appuyer sur <code>Ctrl+V</code> dans n importe quel éditeur de texte et coller un tableau soigneusement formaté.</p>
<h3>Exemple n°3 : Obtention de données spécifiques à utiliser dans un script</h3>
<p>Souvent, vous n avez pas besoin du rapport entier, mais seulement d une ou deux valeurs. Puisque <code>$exifObject</code> est un objet <code>PowerShell</code> ordinaire, vous pouvez facilement accéder à ses propriétés.</p>
<pre class="line-numbers"><code class="language-powershell">
$photoPath = "D:\Photos\IMG_1234.JPG"

# Appeler exiftool.exe directement par son nom.
# PowerShell le trouvera automatiquement dans l un des dossiers répertoriés dans PATH.
$exifObject = exiftool.exe -json $photoPath | ConvertFrom-Json

# 1. Créer un objet PowerShell avec des noms de propriétés compréhensibles.
#    Ceci est similaire à la création d un enregistrement structuré.
$reportObject = [PSCustomObject]@{ 
    "Appareil photo"    = $exifObject.Model
    "Date de prise de vue" = $exifObject.DateTimeOriginal
    "Sensibilité"      = $exifObject.ISO
    "Nom du fichier"   = $exifObject.FileName # Ajouter le nom du fichier pour le contexte
}

# 2. Afficher cet objet dans une fenêtre interactive.
#    Out-GridView créera automatiquement des colonnes à partir des noms de propriétés.
$reportObject | Out-ConsoleGridView -Title "Métadonnées du fichier : $(Split-Path $photoPath -Leaf)"
</code></pre>
<p>Cette approche est la base de toute automatisation sérieuse, telle que le renommage de fichiers en fonction de la date de prise de vue, le tri de photos par modèle d appareil photo ou l ajout de filigranes avec des informations d exposition.</p>
<h3>Exemple n°4 : Extraction par lots de métadonnées d un dossier</h3>
<p>Parfois, il est nécessaire d analyser non pas une seule photo, mais un dossier entier d images.</p>
<pre class="line-numbers"><code class="language-powershell"># Spécifier uniquement le dossier de photos.
$photoFolder = "D:\Photos"

# Appeler exiftool.exe directement. La variable pour le chemin et l opérateur &amp; ne sont pas nécessaires.
$allExif = exiftool.exe -json "$photoFolder\*.jpg" | ConvertFrom-Json

# Transformer en une vue pratique 
$report = foreach ($photo in $allExif) {
    [PSCustomObject]@{ 
        # -- Données de base sur le fichier et l appareil photo ---
        FileName       = $photo.FileName
        DateTime       = $photo.DateTimeOriginal
        CameraMake     = $photo.Make                 # Fabricant (par exemple, "Canon", "SONY")
        CameraModel    = $photo.Model                 # Modèle d appareil photo (par exemple, "EOS R5")
        LensModel      = $photo.LensID                # Nom complet du modèle d objectif
        
        # -- Paramètres de prise de vue (exposition) ---
        ISO            = $photo.ISO
        ShutterSpeed   = $photo.ShutterSpeed
        Aperture       = $photo.Aperture
        FocalLength    = $photo.FocalLength           # Longueur focale (par exemple, "50.0 mm")
        ExposureMode   = $photo.ExposureProgram       # Mode de prise de vue (par exemple, "Manuel", "Priorité à l ouverture")
        Flash          = $photo.Flash                 # Informations sur le déclenchement du flash
        
        # -- GPS et données d image ---
        GPSPosition    = $photo.GPSPosition           # Coordonnées GPS sous forme de chaîne unique (si disponible)
        Dimensions     = "$($photo.ImageWidth)x$($photo.ImageHeight)" # Dimensions de l image en pixels
    }
}

# Afficher les données dans un tableau interactif dans la CONSOLE
$report | Out-ConsoleGridView -Title "Rapport récapitulatif pour le dossier : $photoFolder"
</code></pre>
<p>💡 Vous obtenez un tableau soigné pour tout le dossier en une seule fois.</p>
<hr>
<h3>Exemple n°5 : Recherche récursive dans les sous-dossiers</h3>
<p><code>ExifTool</code> peut rechercher des fichiers dans tous les sous-dossiers lui-même en utilisant l option <code>-r</code>.</p>
<pre class="line-numbers"><code class="language-powershell">&amp; $exifToolPath -r -json "D:\Photos" | ConvertFrom-Json |
    Select-Object FileName, Model, DateTimeOriginal |
    Export-Csv "C:\Reports\all_photos_recursive.csv" -NoTypeInformation -Encoding UTF8
</code></pre>
<hr>
<h3>Exemple n°6 : Renommer les fichiers par date de prise de vue</h3>
<p>C est l un des scénarios d automatisation les plus populaires – les fichiers sont nommés par la date/heure de leur prise de vue.</p>
<pre class="line-numbers"><code class="language-powershell">$exifToolPath = "C:\Tools\exiftool.exe"
$photoFolder = "D:\Photos"

# Renommer au format AAAA-MM-JJ_HH-MM-SS.jpg
&amp; $exifToolPath -r -d "%Y-%m-%d_%H-%M-%S.%%e" "-FileName&lt;DateTimeOriginal" $photoFolder
</code></pre>
<p>💡 <em><code>ExifTool</code> insérera automatiquement l extension de fichier d origine via <code>%%e</code>.</em></p>
<hr>
<h3>Exemple n°7 : Extraction des seules coordonnées <code>GPS</code></h3>
<p>Utile si vous souhaitez créer une carte à partir de vos photos.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Spécifiez le chemin du dossier contenant vos photos
$photoFolder = "E:\DCIM\Camera"

# 2. Listez les balises dont nous avons besoin : nom de fichier et trois balises GPS.
#    Cela rend la requête beaucoup plus rapide que si nous récupérions toutes les balises.
$tagsToExtract = @(
    "-SourceFile", # SourceFile est préférable à FileName, car il contient généralement le chemin complet
    "-GPSLatitude",
    "-GPSLongitude",
    "-GPSAltitude"
)

# 3. Appeler exiftool.exe directement (puisqu il est dans le PATH).
#    L option -r recherche les fichiers dans tous les sous-dossiers.
#    Le résultat est immédiatement converti à partir de JSON.
$allExifData = exiftool.exe -r -json $tagsToExtract $photoFolder | ConvertFrom-Json

# 4. Filtrer les résultats : ne conserver QUE les objets qui ont une latitude et une longitude.
$filesWithGps = $allExifData | Where-Object { $_.GPSLatitude -and $_.GPSLongitude }

# 5. Vérifier si des fichiers avec des données GPS ont été trouvés
if ($filesWithGps) {
    # 6. Créer un beau rapport à partir des données filtrées.
    #    Utiliser Select-Object pour renommer les colonnes et formater.
    $report = $filesWithGps | Select-Object @{Name="Nom du fichier"; Expression={Split-Path $_.SourceFile -Leaf}},
                                             @{Name="Latitude"; Expression={$_.GPSLatitude}},
                                             @{Name="Longitude"; Expression={$_.GPSLongitude}},
                                             @{Name="Altitude"; Expression={if ($_.GPSAltitude) { "$($_.GPSAltitude) m" } else { "N/A" }}}
    
    # 7. Afficher le rapport final dans un tableau de console interactif.
    $report | Out-ConsoleGridView -Title "Fichiers avec données GPS dans le dossier : $photoFolder"

} else {
    # Si rien n est trouvé, informer poliment l utilisateur.
    Write-Host "Fichiers avec données GPS dans le dossier '$photoFolder' introuvables." -ForegroundColor Yellow
}
</code></pre>
<hr>
<h3>Exemple n°8 : Suppression en masse de toutes les données <code>GPS</code> (pour la confidentialité)</h3>
<pre class="line-numbers"><code class="language-powershell"># Supprimer toutes les balises GPS des JPG et PNG
&amp; $exifToolPath -r -overwrite_original -gps:all= "D:\Photos"
</code></pre>
<p>💡 <em>Cette action est irréversible, alors faites une sauvegarde avant d exécuter.</em></p>
<hr>
<h3>Exemple n°9 : Conversion de l heure de prise de vue en heure locale</h3>
<p>Parfois, les photos sont prises dans un fuseau horaire différent. <code>ExifTool</code> peut décaler la date.</p>
<pre class="line-numbers"><code class="language-powershell"># Décaler l heure de +3 heures
&amp; $exifToolPath "-AllDates+=3:0:0" "D:\Photos\IMG_*.JPG"
</code></pre>
<hr>
<h3>Exemple n°10 : Obtenir une liste de tous les modèles d appareils photo uniques dans un dossier</h3>
<pre class="line-numbers"><code class="language-powershell">$models = &amp; $exifToolPath -r -Model -s3 "D:\Photos" | Sort-Object -Unique
$models | ForEach-Object { Write-Host "Modèle : $_" }
</code></pre>
<hr>
<h3>Exemple n°11 : Afficher uniquement les balises nécessaires sous forme de tableau</h3>
<pre class="line-numbers"><code class="language-powershell">&amp; $exifToolPath -T -Model -DateTimeOriginal -ISO -Aperture -ShutterSpeed "D:\Photos\IMG_1234.JPG"
</code></pre>
<p><code>-T</code> affiche la sortie au format tabulaire, séparée par des tabulations – pratique pour un traitement ultérieur.</p>
<hr>
<h3>Exemple n°12 : Vérification de la présence de <code>GPS</code> dans un grand tableau de fichiers</h3>
<pre class="line-numbers"><code class="language-powershell">$files = &amp; $exifToolPath -r -if "$gpslatitude" -p '$FileName' "D:\Photos"
Write-Host "Fichiers avec GPS :"
$files
</code></pre>
<hr>
<h3>Exemple n°13 : Copie de métadonnées d un fichier à l autre</h3>
<pre class="line-numbers"><code class="language-powershell"># 1. Sélectionner le fichier de référence
$sourceFile = Get-ChildItem "D:\Photos" -Filter "*.jpg" | Out-ConsoleGridView -Title "Sélectionner le fichier de RÉFÉRENCE"

# 2. Si une référence est sélectionnée, sélectionner les fichiers cibles
if ($sourceFile) {
    $targetFiles = Get-ChildItem "D:\Photos\New" -Filter "*.jpg" | Out-ConsoleGridView -Title "Sélectionner les fichiers CIBLES pour la copie de métadonnées" -OutputMode Multiple
    
    # 3. Si les cibles sont sélectionnées, effectuer la copie
    if ($targetFiles) {
        &amp; exiftool.exe -TagsFromFile $sourceFile.FullName ($targetFiles.FullName)
        Write-Host "Métadonnées copiées de $($sourceFile.Name) vers $($targetFiles.Count) fichiers."
    }
}
</code></pre>
<hr>
<h3>Exemple n°14 : Enregistrement des métadonnées d origine dans un fichier <code>JSON</code> séparé avant modification</h3>
<pre class="line-numbers"><code class="language-powershell">$backupPath = "C:\Reports\metadata_backup.json"
&amp; $exifToolPath -r -json "D:\Photos" | Out-File -Encoding UTF8 $backupPath
</code></pre>
<hr>
<h3>Exemple n°15 : Utilisation de <code>PowerShell</code> pour le tri automatique des photos par date</h3>
<pre class="line-numbers"><code class="language-powershell">$photos = Get-ChildItem "D:\Photos" -Filter *.jpg -Recurse
foreach ($photo in $photos) {
    $meta = &amp; $exifToolPath -json $photo.FullName | ConvertFrom-Json
    $date = Get-Date $meta.DateTimeOriginal -ErrorAction SilentlyContinue
    if ($date) {
        $targetFolder = "D:\Sorted\{0:yyyy}\{0:MM}" -f $date
        if (-not (Test-Path $targetFolder)) { New-Item -Path $targetFolder -ItemType Directory }
        Move-Item $photo.FullName -Destination $targetFolder
    }
}
</code></pre>
<hr>
<h3>Exemple 16 : Trouver tous les modèles d appareils photo uniques dans une collection</h3>
<p>Bien que cela puisse être fait en une seule ligne, l affichage dans <code>GridView</code> vous permet de copier immédiatement le nom du modèle souhaité.</p>
<pre class="line-numbers"><code class="language-powershell"># L option -s3 affiche uniquement les valeurs, -Model - le nom de la balise
$uniqueModels = &amp; exiftool.exe -r -Model -s3 "D:\Photos" | Sort-Object -Unique

# Afficher dans GridView pour une visualisation et une copie faciles
$uniqueModels | Out-ConsoleGridView -Title "Modèles d appareils photo uniques dans la collection"
</code></pre>