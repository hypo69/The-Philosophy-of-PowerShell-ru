<h2>Philosophie PowerShell.</h2>
<h3>**Partie 3 : Navigation et gestion du système de fichiers. Opérateurs logiques. Introduction aux fonctions.**</h3>
<p>Dans la <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md">partie précédente</a>, nous avons exploré les pipelines et les objets de processus abstraits. Appliquons maintenant nos connaissances sur les pipelines et les objets à l'une des tâches courantes de l'utilisateur ou de l'administrateur : le travail avec le système de fichiers. Dans <code>PowerShell</code>, ce travail est basé sur les mêmes principes : les commandes renvoient des objets qui peuvent être passés via le pipeline pour un traitement ultérieur.</p>
<hr>
<h3>**1. Concept des PowerShell Drives (PSDrives)**</h3>
<p>Avant de commencer à travailler avec les fichiers, il est important de comprendre le concept des **<code>PowerShell</code>-disques (<code>PSDrives</code>)**. Contrairement à <code>cmd.exe</code>, où les disques — ce sont seulement des lettres <code>C:</code>, <code>D:</code> et ainsi de suite, dans <code>PowerShell</code> "disque" — c'est une abstraction pour accéder à tout stockage de données hiérarchique.</p>
<pre class="line-numbers"><code class="language-powershell">Get-PSDrive
</code></pre>
<p>Le résultat affichera non seulement les disques physiques, mais aussi les pseudo-disques :</p>
<table>
<thead>
<tr>
<th>Nom</th>
<th>Fournisseur</th>
<th>Racine</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alias</td>
<td>Alias</td>
<td>Alias:\</td>
<td>Alias de commandes</td>
</tr>
<tr>
<td>C</td>
<td>FileSystem</td>
<td>C:\</td>
<td>Disque local C</td>
</tr>
<tr>
<td>Cert</td>
<td>Certificate</td>
<td>Cert:\</td>
<td>Magasin de certificats</td>
</tr>
<tr>
<td>Env</td>
<td>Environment</td>
<td>Env:\</td>
<td>Variables d'environnement</td>
</tr>
<tr>
<td>Function</td>
<td>Function</td>
<td>Function:\</td>
<td>Fonctions chargées</td>
</tr>
<tr>
<td>HKCU</td>
<td>Registry</td>
<td>HKEY_CURRENT_USER</td>
<td>Branche du registre</td>
</tr>
<tr>
<td>HKLM</td>
<td>Registry</td>
<td>HKEY_LOCAL_MACHINE</td>
<td>Branche du registre</td>
</tr>
<tr>
<td>Variable</td>
<td>Variable</td>
<td>Variable:\</td>
<td>Variables de session</td>
</tr>
<tr>
<td>WSMan</td>
<td>WSMan</td>
<td>WSMan:\</td>
<td>Configuration WinRM</td>
</tr>
</tbody>
</table>
<p>Cette unification signifie que vous pouvez "entrer" dans le registre (<code>Set-Location HKLM:</code>) et obtenir une liste de ses clés avec la même commande <code>Get-ChildItem</code> que celle utilisée pour obtenir une liste de fichiers sur le disque <code>C:</code>. C'est un concept incroyablement puissant.</p>
<h4>**Exemples de travail avec différents fournisseurs**</h4>
<ul>
<li>
<p><strong>Magasin de certificats (Cert:)</strong>
Permet de travailler avec des certificats numériques comme s'il s'agissait de fichiers dans des dossiers.</p>
<p><strong>Tâche :</strong> Trouver tous les certificats <code>SSL</code> sur la machine locale dont la date d'expiration est dans les 30 prochains jours.</p>
<pre class="line-numbers"><code class="language-powershell"># Accéder au magasin de certificats de l'ordinateur local
Set-Location Cert:\LocalMachine\My

# Trouver les certificats dont la date de fin est inférieure à aujourd'hui + 30 jours
Get-ChildItem | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) } | Select-Object Subject, NotAfter, Thumbprint
</code></pre>
</li>
<li>
<p><strong>Variables d'environnement (Env:)</strong>
Fournit un accès aux variables d'environnement <code>Windows</code> (<code>%PATH%</code>, <code>%windir%</code> et ainsi de suite) comme s'il s'agissait de fichiers.</p>
<p><strong>Tâche :</strong> Obtenir le chemin du dossier système <code>Windows</code> et y ajouter le chemin de <code>System32</code>.</p>
<pre class="line-numbers"><code class="language-powershell"># Obtenir la valeur de la variable windir
$windowsPath = (Get-Item Env:windir).Value
# Ou plus simplement : $windowsPath = $env:windir

# Construire le chemin complet en toute sécurité
$system32Path = Join-Path -Path $windowsPath -ChildPath "System32"
Write-Host $system32Path
# Résultat : C:\WINDOWS\System32
</code></pre>
</li>
<li>
<p><strong>Registre <code>Windows</code> (HKCU: et HKLM:)</strong>
Imaginez que le registre — c'est juste un autre système de fichiers. Les branches — ce sont des dossiers, et les paramètres — des propriétés de ces dossiers.</p>
<p><strong>Tâche :</strong> Connaître le nom complet de la version de <code>Windows</code> installée à partir du registre.</p>
<pre class="line-numbers"><code class="language-powershell"># Accéder à la branche de registre souhaitée
Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

# Obtenir la propriété (paramètre de registre) nommée "ProductName"
Get-ItemProperty -Path . -Name "ProductName"
# Résultat : ProductName : Windows 11 Pro
</code></pre>
</li>
<li>
<p><strong>Fonctions chargées (Function:)</strong>
Affiche toutes les fonctions disponibles dans la session <code>PowerShell</code> actuelle, comme s'il s'agissait de fichiers.</p>
<p><strong>Tâche :</strong> Trouver toutes les fonctions chargées dont le nom contient le mot "Help" et afficher le code de l'une d'elles.</p>
<pre class="line-numbers"><code class="language-powershell"># Rechercher des fonctions par masque
Get-ChildItem Function: | Where-Object { $_.Name -like "*Help*" }

# Obtenir le code complet (définition) de la fonction Get-Help
(Get-Item Function:Get-Help).Definition
</code></pre>
</li>
<li>
<p><strong>Variables de session (Variable:)</strong>
Permet de gérer toutes les variables (<code>$myVar</code>, <code>$PROFILE</code>, <code>$Error</code> et ainsi de suite), définies dans la session actuelle.</p>
<p><strong>Tâche :</strong> Trouver toutes les variables liées à la version de <code>PowerShell</code> (<code>$PSVersionTable</code>, <code>$PSHOME</code> et ainsi de suite).</p>
<pre class="line-numbers"><code class="language-powershell"># Trouver toutes les variables commençant par "PS"
Get-ChildItem Variable:PS*

# Obtenir la valeur d'une variable spécifique
Get-Variable -Name "PSVersionTable"
</code></pre>
</li>
</ul>
<hr>
<h3>**2. Navigation et analyse**</h3>
<h4>**Bases de la navigation**</h4>
<pre class="line-numbers"><code class="language-powershell"># Savoir où nous sommes (renvoie un objet PathInfo)
Get-Location          # Alias : gl, pwd

# Aller à la racine du disque C:
Set-Location C:\      # Alias : sl, cd

# Aller au dossier personnel de l'utilisateur actuel
Set-Location ~

# Afficher le contenu du dossier actuel (renvoie une collection d'objets)
Get-ChildItem         # Alias : gci, ls, dir
</code></pre>
<pre class="line-numbers"><code class="language-powershell"># **Recherche récursive**
# Trouver le fichier hosts dans le système, en ignorant les erreurs "Accès refusé"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
</code></pre>
<p><strong>Clé <code>-Recurse</code> (Récursif) :</strong> Force le cmdlet à travailler non seulement avec l'élément spécifié, mais aussi avec tout son contenu.</p>
<p><strong>Clé <code>-ErrorAction SilentlyContinue</code> :</strong> Instruction d'ignorer les erreurs et de continuer à travailler silencieusement.</p>
<h4>**Analyse de l'espace disque**</h4>
<p>Un exemple classique de la puissance du pipeline : trouver, trier, formater et sélectionner.</p>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue | \
    Sort-Object Length -Descending | \
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} | \
    Select-Object -First 20
</code></pre>
<h6>**Astuce pour saisir de longues commandes.**</h6>
<blockquote>
<p><code>PowerShell</code> permet de les diviser en plusieurs lignes pour faciliter la lecture.</p>
<ul>
<li><strong>Après l'opérateur de pipeline (<code>|</code>) :</strong> C'est le moyen le plus courant et le plus pratique. Appuyez simplement sur <code>Entrée</code> après le symbole <code>|</code>. <code>PowerShell</code> verra que la commande n'est pas terminée et attendra la suite sur la ligne suivante.</li>
<li><strong>N'importe où ailleurs :</strong> Utilisez le caractère d'accent grave (backtick) `` ` `` à la fin de la ligne, puis appuyez sur <code>Entrée</code>. Ce caractère indique à <code>PowerShell</code> : "La commande continuera sur la ligne suivante".</li>
<li><strong>Dans les éditeurs (<code>ISE</code>, <code>VS Code</code>) :</strong> La combinaison de touches <code>Shift+Entrée</code> insère généralement automatiquement un saut de ligne sans exécuter la commande.</li>
</ul>
</blockquote>
<h4>**Filtrage du contenu et opérateurs logiques**</h4>
<pre class="line-numbers"><code class="language-powershell"># Trouver tous les fichiers .exe. Le paramètre -Filter fonctionne très rapidement.
Get-ChildItem C:\Windows -Filter "*.exe"
</code></pre>
<p><code>Get-ChildItem</code> renvoie une collection d'objets. Nous pouvons la passer via le pipeline à <code>Where-Object</code> pour un filtrage ultérieur.</p>
<pre class="line-numbers"><code class="language-powershell"># Afficher uniquement les fichiers
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
</code></pre>
<p>Cette commande nous introduit à l'une des notions fondamentales des scripts <code>PowerShell</code> : les **opérateurs de comparaison**.</p>
<h4>**Opérateurs de comparaison et de logique**</h4>
<p>Ce sont des clés spéciales pour comparer des valeurs. Elles commencent toujours par un tiret (<code>-</code>) et sont la base pour filtrer les données dans <code>Where-Object</code> et construire la logique dans <code>if</code>.</p>
<table>
<thead>
<tr>
<th>Opérateur</th>
<th>Description</th>
<th>Exemple dans le pipeline</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-eq</code></td>
<td>Égal (<code>EQual</code>)</td>
<td><code>$_.Name -eq "svchost.exe"</code></td>
</tr>
<tr>
<td><code>-ne</code></td>
<td>Non égal (<code>Not Equal</code>)</td>
<td><code>$_.Status -ne "Running"</code></td>
</tr>
<tr>
<td><code>-gt</code></td>
<td>Plus grand que (<code>Greater Than</code>)</td>
<td><code>$_.Length -gt 1MB</code></td>
</tr>
<tr>
<td><code>-ge</code></td>
<td>Plus grand ou égal (<code>Greater or Equal</code>)</td>
<td><code>$_.Handles -ge 500</code></td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>Plus petit que (<code>Less Than</code>)</td>
<td><code>$_.LastWriteTime -lt (Get-Date).AddDays(-30)</code></td>
</tr>
<tr>
<td><code>-le</code></td>
<td>Plus petit ou égal (<code>Less or Equal</code>)</td>
<td><code>$_.Count -le 1</code></td>
</tr>
<tr>
<td><code>-like</code></td>
<td>Similaire à (avec des caractères génériques <code>*</code>, <code>?</code>)</td>
<td><code>$_.Name -like "win*"</code></td>
</tr>
<tr>
<td><code>-notlike</code></td>
<td>Non similaire à</td>
<td><code>$_.Name -notlike "*.tmp"</code></td>
</tr>
<tr>
<td><code>-in</code></td>
<td>La valeur est contenue dans la collection</td>
<td><code>$_.Extension -in ".log", ".txt"</code></td>
</tr>
<tr>
<td><code>-and</code></td>
<td>Logique ET (les deux conditions sont vraies)</td>
<td></td>
</tr>
<tr>
<td><code>-or</code></td>
<td>Logique OU (au moins une condition est vraie)</td>
<td></td>
</tr>
<tr>
<td><code>-not</code></td>
<td>Logique NON (inverse la condition)</td>
<td></td>
</tr>
</tbody>
</table>
<p>Le sujet des opérateurs logiques est très vaste et je lui consacrerai une partie séparée (voire deux). En attendant, armés de ces opérateurs, nous pouvons <strong>filtrer, trier et sélectionner les fichiers et dossiers dont nous avons besoin</strong>, en utilisant toute la puissance du pipeline d'objets.</p>
<h4>**Exemples d'utilisation dans le système de fichiers**</h4>
<ul>
<li>
<p><strong>Trouver un fichier par nom exact (sensible à la casse) :</strong></p>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem C:\Windows\System32 -Recurse | Where-Object { $_.Name -eq "kernel32.dll" }
</code></pre>
</li>
<li>
<p><strong>Trouver tous les fichiers commençant par "host", mais qui ne sont pas des dossiers :</strong></p>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem C:\Windows\System32\drivers\etc | Where-Object { ($_.Name -like "host*") -and (-not $_.PSIsContainer) }
</code></pre>
</li>
<li>
<p><strong>Trouver tous les fichiers journaux (.log) dont la taille dépasse 50 mégaoctets :</strong></p>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem C:\Windows\Logs -Filter "*.log" -Recurse | Where-Object { $_.Length -gt 50MB }
</code></pre>
</li>
<li>
<p><strong>Trouver tous les fichiers temporaires (.tmp) et les fichiers de sauvegarde (.bak) à nettoyer :</strong>
L'opérateur <code>-in</code> est ici beaucoup plus élégant que plusieurs conditions avec <code>-or</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$extensionsToDelete = ".tmp", ".bak", ".old"
Get-ChildItem C:\Temp -Recurse | Where-Object { $_.Extension -in $extensionsToDelete }
</code></pre>
</li>
<li>
<p><strong>Trouver tous les fichiers <code>Word</code> (.docx) créés au cours de la dernière semaine :</strong></p>
<pre class="line-numbers"><code class="language-powershell">$oneWeekAgo = (Get-Date).AddDays(-7)
Get-ChildItem C:\Users\MyUser\Documents -Filter "*.docx" -Recurse | Where-Object { $_.CreationTime -ge $oneWeekAgo }
</code></pre>
</li>
<li>
<p><strong>Trouver les fichiers vides (taille 0 octet) qui ne sont pas des dossiers :</strong></p>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem C:\Downloads -Recurse | Where-Object { ($_.Length -eq 0) -and (-not $_.PSIsContainer) }
</code></pre>
</li>
<li>
<p><strong>Trouver tous les fichiers exécutables (.exe) qui ont été modifiés cette année, mais PAS ce mois-ci :</strong>
Cet exemple complexe démontre la puissance de la combinaison d'opérateurs.</p>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem "C:\Program Files" -Filter "*.exe" -Recurse | Where-Object {
    ($_.LastWriteTime.Year -eq (Get-Date).Year) -and ($_.LastWriteTime.Month -ne (Get-Date).Month)
}
</code></pre>
</li>
</ul>
<p>(<em>Note : les parenthèses <code>()</code> autour de chaque condition sont utilisées pour le regroupement et l'amélioration de la lisibilité, en particulier dans les cas complexes).</em></p>
<p>Soyez prudent avec la récursion :
Beaucoup de fichiers/dossiers – <code>-Recurse</code> peut entrer récursivement dans des dizaines de milliers d'éléments.
Liens symboliques / liens cycliques – peuvent provoquer une récursion infinie.
Fichiers sans droits d'accès – peuvent bloquer l'exécution.</p>
<h3>4. **Création, gestion et suppression sécurisée**</h3>
<h4>**Création, copie et déplacement**</h4>
<pre class="line-numbers"><code class="language-powershell">New-Item -Path "C:\Temp\MyFolder" -ItemType Directory
Add-Content -Path "C:\Temp\MyFolder\MyFile.txt" -Value "Première ligne"
Copy-Item -Path "C:\Temp\MyFolder" -Destination "C:\Temp\MyFolder_Copy" -Recurse
</code></pre>
<h4>**Suppression sécurisée**</h4>
<p><code>Remove-Item</code> est un cmdlet potentiellement dangereux, c'est pourquoi <code>PowerShell</code> intègre des mécanismes de protection.</p>
<blockquote>
<p><strong>Clé <code>-WhatIf</code> (Et si ?) :</strong> Votre meilleur ami. Il <strong>n'exécute pas</strong> la commande, mais affiche simplement un message dans la console sur <strong>ce qui se passerait</strong>.</p>
</blockquote>
<pre class="line-numbers"><code class="language-powershell"># VÉRIFICATION SÉCURISÉE avant la suppression
Remove-Item C:\Temp\MyFolder -Recurse -Force -WhatIf
# Résultat : What if: Performing the operation "Remove Directory" on target "C:\Temp\MyFolder".

# Seulement après s'être assuré que tout est correct, on retire -WhatIf et on EXÉCUTE la commande
Remove-Item C:\Temp\MyFolder -Recurse -Force
</code></pre>
<hr>
<h3>**Introduction aux fonctions**</h3>
<p>Lorsqu'une ligne de code se transforme en un ensemble complexe de commandes que vous souhaitez utiliser encore et encore, il est temps de créer des <strong>fonctions</strong>.</p>
<h4>**Comment utiliser et enregistrer des fonctions**</h4>
<p>Il existe trois façons principales de rendre vos fonctions disponibles :</p>
<p><strong>Méthode 1 : Temporaire (pour les tests)</strong>
Vous pouvez taper dans la console ou simplement copier-coller tout le code de la fonction dans la console <code>PowerShell</code>. La fonction sera disponible jusqu'à la fermeture de cette fenêtre.</p>
<p><strong>Méthode 2 : Permanente, mais manuelle (via un fichier <code>.ps1</code>)</strong>
C'est le moyen le plus courant d'organiser et de partager des outils. Vous enregistrez la fonction dans un fichier <code>.ps1</code> et la chargez dans la session lorsque vous en avez besoin.</p>
<blockquote>
<p><strong>Dot Sourcing (<code>. .\script.ps1</code>) :</strong> Cette commande spéciale exécute le script dans le <em>contexte actuel</em>, rendant toutes ses fonctions et variables disponibles dans votre console.</p>
</blockquote>
<p><strong>Méthode 3 : Automatique (via le profil <code>PowerShell</code>)</strong>
C'est le moyen le plus puissant pour vos outils personnels, fréquemment utilisés.</p>
<blockquote>
<p><strong>Qu'est-ce qu'un profil <code>PowerShell</code> ?</strong> C'est un script <code>.ps1</code> spécial que <code>PowerShell</code> exécute automatiquement à chaque démarrage. Tout ce que vous placez dans ce fichier – alias, variables et, bien sûr, fonctions – sera disponible dans chacune de vos sessions par défaut.</p>
</blockquote>
<h5>**Exemple 1 : Recherche de fichiers en double**</h5>
<p>Passons en revue toutes les étapes avec l'exemple de la fonction <code>Find-DuplicateFiles</code>.</p>
<p><strong>Étape 1 : Définir le code de la fonction</strong></p>
<pre class="line-numbers"><code class="language-powershell">$functionCode = @'
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )
    
    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue | \
        Group-Object Name, Length | \
        Where-Object { $_.Count -gt 1 } | \
        ForEach-Object {
            # C'EST LA LIGNE CORRIGÉE :
            # À l'intérieur de l'opérateur $() les variables ne sont pas échappées.
            Write-Host "Doublons trouvés : $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
        }
}
'@
</code></pre>
<p><strong>Étape 2 (Option A) : Enregistrer dans un fichier séparé pour un chargement manuel</strong></p>
<pre class="line-numbers"><code class="language-powershell"># Enregistrer
Set-Content -Path ".\Find-DuplicateFiles.ps1" -Value $functionCode
# Charger 
. .\Find-DuplicateFiles.ps1
</code></pre>
<blockquote>
<p>Dot Sourcing (<code>. .\Find-DuplicateFiles.ps1</code>) : Cette commande spéciale exécute le script dans le contexte actuel, rendant toutes ses fonctions et variables disponibles dans votre console.</p>
</blockquote>
<pre class="line-numbers"><code class="language-powershell"># Appeler
Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Downloads"
</code></pre>
<p><strong>Étape 2 (Option B) : Ajouter au profil pour un chargement automatique</strong>
Rendons cette fonction toujours disponible.</p>
<blockquote>
<p>Qu'est-ce qu'un profil <code>PowerShell</code> ? C'est un script <code>.ps1</code> spécial que <code>PowerShell</code> exécute automatiquement à chaque démarrage. Tout ce que vous placez dans ce fichier – alias, variables et fonctions – sera disponible dans chacune de vos sessions par défaut.</p>
</blockquote>
<ol>
<li><strong>Trouver le chemin du fichier de profil.</strong> <code>PowerShell</code> le stocke dans la variable <code>$PROFILE</code>.</li>
</ol>
<pre class="line-numbers"><code class="language-powershell">$PROFILE
</code></pre>
<ol start="2">
<li><strong>Créer le fichier de profil s'il n'existe pas.</strong></li>
</ol>
<pre class="line-numbers"><code class="language-powershell">if (-not (Test-Path $PROFILE)) {
    New-Item -Path $PROFILE -Type File -Force
}
</code></pre>
<ol start="3">
<li><strong>Ajouter le code de notre fonction à la fin du fichier de profil.</strong></li>
</ol>
<pre class="line-numbers"><code class="language-powershell">Add-Content -Path $PROFILE -Value $functionCode
</code></pre>
<ol start="4">
<li><strong>Redémarrez <code>PowerShell</code></strong> (ou exécutez <code>. $PROFILE</code>), et maintenant votre commande <code>Find-DuplicateFiles</code> sera toujours disponible, tout comme <code>Get-ChildItem</code>.</li>
</ol>
<h5>**Exemple 2 : Création d'une archive <code>ZIP</code> de sauvegarde**</h5>
<p><strong>Code pour le fichier <code>Backup-FolderToZip.ps1</code> :</strong></p>
<pre class="line-numbers"><code class="language-powershell">function Backup-FolderToZip {
    param([string]$SourcePath, [string]$DestinationPath)
    if (-not (Test-Path $SourcePath)) { Write-Error "Le dossier source est introuvable."; return }
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName
    if (-not (Test-Path $DestinationPath)) { New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null }
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force
    Write-Host "Sauvegarde terminée : $fullArchivePath" -ForegroundColor Green
}
</code></pre>
<p>Une analyse détaillée des fonctions sera effectuée dans les parties suivantes.</p>
<hr>
<h3>**Référence des cmdlets pour le travail avec le système de fichiers**</h3>
<h4>**1. Cmdlets de base**</h4>
<p>Cette liste comprend les 12 cmdlets les plus nécessaires, qui couvrent 90% des tâches quotidiennes.</p>
<table>
<thead>
<tr>
<th>Cmdlet</th>
<th>Objectif principal</th>
<th>Exemple d'utilisation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Get-ChildItem</code></td>
<td>Obtenir la liste des fichiers et dossiers.</td>
<td><code>Get-ChildItem C:\Windows</code></td>
</tr>
<tr>
<td><code>Set-Location</code></td>
<td>Se déplacer vers un autre répertoire.</td>
<td><code>Set-Location C:\Temp</code></td>
</tr>
<tr>
<td><code>Get-Location</code></td>
<td>Afficher le répertoire actuel.</td>
<td><code>Get-Location</code></td>
</tr>
<tr>
<td><code>New-Item</code></td>
<td>Créer un nouveau fichier ou dossier.</td>
<td><code>New-Item "report.docx" -Type File</code></td>
</tr>
<tr>
<td><code>Remove-Item</code></td>
<td>Supprimer un fichier ou un dossier.</td>
<td><code>Remove-Item "old_log.txt"</code></td>
</tr>
<tr>
<td><code>Copy-Item</code></td>
<td>Copier un fichier ou un dossier.</td>
<td><code>Copy-Item "file.txt" -Dest "D:\"</code></td>
</tr>
<tr>
<td><code>Move-Item</code></td>
<td>Déplacer un fichier ou un dossier.</td>
<td><code>Move-Item "report.docx" -Dest "C:\Archive"</code></td>
</tr>
<tr>
<td><code>Rename-Item</code></td>
<td>Renommer un fichier ou un dossier.</td>
<td><code>Rename-Item "old.txt" -NewName "new.txt"</code></td>
</tr>
<tr>
<td><code>Get-Content</code></td>
<td>Lire le contenu d'un fichier.</td>
<td><code>Get-Content "config.ini"</code></td>
</tr>
<tr>
<td><code>Set-Content</code></td>
<td>Écrire/écraser le contenu d'un fichier.</td>
<td><code>"data" | Set-Content "file.txt"</code></td>
</tr>
<tr>
<td><code>Add-Content</code></td>
<td>Ajouter du contenu à la fin d'un fichier.</td>
<td><code>Get-Date | Add-Content "log.txt"</code></td>
</tr>
<tr>
<td><code>Test-Path</code></td>
<td>Vérifier si un fichier ou un dossier existe.</td>
<td><code>Test-Path "C:\Temp"</code></td>
</tr>
</tbody>
</table>
<p>Il faut <strong>lire le contenu</strong> d'un fichier texte ? Utilisez <code>Get-Content</code>.
Il faut <strong>écraser complètement un fichier</strong> avec un nouveau contenu ? Utilisez <code>Set-Content</code>.
Il faut <strong>ajouter une ligne à un fichier journal</strong>, sans effacer les anciennes données ? Utilisez <code>Add-Content</code>.
Il faut <strong>vérifier si un fichier existe</strong> avant d'écrire ? Utilisez <code>Test-Path</code>.</p>
<h4>**2. Cmdlets spécialisés pour les tâches avancées**</h4>
<p>Lorsque les cmdlets de base ne suffisent pas, <code>PowerShell</code> propose des outils plus spécialisés. Ils ne dupliquent pas les cmdlets de base, mais étendent vos capacités.</p>
<ul>
<li>
<p><strong>Travail avec les chemins (Path)</strong></p>
<ul>
<li><strong><code>Join-Path</code></strong> : Joint les parties d'un chemin en toute sécurité, en insérant automatiquement <code>\</code>.</li>
<li><strong><code>Split-Path</code></strong> : Divise un chemin en parties (dossier, nom de fichier, extension).</li>
<li><strong><code>Resolve-Path</code></strong> : Convertit un chemin relatif (par exemple, <code>.</code> ou <code>..\files</code>) en un chemin complet, absolu.</li>
</ul>
</li>
<li>
<p><strong>Travail avec les propriétés et le contenu (Item Properties and Content)</strong></p>
<ul>
<li><strong><code>Get-ItemProperty</code></strong> : Obtient les propriétés d'un fichier spécifique (par exemple, <code>IsReadOnly</code>, <code>CreationTime</code>).</li>
<li><strong><code>Set-ItemProperty</code></strong> : Modifie les propriétés d'un fichier ou d'un dossier.</li>
<li><strong><code>Clear-Content</code></strong> : Supprime tout le contenu d'un fichier, mais laisse le fichier vide.</li>
</ul>
</li>
<li>
<p><strong>Navigation avancée (Location Stack)</strong></p>
<ul>
<li><strong><code>Push-Location</code></strong> : "Mémorise" le répertoire actuel et passe à un nouveau.</li>
<li><strong><code>Pop-Location</code></strong> : Revient au répertoire "mémorisé" par <code>Push-Location</code>.</li>
</ul>
</li>
<li>
<p><strong>Gestion des droits d'accès (ACL)</strong></p>
<ul>
<li><strong><code>Get-Acl</code></strong> : Obtient la liste des droits d'accès (<code>ACL</code>) pour un fichier ou un dossier.</li>
<li><strong><code>Set-Acl</code></strong> : Définit les droits d'accès pour un fichier ou un dossier (opération complexe).</li>
</ul>
</li>
</ul>
<p>Il faut <strong>modifier un attribut de fichier</strong>, par exemple, le rendre « en lecture seule » ? Utilisez <code>Set-ItemProperty</code>.
Il faut <strong>effacer complètement un fichier journal</strong>, sans le supprimer ? Utilisez <code>Clear-Content</code>.
Il faut <strong>passer temporairement à un autre dossier</strong> dans un script, puis revenir en arrière de manière garantie ? Utilisez <code>Push-Location</code> et <code>Pop-Location</code>.
Il faut <strong>savoir qui a les droits</strong> d'accès à un dossier ? Utilisez <code>Get-Acl</code>.</p>
<p>Dans la partie suivante, nous apprendrons à travailler avec d'autres stockages de données, tels que le registre <code>Windows</code>, en utilisant les mêmes approches, nous approfondirons la notion de fonctions, examinerons les opérateurs logiques et apprendrons à interagir de manière interactive avec le shell.</p>
<p>Philosophie <code>PowerShell</code> sur <code>github</code>:<br>
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md">Histoire et premier cmdlet</a></p>
<p>Partie 2 : <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/02.md">Pipeline, variables, Get-Member, fichier .ps1 et exportation des résultats.</a><br>
Exemples pour la deuxième partie :<br>
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/02/system_monitor.ps1">system_monitor.ps1</a></p>
<p>Partie 3 : <a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/03.md">Navigation et gestion du système de fichiers.</a></p>
<p>Exemples pour la troisième partie:<br>
<a href="https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/03/Find-DuplicateFiles.ps1">Find-DuplicateFiles.ps1</a><br>
<a href="">Backup-FolderToZip</a></p>