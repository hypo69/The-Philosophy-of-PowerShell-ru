<h2>La philosophie PowerShell.</h2>
<h3>Partie 0.</h3>
<p>Qu'est-ce qui a pr√©c√©d√© PowerShell?</p>
<p>en 1981, MS-DOS 1.0 a √©t√© publi√© avec l'interpr√©teur de commandes `COMMAND.COM`. Pour automatiser les t√¢ches, des **fichiers batch (`.bat`)** √©taient utilis√©s ‚Äî de simples fichiers texte avec une s√©quence de commandes de console. Un asc√©tisme √©tonnant de la ligne de commande par rapport aux syst√®mes compatibles POSIX o√π le **shell Bourne (`sh`)** existait depuis 1979.</p>

<h3>üìÖ √âtat du march√© des shells au moment de la sortie de MS-DOS 1.0 (ao√ªt 1981)</h3>
<p>Voici un tableau r√©capitulatif des syst√®mes d'exploitation populaires de l'√©poque et de leur prise en charge des shells (`sh`, `csh`, etc.):</p>
<table>
<thead>
<tr>
<th>Syst√®me d'exploitation</th>
<th>Prise en charge des shells (`sh`, `csh`, etc.)</th>
<th>Commentaire</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UNIX Version 7 (V7)</strong></td>
<td>`sh`</td>
<td>Le dernier UNIX classique de Bell Labs, largement diffus√©</td>
</tr>
<tr>
<td><strong>UNIX/32V</strong></td>
<td>`sh`, `csh`</td>
<td>Version UNIX pour l'architecture VAX</td>
</tr>
<tr>
<td><strong>4BSD / 3BSD</strong></td>
<td>`sh`, `csh`</td>
<td>Branche universitaire d'UNIX de Berkeley</td>
</tr>
<tr>
<td><strong>UNIX System III</strong></td>
<td>`sh`</td>
<td>La premi√®re version commerciale d'AT&amp;T, le pr√©d√©cesseur de System V</td>
</tr>
<tr>
<td><strong>Xenix (de Microsoft)</strong></td>
<td>`sh`</td>
<td>Version sous licence d'UNIX, vendue par Microsoft depuis 1980</td>
</tr>
<tr>
<td><strong>IDRIS</strong></td>
<td>`sh`</td>
<td>Syst√®me d'exploitation de type UNIX pour PDP-11 et Intel</td>
</tr>
<tr>
<td><strong>Coherent (Mark Williams)</strong></td>
<td>`sh` (similaire)</td>
<td>Alternative peu co√ªteuse √† UNIX pour PC</td>
</tr>
<tr>
<td><strong>CP/M (Digital Research)</strong></td>
<td>‚ùå (Pas de `sh`, seulement un simple CLI)</td>
<td>Pas UNIX, le syst√®me d'exploitation le plus populaire pour les PC 8 bits</td>
</tr>
<tr>
<td><strong>MS-DOS 1.0</strong></td>
<td>‚ùå (seulement `COMMAND.COM`)</td>
<td>Shell de commande minimal, pas de scripts ni de pipes</td>
</tr>
</tbody>
</table>
<hr>
<h3>üí° Que sont `sh`, `csh`</h3>
<ul>
<li>`sh` ‚Äî <strong>Bourne Shell</strong>, le principal interpr√©teur de scripts pour UNIX depuis 1977.</li>
<li>`csh` ‚Äî <strong>C Shell</strong>, un shell am√©lior√© avec une syntaxe de type C et des commodit√©s pour le travail interactif.</li>
<li>Ces shells <strong>prenaient en charge les redirections, les pipes, les variables, les fonctions et les conditions</strong> ‚Äî tout ce qui a fait d'UNIX un puissant outil d'automatisation.</li>
</ul>
<hr>
<p>Microsoft s'est concentr√© sur les <strong>PC IBM 16 bits bon march√©</strong>, qui avaient <strong>peu de m√©moire</strong> (g√©n√©ralement 64 √† 256 Ko), pas de multit√¢che et √©taient destin√©s √† un <strong>usage domestique et de bureau</strong>, pas aux serveurs. UNIX √©tait payant, n√©cessitait une architecture et une exp√©rience complexes, et les comptables et les ing√©nieurs, et non les administrateurs syst√®me, avaient besoin d'un syst√®me d'exploitation rapide et simple.</p>
<p>Au lieu du complexe `sh`, l'interface DOS √©tait un seul fichier command.com avec un maigre ensemble de commandes internes <a href="https://www.techgeekbuzz.com/blog/dos-commands/" target="_blank">(dir, copy, del, etc.)</a> sans fonctions, boucles ou modules.</p>
<p>Il y avait aussi des commandes externes ‚Äî des fichiers ex√©cutables s√©par√©s (.exe ou .com). Exemples: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Les sc√©narios d'ex√©cution √©taient √©crits dans un fichier texte avec l'extension .bat (fichier batch).</p>
<p>Exemples de fichiers de configuration:</p>
<ul>
<li>AUTOEXEC.BAT</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Configuration et d√©marrage automatiques de Windows 3.11
:: Auteur: hypo69
:: Ann√©e: environ 1993
:: Objectif: initialise l'environnement DOS, charge les pilotes r√©seau et d√©marre Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: D√©finition de l'invite de commandes
PROMPT $p$g

:: D√©finition des variables d'environnement
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Chargement des pilotes et des utilitaires en m√©moire haute
LH C:\DOS\SMARTDRV.EXE       :: Cache de disque
LH C:\DOS\MOUSE.COM          :: Pilote de souris

:: Chargement des services r√©seau (pertinent pour Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: D√©marrage automatique de Windows
WIN
</code></pre>
<ul>
<li>CONFIG.SYS</li>
</ul>
<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî Configuration de la m√©moire et des pilotes DOS pour Windows 3.11
:: Auteur: hypo69
:: Ann√©e: environ 1993
:: Objectif: initialise les pilotes de m√©moire, configure les param√®tres syst√®me
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE
</code></pre>
<p>En parall√®le de DOS, Microsoft a presque imm√©diatement commenc√© √† d√©velopper un noyau fondamentalement nouveau.</p>
<p>Le noyau <strong>Windows NT</strong> (New Technology) est apparu pour la premi√®re fois avec la sortie du syst√®me d'exploitation:</p>
<blockquote>
<p><strong>Windows NT 3.1 ‚Äî 27 juillet 1993</strong></p>
</blockquote>
<hr>
<ul>
<li><strong>Le d√©veloppement a commenc√©</strong>: en <strong>1988</strong> sous la direction de <strong>Dave Cutler</strong> (un ancien ing√©nieur de DEC, cr√©ateur de VMS) dans le but de cr√©er un syst√®me d'exploitation enti√®rement nouveau, s√©curis√©, portable et multit√¢che, non compatible avec MS-DOS au niveau du noyau.</li>
<li><strong>NT 3.1</strong> ‚Äî a √©t√© ainsi nomm√© pour souligner la compatibilit√© avec <strong>Windows 3.1</strong> au niveau de l'interface, mais √©tait une <strong>architecture compl√®tement nouvelle</strong>.</li>
</ul>
<hr>
<h4>üß† Ce que le noyau NT a apport√©:</h4>
<table>
<thead>
<tr>
<th>Fonctionnalit√©</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Architecture 32 bits</strong></td>
<td>Contrairement √† MS-DOS et Windows 3.x, qui √©taient en 16 bits.</td>
</tr>
<tr>
<td><strong>Multit√¢che</strong></td>
<td>V√©ritable multit√¢che pr√©emptif.</td>
</tr>
<tr>
<td><strong>M√©moire prot√©g√©e</strong></td>
<td>Les programmes ne pouvaient pas endommager la m√©moire des autres.</td>
</tr>
<tr>
<td><strong>Modularit√©</strong></td>
<td>Architecture de noyau √† plusieurs niveaux: HAL, Executive, Kernel, pilotes.</td>
</tr>
<tr>
<td><strong>Prise en charge multi-plateforme</strong></td>
<td>NT 3.1 fonctionnait sur x86, MIPS et Alpha.</td>
</tr>
<tr>
<td><strong>Compatibilit√© POSIX</strong></td>
<td>NT √©tait livr√© avec un <strong>sous-syst√®me POSIX</strong>, certifi√© POSIX.1.</td>
</tr>
</tbody>
</table>
<hr>
<h4>üìú La lign√©e NT:</h4>
<table>
<thead>
<tr>
<th>Version NT</th>
<th>Ann√©e</th>
<th>Commentaire</th>
</tr>
</thead>
<tbody>
<tr>
<td>NT 3.1</td>
<td>1993</td>
<td>Premi√®re version de NT</td>
</tr>
<tr>
<td>NT 3.5 / 3.51</td>
<td>1994‚Äì1995</td>
<td>Am√©liorations, optimisation</td>
</tr>
<tr>
<td>NT 4.0</td>
<td>1996</td>
<td>Interface de Windows 95, mais noyau NT</td>
</tr>
<tr>
<td>Windows 2000</td>
<td>2000</td>
<td>NT 5.0</td>
</tr>
<tr>
<td>Windows XP</td>
<td>2001</td>
<td>NT 5.1</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>2007</td>
<td>NT 6.0</td>
</tr>
<tr>
<td>Windows 10</td>
<td>2015</td>
<td>NT 10.0</td>
</tr>
<tr>
<td>Windows 11</td>
<td>2021</td>
<td>Aussi NT 10.0 (marketing üòä)</td>
</tr>
</tbody>
</table>
<hr>
<p>Diff√©rence dans les capacit√©s du syst√®me d'exploitation:</p>
<table>
<thead>
<tr>
<th>Caract√©ristique</th>
<th><strong>MS-DOS</strong> (1981)</th>
<th><strong>Windows NT</strong> (1993)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Type de syst√®me</strong></td>
<td>Monolithique, mono-t√¢che</td>
<td>Micro-noyau/hybride, multit√¢che</td>
</tr>
<tr>
<td><strong>Architecture</strong></td>
<td>16 bits</td>
<td>32 bits (avec prise en charge 64 bits avec NT 5.2 / XP x64)</td>
</tr>
<tr>
<td><strong>Multit√¢che</strong></td>
<td>‚ùå Absent (un processus √† la fois)</td>
<td>‚úÖ Multit√¢che pr√©emptif</td>
</tr>
<tr>
<td><strong>M√©moire prot√©g√©e</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Oui (chaque processus dans son propre espace d'adressage)</td>
</tr>
<tr>
<td><strong>Mode multi-utilisateur</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Partiellement (dans NT Workstation/Server)</td>
</tr>
<tr>
<td><strong>Compatibilit√© POSIX</strong></td>
<td>‚ùå Non</td>
<td>‚úÖ Sous-syst√®me POSIX int√©gr√© dans NT 3.1‚Äì5.2</td>
</tr>
<tr>
<td><strong>Portabilit√© du noyau</strong></td>
<td>‚ùå x86 uniquement</td>
<td>‚úÖ x86, MIPS, Alpha, PowerPC</td>
</tr>
<tr>
<td><strong>Pilotes</strong></td>
<td>Acc√®s direct au mat√©riel</td>
<td>Via HAL et pilotes en mode noyau</td>
</tr>
<tr>
<td><strong>Niveau d'acc√®s des applications</strong></td>
<td>Applications = niveau syst√®me</td>
<td>Niveau utilisateur / noyau s√©par√©</td>
</tr>
<tr>
<td><strong>S√©curit√©</strong></td>
<td>‚ùå Absente</td>
<td>‚úÖ Mod√®le de s√©curit√©: SID, ACL, jetons d'acc√®s</td>
</tr>
<tr>
<td><strong>Stabilit√©</strong></td>
<td>‚ùå La d√©pendance d'un programme = crash du syst√®me d'exploitation</td>
<td>‚úÖ Isolation des processus, protection du noyau</td>
</tr>
</tbody>
</table>
<hr>
<p>Mais il y avait un gros MAIS! Mais les outils d'automatisation et d'administration n'ont pas re√ßu l'attention voulue avant 2002.</p>
<hr>
<p>Microsoft a utilis√© des approches, des strat√©gies et des outils compl√®tement diff√©rents pour l'administration. Tout cela √©tait <strong>disparate</strong>, souvent orient√© GUI et pas toujours automatisable.</p>
<hr>
<h5>üìå Liste de quelques outils:</h5>
<table>
<thead>
<tr>
<th>Outil</th>
<th>Objectif</th>
</tr>
</thead>
<tbody>
<tr>
<td>`cmd.exe`</td>
<td>Interpr√©teur de commandes am√©lior√© (remplacement de `COMMAND.COM`)</td>
</tr>
<tr>
<td>`.bat`, `.cmd`</td>
<td>Scripts de ligne de commande</td>
</tr>
<tr>
<td><strong>Windows Script Host (WSH)</strong></td>
<td>Prise en charge de VBScript et JScript pour l'automatisation</td>
</tr>
<tr>
<td>`reg.exe`</td>
<td>G√©rer le registre √† partir de la ligne de commande</td>
</tr>
<tr>
<td>`net.exe`</td>
<td>Travailler avec les utilisateurs, le r√©seau, les imprimantes</td>
</tr>
<tr>
<td>`sc.exe`</td>
<td>G√©rer les services</td>
</tr>
<tr>
<td>`tasklist`, `taskkill`</td>
<td>G√©rer les processus</td>
</tr>
<tr>
<td>`gpedit.msc`</td>
<td>Strat√©gie de groupe (locale)</td>
</tr>
<tr>
<td>`MMC`</td>
<td>Console avec des composants logiciels enfichables pour la gestion</td>
</tr>
<tr>
<td>`WMI`</td>
<td>Acc√®s aux informations syst√®me (via `wmic`, VBScript ou COM)</td>
</tr>
<tr>
<td>`WbemTest.exe`</td>
<td>GUI pour tester les requ√™tes WMI</td>
</tr>
<tr>
<td>`eventvwr`</td>
<td>Afficher les journaux d'√©v√©nements</td>
</tr>
<tr>
<td>`perfmon`</td>
<td>Surveillance des ressources</td>
</tr>
</tbody>
</table>
<h5>üõ† Exemples d'automatisation:</h5>
<ul>
<li>Fichiers VBScript (`*.vbs`) pour l'administration des utilisateurs, des r√©seaux, des imprimantes et des services.</li>
<li>`WMIC` ‚Äî interface de ligne de commande pour WMI (par exemple, `wmic process list brief`).</li>
<li>Scripts `.cmd` avec des appels √† `net`, `sc`, `reg`, `wmic`, etc.</li>
</ul>
<hr>
<h3>‚öôÔ∏è Windows Scripting Host (WSH)</h3>
<ul>
<li>Apparu pour la premi√®re fois dans <strong>Windows 98</strong>, activement utilis√© dans <strong>Windows 2000 et XP</strong>.</li>
<li>Permettait d'ex√©cuter des fichiers VBScript et JScript √† partir de la ligne de commande:</li>
</ul>
<pre class="line-numbers"><code class="language-vbscript">Set objShell = WScript.CreateObject("WScript.Shell")
objShell.Run "notepad.exe"
</code></pre>
<hr>
<h2>Partie 1.</h2>
<p>Ce n'est qu'en 2002 que l'entreprise a formul√© le projet <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, qui a ensuite abouti √† powershell:</p>
<p>D√©but du d√©veloppement: environ en 2002</p>
<p>Annonce publique: 2003, sous le nom de "Monad Shell"</p>
<p>Premi√®res versions b√™ta: apparues en 2005</p>
<p>Version finale (PowerShell 1.0): novembre 2006</p>
<p>L'auteur et architecte en chef du projet Monad / PowerShell est Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank">(Jeffrey Snover)</a></p>
<p>Aujourd'hui, PowerShell Core fonctionne sur
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a></p>
<p>En parall√®le, le framework .NET √©tait en cours de d√©veloppement, et powershell y √©tait profond√©ment int√©gr√©, dans les chapitres suivants, je montrerai des exemples</p>
<p>Et maintenant ‚Äî la chose la plus importante!</p>
<p>Le principal avantage de PowerShell par rapport aux shells de commandes classiques est qu'il fonctionne avec des <em>objets</em>, et non avec du texte. Lorsque vous ex√©cutez une commande, elle ne renvoie pas seulement du texte, mais un objet structur√© (ou une collection d'objets) qui a des propri√©t√©s et des m√©thodes clairement d√©finies.</p>
<p>Voyez comment PowerShell surpasse les shells classiques gr√¢ce √† la <strong>gestion des objets</strong></p>
<h3>üìÅ Comment c'√©tait avant: `dir` et l'analyse manuelle</h3>
<p>Dans <strong>CMD</strong> (√† la fois dans l'ancien `COMMAND.COM` et dans `cmd.exe`), la commande `dir` renvoie le r√©sultat sous forme de texte brut. Exemple de sortie:</p>
<pre class="line-numbers"><code>24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
</code></pre>
<p>Supposons que vous souhaitiez extraire le <strong>nom de fichier</strong> et la <strong>taille</strong> de chaque fichier. Vous devriez analyser les cha√Ænes manuellement:</p>
<pre class="line-numbers"><code class="language-cmd">for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
</code></pre>
<ul>
<li>C'est terriblement difficile √† lire, cela d√©pend de la locale, du format de la date, de la police. Et cela ne fonctionne pas avec les espaces dans les noms</li>
</ul>
<hr>
<h3>‚úÖ PowerShell: des objets au lieu du texte</h3>
<h4>‚úî Exemple simple et lisible:</h4>
<pre class="line-numbers"><code class="language-powershell">Get-ChildItem | Select-Object Name, Length
</code></pre>
<p><strong>R√©sultat:</strong></p>
<pre class="line-numbers"><code>Name          Length
----          ------
my_script.js   1428
report.html    3980
</code></pre>
<ul>
<li>`Get-ChildItem` renvoie un <strong>tableau d'objets de fichiers/dossiers</strong></li>
<li>`Select-Object` vous permet d'obtenir facilement les <strong>propri√©t√©s</strong> requises</li>
</ul>
<hr>
<h3>üîç Que renvoie r√©ellement `Get-ChildItem`?</h3>
<pre class="line-numbers"><code class="language-powershell">$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
</code></pre>
<p><strong>R√©sultat:</strong></p>
<pre class="line-numbers"><code>TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
</code></pre>
<p>PowerShell renvoie des <strong>objets `System.IO.FileInfo`</strong>, qui ont:</p>
<ul>
<li>üß± Propri√©t√©s (`Name`, `Length`, `CreationTime`, `Extension`, ‚Ä¶)</li>
<li>üõ† M√©thodes (`Delete()`, `CopyTo()`, `MoveTo()`, etc.)</li>
</ul>
<p>Vous travaillez <strong>avec des objets √† part enti√®re</strong>, pas avec des cha√Ænes.</p>
<hr>
<h3>Syntaxe "Verbe-Nom":</h3>
<p>PowerShell utilise une <strong>syntaxe de commande stricte et logique</strong>:
`Verbe-Nom`</p>
<table>
<thead>
<tr>
<th>Verbe</th>
<th>Ce qu'il fait</th>
</tr>
</thead>
<tbody>
<tr>
<td>`Get-`</td>
<td>Obtenir</td>
</tr>
<tr>
<td>`Set-`</td>
<td>D√©finir</td>
</tr>
<tr>
<td>`New-`</td>
<td>Cr√©er</td>
</tr>
<tr>
<td>`Remove-`</td>
<td>Supprimer</td>
</tr>
<tr>
<td>`Start-`</td>
<td>D√©marrer</td>
</tr>
<tr>
<td>`Stop-`</td>
<td>Arr√™ter</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Nom</th>
<th>Sur quoi il travaille</th>
</tr>
</thead>
<tbody>
<tr>
<td>`Process`</td>
<td>Processus</td>
</tr>
<tr>
<td>`Service`</td>
<td>Service</td>
</tr>
<tr>
<td>`Item`</td>
<td>Fichier/dossier</td>
</tr>
<tr>
<td>`EventLog`</td>
<td>Journaux d'√©v√©nements</td>
</tr>
<tr>
<td>`Computer`</td>
<td>Ordinateur</td>
</tr>
</tbody>
</table>
<h4>üîÑ Exemples:</h4>
<table>
<thead>
<tr>
<th>Que faire</th>
<th>Commande</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obtenir les processus</td>
<td>`Get-Process`</td>
</tr>
<tr>
<td>Arr√™ter un service</td>
<td>`Stop-Service`</td>
</tr>
<tr>
<td>Cr√©er un nouveau fichier</td>
<td>`New-Item`</td>
</tr>
<tr>
<td>Obtenir le contenu d'un dossier</td>
<td>`Get-ChildItem`</td>
</tr>
<tr>
<td>Supprimer un fichier</td>
<td>`Remove-Item`</td>
</tr>
</tbody>
</table>
<p>‚û° M√™me si vous <strong>ne connaissez pas la commande exacte</strong>, vous pouvez la <strong>deviner</strong> √† partir du sens ‚Äî et vous aurez presque toujours raison.</p>
<hr>
<p>L'applet de commande `Get-Help` est votre principal assistant.</p>
<ol>
<li><strong>Obtenir de l'aide sur l'aide elle-m√™me:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Help
</code></pre>
</li>
<li><strong>Obtenir de l'aide de base sur la commande pour travailler avec les processus:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process
</code></pre>
</li>
<li><strong>Voir des exemples d'utilisation de cette commande:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Examples
</code></pre>
C'est un param√®tre incroyablement utile qui fournit souvent des solutions pr√™tes √† l'emploi pour vos t√¢ches.</li>
<li><strong>Obtenir les informations les plus d√©taill√©es sur la commande:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Full
</code></pre>
Dans la partie suivante: le pipeline ou la cha√Æne de commandes (PipeLines)</li>
</ol>