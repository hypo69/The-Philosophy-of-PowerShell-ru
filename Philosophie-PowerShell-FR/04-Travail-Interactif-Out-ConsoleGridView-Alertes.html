# Philosophie PowerShell.

## Partie 4 : Travail interactif : `Out-ConsoleGridView`, alertes.

- Dans la [premi√®re partie](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md), nous avons d√©fini deux concepts cl√©s de PowerShell : le pipeline et l'objet.

- Dans la [deuxi√®me partie](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md), j'ai expliqu√© ce que sont les objets et le pipeline.

- Dans la [troisi√®me partie](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md), nous avons d√©couvert le syst√®me de fichiers et les fournisseurs.

- Aujourd'hui, nous allons examiner le travail interactif avec les donn√©es dans la console, ainsi que les alertes et les notifications.

### Chapitre un : Travail interactif avec les donn√©es dans la console.

#### `Out-ConsoleGridView`. GUI dans la console PowerShell.

**‚ùó Important :** Tous les outils d√©crits ci-dessous n√©cessitent **PowerShell 7.2 ou plus r√©cent**.

`Out-ConsoleGridView` est un tableau interactif, directement dans la console PowerShell, permettant de :
- visualiser les donn√©es sous forme de tableau ;
- filtrer et trier les colonnes ;
- s√©lectionner des lignes avec le curseur ‚Äì pour les passer plus loin dans le pipeline ;
- et bien plus encore.

`Out-ConsoleGridView` fait partie du module `Microsoft.PowerShell.ConsoleGuiTools`. Pour l'utiliser, vous devez d'abord installer ce module.

Pour installer le module, ex√©cutez la commande suivante dans PowerShell :
```powershell
Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
```
![Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser](assets/04/1.png)

`Install-Module` t√©l√©charge et installe le module sp√©cifi√© depuis le r√©f√©rentiel dans le syst√®me. Analogues : `pip install` en `Python` ou `npm install` en `Node.js`.

üìé Param√®tres cl√©s de `Install-Module`

------------------------------------------------------------------------------------------------------------------------------------------------------
| Param√®tre | Description |
| ------------------ | -----------------------------------------------------------------------------------------------------------------------------
| `-Name` | Nom du module √† installer. |
| `-Scope` | Port√©e de l'installation : `AllUsers` (par d√©faut, n√©cessite des droits d'administrateur) ou `CurrentUser` (ne n√©cessite pas de droits d'administrateur). |
| `-Repository` | Sp√©cifie le r√©f√©rentiel, par exemple `PSGallery`. |
| `-Force` | Installation forc√©e sans confirmation. |
| `-AllowClobber` | Autorise l'√©crasement des commandes existantes. |
| `-AcceptLicense` | Accepte automatiquement la licence du module. |
| `-RequiredVersion` | Installe une version sp√©cifique du module. |

Apr√®s l'installation, vous pouvez passer n'importe quelle sortie √† `Out-ConsoleGridView` pour un travail interactif.

```powershell   
# Exemple classique : affichage de la liste des processus dans un tableau interactif
Get-Process | Out-ConsoleGridView
```

[1](https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>

**Interface :**
*   **Filtrage :** Commencez simplement √† saisir du texte, et la liste sera filtr√©e √† la vol√©e.
*   **Navigation :** Utilisez les touches fl√©ch√©es pour vous d√©placer dans la liste.
*   **S√©lection :** Appuyez sur `Espace` pour s√©lectionner/d√©s√©lectionner un √©l√©ment.
*   **S√©lection multiple :** `Ctrl+A` pour s√©lectionner tous les √©l√©ments, `Ctrl+D` pour d√©s√©lectionner tout.
*   **Confirmation :** Appuyez sur `Entr√©e` pour renvoyer les objets s√©lectionn√©s.
*   **Annulation :** Appuyez sur `ESC` pour fermer la fen√™tre sans renvoyer de donn√©es.

## Ce que `Out-ConsoleGridView` peut faire :

* Afficher des donn√©es tabulaires directement dans la console sous forme de tableau interactif avec navigation par lignes et colonnes.
* Trier les colonnes en appuyant sur les touches.
* Filtrer les donn√©es √† l'aide de la recherche.
* S√©lectionner une ou plusieurs lignes avec renvoi du r√©sultat.
* Travailler dans une console propre sans fen√™tres GUI.
* Supporter un grand nombre de lignes avec d√©filement.
* Supporter diff√©rents types de donn√©es (cha√Ænes, nombres, dates, etc.).

---

## Exemples d'utilisation de `Out-ConsoleGridView`

### Utilisation de base ‚Äî afficher un tableau avec possibilit√© de s√©lection interactive. (case √† cocher)

```powershell
Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Afficher le tableau avec possibilit√© de filtrage, de tri et de s√©lection de lignes
$selected = $data | Out-ConsoleGridView -Title "Select process(es)" -OutputMode Multiple

$selected | Format-Table -AutoSize
```

[2](https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356)

<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>

Une liste de processus est affich√©e dans un tableau interactif de console. Il est possible de filtrer par nom, de trier les colonnes et de s√©lectionner des processus. Les processus s√©lectionn√©s sont renvoy√©s dans la variable `$selected`.

---

### S√©lection d'une seule ligne avec renvoi obligatoire du r√©sultat. (radio)

```powershell
$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Select a service" -OutputMode Single

Write-Host "You selected service: $($choice.Name)"
```

[](https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e)

<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>

L'utilisateur s√©lectionne une seule ligne (service). `-OutputMode Single` interdit de s√©lectionner plusieurs √©l√©ments.

---

### Filtrage et tri de grands tableaux

```powershell
$data = 1..1000 | ForEach-Object { 
    [PSCustomObject]@{ 
        Number = $_ 
        Square = $_ * $_ 
        Cube   = $_ * $_ * $_ 
    }
}

$data | Out-ConsoleGridView -Title "Numbers and powers"  -OutputMode Multiple
```

Affiche un tableau de 1000 lignes avec des nombres et leurs puissances.

### **Gestion interactive des processus :**

Vous pouvez s√©lectionner plusieurs processus √† arr√™ter. Le param√®tre `-OutputMode Multiple` indique que nous voulons renvoyer tous les √©l√©ments s√©lectionn√©s.

```powershell
# Transf√©rer les r√©sultats via le pipeline.
# Arr√™ter les processus s√©lectionn√©s avec le param√®tre -WhatIf pour un aper√ßu.
# Pour cela, d√©finissons la variable $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple
    
# Si quelque chose a √©t√© s√©lectionn√©, passer les objets plus loin dans le pipeline
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
```

### **S√©lection de fichiers pour l'archivage :**
Trouvons tous les fichiers `.log` dans le dossier, s√©lectionnons ceux dont nous avons besoin et cr√©ons une archive √† partir d'eux.

```powershell
$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
```

‚ùó Soyez prudent avec la r√©cursion

```powershell
if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip
    
    # Ajouter un message de succ√®s
    Write-Host "‚úÖ Archivage termin√© avec succ√®s !" -ForegroundColor Green
}
```

### **S√©lection d'un √©l√©ment pour une analyse d√©taill√©e :**

#### Mod√®le "Drill-Down" ‚Äî d'une liste g√©n√©rale aux d√©tails avec `Out-ConsoleGridView`

Souvent, lorsque nous travaillons avec des objets syst√®me, nous sommes confront√©s √† un dilemme :
1.  Si nous demandons **toutes les propri√©t√©s** pour **tous les objets** (`Get-NetAdapter | Format-List *`), la sortie sera √©norme et illisible.
2.  Si nous affichons un **tableau concis**, nous perdrons des d√©tails importants.
3.  Parfois, tenter d'obtenir toutes les donn√©es en m√™me temps peut entra√Æner une erreur si l'un des objets contient des valeurs incorrectes.

La solution √† ce probl√®me est le mod√®le **"Drill-Down"** (d√©tail ou "plong√©e en profondeur"). Son essence est simple :

*   **√âtape 1 (Aper√ßu) :** Afficher √† l'utilisateur une liste d'√©l√©ments propre, concise et s√ªre pour la **s√©lection**.
*   **√âtape 2 (D√©tail) :** Une fois que l'utilisateur a s√©lectionn√© un √©l√©ment sp√©cifique, lui montrer **toutes les informations disponibles** pour cet √©l√©ment.

#### Exemple pratique : Cr√©ation d'un explorateur d'adaptateurs r√©seau

Impl√©mentons ce mod√®le avec la commande `Get-NetAdapter`.

**T√¢che :** Afficher d'abord une liste concise d'adaptateurs r√©seau. Apr√®s en avoir s√©lectionn√© un, ouvrir une deuxi√®me fen√™tre avec toutes ses propri√©t√©s.

**Code pr√™t √† l'emploi :**
```powershell
# --- √âtape 1 : S√©lection de l'adaptateur dans la liste concise ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "√âTAPE 1 : S√©lectionnez un adaptateur r√©seau"

# --- √âtape 2 : Affichage des informations d√©taill√©es ou du message d'annulation ---
if ($null -ne $selectedAdapter) {
    # Obtenir TOUTES les propri√©t√©s pour l'adaptateur S√âLECTIONN√â
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Utiliser notre astuce avec .psobject.Properties pour transformer l'objet en un tableau pratique "Nom-Valeur"
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value
    
    # Ouvrir la DEUXI√àME fen√™tre GridView avec toutes les informations
    $detailedInfoForGrid | Out-ConsoleGridView -Title "√âTAPE 2 : Informations compl√®tes sur '$($selectedAdapter.Name)'"
} else {
    Write-Host "Op√©ration annul√©e. Aucun adaptateur n'a √©t√© s√©lectionn√©." -ForegroundColor Yellow
}
```

#### Analyse √©tape par √©tape

1.  **Cr√©ation d'une liste "s√ªre" :**
    `$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed`
    Nous ne transmettons pas la sortie de `Get-NetAdapter` directement. Au lieu de cela, nous cr√©ons de nouveaux objets "propres" √† l'aide de `Select-Object`, en incluant uniquement les propri√©t√©s dont nous avons besoin pour l'aper√ßu. Cela garantit que les donn√©es probl√©matiques qui ont caus√© l'erreur seront ignor√©es.

2.  **Premi√®re fen√™tre interactive :**
    `$selectedAdapter = $adapterList | Out-ConsoleGridView ...`
    Le script affiche la premi√®re fen√™tre et **arr√™te son ex√©cution**, attendant votre s√©lection. D√®s que vous s√©lectionnez une ligne et appuyez sur `Entr√©e`, l'objet correspondant √† cette ligne sera enregistr√© dans la variable `$selectedAdapter`.

3.  **V√©rification de la s√©lection :**
    `if ($null -ne $selectedAdapter)`
    Ceci est une v√©rification cruciale. Si l'utilisateur appuie sur `Esc` ou ferme la fen√™tre, la variable `$selectedAdapter` sera vide (`$null`). Cette v√©rification emp√™che l'ex√©cution du reste du code et l'apparition d'erreurs.

4.  **Obtention des informations compl√®tes :**
    `$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name`
    Voici le point cl√© du mod√®le. Nous nous adressons √† nouveau √† `Get-NetAdapter`, mais cette fois, nous demandons **un seul** objet par son nom, que nous avons pris de l'√©l√©ment s√©lectionn√© √† la premi√®re √©tape. Nous obtenons maintenant l'objet complet avec toutes ses propri√©t√©s.

5.  **Transformation pour la deuxi√®me fen√™tre :**
    `$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...`
    Nous utilisons l'astuce puissante que vous connaissez d√©j√† pour "d√©rouler" cet objet complexe unique en une longue liste de paires "Nom de propri√©t√©" | "Valeur", ce qui est id√©al pour l'affichage dans un tableau.

6.  **Deuxi√®me fen√™tre interactive :**
    `$detailedInfoForGrid | Out-ConsoleGridView ...`
    Une deuxi√®me fen√™tre appara√Æt √† l'√©cran, cette fois avec des informations exhaustives sur l'adaptateur que vous avez s√©lectionn√©.

---

### Exemple avec un titre et des astuces personnalis√©s

Affichage du journal des √©v√©nements Windows dans un tableau interactif avec le titre "System Events".

```powershell
Get-EventLog -LogName System -Newest 50 |\
    Select-Object TimeGenerated, EntryType, Source, Message |\
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
```
Ce code obtient les 50 derniers √©v√©nements du journal syst√®me de Windows, s√©lectionne pour chaque √©v√©nement seulement quatre propri√©t√©s cl√©s (heure, type, source et message) et les affiche dans la fen√™tre `Out-ConsoleGridView`.

----

### Informations sur le syst√®me.

[1](https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>

code du script pour obtenir des informations sur le syst√®me :
[Get-SystemMonitor.ps1](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1)

### Cr√©ation du cmdlet 'Get-SystemMonitor'

#### √âtape 1 : Configuration de la variable `PATH`

1.  **Cr√©ez un dossier permanent pour vos outils,** si ce n'est pas d√©j√† fait. Par exemple :
    `C:\PowerShell\Scripts`

2.  **Placez votre fichier** `Get-SystemMonitor.ps1` dans ce dossier.

3.  **Ajoutez ce dossier √† la variable syst√®me `PATH`**, 

#### √âtape 2 : Configuration de l'alias dans le profil PowerShell

Maintenant que le syst√®me sait o√π trouver votre script par son nom complet, nous pouvons cr√©er un alias court pour celui-ci.

1.  **Ouvrez votre fichier de profil PowerShell** :
    ```powershell
    notepad $PROFILE
    ```

2.  **Ajoutez-y la ligne suivante :**
    ```powershell
    # Alias pour le moniteur syst√®me
    Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
    ```

    **Notez le point cl√© :** Puisque le dossier avec le script est d√©j√† dans `PATH`, nous n'avons plus **besoin de sp√©cifier le chemin complet** du fichier ! Nous nous r√©f√©rons simplement √† son nom. Cela rend votre profil plus propre et plus fiable. Si vous d√©placez un jour le dossier `C:\PowerShell\Scripts`, vous n'aurez qu'√† mettre √† jour la variable `PATH`, et votre fichier de profil restera inchang√©.

#### Red√©marrez PowerShell

Fermez **toutes** les fen√™tres PowerShell ouvertes et ouvrez-en une nouvelle. Ceci est n√©cessaire pour que le syst√®me applique les modifications √† la fois dans la variable `PATH` et dans votre profil.

---

### R√©sultat : Ce que vous obtenez

Apr√®s avoir effectu√© ces √©tapes, vous pourrez appeler votre script **de deux mani√®res depuis n'importe quel endroit du syst√®me** :

1.  **Par nom complet (fiable, pour une utilisation dans d'autres scripts) :**
    ```powershell
    Get-SystemMonitor.ps1
    Get-SystemMonitor.ps1 -Resource storage
    ```

2.  **Par alias court (pratique, pour un travail interactif) :**
    ```powershell
    sysmon
    sysmon -Resource memory
    ```

Vous avez r√©ussi √† "enregistrer" votre script dans le syst√®me de la mani√®re la plus professionnelle et la plus flexible.

Utile ? Abonnez-vous.
Aim√© ‚Äî mettez ¬´ + ¬ª
Bonne chance ! üöÄ

Autres articles sur PowerShell:
```