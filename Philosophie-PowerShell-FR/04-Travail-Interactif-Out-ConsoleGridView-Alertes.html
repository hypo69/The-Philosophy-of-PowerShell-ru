# Philosophie de PowerShell.

## Partie 4 : Travail interactif : `Out-ConsoleGridView`, alertes.

- Dans la [premi√®re partie](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md), nous avons d√©fini deux concepts cl√©s de PowerShell : le pipeline et l'objet.

- Dans la [deuxi√®me partie](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md), j'ai expliqu√© ce que sont les objets et les pipelines.

- Dans la [troisi√®me partie](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md), nous avons fait connaissance avec le syst√®me de fichiers et les fournisseurs.

- Aujourd'hui, nous allons examiner le travail interactif avec les donn√©es dans la console, ainsi que les alertes et les notifications.

### Chapitre un : Travail interactif avec les donn√©es dans la console.

#### `Out-ConsoleGridView`. Interface graphique dans la console PowerShell.


**‚ùó Important :** Tous les outils d√©crits ci-dessous n√©cessitent **PowerShell 7.2 ou plus r√©cent**.

Out-ConsoleGridView est un tableau interactif, directement dans la console PowerShell, permettant de :
- afficher les donn√©es dans un tableau ;
- filtrer et trier les colonnes ;
- s√©lectionner des lignes avec le curseur ‚Äî pour les transmettre plus loin dans le pipeline.
- et bien plus encore.

`Out-ConsoleGridView` fait partie du module `Microsoft.PowerShell.ConsoleGuiTools`. 
Pour l'utiliser, vous devez d'abord installer ce module.

Pour installer le module, ex√©cutez la commande suivante dans PowerShell :
```powershell
Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
```
![Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser](assets/04/1.png)

*Install-Module* t√©l√©charge et installe le module sp√©cifi√© depuis le r√©f√©rentiel vers le syst√®me. 
Analogues : `pip install` dans `Python` ou `npm install` dans `Node.js`.

üìé Param√®tres cl√©s de *Install-Module*

------------------------------------------------------------------------------------------------------------------------------------------------------
| Param√®tre | Description |
|---|---|
| `-Name` | Le nom du module √† installer. |
| `-Scope` | Port√©e de l'installation : `AllUsers` (par d√©faut, n√©cessite des droits d'administrateur) ou `CurrentUser` (ne n√©cessite pas de droits d'administrateur). |
| `-Repository` | Sp√©cifie le r√©f√©rentiel, par exemple `PSGallery`. |
| `-Force` | Installation forc√©e sans confirmation. |
| `-AllowClobber` | Autorise l'√©crasement des commandes existantes. |
| `-AcceptLicense` | Accepte automatiquement la licence du module. |
| `-RequiredVersion` | Installe une version sp√©cifique du module. |



Apr√®s l'installation, vous pouvez transmettre n'importe quelle sortie √† `Out-ConsoleGridView` pour un travail interactif.

```powershell   
# Exemple classique : affichage d'une liste de processus dans un tableau interactif
Get-Process | Out-ConsoleGridView
```

[1](https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>



**Interface :**
*   **Filtrage :** Commencez simplement √† taper, et la liste sera filtr√©e √† la vol√©e.
*   **Navigation :** Utilisez les touches fl√©ch√©es pour vous d√©placer dans la liste.
*   **S√©lection :** Appuyez sur `Espace` pour s√©lectionner/d√©s√©lectionner un √©l√©ment.
*   **S√©lection multiple :** `Ctrl+A` pour s√©lectionner tous les √©l√©ments, `Ctrl+D` pour tout d√©s√©lectionner.
*   **Confirmation :** Appuyez sur `Entr√©e` pour renvoyer les objets s√©lectionn√©s.
*   **Annuler :** Appuyez sur `√âchap` pour fermer la fen√™tre sans renvoyer de donn√©es.




## Ce que `Out-ConsoleGridView` peut faire :

* Afficher des donn√©es tabulaires directement dans la console PowerShell sous forme de tableau interactif avec navigation par lignes et colonnes.
* Trier les colonnes en appuyant sur les touches.
* Filtrer les donn√©es √† l'aide de la recherche.
* S√©lectionner une ou plusieurs lignes avec retour de r√©sultat.
* Travailler dans une console propre sans fen√™tres GUI.
* Prendre en charge un grand nombre de lignes avec d√©filement.
* Prendre en charge diff√©rents types de donn√©es (cha√Ænes, nombres, dates, etc.).

---

## Exemples d'utilisation de `Out-ConsoleGridView`

### Utilisation de base ‚Äî afficher un tableau avec possibilit√© de s√©lection interactive. (case √† cocher)

```powershell
Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Afficher un tableau avec des capacit√©s de filtrage, de tri et de s√©lection de lignes
$selected = $data | Out-ConsoleGridView -Title "S√©lectionner le(s) processus" -OutputMode Multiple

$selected | Format-Table -AutoSize
```

[2](https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356)

<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>



La liste des processus est affich√©e dans un tableau de console interactif. 
Vous pouvez filtrer par nom, trier les colonnes et s√©lectionner les processus. 
Les processus s√©lectionn√©s sont renvoy√©s √† la variable `$selected`.

---

### S√©lection d'une seule ligne avec retour de r√©sultat obligatoire. (radio)



```powershell
$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "S√©lectionner un service" -OutputMode Single

Write-Host "Vous avez s√©lectionn√© le service : $($choice.Name)"
```

[](https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e)

<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>


L'utilisateur s√©lectionne une seule ligne (service). `-OutputMode Single` emp√™che les s√©lections multiples.

---

### Filtrage et tri de grands tableaux

```powershell
$data = 1..1000 | ForEach-Object { 
    [PSCustomObject]@{ 
        Number = $_ 
        Square = $_ * $_ 
        Cube   = $_ * $_ * $_ 
    } 
}

$data | Out-ConsoleGridView -Title "Nombres et puissances"  -OutputMode Multiple
```

Affiche un tableau de 1000 lignes avec des nombres et leurs puissances.



### **Gestion interactive des processus :**

Vous pouvez s√©lectionner plusieurs processus √† arr√™ter. Le param√®tre `-OutputMode Multiple` indique que nous voulons renvoyer tous les √©l√©ments s√©lectionn√©s.



```powershell
# Transf√©rer les r√©sultats via le pipeline.
# Arr√™ter les processus s√©lectionn√©s avec le param√®tre -WhatIf pour un aper√ßu.
# Pour ce faire, d√©finissons la variable $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple
    
# Si quelque chose a √©t√© s√©lectionn√©, transmettez les objets plus loin dans le pipeline
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
```

### **S√©lection de fichiers pour l'archivage :**
    Trouvez tous les fichiers `.log` dans un dossier, s√©lectionnez ceux n√©cessaires et cr√©ez une archive √† partir d'eux.

```powershell
$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
```

    ‚ùóSoyez prudent avec la r√©cursion

```powershell
if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip
    
    # Ajouter un message de succ√®s
    Write-Host "‚úÖ Archivage termin√© avec succ√®s !" -ForegroundColor Green
}
```


### **S√©lection d'un seul √©l√©ment pour une analyse d√©taill√©e :**


#### Mod√®le "Drill-Down" ‚Äî de la liste g√©n√©rale aux d√©tails avec `Out-ConsoleGridView`

Souvent, lorsque nous travaillons avec des objets syst√®me, nous sommes confront√©s √† un dilemme :
1.  Si vous demandez **toutes les propri√©t√©s** pour **tous les objets** (`Get-NetAdapter | Format-List *`), la sortie sera √©norme et illisible.
2.  Si vous affichez un **tableau bref**, nous perdrons des d√©tails importants.
3.  Parfois, tenter d'obtenir toutes les donn√©es en une seule fois peut entra√Æner une erreur si l'un des objets contient des valeurs non valides.

La solution √† ce probl√®me est le mod√®le **"Drill-Down"** (d√©tail ou "exploration"). Son essence est simple :

*   **√âtape 1 (Aper√ßu) :** Afficher √† l'utilisateur une liste d'√©l√©ments propre, concise et s√ªre pour la **s√©lection**.
*   **√âtape 2 (D√©tail) :** Une fois que l'utilisateur a s√©lectionn√© un √©l√©ment sp√©cifique, lui afficher **toutes les informations disponibles** pour cet √©l√©ment particulier.


#### Exemple pratique : Cr√©ation d'un explorateur d'adaptateurs r√©seau

Impl√©mentons ce mod√®le en utilisant la commande `Get-NetAdapter` comme exemple.

**T√¢che :** D'abord, afficher une br√®ve liste d'adaptateurs r√©seau. Apr√®s en avoir s√©lectionn√© un, ouvrir une deuxi√®me fen√™tre avec toutes ses propri√©t√©s.

**Code pr√™t √† l'emploi :**
```powershell
# --- √âtape 1 : S√©lection d'un adaptateur dans une br√®ve liste ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "√âTAPE 1 : S√©lectionner un adaptateur r√©seau"

# --- √âtape 2 : Affichage des informations d√©taill√©es ou d'un message d'annulation ---
if ($null -ne $selectedAdapter) {
    # Obtenir TOUTES les propri√©t√©s pour l'adaptateur S√âLECTIONN√â
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Utiliser notre astuce avec .psobject.Properties pour transformer l'objet en un tableau pratique "Nom-Valeur"
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value
    
    # Ouvrir une DEUXI√àME fen√™tre GridView avec toutes les informations
    $detailedInfoForGrid | Out-ConsoleGridView -Title "√âTAPE 2 : Informations compl√®tes pour '$($selectedAdapter.Name)'"
} else {
    Write-Host "Op√©ration annul√©e. L'adaptateur n'a pas √©t√© s√©lectionn√©." -ForegroundColor Yellow
}
```

#### Analyse √©tape par √©tape

1.  **Cr√©ation d'une liste "s√ªre" :**
    `$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed`
    Nous ne transmettons pas la sortie de `Get-NetAdapter` directement. Au lieu de cela, nous cr√©ons de nouveaux objets "propres" √† l'aide de `Select-Object`, en n'incluant que les propri√©t√©s dont nous avons besoin pour un aper√ßu. Cela garantit que les donn√©es probl√©matiques qui ont caus√© une erreur seront ignor√©es.

2.  **Premi√®re fen√™tre interactive :**
    `$selectedAdapter = $adapterList | Out-ConsoleGridView ...`
    Le script affiche la premi√®re fen√™tre et **suspend son ex√©cution**, en attendant votre s√©lection. Une fois que vous avez s√©lectionn√© une ligne et appuy√© sur `Entr√©e`, l'objet correspondant √† cette ligne sera √©crit dans la variable `$selectedAdapter`.

3.  **V√©rification de la s√©lection :**
    `if ($null -ne $selectedAdapter)`
    Ceci est une v√©rification d'une importance capitale. Si l'utilisateur appuie sur `√âchap` ou ferme la fen√™tre, la variable `$selectedAdapter` sera vide (`$null`). Cette v√©rification emp√™che l'ex√©cution du reste du code et l'apparition d'erreurs.

4.  **Obtention d'informations compl√®tes :**
    `$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name`
    Voici le point cl√© du mod√®le. Nous appelons √† nouveau `Get-NetAdapter`, mais cette fois, nous demandons **un seul** objet par son nom, que nous avons pris de l'√©l√©ment s√©lectionn√© √† la premi√®re √©tape. Nous obtenons maintenant l'objet complet avec toutes ses propri√©t√©s.

5.  **Transformation pour la deuxi√®me fen√™tre :**
    `$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...`
    Nous utilisons l'astuce puissante que vous connaissez d√©j√† pour "d√©rouler" cet objet complexe unique en une longue liste de paires "Nom de propri√©t√©" | "Valeur", ce qui est id√©al pour l'affichage dans un tableau.

6.  **Deuxi√®me fen√™tre interactive :**
    `$detailedInfoForGrid | Out-ConsoleGridView ...`
    Une deuxi√®me fen√™tre appara√Æt √† l'√©cran, cette fois avec des informations compl√®tes sur l'adaptateur que vous avez s√©lectionn√©.


---



### Exemple avec titre personnalis√© et astuces

Affichage du journal des √©v√©nements Windows dans un tableau interactif avec le titre "√âv√©nements syst√®me".

```powershell
Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
```
Ce code r√©cup√®re les 50 derniers √©v√©nements du journal syst√®me Windows, s√©lectionne uniquement quatre propri√©t√©s cl√©s (heure, type, source et message) de chaque √©v√©nement, et les affiche dans la fen√™tre Out-ConsoleGridView.

----

### Informations syst√®me.


[1](https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>


Code du script d'informations syst√®me :
[Get-SystemMonitor.ps1](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1)


### Cr√©ation du cmdlet 'Get-SystemMonitor'


#### √âtape 1 : Configuration de la variable `PATH`

1.  **Cr√©ez un dossier permanent pour vos outils,** si ce n'est pas d√©j√† fait. Par exemple :
    `C:\PowerShell\Scripts`

2.  **Placez votre fichier** `Get-SystemMonitor.ps1` dans ce dossier.

3.  **Ajoutez ce dossier √† la variable syst√®me `PATH`**,

#### √âtape 2 : Configuration d'un alias dans le profil PowerShell

Maintenant que le syst√®me sait o√π trouver votre script par son nom complet, nous pouvons cr√©er un alias court pour celui-ci.

1.  **Ouvrez votre fichier de profil PowerShell** :
    ```powershell
    notepad $PROFILE
    ```

2.  **Ajoutez la ligne suivante :**
    ```powershell
    # Alias pour le moniteur syst√®me
    Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
    ```

    **Notez le point cl√© :** Puisque le dossier avec le script est d√©j√† dans `PATH`, nous n'avons plus besoin de sp√©cifier le chemin complet du fichier ! Nous nous r√©f√©rons simplement √† son nom. Cela rend votre profil plus propre et plus fiable. Si vous d√©placez un jour le dossier `C:\PowerShell\Scripts`, vous n'aurez qu'√† mettre √† jour la variable `PATH`, et votre fichier de profil restera inchang√©.

#### Red√©marrer PowerShell

Fermez **toutes** les fen√™tres PowerShell ouvertes et ouvrez-en une nouvelle. Ceci est n√©cessaire pour que le syst√®me applique les modifications √† la fois √† la variable `PATH` et √† votre profil.

---

### R√©sultat : Ce que vous obtenez

Apr√®s avoir effectu√© ces √©tapes, vous pourrez appeler votre script **de deux mani√®res depuis n'importe o√π dans le syst√®me** :

1.  **Par nom complet (fiable, pour une utilisation dans d'autres scripts) :**
    ```powershell
    Get-SystemMonitor.ps1
    Get-SystemMonitor.ps1 -Resource storage
    ```

2.  **Par alias court (pratique, pour un travail interactif) :**
    ```powershell
    sysmon
    sysmon -Resource memory
    ```

Vous avez r√©ussi √† "enregistrer" votre script dans le syst√®me de la mani√®re la plus professionnelle et la plus flexible.


Utile ? Abonnez-vous.
Aim√© ‚Äî mettez ¬´ + ¬ª
Bonne chance ! üöÄ

Autres articles PowerShell:
