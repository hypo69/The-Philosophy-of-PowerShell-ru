<h2>La philosophie PowerShell.</h2>
<h3>Partie 2 : Pipeline, variables, Get-Member, fichiers .ps1 et exportation des résultats</h3>
<p><strong>❗ Important :</strong>
J'écris sur PS7 (PowerShell 7). Il est différent de PS5 (PowerShell 5). À partir de la version 7, ps est devenu multiplateforme. Pour cette raison, le comportement de certaines commandes a changé.</p>
<p>Dans la première partie, nous avons établi un principe clé : PowerShell fonctionne avec des <strong>objets</strong>, et non avec du texte.
Ce billet est consacré à certains outils importants de PowerShell :
nous apprendrons à passer des objets dans le <strong>pipeline</strong>, à les analyser avec <strong>`Get-Member`</strong>,
à enregistrer les résultats dans des <strong>variables</strong> et à automatiser tout cela dans des <strong>fichiers de script (`.ps1`)</strong> avec <strong>exportation</strong>
des résultats dans des formats pratiques.</p>
<h3>1. Qu'est-ce qu'un pipeline (`|`) ?</h3>
<p>Le pipeline dans PowerShell est un mécanisme permettant de transmettre des objets .NET complets (et pas seulement du texte) d'une commande
à une autre, où chaque cmdlet suivante reçoit des objets structurés avec toutes leurs propriétés et méthodes.</p>
<p>Le symbole `|` (barre verticale) est l'opérateur de pipeline. Son travail consiste à prendre le résultat (sortie) de la commande à sa gauche et à le transmettre à l'entrée de la commande à sa droite.</p>
<p>`Commande 1 (crée des objets)` → `|` → `Commande 2 (reçoit et traite les objets)` → `|` → `Commande 3 (reçoit les objets traités)` → | ...</p>
<h4>Pipeline UNIX classique : flux de texte</h4>
<p>Dans `bash`, un <strong>flux d'octets</strong> est transmis par le pipeline, qui est généralement interprété comme du texte.</p>
<pre class="line-numbers"><code class="language-bash"># Trouver tous les processus 'nginx' et les compter
ps -ef | grep 'nginx' | wc -l
</code></pre>
<p>Ici, `ps` affiche du texte, `grep` filtre ce texte et `wc` compte les lignes. Chaque utilitaire ne sait rien des "processus", il ne fonctionne qu'avec des chaînes.</p>
<h4>Pipeline PowerShell : flux d'objets</h4>
<p><strong>Exemple :</strong> Obtenons tous les processus, trions-les par utilisation du processeur et sélectionnons les 5 plus "gourmands".</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<p><img src="assets/02/1.png" alt="1"></p>
<p>Ici, `Get-Process` crée des <strong>objets</strong> de processus. `Sort-Object` reçoit ces <strong>objets</strong> et les trie par la propriété `CPU`. `Select-Object` reçoit les <strong>objets</strong> triés et sélectionne les 5 premiers.</p>
<p>Vous avez probablement remarqué des mots dans la commande qui commencent par un trait d'union (-) : -Property, -Descending, -First. Ce sont des paramètres.
Les paramètres sont des paramètres, des commutateurs et des instructions pour un cmdlet. Ils vous permettent de contrôler <strong>COMMENT</strong> la commande effectuera son travail.
Sans paramètres, la commande fonctionne en mode par défaut, et avec des paramètres, vous lui donnez des instructions spécifiques.</p>
<p>Principaux types de paramètres :</p>
<ul>
<li>
<p>Paramètre avec une valeur : nécessite des informations supplémentaires.</p>
<p>`-Property CPU` : nous indiquons à Sort-Object la propriété par laquelle trier. CPU est la valeur du paramètre.</p>
<p>`-First 5` : nous indiquons à Select-Object le nombre d'objets à sélectionner. 5 est la valeur du paramètre.</p>
</li>
<li>
<p>Paramètre de commutateur (indicateur) : ne nécessite pas de valeur. Sa simple présence dans la commande active ou désactive un certain comportement.</p>
<p>`-Descending` : cet indicateur indique à Sort-Object d'inverser l'ordre de tri (du plus grand au plus petit). Il n'a pas besoin de valeur supplémentaire — c'est une instruction en soi.</p>
</li>
</ul>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<p><img src="assets/02/2.png" alt="1"></p>
<p>Cette commande répond à une question très simple :
<strong>"Combien de processus nommés `svchost.exe` sont actuellement en cours d'exécution sur mon système ?"</strong></p>
<h4>Répartition étape par étape</h4>
<h5><strong>Étape 1 : `Get-Process -Name 'svchost'`</strong></h5>
<p>Cette partie de la commande accède au système d'exploitation et demande de trouver <strong>tous</strong> les processus en cours d'exécution dont le nom du fichier exécutable est `svchost.exe`.
Contrairement aux processus comme `notepad` (dont il y en a généralement un ou deux), il y a toujours <strong>beaucoup</strong> de processus `svchost` dans le système. La commande renverra un <strong>tableau (collection) d'objets</strong>,
où chaque objet est un processus `svchost` distinct et complet avec son propre ID unique, son utilisation de la mémoire, etc.
PowerShell a trouvé, par exemple, 90 processus `svchost` dans le système et détient maintenant une collection de 90 objets.</p>
<h5><strong>Étape 2 : `|` (opérateur de pipeline)</strong></h5>
<p>Ce symbole prend la collection de 90 objets `svchost` obtenus à la première étape et commence à les transmettre <strong>un par un</strong> à l'entrée de la commande suivante.</p>
<h5><strong>Étape 3 : `Measure-Object`</strong></h5>
<p>Comme nous avons appelé `Measure-Object` sans paramètres (tels que `-Property`, `-Sum`, etc.), il effectue son opération par <strong>défaut</strong> — il compte simplement le nombre d'"éléments" qui lui ont été transmis.
Un, deux, trois ... Une fois que tous les objets ont été comptés, `Measure-Object` crée son <strong>propre objet de résultat</strong>, qui a une propriété `Count` égale au nombre final.</p>
<p><strong>`Count: 90`</strong> — c'est la réponse à notre question. 90 processus `svchost` sont en cours d'exécution.
Les autres champs sont vides car nous n'avons pas demandé à `Measure-Object` d'effectuer des calculs plus complexes.</p>
<h4>Exemple avec `svchost` et des paramètres</h4>
<p>Changeons notre tâche. Maintenant, nous ne voulons pas seulement compter les processus `svchost`,
mais savoir <strong>quelle quantité de RAM totale (en mégaoctets) ils consomment ensemble</strong>.</p>
<p>Pour ce faire, nous aurons besoin de paramètres :
*   `-Property WorkingSet64` : cette instruction indique à `Measure-Object` : "De chaque objet `svchost` qui vous parvient, prenez la valeur numérique de la propriété `WorkingSet64` (c'est l'utilisation de la mémoire en octets)".
*   `-Sum` : cette instruction d'indicateur dit : "Additionnez toutes ces valeurs que vous avez prises de la propriété `WorkingSet64`".</p>
<p>Notre nouvelle commande ressemblera à ceci :
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
<img src="assets/02/3.png" alt="3"></p>
<ol>
<li>`Get-Process` trouvera le nombre d'objets `svchost`.</li>
<li>Le pipeline `|` les transmettra à `Measure-Object`.</li>
<li>Mais maintenant, `Measure-Object` fonctionne d'une nouvelle manière :
<ul>
<li>Il prend le premier objet `svchost`, examine sa propriété `.WorkingSet64` (par exemple, `25000000` octets) et mémorise ce nombre.</li>
<li>Il prend le deuxième objet, examine son `.WorkingSet64` (par exemple, `15000000` octets) et l'ajoute au précédent.</li>
<li>...et ainsi de suite pour tous les objets.</li>
</ul>
</li>
<li>En conséquence, `Measure-Object` créera un objet de résultat, mais maintenant il sera différent.</li>
</ol>
<ul>
<li><strong>`Count: 92`</strong> : le nombre d'objets.</li>
<li><strong>`Sum: 1661890560`</strong> : c'est la somme totale de toutes les valeurs `WorkingSet64` en octets.</li>
<li><strong>`Property: WorkingSet64`</strong> : ce champ est maintenant également rempli, il nous informe de la propriété qui a été utilisée pour les calculs.</li>
</ul>
<h3>2. Variables (régulières et spéciales `$_`)</h3>
<p>Une variable est un stockage nommé en mémoire qui contient une certaine valeur.</p>
<p>Cette valeur peut être n'importe quoi : du texte, un nombre, une date ou, plus important encore pour PowerShell,
un objet entier ou même une collection d'objets. Un nom de variable dans PowerShell commence toujours par un signe dollar ($).
Exemples : $name, $counter, $processList.</p>
<p>Variable spéciale $_ ?</p>
<p>$_ est une abréviation pour "l'objet actuel" ou "cette chose ici".
Imaginez un tapis roulant dans une usine. Différentes pièces (objets) se déplacent dessus.</p>
<p>$_ est la pièce même qui se trouve juste devant vous (ou devant le robot de traitement).</p>
<p>La source (Get-Process) verse une boîte entière de pièces (tous les processus) sur le tapis roulant.</p>
<p>Le pipeline (|) fait bouger ces pièces le long de la bande une par une.</p>
<p>Le gestionnaire (Where-Object ou ForEach-Object) est un robot qui regarde chaque pièce.</p>
<p>La variable $_ est la pièce même qui se trouve actuellement dans les "mains" du robot.</p>
<p>Lorsque le robot a terminé avec une pièce, le tapis roulant lui en fournit la suivante, et $_ pointera maintenant vers elle.</p>
<p>Calculons la quantité totale de mémoire utilisée par les processus `svchost` et affichons le résultat sur le moniteur.
```powershell
# 1. Exécutez la commande et enregistrez son objet de résultat complexe dans la variable $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Nous pouvons maintenant travailler avec l'objet enregistré. Nous en extrayons la propriété Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Affichez le résultat à l'écran, en utilisant la nouvelle variable
Write-Host "Tous les processus svchost utilisent $memoryInMB Mo de mémoire."
```
<img src="assets/02/4.png" alt="3"></p>
<ul>
<li>
<p>`Write-Host` est un cmdlet spécialisé dont le seul travail consiste à <strong>afficher du texte directement à l'utilisateur dans la console</strong>.</p>
</li>
<li>
<p>La chaîne entre guillemets doubles : `"..."` est la chaîne de texte que nous passons au cmdlet `Write-Host` en tant qu'argument. Pourquoi des guillemets doubles et non des guillemets simples ?</p>
<p>Dans PowerShell, il existe deux types de guillemets :</p>
<ul>
<li><strong>Simples (`'...'`) :</strong> créent une <strong>chaîne littérale</strong>. Tout ce qui se trouve à l'intérieur est traité comme du texte brut, sans exception.</li>
<li><strong>Doubles (`"..."`) :</strong> créent une <strong>chaîne extensible (ou de substitution)</strong>. PowerShell "analyse" une telle chaîne à la recherche de variables (commençant par `$`) et substitue leurs valeurs à leur place.</li>
</ul>
</li>
<li>
<p>`$memoryInMB`. C'est la variable dans laquelle nous avons mis le résultat des calculs <strong>à l'étape précédente</strong> de notre script. Lorsque `Write-Host` reçoit une chaîne entre guillemets doubles,
un processus appelé <strong>"Expansion de chaîne"</strong> se produit :
1.  PowerShell voit le texte `"Tous les processus svchost utilisent "`.
2.  Puis il rencontre la construction `$memoryInMB`. Il comprend que ce n'est pas seulement du texte, mais une variable.
3.  Il regarde dans la mémoire, trouve la valeur stockée dans `$memoryInMB` (par exemple, `1585.52`).
4.  Il <strong>substitue cette valeur</strong> directement dans la chaîne.
5.  Puis il ajoute le reste du texte : `" Mo de mémoire."`.
6.  En conséquence, la chaîne déjà assemblée est transmise à `Write-Host` : `"Tous les processus svchost utilisent 1585.52 Mo de mémoire."`.</li>
</ul>
<p>Démarrez le Bloc-notes :
1. Trouvez le processus du Bloc-notes et enregistrez-le dans la variable $notepadProcess
```powershell
$notepadProcess = Get-Process -Name notepad
```</p>
<ol start="2">
<li>Nous accédons à la propriété 'Id' de cet objet via un point et l'affichons
```powershell
Write-Host "L'ID du processus 'Bloc-notes' est : $($notepadProcess.Id)"
```
<img src="assets/02/5.png" alt="5"></li>
</ol>
<p><strong>❗ Important :</strong>
    Write-Host "casse" le pipeline. Le texte qu'il affiche ne peut pas être transmis plus loin dans le pipeline pour traitement. Il est uniquement destiné à l'affichage.</p>
<h3>3. Get-Member (Inspecteur d'objets)</h3>
<p>Nous savons que les objets "circulent" dans le pipeline. Mais comment savoir de quoi ils sont composés ? Quelles propriétés ont-ils et quelles actions (méthodes) peuvent être effectuées avec eux ?</p>
<p>Le cmdlet **`Get-Member`** (alias : `gm`) est l'outil principal pour la recherche.
Avant de travailler avec un objet, passez-le par `Get-Member` pour voir toutes ses fonctionnalités.</p>
<p>Analysons les objets que `Get-Process` crée :
```powershell
Get-Process | Get-Member
```
<img src="assets/02/6.png" alt="6"></p>
<p><em>Détaillons chaque partie de la sortie de Get-Member.</em></p>
<p>`TypeName: System.Diagnostics.Process` - C'est le "nom de type" complet et officiel de l'objet de la bibliothèque .NET. C'est son "passeport".
Cette ligne vous indique que tous les objets renvoyés par Get-Process sont des objets de type System.Diagnostics.Process.
Cela garantit qu'ils auront tous le même ensemble de propriétés et de méthodes.
Vous pouvez <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">rechercher sur Google</a> "System.Diagnostics.Process" pour trouver la documentation officielle de Microsoft avec des informations encore plus détaillées.</p>
<ul>
<li>Colonne 1 : `Name`</li>
</ul>
<p>C'est un <strong>nom</strong> simple et lisible par l'homme d'une propriété, d'une méthode ou d'un autre "membre" d'un objet. C'est le nom que vous utiliserez dans votre code pour accéder aux données ou effectuer des actions.</p>
<ul>
<li>Colonne 2 : `MemberType` (Type d'objet)</li>
</ul>
<p>C'est la colonne la plus importante à comprendre. Elle classifie <strong>ce qu'est</strong> chaque objet. C'est son "poste", qui vous indique <strong>COMMENT</strong> l'utiliser.</p>
<ul>
<li>
<p><strong>`Property` (Propriété) :** une <strong>caractéristique</strong> ou une <strong>partie de données</strong> stockée à l'intérieur d'un objet. Vous pouvez "lire" sa valeur.
*   <em>Exemples sur la capture d'écran :</em> `BasePriority`, `HandleCount`, `ExitCode`. Ce ne sont que des données qui peuvent être consultées.</p>
</li>
<li>
<p><strong>`Method` (Méthode) :** une <strong>ACTION</strong> qui peut être effectuée avec un objet. Les méthodes sont toujours appelées avec des parenthèses `()`.
*   <em>Exemples sur la capture d'écran :</em> `Kill`, `Refresh`, `WaitForExit`. Vous écririez `$process.Kill()` ou `$process.Refresh()`.</p>
</li>
<li>
<p><strong>`AliasProperty` (Propriété d'alias) :** un <strong>alias convivial</strong> pour une autre propriété plus longue. PowerShell les ajoute pour plus de commodité et de brièveté.
*   <em>Exemples sur la capture d'écran :</em> `WS` est un alias court pour `WorkingSet64`. `Name` est pour `ProcessName`. `VM` est pour `VirtualMemorySize64`.</p>
</li>
<li>
<p><strong>`Event` (Événement) :** une <strong>NOTIFICATION</strong> que quelque chose s'est produit, à laquelle vous pouvez vous "abonner".
*   <em>Exemple sur la capture d'écran :</em> `Exited`. Votre script peut "écouter" cet événement pour effectuer une action immédiatement après la fin du processus.</p>
</li>
<li>
<p><strong>`CodeProperty` et `NoteProperty` :** des types spéciaux de propriétés, souvent ajoutés par PowerShell lui-même pour plus de commodité. `CodeProperty` calcule sa valeur "à la volée", et `NoteProperty` est une simple propriété de note ajoutée à l'objet.</p>
</li>
<li>
<p>Colonne 3 : `Definition` (Définition)</p>
</li>
</ul>
<p>C'est la <strong>définition technique</strong> ou la "signature" du membre. Elle vous donne les détails exacts pour son utilisation. Son contenu dépend du `MemberType` :</p>
<ul>
<li>
<p><strong>Pour `AliasProperty` :** montre <strong>à quoi l'alias est égal</strong>. C'est incroyablement utile !
*   <em>Exemple sur la capture d'écran :</em> `WS = WorkingSet64`. Vous pouvez voir immédiatement que `WS` n'est qu'une notation courte pour `WorkingSet64`.</p>
</li>
<li>
<p><strong>Pour `Property` :** montre le <strong>type de données</strong> qui est stocké dans la propriété (par exemple, `int` pour un entier, `string` pour du texte, `datetime` pour la date et l'heure), et ce que l'on peut en faire (`{get;}` — lecture seule, `{get;set;}` — lecture et modification).
*   <em>Exemple sur la capture d'écran :</em> `int BasePriority {get;}`. C'est une propriété entière qui ne peut être que lue.</p>
</li>
<li>
<p><strong>Pour `Method` :** montre ce que la méthode renvoie (par exemple, `void` — rien, `bool` — vrai/faux) et quels <strong>paramètres</strong> (données d'entrée) elle accepte entre parenthèses.
*   <em>Exemple sur la capture d'écran :</em> `void Kill()`. Cela signifie que la méthode `Kill` ne renvoie rien et peut être appelée sans paramètres. Il existe également une deuxième version `void Kill(bool entireProcessTree)`, qui accepte une valeur booléenne (vrai/faux).</p>
</li>
</ul>
<h4>Sous forme de tableau</h4>
<table>
<thead>
<tr>
<th>Colonne</th>
<th>Qu'est-ce que c'est ?</th>
<th>Exemple de la capture d'écran</th>
<th>À quoi ça sert ?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td>Le nom que vous utilisez dans le code.</td>
<td>`Kill`, `WS`, `Name`</td>
<td>pour accéder à une propriété ou à une méthode (`$process.WS`, `$process.Kill()`).</td>
</tr>
<tr>
<td><strong>MemberType</strong></td>
<td>Le type de membre (données, action, etc.).</td>
<td>`Method`, `Property`, `AliasProperty`</td>
<td><strong>comment</strong> l'utiliser (lire une valeur ou appeler avec `()`).</td>
</tr>
<tr>
<td><strong>Definition</strong></td>
<td>Détails techniques.</td>
<td>`WS = WorkingSet64`, `void Kill()`</td>
<td>ce qui se cache derrière l'alias et quels paramètres la méthode nécessite.</td>
</tr>
</tbody>
</table>
<h4>Exemple : Travailler avec les fenêtres de processus</h4>
<h5>1. Problème :</h5>
<p>"J'ai ouvert de nombreuses fenêtres du Bloc-notes. Comment puis-je réduire par programme toutes les fenêtres sauf la principale, puis fermer uniquement celle qui a le mot 'Untitled' dans son titre ?"</p>
<h5>2. Recherche avec `Get-Member` :</h5>
<p>Nous devons trouver les propriétés liées à la fenêtre et à son titre.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name notepad | Get-Member
</code></pre>
<p><strong>Analyse du résultat de `Get-Member` :</strong>
*   En parcourant les propriétés, nous trouvons `MainWindowTitle`. Type `string`. Super, c'est le titre de la fenêtre principale !
*   Dans les méthodes, nous voyons `CloseMainWindow()`. C'est une façon plus "douce" de fermer une fenêtre que `Kill()`.
*   Dans les méthodes, il y a aussi `WaitForInputIdle()`. Ça a l'air intéressant, peut-être que cela aidera à attendre que le processus soit prêt pour l'interaction.</p>
<p><img src="assets/02/7.png" alt="7"></p>
<p>`Get-Member` nous a montré la propriété `MainWindowTitle`, qui est la clé pour résoudre le problème et nous permet d'interagir avec les processus en fonction de l'état de leurs fenêtres, et pas seulement par leur nom.</p>
<h5>3. Solution :</h5>
<p>Nous pouvons maintenant construire une logique basée sur le titre de la fenêtre.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Trouver tous les processus du Bloc-notes
$notepads = Get-Process -Name notepad

# 2. Parcourir chacun d'eux et vérifier le titre
foreach ($pad in $notepads) {
    # Pour chaque processus ($pad), vérifier sa propriété MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Bloc-notes non enregistré trouvé (ID : $($pad.Id)). Fermeture de sa fenêtre..."
        # $pad.CloseMainWindow() # Décommentez pour fermer réellement
        Write-Host "La fenêtre '$($pad.MainWindowTitle)' aurait été fermée." -ForegroundColor Yellow
    } else {
        Write-Host "Ignorer le Bloc-notes avec le titre : $($pad.MainWindowTitle)"
    }
}
</code></pre>
<p><img src="assets/02/8.png" alt="8"></p>
<p><img src="assets/02/9.png" alt="9"></p>
<hr>
<h4>Exemple : Trouver le processus parent</h4>
<h5>1. Problème :</h5>
<p>"Parfois, je vois beaucoup de processus enfants `chrome.exe` dans le système. Comment savoir lequel est le processus principal, le processus "parent" qui les a tous lancés ?"</p>
<h5>2. Recherche avec `Get-Member` :</h5>
<p>Nous devons trouver quelque chose qui relie un processus à un autre.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<p><img src="assets/02/10.png" alt="10"></p>
<p><strong>Analyse du résultat de `Get-Member` :</strong>
*   En examinant attentivement la liste, nous trouvons une propriété de type `CodeProperty` avec le nom `Parent`.
*   Sa définition (`Definition`) est `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
C'est une propriété calculée qui, lorsqu'on y accède, renvoie l'<strong>objet du processus parent</strong>.</p>
<h5>3. Solution :</h5>
<p>Nous pouvons maintenant écrire un script qui affichera des informations sur son parent pour chaque processus `chrome`.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Obtenir tous les processus chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Pour chacun d'eux, afficher des informations sur lui et son parent
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Obtenir le processus parent
    $parent = $_.Parent
    
    # Formater une belle sortie
    Write-Host "Processus :" -ForegroundColor Green
    Write-Host "  - Nom : $($_.ProcessName), ID : $($_.Id)"
    Write-Host "Son parent :" -ForegroundColor Yellow
    Write-Host "  - Nom : $($parent.ProcessName), ID : $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<p><img src="assets/02/11.png" alt="11"></p>
<p><img src="assets/02/12.png" alt="12"></p>
<p>Nous pouvons voir immédiatement que les processus avec les ID 4756, 7936, 8268 et 9752 ont été lancés par le processus avec l'ID 14908. Vous pouvez également remarquer un cas intéressant avec l'ID de processus : 7252, dont le processus parent n'a pas été déterminé (peut-être que le parent avait déjà réussi à se terminer au moment de la vérification). La modification du script avec la vérification `if ($parent)` gère proprement ce cas sans provoquer d'erreur.
Get-Member nous a aidés à découvrir la propriété "cachée" Parent, qui offre de puissantes fonctionnalités pour analyser la hiérarchie des processus.</p>
<h4>4. Fichier *.ps1* (Création de scripts)</h4>
<p>Lorsque votre chaîne de commandes devient utile, vous voudrez l'enregistrer pour la réutiliser. C'est à cela que servent les <strong>scripts</strong> — des fichiers texte avec l'extension <strong>`.ps1`</strong>.</p>
<h5>Autorisation d'exécuter des scripts</h5>
<p>Par défaut, Windows interdit l'exécution de scripts locaux. Pour corriger cela <strong>pour l'utilisateur actuel</strong>, exécutez une fois dans PowerShell <strong>en tant qu'administrateur</strong> :
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
C'est un paramètre sûr qui vous permet d'exécuter vos propres scripts et des scripts signés par un éditeur de confiance.</p>
<h5>Exemple de script `system_monitor.ps1`</h5>
<p>Créez un fichier avec ce nom et collez-y le code ci-dessous. Ce script collecte des informations système et génère des rapports.</p>
<pre class="line-numbers"><code class="language-powershell"># system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Un script pour créer un rapport d'état du système.
.DESCRIPTION
    Collecte des informations sur les processus, les services et l'espace disque et génère des rapports.
.PARAMETER OutputPath
    Le chemin pour enregistrer les rapports. La valeur par défaut est 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Bloc 1 : Préparation ---
Write-Host "Préparation de la création d'un rapport..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Bloc 2 : Collecte de données ---
Write-Host "Collecte d'informations..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Bloc 3 : Appel de la fonction d'exportation (voir la section suivante) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Rapports enregistrés avec succès dans le dossier $OutputPath" -ForegroundColor Magenta
</code></pre>
<p><em>Remarque : la fonction `Export-Results` sera définie dans la section suivante comme un exemple de bonne pratique.</em></p>
<h4>5. Exporter les résultats</h4>
<p>Les données brutes sont une bonne chose, mais il faut souvent les présenter sous une forme pratique pour une personne ou un autre programme. PowerShell propose de nombreux cmdlets pour l'exportation.</p>
<table>
<thead>
<tr>
<th>Méthode</th>
<th>Commande</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Texte brut</strong></td>
<td>`... \| Out-File C:\Temp\data.txt`</td>
<td>Redirige la représentation textuelle vers un fichier.</td>
</tr>
<tr>
<td><strong>CSV (pour Excel)</strong></td>
<td>`... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`</td>
<td>Exporte les objets au format CSV. `-NoTypeInfo` supprime la première ligne de service.</td>
</tr>
<tr>
<td><strong>Rapport HTML</strong></td>
<td>`... \| ConvertTo-Html -Title "Rapport"`</td>
<td>Crée du code HTML à partir d'objets.</td>
</tr>
<tr>
<td><strong>JSON (pour API, web)</strong></td>
<td>`... \| ConvertTo-Json`</td>
<td>Convertit les objets au format JSON.</td>
</tr>
<tr>
<td><strong>XML (format natif de PowerShell)</strong></td>
<td>`... \| Export-Clixml C:\Temp\data.xml`</td>
<td>Enregistre les objets avec tous les types de données. Ils peuvent être parfaitement restaurés via `Import-Clixml`.</td>
</tr>
</tbody>
</table>
<h5>Ajout au script : fonction d'exportation</h5>
<p>Ajoutons une fonction à notre script `system_monitor.ps1` qui se chargera de l'exportation. Placez ce code <strong>avant</strong> l'appel à `Export-Results`.</p>
<pre class="line-numbers"><code class="language-powershell">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Exporter au format CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Créer un beau rapport HTML
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Top 10 des processus par processeur</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Statistiques des services</h2>"

    ConvertTo-Html -Head "<title>Rapport système</title>" -Body "<h1>Rapport système du $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<p>Maintenant, notre script ne se contente pas de collecter des données, il les enregistre également proprement dans deux formats : CSV pour l'analyse et HTML pour une visualisation rapide.</p>
<h4>Conclusion</h4>
<ol>
<li><strong>Pipeline (`|`)</strong> — l'outil principal pour combiner des commandes et traiter des objets.</li>
<li><strong>`Get-Member`</strong> — une analyse des objets qui montre de quoi ils sont composés.</li>
<li><strong>Variables (`$var`, `$_`)</strong> vous permettent d'enregistrer des données et d'accéder à l'objet actuel dans le pipeline.</li>
<li>Les <strong>fichiers `.ps1`</strong> transforment les commandes en outils d'automatisation réutilisables.</li>
<li><strong>Cmdlets d'exportation</strong> (`Export-Csv`, `ConvertTo-Html`) Exportent les données au format approprié.</li>
</ol>
<p><strong>Dans la partie suivante, nous appliquerons ces connaissances pour naviguer et gérer le système de fichiers, en explorant les objets `System.IO.DirectoryInfo` et `System.IO.FileInfo`.</strong></p>
