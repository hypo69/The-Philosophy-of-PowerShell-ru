<h2>La philosophie PowerShell.</h2>
<h3>Partie 4 : Travail interactif : <code>Out-ConsoleGridView</code>, alertes.</h3>
<ul>
<li>Dans <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md">la premi√®re partie</a>, nous avons d√©fini deux concepts cl√©s de PowerShell : le pipeline et l'objet.</li>
<li>Dans <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md">la deuxi√®me partie</a>, j'ai expliqu√© ce que sont les objets et le pipeline.</li>
<li>Dans <a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md">la troisi√®me partie</a>, nous nous sommes familiaris√©s avec le syst√®me de fichiers et les fournisseurs.</li>
<li>Aujourd'hui, nous allons nous pencher sur le travail interactif avec les donn√©es dans la console, et nous nous familiariserons √©galement avec les alertes et les notifications.</li>
</ul>
<h3>Chapitre premier : Travail interactif avec les donn√©es dans la console.</h3>
<h4><code>Out-ConsoleGridView</code>. Interface graphique dans la console PowerShell.</h4>
<p><strong>‚ùó Important :</strong> tous les outils d√©crits ci-dessous n√©cessitent <strong>PowerShell 7.2 ou une version plus r√©cente</strong>.</p>
<p>Out-ConsoleGridView est un tableau interactif, directement dans la console PowerShell, qui vous permet de :
- afficher les donn√©es sous forme de tableau ;
- filtrer et trier les colonnes ;
- s√©lectionner des lignes avec le curseur ‚Äî pour les transmettre plus loin dans le pipeline.
- et bien plus encore.</p>
<p><code>Out-ConsoleGridView</code> fait partie du module <code>Microsoft.PowerShell.ConsoleGuiTools</code>.
Pour l'utiliser, vous devez d'abord installer ce module.</p>
<p>Pour installer le module, ex√©cutez la commande suivante dans PowerShell :
```powershell
Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
```
<img src="assets/04/1.png" alt="Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser"></p>
<p><em>Install-Module</em> t√©l√©charge et installe le module sp√©cifi√© √† partir du r√©f√©rentiel dans le syst√®me.
Analogues : `pip install` en `Python` ou `npm install` en `Node.js`.</p>
<p>üìé Param√®tres cl√©s de <em>Install-Module</em></p>
<hr>
<table>
<thead>
<tr>
<th>Param√®tre</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Name</code></td>
<td>Le nom du module √† installer.</td>
</tr>
<tr>
<td><code>-Scope</code></td>
<td>La port√©e de l'installation : `AllUsers` (par d√©faut, n√©cessite des droits d'administrateur) ou `CurrentUser` (ne n√©cessite pas de droits d'administrateur).</td>
</tr>
<tr>
<td><code>-Repository</code></td>
<td>Sp√©cifie le r√©f√©rentiel, par exemple `PSGallery`.</td>
</tr>
<tr>
<td><code>-Force</code></td>
<td>Installation forc√©e sans confirmation.</td>
</tr>
<tr>
<td><code>-AllowClobber</code></td>
<td>Autorise l'√©crasement des commandes existantes.</td>
</tr>
<tr>
<td><code>-AcceptLicense</code></td>
<td>Accepte automatiquement la licence du module.</td>
</tr>
<tr>
<td><code>-RequiredVersion</code></td>
<td>Installe une version sp√©cifique du module.</td>
</tr>
</tbody>
</table>
<p>Apr√®s l'installation, vous pouvez transmettre n'importe quelle sortie √† `Out-ConsoleGridView` pour un travail interactif.</p>
<pre class="line-numbers"><code class="language-powershell"># Exemple classique : afficher une liste de processus dans un tableau interactif
Get-Process | Out-ConsoleGridView
</code></pre>
<p><a href="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be">1</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p><strong>Interface :</strong>
*   <strong>Filtrage :</strong> commencez simplement √† taper, et la liste sera filtr√©e √† la vol√©e.
*   <strong>Navigation :</strong> utilisez les touches fl√©ch√©es pour vous d√©placer dans la liste.
*   <strong>S√©lection :</strong> appuyez sur `Espace` pour s√©lectionner/d√©s√©lectionner un seul √©l√©ment.
*   <strong>S√©lection multiple :</strong> `Ctrl+A` pour s√©lectionner tous les √©l√©ments, `Ctrl+D` pour tout d√©s√©lectionner.
*   <strong>Confirmation :</strong> appuyez sur `Entr√©e` pour renvoyer les objets s√©lectionn√©s.
*   <strong>Annulation :</strong> appuyez sur `√âchap` pour fermer la fen√™tre sans renvoyer de donn√©es.</p>
<h2>Que peut faire `Out-ConsoleGridView` :</h2>
<ul>
<li>Afficher des donn√©es tabulaires directement dans la console sous la forme d'un tableau interactif avec navigation par lignes et colonnes.</li>
<li>Trier les colonnes en appuyant sur des touches.</li>
<li>Filtrer les donn√©es √† l'aide de la recherche.</li>
<li>S√©lectionner une ou plusieurs lignes avec le r√©sultat renvoy√©.</li>
<li>Travailler dans une console propre sans fen√™tres d'interface graphique.</li>
<li>Prendre en charge un grand nombre de lignes avec d√©filement.</li>
<li>Prendre en charge diff√©rents types de donn√©es (cha√Ænes, nombres, dates, etc.).</li>
</ul>
<hr>
<h2>Exemples d'utilisation de `Out-ConsoleGridView`</h2>
<h3>Utilisation de base ‚Äî afficher un tableau avec la possibilit√© de s√©lectionner de mani√®re interactive. (case √† cocher)</h3>
<pre class="line-numbers"><code class="language-powershell">Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Afficher un tableau avec la possibilit√© de filtrer, trier et s√©lectionner des lignes
$selected = $data | Out-ConsoleGridView -Title "Select process(es)" -OutputMode Multiple

$selected | Format-Table -AutoSize
</code></pre>
<p><a href="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356">2</a></p>
<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>Une liste de processus est affich√©e dans un tableau de console interactif.
Vous pouvez filtrer par nom, trier les colonnes et s√©lectionner des processus.
Les processus s√©lectionn√©s sont renvoy√©s √† la variable `$selected`.</p>
<hr>
<h3>S√©lectionner une ligne avec retour de r√©sultat obligatoire. (radio)</h3>
<pre class="line-numbers"><code class="language-powershell">$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Select a service" -OutputMode Single

Write-Host "You selected service: $($choice.Name)"
</code></pre>
<p><a href="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e"></a></p>
<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>L'utilisateur s√©lectionne une ligne (service). `-OutputMode Single` interdit la s√©lection de plusieurs.</p>
<hr>
<h3>Filtrage et tri de grands tableaux</h3>
<pre class="line-numbers"><code class="language-powershell">$data = 1..1000 | ForEach-Object { 
    [PSCustomObject]@{ 
        Number = $_ 
        Square = $_ * $_ 
        Cube   = $_ * $_ * $_ 
    } 
}

$data | Out-ConsoleGridView -Title "Numbers and powers"  -OutputMode Multiple
</code></pre>
<p>Affiche un tableau de 1000 lignes avec des nombres et leurs puissances.</p>
<h3><strong>Gestion interactive des processus :</strong></h3>
<p>Vous pouvez s√©lectionner plusieurs processus √† arr√™ter. Le param√®tre `-OutputMode Multiple` indique que nous voulons renvoyer tous les √©l√©ments s√©lectionn√©s.</p>
<pre class="line-numbers"><code class="language-powershell"># Transmettre les r√©sultats par le pipeline.
# Arr√™ter les processus s√©lectionn√©s avec le param√®tre -WhatIf pour un aper√ßu.
# Pour ce faire, nous d√©finirons la variable $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple
    
# Si quelque chose a √©t√© s√©lectionn√©, transmettre les objets plus loin dans le pipeline
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
</code></pre>
<h3><strong>S√©lection de fichiers pour l'archivage :</strong></h3>
<p>Trouver tous les fichiers `.log` dans un dossier, s√©lectionner ceux qui sont n√©cessaires et en cr√©er une archive.</p>
<pre class="line-numbers"><code class="language-powershell">$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
</code></pre>
<p>‚ùóSoyez prudent avec la r√©cursivit√©</p>
<pre class="line-numbers"><code class="language-powershell">if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip
    
    # Ajouter un message de r√©ussite
    Write-Host "‚úÖ L'archivage s'est termin√© avec succ√®s !" -ForegroundColor Green
}
</code></pre>
<h3><strong>S√©lection d'un seul √©l√©ment pour une analyse d√©taill√©e :</strong></h3>
<h4>Le mod√®le "Drill-Down" ‚Äî d'une liste g√©n√©rale aux d√©tails avec `Out-ConsoleGridView`</h4>
<p>Souvent, lorsque nous travaillons avec des objets syst√®me, nous sommes confront√©s √† un dilemme :
1.  Si vous demandez <strong>toutes les propri√©t√©s</strong> pour <strong>tous les objets</strong> (`Get-NetAdapter | Format-List *`), la sortie sera √©norme et illisible.
2.  Si vous affichez un <strong>tableau court</strong>, vous perdrez des d√©tails importants.
3.  Parfois, essayer d'obtenir toutes les donn√©es en m√™me temps peut entra√Æner une erreur si l'un des objets contient des valeurs incorrectes.</p>
<p>La solution √† ce probl√®me est le mod√®le <strong>"Drill-Down"</strong> (exploration en profondeur). Son essence est simple :</p>
<ul>
<li><strong>√âtape 1 (Vue d'ensemble) :</strong> montrer √† l'utilisateur une liste d'√©l√©ments propre, concise et s√ªre pour la <strong>s√©lection</strong>.</li>
<li><strong>√âtape 2 (Exploration en profondeur) :</strong> une fois que l'utilisateur a s√©lectionn√© un √©l√©ment sp√©cifique, lui montrer <strong>toutes les informations disponibles</strong> pour cet √©l√©ment particulier.</li>
</ul>
<h4>Exemple pratique : cr√©ation d'un explorateur de cartes r√©seau</h4>
<p>Impl√©mentons ce mod√®le en utilisant la commande `Get-NetAdapter` comme exemple.</p>
<p><strong>T√¢che :</strong> tout d'abord, afficher une courte liste de cartes r√©seau. Apr√®s en avoir s√©lectionn√© une, ouvrir une deuxi√®me fen√™tre avec toutes ses propri√©t√©s.</p>
<p><strong>Code pr√™t √† l'emploi :</strong>
```powershell
# --- √âtape 1 : S√©lection d'une carte dans une liste courte ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "√âTAPE 1 : S√©lectionnez une carte r√©seau"

# --- √âtape 2 : Affichage d'informations d√©taill√©es ou d'un message d'annulation ---
if ($null -ne $selectedAdapter) {
    # Obtenir TOUTES les propri√©t√©s de la carte S√âLECTIONN√âE
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Utiliser notre astuce avec .psobject.Properties pour transformer l'objet en un tableau "Nom-Valeur" pratique
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value
    
    # Ouvrir une DEUXI√àME fen√™tre GridView avec des informations compl√®tes
    $detailedInfoForGrid | Out-ConsoleGridView -Title "√âTAPE 2 : Informations compl√®tes pour '$($selectedAdapter.Name)'"
} else {
    Write-Host "Op√©ration annul√©e. Aucune carte n'a √©t√© s√©lectionn√©e." -ForegroundColor Yellow
}
```</p>
<h4>Analyse √©tape par √©tape</h4>
<ol>
<li>
<p><strong>Cr√©ation d'une liste "s√ªre" :</strong>
`$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed`
Nous ne transmettons pas directement la sortie de `Get-NetAdapter`. Au lieu de cela, nous cr√©ons de nouveaux objets "propres" √† l'aide de `Select-Object`, en n'incluant que les propri√©t√©s dont nous avons besoin pour la vue d'ensemble. Cela garantit que les donn√©es probl√©matiques qui ont provoqu√© une erreur seront ignor√©es.</p>
</li>
<li>
<p><strong>Premi√®re fen√™tre interactive :</strong>
`$selectedAdapter = $adapterList | Out-ConsoleGridView ...`
Le script affiche la premi√®re fen√™tre et <strong>arr√™te son ex√©cution</strong>, en attendant votre choix. D√®s que vous s√©lectionnez une ligne et appuyez sur `Entr√©e`, l'objet correspondant √† cette ligne sera √©crit dans la variable `$selectedAdapter`.</p>
</li>
<li>
<p><strong>V√©rification de la s√©lection :</strong>
`if ($null -ne $selectedAdapter)`
C'est une v√©rification d'une importance capitale. Si l'utilisateur appuie sur `√âchap` ou ferme la fen√™tre, la variable `$selectedAdapter` sera vide (`$null`). Cette v√©rification emp√™che l'ex√©cution du reste du code et l'apparition d'erreurs.</p>
</li>
<li>
<p><strong>Obtention d'informations compl√®tes :</strong>
`$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name`
C'est le point cl√© du mod√®le. Nous acc√©dons √† nouveau √† `Get-NetAdapter`, mais cette fois, nous ne demandons <strong>qu'un seul</strong> objet par son nom, que nous avons pris de l'√©l√©ment s√©lectionn√© √† la premi√®re √©tape. Nous obtenons maintenant l'objet complet avec toutes ses propri√©t√©s.</p>
</li>
<li>
<p><strong>Conversion pour la deuxi√®me fen√™tre :</strong>
`$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...`
Nous utilisons la technique puissante que vous connaissez d√©j√† pour "d√©velopper" cet objet complexe en une longue liste de paires "Nom de la propri√©t√©" | "Valeur", ce qui est id√©al pour l'affichage dans un tableau.</p>
</li>
<li>
<p><strong>Deuxi√®me fen√™tre interactive :</strong>
`$detailedInfoForGrid | Out-ConsoleGridView ...`
Une deuxi√®me fen√™tre appara√Æt √† l'√©cran, cette fois avec des informations compl√®tes sur la carte m√™me que vous avez s√©lectionn√©e.</p>
</li>
</ol>
<hr>
<h3>Exemple avec un titre et des conseils personnalis√©s</h3>
<p>Affichage du journal des √©v√©nements Windows dans un tableau interactif avec le titre "√âv√©nements syst√®me".</p>
<pre class="line-numbers"><code class="language-powershell">Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
</code></pre>
<p>Ce code obtient les 50 √©v√©nements les plus r√©cents du journal syst√®me de Windows, ne s√©lectionne que quatre propri√©t√©s cl√©s de chaque √©v√©nement
(heure, type, source et message) et les affiche dans la fen√™tre Out-ConsoleGridView.</p>
<hr>
<h3>Informations syst√®me.</h3>
<p><a href="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06">1</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>
<p>code de script pour obtenir des informations syst√®me :
<a href="https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1">Get-SystemMonitor.ps1</a></p>
<h3>Cr√©ation du cmdlet 'Get-SystemMonitor'</h3>
<h4>√âtape 1 : configuration de la variable `PATH`</h4>
<ol>
<li>
<p><strong>Cr√©ez un dossier permanent pour vos outils,</strong> si vous ne l'avez pas d√©j√† fait. Par exemple :
`C:\PowerShell\Scripts`</p>
</li>
<li>
<p><strong>Placez votre fichier `Get-SystemMonitor.ps1`</strong> dans ce dossier.</p>
</li>
<li>
<p><strong>Ajoutez ce dossier √† la variable syst√®me `PATH`</strong>,</p>
</li>
</ol>
<h4>√âtape 2 : configuration d'un alias dans le profil PowerShell</h4>
<p>Maintenant que le syst√®me sait o√π trouver votre script par son nom complet, nous pouvons cr√©er un alias court pour celui-ci.</p>
<ol>
<li>
<p><strong>Ouvrez votre fichier de profil PowerShell</strong> :
```powershell
notepad $PROFILE
```</p>
</li>
<li>
<p><strong>Ajoutez-y la ligne suivante :</strong>
```powershell
# Alias pour le moniteur syst√®me
Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
```</p>
<p><strong>Faites attention au point cl√© :</strong> comme le dossier avec le script se trouve d√©j√† dans le `PATH`, nous n'avons <strong>plus besoin de sp√©cifier le chemin d'acc√®s complet</strong> au fichier ! Nous nous r√©f√©rons simplement √† son nom. Cela rend votre profil plus propre et plus fiable. Si vous d√©placez un jour le dossier `C:\PowerShell\Scripts`, vous n'aurez qu'√† mettre √† jour la variable `PATH`, et votre fichier de profil restera inchang√©.</p>
</li>
</ol>
<h4>Red√©marrez PowerShell</h4>
<p>Fermez <strong>toutes</strong> les fen√™tres PowerShell ouvertes et ouvrez-en une nouvelle. Cela est n√©cessaire pour que le syst√®me applique les modifications √† la fois √† la variable `PATH` et √† votre profil.</p>
<hr>
<h3>R√©sum√© : ce que vous obtenez</h3>
<p>Apr√®s avoir termin√© ces √©tapes, vous pourrez appeler votre script <strong>de deux mani√®res depuis n'importe o√π dans le syst√®me</strong> :</p>
<ol>
<li>
<p><strong>Par nom complet (fiable, pour une utilisation dans d'autres scripts) :</strong>
```powershell
Get-SystemMonitor.ps1
Get-SystemMonitor.ps1 -Resource storage
```</p>
</li>
<li>
<p><strong>Par alias court (pratique, pour un travail interactif) :</strong>
```powershell
sysmon
sysmon -Resource memory
```</p>
</li>
</ol>
<p>Vous avez r√©ussi √† "enregistrer" votre script dans le syst√®me de la mani√®re la plus professionnelle et la plus flexible.</p>
<p>Utile ? Abonnez-vous.
Vous avez aim√© ‚Äî mettez un "+"
Bonne chance ! üöÄ</p>
<p>Autres articles sur PowerShell :</p>
