# PowerShell-Philosophie.
## Teil 2: Pipeline, Variablen, Get-Member, *.ps1*-Datei und Export von Ergebnissen
**❗ Wichtig:**
Ich schreibe über PS7 (PowerShell 7). Es unterscheidet sich von PS5 (PowerShell 5). Ab der siebten Version wurde PowerShell plattformübergreifend. Aus diesem Grund hat sich das Verhalten einiger Befehle geändert.

Im ersten Teil haben wir das Schlüsselprinzip festgelegt: PowerShell arbeitet mit **Objekten**, nicht mit Text.
Dieser Beitrag widmet sich einigen wichtigen PowerShell-Tools: Wir lernen, Objekte über die **Pipeline** zu übergeben, sie mit **`Get-Member`** zu analysieren, Ergebnisse in **Variablen** zu speichern und all dies in **Skriptdateien (`.ps1`)** mit **Export** der Ergebnisse in praktische Formate zu automatisieren.

### 1. Was ist eine Pipeline (`|`)?
Die Pipeline in PowerShell ist ein Mechanismus zur Übergabe vollwertiger .NET-Objekte (und nicht nur einfachen Textes) von einem Befehl zum nächsten, wobei jedes nachfolgende Cmdlet strukturierte Objekte mit all ihren Eigenschaften und Methoden erhält.

Das Symbol `|` (vertikaler Strich) ist der Pipeline-Operator. Seine Aufgabe ist es, das Ergebnis (die Ausgabe) des Befehls links davon zu nehmen und es als Eingabe an den Befehl rechts davon weiterzuleiten.

`Befehl 1 (erzeugt Objekte)` → `|` → `Befehl 2 (empfängt und verarbeitet Objekte)` → `|` → `Befehl 3 (empfängt verarbeitete Objekte)` → | ...

#### Klassische UNIX-Pipeline: Textstrom

In `bash` wird ein **Bytestrom** über die Pipeline geleitet, der normalerweise als Text interpretiert wird.

```bash
# Alle 'nginx'-Prozesse finden und ihre Anzahl zählen
ps -ef | grep 'nginx' | wc -l
```
Hier gibt `ps` Text aus, `grep` filtert diesen Text, und `wc` zählt die Zeilen. Jedes Dienstprogramm weiß nichts über "Prozesse", es arbeitet nur mit Zeilen.

#### PowerShell-Pipeline: Objektstrom
**Beispiel:** Lassen Sie uns alle Prozesse abrufen, sie nach CPU-Auslastung sortieren und die 5 "hungrigsten" auswählen.

```powershell
Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
```
![1](assets/02/1.png)

Hier erzeugt `Get-Process` **Prozessobjekte**. `Sort-Object` empfängt diese **Objekte** und sortiert sie nach der Eigenschaft `CPU`. `Select-Object` empfängt die sortierten **Objekte** und wählt die ersten 5 aus.

Sie haben sicherlich in dem Befehl Wörter bemerkt, die mit einem Bindestrich (-) beginnen: -Property, -Descending, -First. Das sind Parameter.
Parameter sind Einstellungen, Schalter und Anweisungen für ein Cmdlet. Sie ermöglichen es Ihnen, zu steuern, **WIE** ein Befehl seine Arbeit ausführt.
Ohne Parameter arbeitet ein Befehl im Standardmodus, mit Parametern geben Sie ihm spezifische Anweisungen.

Haupttypen von Parametern:

- Parameter mit Wert: erfordert zusätzliche Informationen.

    `-Property CPU`: Wir sagen Sort-Object, nach welcher Eigenschaft sortiert werden soll. CPU ist der Wert des Parameters.

    `-First 5`: Wir sagen Select-Object, wie viele Objekte ausgewählt werden sollen. 5 ist der Wert des Parameters.

- Schalterparameter (Flag): Benötigt keinen Wert. Seine bloße Anwesenheit im Befehl schaltet ein bestimmtes Verhalten ein oder aus.

   `-Descending`: Dieses Flag weist Sort-Object an, die Sortierreihenfolge umzukehren (vom Größten zum Kleinsten). Es benötigt keinen zusätzlichen Wert – es ist an sich eine Anweisung.

```powershell
Get-Process -Name 'svchost' | Measure-Object
```
![1](assets/02/2.png)
Dieser Befehl beantwortet eine sehr einfache Frage:
**"Wie viele Prozesse mit dem Namen `svchost.exe` laufen derzeit auf meinem System?"**

#### Schritt-für-Schritt-Analyse

##### **Schritt 1: `Get-Process -Name 'svchost'`**

Dieser Teil des Befehls wendet sich an das Betriebssystem und fordert es auf, **alle ausnahmslos** laufenden Prozesse zu finden, deren ausführbarer Dateiname `svchost.exe` ist.
Im Gegensatz zu Prozessen wie `notepad` (von denen es normalerweise ein oder zwei gibt), gibt es immer **viele** `svchost`-Prozesse im System. Der Befehl gibt ein **Array (Sammlung) von Objekten** zurück,
wobei jedes Objekt ein separater, vollständiger `svchost`-Prozess mit seiner eindeutigen ID, Speichernutzung usw. ist.
PowerShell hat im System beispielsweise 90 `svchost`-Prozesse gefunden und hält nun eine Sammlung von 90 Objekten in der Hand.

##### **Schritt 2: `|` (Pipeline-Operator)**

Dieses Symbol nimmt die Sammlung von 90 `svchost`-Objekten, die im ersten Schritt erhalten wurden, und beginnt, sie **einzeln** als Eingabe an den nächsten Befehl zu übergeben.

##### **Schritt 3: `Measure-Object`**

Da wir `Measure-Object` ohne Parameter (wie `-Property`, `-Sum` usw.) aufgerufen haben, führt es seine **Standardoperation** aus – es zählt einfach die Anzahl der ihm übergebenen "Elemente".
Eins, zwei, drei ... Nachdem alle Objekte gezählt wurden, erstellt `Measure-Object` **sein eigenes Ergebnisobjekt**, das eine Eigenschaft `Count` enthält, die der Gesamtzahl entspricht.

**`Count: 90`** – das ist die Antwort auf unsere Frage. Es laufen 90 `svchost`-Prozesse.
Die restlichen Felder sind leer, da wir `Measure-Object` nicht aufgefordert haben, komplexere Berechnungen durchzuführen.

#### Beispiel mit `svchost` und Parametern

Lassen Sie uns unsere Aufgabe ändern. Jetzt wollen wir nicht nur die `svchost`-Prozesse zählen,
sondern herausfinden, **wie viel Arbeitsspeicher (in Megabyte) sie insgesamt verbrauchen**.

Dafür benötigen wir Parameter:
*   `-Property WorkingSet64`: Diese Anweisung sagt `Measure-Object`: "Nimm aus jedem `svchost`-Objekt, das zu dir kommt, den numerischen Wert aus der Eigenschaft `WorkingSet64` (das ist die Speichernutzung in Bytes)."
*   `-Sum`: Diese Anweisung (Flag) sagt: "Addiere alle diese Werte, die du aus der Eigenschaft `WorkingSet64` genommen hast."

Unser neuer Befehl sieht so aus:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
![3](assets/02/3.png)

1.  `Get-Process` findet die Anzahl der `svchost`-Objekte.
2.  Die Pipeline `|` übergibt sie an `Measure-Object`.
3.  Aber jetzt arbeitet `Measure-Object` anders:
    *   Es nimmt das erste `svchost`-Objekt, schaut sich seine Eigenschaft `.WorkingSet64` an (z.B. `25000000` Bytes) und merkt sich diese Zahl.
    *   Es nimmt das zweite Objekt, schaut sich sein `.WorkingSet64` an (z.B. `15000000` Bytes) und addiert es zum vorherigen.
    *   ...und so weiter für alle Objekte.
4.  Am Ende erstellt `Measure-Object` ein Ergebnisobjekt, aber diesmal wird es anders sein.


*   **`Count: 92`**: Anzahl der Objekte.
*   **`Sum: 1661890560`**: Dies ist die Gesamtsumme aller `WorkingSet64`-Werte in Bytes.
*   **`Property: WorkingSet64`**: Dieses Feld ist nun ebenfalls gefüllt, es informiert uns, welche Eigenschaft für die Berechnungen verwendet wurde.




### 2. Variablen (Normale und spezielle `$_`)

Eine Variable ist ein benannter Speicherort im Arbeitsspeicher, der einen Wert enthält. 

Dieser Wert kann alles sein: Text, eine Zahl, ein Datum oder, was für PowerShell am wichtigsten ist, 
 ein ganzes Objekt oder sogar eine Sammlung von Objekten. Der Variablenname in PowerShell beginnt immer mit einem Dollarzeichen ($).
Beispiele: $name, $counter, $processList.

Spezielle Variable $_?

`$_` ist die Abkürzung für "aktuelles Objekt" oder "dieses Ding".
Stellen Sie sich ein Fließband in einer Fabrik vor. Verschiedene Teile (Objekte) fahren darauf entlang.

`$_` ist genau das Teil, das sich gerade vor Ihnen (oder vor dem Roboter-Bearbeiter) befindet.

Quelle (Get-Process) — schüttet eine ganze Kiste mit Teilen (allen Prozessen) auf das Fließband.

Pipeline (|) — lässt diese Teile einzeln auf dem Band bewegen.

Bearbeiter (Where-Object oder ForEach-Object) — das ist ein Roboter, der jedes Teil betrachtet.

Variable `$_` — das ist genau das Teil, das sich gerade in den "Händen" des Roboters befindet.

Wenn der Roboter mit einem Teil fertig ist, liefert das Fließband das nächste, und `$_` wird nun auf dieses zeigen.



Lassen Sie uns berechnen, wie viel Speicher die `svchost`-Prozesse insgesamt verwenden, und das Ergebnis auf dem Monitor anzeigen.
```powershell
# 1. Führen Sie den Befehl aus und speichern Sie sein komplexes Ergebnisobjekt in der Variable $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Jetzt können wir mit dem gespeicherten Objekt arbeiten. Holen Sie die Sum-Eigenschaft daraus
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Zeigen Sie das Ergebnis auf dem Bildschirm an, indem Sie die neue Variable verwenden
Write-Host "Alle svchost-Prozesse verwenden $memoryInMB MB Speicher."
```
![3](assets/02/4.png)

*   `Write-Host` — ist ein spezialisiertes Cmdlet, dessen einzige Aufgabe es ist, **Text direkt dem Benutzer in der Konsole anzuzeigen**.

*   Zeichenkette in doppelten Anführungszeichen: `"..."` - eine Textzeichenkette, die wir dem Cmdlet `Write-Host` als Argument übergeben. Warum doppelte und nicht einfache Anführungszeichen? 
    
    In PowerShell gibt es zwei Arten von Anführungszeichen:
    
    *   **Einfache (`'...'`):** Erzeugen eine **buchstäbliche Zeichenkette**. Alles, was sich darin befindet, wird als normaler Text behandelt, ohne Ausnahmen.
    *   **Doppelte (`"..."`):** Erzeugen eine **erweiterbare (oder substituierbare) Zeichenkette**. PowerShell "scannt" eine solche Zeichenkette nach Variablen (beginnend mit `$`) und ersetzt diese durch ihre Werte.

* `$memoryInMB`. Dies ist die Variable, in die wir **im vorherigen Schritt** unseres Skripts das Ergebnis der Berechnungen gelegt haben. Wenn `Write-Host` eine Zeichenkette in doppelten Anführungszeichen erhält, 
findet ein Prozess statt, der als **"Variablensubstitution" (String Expansion)** bezeichnet wird:
    1.  PowerShell sieht den Text `"Alle svchost-Prozesse verwenden "`.
    2.  Dann stößt es auf die Konstruktion `$memoryInMB`. Es versteht, dass dies nicht nur Text, sondern eine Variable ist.
    3.  Es schaut im Speicher nach, findet den in `$memoryInMB` gespeicherten Wert (z.B. `1585.52`).
    4.  Es **ersetzt diesen Wert** direkt in der Zeichenkette.
    5.  Dann fügt es den restlichen Text hinzu: `" MB Speicher."`.
    6.  Am Ende wird an `Write-Host` die fertige, zusammengesetzte Zeichenkette übergeben: `"Alle svchost-Prozesse verwenden 1585.52 MB Speicher."`.



Starten Sie den Editor:
 1. Finden Sie den Editor-Prozess und speichern Sie ihn in der Variable $notepadProcess
 ```powershell
$notepadProcess = Get-Process -Name notepad
```

 2. Greifen Sie über den Punkt auf die Eigenschaft 'Id' dieses Objekts zu und geben Sie sie aus
 ```powershell
Write-Host "Die ID des 'Editor'-Prozesses ist: $($notepadProcess.Id)"
```
![5](assets/02/5.png)

**❗ Wichtig:** 
    Write-Host "bricht" die Pipeline. Der von ihm ausgegebene Text kann nicht zur weiteren Verarbeitung über die Pipeline weitergeleitet werden. Er dient nur zur Anzeige.

### 3. Get-Member (Objektinspektor)

Wir wissen, dass Objekte durch die Pipeline "fließen". Aber wie erfahren wir, woraus sie bestehen? Welche Eigenschaften sie haben und welche Aktionen (Methoden) mit ihnen ausgeführt werden können?

Das Cmdlet **`Get-Member`** (Alias: `gm`) ist das Hauptwerkzeug zur Untersuchung. 
Bevor Sie mit einem Objekt arbeiten, leiten Sie es durch `Get-Member`, um alle seine Möglichkeiten zu sehen. 

Lassen Sie uns die Objekte analysieren, die `Get-Process` erzeugt:
```powershell
Get-Process | Get-Member
```
![6](assets/02/6.png)

*Lassen Sie uns jeden Teil der Get-Member-Ausgabe aufschlüsseln.*

`TypeName: System.Diagnostics.Process` - Dies ist der vollständige, offizielle "Typname" des Objekts aus der .NET-Bibliothek. Es ist sein "Pass".
Diese Zeile sagt Ihnen, dass alle Objekte, die Get-Process zurückgibt, Objekte vom Typ System.Diagnostics.Process sind. 
Dies garantiert, dass sie alle den gleichen Satz von Eigenschaften und Methoden haben werden. 
Sie können [googeln](https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com) "System.Diagnostics.Process", um die offizielle Microsoft-Dokumentation mit noch detaillierteren Informationen zu finden.



- Spalte 1: `Name`

Dies ist der einfache, menschenlesbare **Name** einer Eigenschaft, Methode oder eines anderen "Members" des Objekts. Genau diesen Namen werden Sie in Ihrem Code verwenden, um auf Daten zuzugreifen oder Aktionen auszuführen.



- Spalte 2: `MemberType` (Objekttyp)

Dies ist die wichtigste Spalte zum Verständnis. Sie klassifiziert, **was** jedes Objekt ist. Es ist seine "Rolle", die Ihnen sagt, **WIE** es zu verwenden ist.

*   **`Property` (Eigenschaft):**  **Charakteristik** oder **Datenteil**, der innerhalb des Objekts gespeichert ist. Sie können seinen Wert "lesen".
    *   *Beispiele im Screenshot:* `BasePriority`, `HandleCount`, `ExitCode`. Dies sind einfach Daten, die man sich ansehen kann.

*   **`Method` (Methode):**   **AKTION**, die mit dem Objekt ausgeführt werden kann. Methoden werden immer mit runden Klammern `()` aufgerufen.
    *   *Beispiele im Screenshot:* `Kill`, `Refresh`, `WaitForExit`. Sie würden `$process.Kill()` oder `$process.Refresh()` schreiben.

*   **`AliasProperty` (Alias-Eigenschaft):**  **freundlicher Alias** für eine andere, längere Eigenschaft. PowerShell fügt sie zur Bequemlichkeit und Kürze hinzu.
    *   *Beispiele im Screenshot:* `WS` — ist ein kurzer Alias für `WorkingSet64`. `Name` — für `ProcessName`. `VM` — für `VirtualMemorySize64`.

*   **`Event` (Ereignis):**  **BENACHRICHTIGUNG** darüber, dass etwas passiert ist, auf die man sich "abonnieren" kann.
    *   *Beispiel im Screenshot:* `Exited`. Ihr Skript kann dieses Ereignis "abhören", um eine Aktion auszuführen, sobald der Prozess beendet ist.

*   **`CodeProperty` und `NoteProperty`:** Spezielle Eigenschaftstypen, oft hinzugefügt von PowerShell selbst zur Bequemlichkeit. `CodeProperty` berechnet seinen Wert "on the fly", während `NoteProperty` — eine einfache Notiz-Eigenschaft ist, die einem Objekt hinzugefügt wird.

- Spalte 3: `Definition` (Definition)

Dies ist die **technische Definition** oder "Signatur" des Members. Sie gibt Ihnen die genauen Details für seine Verwendung. Ihr Inhalt hängt vom `MemberType` ab:

*   **Für `AliasProperty`:** Zeigt an, **worum der Alias gleich ist**. Das ist unglaublich nützlich!
    *   *Beispiel im Screenshot:* `WS = WorkingSet64`. Sie sehen sofort, dass `WS` — einfach eine Kurzform für `WorkingSet64` ist.

*   **Für `Property`:** Zeigt den **Datentyp** an, der in der Eigenschaft gespeichert ist (z.B. `int` für eine ganze Zahl, `string` für Text, `datetime` für Datum und Uhrzeit), und was damit gemacht werden kann (`{get;}` – nur lesen, `{get;set;}` – lesen und ändern).
    *   *Beispiel im Screenshot:* `int BasePriority {get;}`. Dies ist eine Ganzzahleigenschaft, die nur gelesen werden kann.

*   **Für `Method`:** Zeigt an, was die Methode zurückgibt (z.B. `void` – nichts, `bool` – true/false) und welche **Parameter** (Eingabedaten) sie in Klammern akzeptiert.
    *   *Beispiel im Screenshot:* `void Kill()`. Das bedeutet, dass die Methode `Kill` nichts zurückgibt und ohne Parameter aufgerufen werden kann. Es gibt auch eine zweite Version `void Kill(bool entireProcessTree)`, die einen booleschen Wert (true/false) akzeptiert.

#### In Tabellenform

| Kolumna      | Was ist das?                             | Beispiel aus dem Screenshot        | Wofür?                                                                   |
|--------------|------------------------------------------|------------------------------------|--------------------------------------------------------------------------|
| **Name**    | Der Name, den Sie im Code verwenden.     | `Kill`, `WS`, `Name`               | um auf eine Eigenschaft oder Methode zuzugreifen (`$process.WS`, `$process.Kill()`). |
| **MemberType**| Der Typ des Members (Daten, Aktion usw.). | `Method`, `Property`, `AliasProperty` | **wie** es zu verwenden ist (Wert lesen oder mit `()` aufrufen).              |
| **Definition**| Technische Details.                      | `WS = WorkingSet64`, `void Kill()` | was sich hinter dem Alias verbirgt und welche Parameter die Methode benötigt. |

#### Beispiel: Arbeiten mit Prozessfenstern

##### 1. Problem:
"Ich habe viele Editor-Fenster geöffnet. Wie kann ich programmatisch alle außer dem Hauptfenster minimieren und dann nur das schließen, dessen Titel das Wort 'Untitled' enthält?"

##### 2. Untersuchung mit `Get-Member`:
Wir müssen Eigenschaften finden, die mit dem Fenster und seinem Titel zusammenhängen.

```powershell
Get-Process -Name notepad | Get-Member
```
**Analyse des `Get-Member`-Ergebnisses:**
*   Beim Durchsuchen der Eigenschaften finden wir `MainWindowTitle`. Typ `string`. Ausgezeichnet, das ist der Titel des Hauptfensters!
*   In den Methoden sehen wir `CloseMainWindow()`. Dies ist eine "sanftere" Methode zum Schließen eines Fensters als `Kill()`.
*   Auch in den Methoden gibt es `WaitForInputIdle()`. Klingt interessant, vielleicht hilft es, zu warten, bis der Prozess zur Interaktion bereit ist.

![7](assets/02/7.png)

`Get-Member` zeigte uns die Eigenschaft `MainWindowTitle`, die der Schlüssel zur Lösung der Aufgabe ist und es ermöglicht, mit Prozessen basierend auf dem Zustand ihrer Fenster zu interagieren, und nicht nur nach Namen.

##### 3. Lösung:
Jetzt können wir eine Logik aufbauen, die auf dem Fenstertitel basiert.

```powershell
# 1. Finden Sie alle Editor-Prozesse
$notepads = Get-Process -Name notepad

# 2. Gehen Sie jeden einzelnen durch und überprüfen Sie den Titel
foreach ($pad in $notepads) {
    # Für jeden Prozess ($pad) überprüfen Sie seine Eigenschaft MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Unsaved Notepad gefunden (ID: $($pad.Id)). Schließe sein Fenster..."
        # $pad.CloseMainWindow() # Auskommentieren, um tatsächlich zu schließen
        Write-Host "Fenster '$($pad.MainWindowTitle)' wäre geschlossen worden." -ForegroundColor Yellow
    } else {
        Write-Host "Überspringe Notepad mit Titel: $($pad.MainWindowTitle)"
    }
}
```

![8](assets/02/8.png)

![9](assets/02/9.png)

---

#### Beispiel: Übergeordneten Prozess finden

##### 1. Problem:
"Manchmal sehe ich viele untergeordnete `chrome.exe`-Prozesse im System. Wie finde ich heraus, welcher davon der Haupt-, "übergeordnete" Prozess ist, der sie alle gestartet hat?"

##### 2. Untersuchung mit `Get-Member`:
Wir müssen etwas finden, das einen Prozess mit einem anderen verbindet.

```powershell
Get-Process -Name chrome | Select-Object -First 1 | Get-Member
```
![10](assets/02/10.png)

**Analyse des `Get-Member`-Ergebnisses:**
*   Beim sorgfältigen Durchsuchen der Liste, finden wir eine Eigenschaft vom Typ `CodeProperty` mit dem Namen `Parent`.
*   Ihre Definition (`Definition`) — `System.Diagnostics.Process Parent{get=GetParentProcess;}`. 
Dies ist eine berechnete Eigenschaft, die beim Zugriff ein **Objekt des übergeordneten Prozesses** zurückgibt.

##### 3. Lösung:
Jetzt können wir ein Skript schreiben, das für jeden `chrome`-Prozess Informationen über seinen übergeordneten Prozess ausgibt.

```powershell
# 1. Alle Chrome-Prozesse abrufen
$chromeProcesses = Get-Process -Name chrome

# 2. Für jeden von ihnen Informationen über sich selbst und seinen übergeordneten Prozess ausgeben
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Den übergeordneten Prozess abrufen
    $parent = $_.Parent
    
    # Schöne Ausgabe formatieren
    Write-Host "Prozess:" -ForegroundColor Green
    Write-Host "  - Name: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Sein übergeordneter Prozess:" -ForegroundColor Yellow
    Write-Host "  - Name: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
```
![11](assets/02/11.png)

![12](assets/02/12.png)

Wir sehen sofort, dass die Prozesse mit den IDs 4756, 7936, 8268 und 9752 vom Prozess mit der ID 14908 gestartet wurden. Auch kann man einen interessanten Fall mit dem Prozess ID: 7252 bemerken, dessen übergeordneter Prozess nicht ermittelt werden konnte (möglicherweise hatte sich der übergeordnete Prozess zum Zeitpunkt der Überprüfung bereits beendet). Eine Modifikation des Skripts mit der Überprüfung if ($parent) behandelt diesen Fall elegant, ohne einen Fehler zu verursachen.
Get-Member half uns, die "versteckte" Eigenschaft Parent zu entdecken, die leistungsstarke Möglichkeiten zur Analyse der Prozesshierarchie bietet.

#### 4. Datei *.ps1* (Skripte erstellen)

Wenn Ihre Befehlskette nützlich wird, möchten Sie sie zur mehrfachen Verwendung speichern. Dafür sind **Skripte** da – Textdateien mit der Erweiterung **`.ps1`**.

##### Berechtigung zum Ausführen von Skripten
Standardmäßig ist die Ausführung lokaler Skripte unter Windows verboten. Um dies **für den aktuellen Benutzer** zu beheben, führen Sie einmal in PowerShell **als Administrator** aus:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
Dies ist eine sichere Einstellung, die es Ihnen erlaubt, Ihre eigenen Skripte und Skripte, die von einem vertrauenswürdigen Herausgeber signiert wurden, auszuführen.

##### Beispielskript `system_monitor.ps1`
Erstellen Sie eine Datei mit diesem Namen und fügen Sie den folgenden Code ein. Dieses Skript sammelt Systeminformationen und generiert Berichte.

```powershell
# system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    Skript zur Erstellung eines Systemstatusberichts.
.DESCRIPTION
    Sammelt Informationen über Prozesse, Dienste und Speicherplatz und generiert Berichte.
.PARAMETER OutputPath
    Pfad zum Speichern der Berichte. Standard ist 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Block 1: Vorbereitung ---
Write-Host "Vorbereitung zur Berichterstellung..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Block 2: Datenerfassung ---
Write-Host "Informationen sammeln..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Block 3: Aufruf der Exportfunktion (siehe nächster Abschnitt) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Berichte erfolgreich im Ordner $OutputPath" -ForegroundColor Magenta
```
*Hinweis: Die Funktion `Export-Results` wird im nächsten Abschnitt als Beispiel für bewährte Verfahren definiert.*

#### 5. Export von Ergebnissen

Reine Daten — das ist gut, aber oft müssen sie in einem für Menschen oder andere Programme geeigneten Format präsentiert werden. PowerShell bietet viele Cmdlets für den Export.

| Methode                               | Befehl                                            | Beschreibung                                                                            |
| ----------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **Einfacher Text**                   | `... \| Out-File C:\Temp\data.txt`                 | Leitet die Textdarstellung in eine Datei um.                                      |
| **CSV (für Excel)**                 | `... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`   | Exportiert Objekte in CSV. `-NoTypeInfo` entfernt die erste Dienstzeile.     |
| **HTML-Bericht**                      | `... \| ConvertTo-Html -Title "Bericht"`             | Erstellt HTML-Code aus Objekten.                                                       |
| **JSON (für API, Web)**             | `... \| ConvertTo-Json`                            | Konvertiert Objekte in das JSON-Format.                                                  |
| **XML (natives PowerShell-Format)** | `... \| Export-Clixml C:\Temp\data.xml`            | Speichert Objekte mit allen Datentypen. Sie können perfekt über `Import-Clixml` wiederhergestellt werden. |

##### Ergänzung zum Skript: Exportfunktion
Fügen wir unserem Skript `system_monitor.ps1` eine Funktion hinzu, die sich um den Export kümmert. Platzieren Sie diesen Code **vor** dem Aufruf von `Export-Results`.

```powershell
function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Export nach CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Erstellung eines schönen HTML-Berichts
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Top 10 Prozesse nach CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Dienststatistik</h2>"

    ConvertTo-Html -Head "<title>Systembericht</title>" -Body "<h1>Systembericht vom $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
```
Jetzt sammelt unser Skript nicht nur Daten, sondern speichert sie auch sauber in zwei Formaten: CSV zur Analyse und HTML zur schnellen Ansicht.

#### Fazit

1.  **Pipeline (`|`)** – das Hauptwerkzeug zum Kombinieren von Befehlen und Verarbeiten von Objekten.
2.  **`Get-Member`** – Objektanalyse, die zeigt, woraus sie bestehen.
3.  **Variablen (`$var`, `$_`)** ermöglichen das Speichern von Daten und den Zugriff auf das aktuelle Objekt in der Pipeline.
4.  **`.ps1`-Dateien** verwandeln Befehle in wiederverwendbare Automatisierungswerkzeuge.
5.  **Export-Cmdlets** (`Export-Csv`, `ConvertTo-Html`) exportieren Daten im entsprechenden Format.

**Im nächsten Teil werden wir dieses Wissen anwenden, um Dateisysteme zu navigieren und zu verwalten, indem wir die Objekte `System.IO.DirectoryInfo` und `System.IO.FileInfo` untersuchen.**