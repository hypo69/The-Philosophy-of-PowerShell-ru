# PowerShell-Philosophie.

## Teil 4: Interaktives Arbeiten: `Out-ConsoleGridView`, Benachrichtigungen.

- Im [ersten Teil](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/01.md) haben wir zwei Schl√ºsselkonzepte von PowerShell definiert: Pipeline und Objekt.

- Im [zweiten Teil](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/02.md) habe ich erkl√§rt, was Objekte und die Pipeline sind.

- Im [dritten Teil](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/03.md) haben wir das Dateisystem und die Provider kennengelernt.

- Heute werden wir die interaktive Arbeit mit Daten in der Konsole betrachten und uns mit Benachrichtigungen und Hinweisen vertraut machen.

### Kapitel eins: Interaktives Arbeiten mit Daten in der Konsole.

#### `Out-ConsoleGridView`. GUI in der PowerShell-Konsole.

**‚ùó Wichtig:** Alle unten beschriebenen Tools erfordern **PowerShell 7.2 oder neuer**.

Out-ConsoleGridView ist eine interaktive Tabelle direkt in der PowerShell-Konsole, die Folgendes erm√∂glicht:
- Daten in Tabellenform anzeigen;
- Spalten filtern und sortieren;
- Zeilen mit dem Cursor ausw√§hlen ‚Äì um sie weiter durch die Pipeline zu leiten.
- und vieles mehr.

`Out-ConsoleGridView` ist Teil des Moduls `Microsoft.PowerShell.ConsoleGuiTools`.
Um es zu verwenden, m√ºssen Sie dieses Modul zuerst installieren.

F√ºhren Sie zur Installation des Moduls den folgenden Befehl in PowerShell aus:
```powershell
Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser
```
![Install-Module Microsoft.PowerShell.ConsoleGuiTools -Scope CurrentUser](assets/04/1.png)

*Install-Module* l√§dt und installiert das angegebene Modul aus dem Repository in das System.
Analoga: `pip install` in `Python` oder `npm install` in `Node.js`.

üìé Schl√ºsselparameter von *Install-Module*

------------------------------------------------------------------------------------------------------------------------------------------------------
| Parameter          | Beschreibung                                                                                                                  |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------- |
| `-Name`            | Name des zu installierenden Moduls.                                                                                           |
| `-Scope`           | Installationsbereich: `AllUsers` (Standard, erfordert Administratorrechte) oder `CurrentUser` (erfordert keine Administratorrechte). |
| `-Repository`      | Gibt das Repository an, z.B. `PSGallery`.                                                                                     |
| `-Force`           | Erzwingt die Installation ohne Best√§tigung.                                                                                   |
| `-AllowClobber`    | Erlaubt das √úberschreiben bereits existierender Befehle.                                                                      |
| `-AcceptLicense`   | Akzeptiert automatisch die Modullizenz.                                                                                      |
| `-RequiredVersion` | Installiert eine bestimmte Modulversion.                                                                                      |

Nach der Installation k√∂nnen Sie jede Ausgabe an `Out-ConsoleGridView` zur interaktiven Arbeit weiterleiten.

```powershell
# Klassisches Beispiel: Anzeige einer Prozessliste in einer interaktiven Tabelle
Get-Process | Out-ConsoleGridView
```

(https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/5828dd51-cfb8-4904-87be-796ccc8395be" type="video/mp4">
  Your browser does not support the video tag.
</video>

**Benutzeroberfl√§che:**
*   **Filtern:** Beginnen Sie einfach mit der Eingabe von Text, und die Liste wird sofort gefiltert.
*   **Navigation:** Verwenden Sie die Pfeiltasten, um sich in der Liste zu bewegen.
*   **Auswahl:** Dr√ºcken Sie `Space`, um ein Element auszuw√§hlen/abzuw√§hlen.
*   **Mehrfachauswahl:** `Strg+A` zum Ausw√§hlen aller Elemente, `Strg+D` zum Aufheben der Auswahl aller Elemente.
*   **Best√§tigung:** Dr√ºcken Sie `Enter`, um die ausgew√§hlten Objekte zur√ºckzugeben.
*   **Abbrechen:** Dr√ºcken Sie `ESC`, um das Fenster zu schlie√üen, ohne Daten zur√ºckzugeben.

## Was `Out-ConsoleGridView` kann:

* Tabellarische Daten direkt in der Konsole als interaktive Tabelle mit Zeilen- und Spaltennavigation anzeigen.
* Spalten durch Tastendruck sortieren.
* Daten mithilfe der Suche filtern.
* Eine oder mehrere Zeilen ausw√§hlen und das Ergebnis zur√ºckgeben.
* In einer reinen Konsole ohne GUI-Fenster arbeiten.
* Eine gro√üe Anzahl von Zeilen mit Scrollen unterst√ºtzen.
* Verschiedene Datentypen (Zeichenketten, Zahlen, Daten usw.) unterst√ºtzen.

---

## Anwendungsbeispiele f√ºr `Out-ConsoleGridView`

### Grundlegende Verwendung ‚Äì Tabelle mit interaktiver Auswahl anzeigen. (Checkbox)

```powershell
Import-Module Microsoft.PowerShell.ConsoleGuiTools

$data = Get-Process | Select-Object -First 30 -Property Id, ProcessName, CPU, WorkingSet

# Tabelle mit Filter-, Sortier- und Auswahlm√∂glichkeiten anzeigen
$selected = $data | Out-ConsoleGridView -Title "Prozess(e) ausw√§hlen" -OutputMode Multiple

$selected | Format-Table -AutoSize
```

(https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356)

<video>
  <source src="https://github.com/user-attachments/assets/3f1a2a62-066f-4dbb-947a-9b26095da356" type="video/mp4">
  Your browser does not support the video tag.
</video>

Eine Liste von Prozessen wird in einer interaktiven Konsolentabelle angezeigt.
Sie k√∂nnen nach Namen filtern, Spalten sortieren und Prozesse ausw√§hlen.
Die ausgew√§hlten Prozesse werden in der Variable `$selected` zur√ºckgegeben.

---

### Auswahl einer einzelnen Zeile mit obligatorischer Ergebnisr√ºckgabe. (Radio)

```powershell
$choice = Get-Service | Select-Object -First 20 | Out-ConsoleGridView -Title "Dienst ausw√§hlen" -OutputMode Single

Write-Host "Sie haben den Dienst ausgew√§hlt: $($choice.Name)"
```

[](https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e)

<video>
  <source src="https://github.com/user-attachments/assets/5ee8fb92-8e18-496a-9db7-2d86b243742e" type="video/mp4">
  Your browser does not support the video tag.
</video>

Der Benutzer w√§hlt eine einzelne Zeile (Dienst). `-OutputMode Single` verhindert die Auswahl mehrerer.

---

### Filtern und Sortieren gro√üer Arrays

```powershell
$data = 1..1000 | ForEach-Object {
    [PSCustomObject]@{
        Number = $_
        Square = $_ * $_
        Cube   = $_ * $_ * $_
    }
}

$data | Out-ConsoleGridView -Title "Zahlen und Potenzen"  -OutputMode Multiple
```

Zeigt eine Tabelle mit 1000 Zeilen mit Zahlen und ihren Potenzen an.

### **Interaktive Prozessverwaltung:**

Sie k√∂nnen mehrere Prozesse zum Beenden ausw√§hlen. Der Parameter `-OutputMode Multiple` gibt an, dass wir alle ausgew√§hlten Elemente zur√ºckgeben m√∂chten.

```powershell
# Ergebnisse √ºber die Pipeline weiterleiten.
# Ausgew√§hlte Prozesse mit dem Parameter -WhatIf zur Vorschau beenden.
# Dazu definieren wir die Variable $procsToStop
$procsToStop = Get-Process | Out-ConsoleGridView -OutputMode Multiple

# Wenn etwas ausgew√§hlt wurde, Objekte weiter √ºber die Pipeline leiten
if ($procsToStop) {
    $procsToStop | Stop-Process -WhatIf
}
```

### **Dateien zur Archivierung ausw√§hlen:**

Wir finden alle `.log`-Dateien in einem Ordner, w√§hlen die ben√∂tigten aus und erstellen ein Archiv daraus.

```powershell
$filesToArchive = Get-ChildItem -Path C:\Logs -Filter "*.log" -Recurse | Out-ConsoleGridView -OutputMode Multiple
```

‚ùóSeien Sie vorsichtig mit Rekursion

```powershell
if ($filesToArchive) {
    Compress-Archive -Path $filesToArchive.FullName -DestinationPath C:\Temp\LogArchive.zip

    # Erfolgsmeldung hinzuf√ºgen
    Write-Host "‚úÖ Archivierung erfolgreich abgeschlossen!" -ForegroundColor Green
}
```

### **Auswahl eines Elements zur detaillierten Analyse:**

#### Das "Drill-Down"-Muster ‚Äì von der allgemeinen Liste zu Details mit `Out-ConsoleGridView`

Oft stehen wir bei der Arbeit mit Systemobjekten vor einem Dilemma:
1.  Wenn wir **alle Eigenschaften** f√ºr **alle Objekte** anfordern (`Get-NetAdapter | Format-List *`), wird die Ausgabe riesig und unleserlich.
2.  Wenn wir eine **kurze Tabelle** anzeigen, verlieren wir wichtige Details.
3.  Manchmal kann der Versuch, alle Daten auf einmal abzurufen, zu einem Fehler f√ºhren, wenn eines der Objekte ung√ºltige Werte enth√§lt.

Die L√∂sung dieses Problems ist das **"Drill-Down"**-Muster (Detaillierung oder "Eintauchen"). Sein Kern ist einfach:

*   **Schritt 1 (√úbersicht):** Dem Benutzer eine saubere, kurze und sichere Liste von Elementen zur **Auswahl** anzeigen.
*   **Schritt 2 (Detaillierung):** Nachdem der Benutzer ein bestimmtes Element ausgew√§hlt hat, ihm **alle verf√ºgbaren Informationen** genau zu diesem Element anzeigen.

#### Praktisches Beispiel: Erstellen eines Netzwerkadapter-Browsers

Wir implementieren dieses Muster am Beispiel des Befehls `Get-NetAdapter`.

**Aufgabe:** Zuerst eine kurze Liste der Netzwerkadapter anzeigen. Nach Auswahl eines Adapters ein zweites Fenster mit all seinen Eigenschaften √∂ffnen.

**Fertiger Code:**
```powershell
# --- Phase 1: Adapter aus der Kurzliste ausw√§hlen ---
$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed
$selectedAdapter = $adapterList | Out-ConsoleGridView -Title "PHASE 1: Netzwerkadapter ausw√§hlen"

# --- Phase 2: Detaillierte Informationen oder Abbruchmeldung anzeigen ---
if ($null -ne $selectedAdapter) {
    # ALLE Eigenschaften f√ºr den AUSGEW√ÑHLTEN Adapter abrufen
    $detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name | Select-Object *

    # Unser Trick mit .psobject.Properties verwenden, um das Objekt in eine praktische "Name-Wert"-Tabelle umzuwandeln
    $detailedInfoForGrid = $detailedInfoObject.psobject.Properties | Select-Object Name, Value

    # ZWEITES GridView-Fenster mit vollst√§ndigen Informationen √∂ffnen
    $detailedInfoForGrid | Out-ConsoleGridView -Title "PHASE 2: Vollst√§ndige Informationen zu '$($selectedAdapter.Name)'"
} else {
    Write-Host "Vorgang abgebrochen. Es wurde kein Adapter ausgew√§hlt." -ForegroundColor Yellow
}
```

#### Schritt-f√ºr-Schritt-Analyse

1.  **Erstellen einer "sicheren" Liste:**
    `$adapterList = Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, LinkSpeed`
    Wir leiten die Ausgabe von `Get-NetAdapter` nicht direkt weiter. Stattdessen erstellen wir neue, "saubere" Objekte mit `Select-Object`, die nur die Eigenschaften enthalten, die wir f√ºr die √úbersicht ben√∂tigen. Dies stellt sicher, dass problematische Daten, die einen Fehler verursachen k√∂nnten, verworfen werden.

2.  **Erstes interaktives Fenster:**
    `$selectedAdapter = $adapterList | Out-ConsoleGridView ...`
    Das Skript zeigt das erste Fenster an und **h√§lt seine Ausf√ºhrung an**, w√§hrend es auf Ihre Auswahl wartet. Sobald Sie eine Zeile ausw√§hlen und `Enter` dr√ºcken, wird das dieser Zeile entsprechende Objekt in die Variable `$selectedAdapter` geschrieben.

3.  **√úberpr√ºfung der Auswahl:**
    `if ($null -ne $selectedAdapter)`
    Dies ist eine entscheidende √úberpr√ºfung. Wenn der Benutzer `Esc` dr√ºckt oder das Fenster schlie√üt, ist die Variable `$selectedAdapter` leer (`$null`). Diese √úberpr√ºfung verhindert die Ausf√ºhrung des restlichen Codes und das Auftreten von Fehlern.

4.  **Abrufen vollst√§ndiger Informationen:**
    `$detailedInfoObject = Get-NetAdapter -Name $selectedAdapter.Name`
    Hier ist der Schl√ºsselmoment des Musters. Wir greifen erneut auf `Get-NetAdapter` zu, fordern aber diesmal **nur ein** Objekt anhand seines Namens an, den wir aus dem im ersten Schritt ausgew√§hlten Element entnommen haben. Jetzt erhalten wir das vollst√§ndige Objekt mit all seinen Eigenschaften.

5.  **Transformation f√ºr das zweite Fenster:**
    `$detailedInfoForGrid = $detailedInfoObject.psobject.Properties | ...`
    Wir verwenden den Ihnen bereits bekannten leistungsstarken Trick, um dieses eine komplexe Objekt in eine lange Liste von "Eigenschaftsname" | "Wert"-Paaren "aufzul√∂sen", die sich ideal f√ºr die Anzeige in einer Tabelle eignet.

6.  **Zweites interaktives Fenster:**
    `$detailedInfoForGrid | Out-ConsoleGridView ...`
    Auf dem Bildschirm erscheint ein zweites Fenster, diesmal mit umfassenden Informationen zu genau dem Adapter, den Sie ausgew√§hlt haben.

---

### Beispiel mit benutzerdefiniertem Titel und Hinweisen

Anzeige des Windows-Ereignisprotokolls in einer interaktiven Tabelle mit dem Titel "System Events".

```powershell
Get-EventLog -LogName System -Newest 50 |
    Select-Object TimeGenerated, EntryType, Source, Message |
    Out-ConsoleGridView -Title "System Events"  -OutputMode Multiple
```
Dieser Code ruft die 50 neuesten Ereignisse aus dem Windows-Systemprotokoll ab, w√§hlt von jedem Ereignis nur vier Schl√ºsselattribute aus
(Zeit, Typ, Quelle und Nachricht) und zeigt sie im Out-ConsoleGridView-Fenster an.

----

### Systeminformationen.

(https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06)

<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/1e53a339-56f9-4add-8053-86d94dbc8e06" type="video/mp4">
  Your browser does not support the video tag.
</video>

Skriptcode zum Abrufen von Systeminformationen:
[Get-SystemMonitor.ps1](https://github.com/hypo69/The-Philosophy-of-PowerShell-ru/blob/master/code/04/Get-SystemMonitor.ps1)

### Erstellen des Cmdlets 'Get-SystemMonitor'

#### Schritt 1: Konfigurieren der `PATH`-Variable

1.  **Erstellen Sie einen permanenten Ordner f√ºr Ihre Tools,** falls Sie dies noch nicht getan haben. Zum Beispiel:
    `C:\PowerShell\Scripts`

2.  **Legen Sie Ihre Datei** `Get-SystemMonitor.ps1` in diesen Ordner.

3.  **F√ºgen Sie diesen Ordner zur Systemvariablen `PATH` hinzu**,

#### Schritt 2: Konfigurieren des Alias im PowerShell-Profil

Nachdem das System nun wei√ü, wo Ihr Skript unter seinem vollst√§ndigen Namen zu finden ist, k√∂nnen wir einen kurzen Alias daf√ºr erstellen.

1.  **√ñffnen Sie Ihre PowerShell-Profildatei**:
    ```powershell
    notepad $PROFILE
    ```

2.  **F√ºgen Sie die folgende Zeile hinzu:**
    ```powershell
    # Alias f√ºr den Systemmonitor
    Set-Alias -Name sysmon -Value "Get-SystemMonitor.ps1"
    ```

    **Beachten Sie den entscheidenden Punkt:** Da sich der Ordner mit dem Skript bereits im `PATH` befindet, m√ºssen wir **nicht mehr den vollst√§ndigen Pfad** zur Datei angeben! Wir verweisen einfach auf ihren Namen. Dies macht Ihr Profil sauberer und zuverl√§ssiger. Wenn Sie den Ordner `C:\PowerShell\Scripts` jemals verschieben, m√ºssen Sie nur die `PATH`-Variable aktualisieren, und Ihre Profildatei bleibt unver√§ndert.

#### PowerShell neu starten

Schlie√üen Sie **alle** ge√∂ffneten PowerShell-Fenster und √∂ffnen Sie ein neues. Dies ist notwendig, damit das System die √Ñnderungen sowohl in der `PATH`-Variablen als auch in Ihrem Profil anwendet.

---

### Ergebnis: Was Sie erhalten

Nachdem Sie diese Schritte ausgef√ºhrt haben, k√∂nnen Sie Ihr Skript **auf zwei Arten von jedem Ort im System aus aufrufen**:

1.  **Mit dem vollst√§ndigen Namen (zuverl√§ssig, zur Verwendung in anderen Skripten):**
    ```powershell
    Get-SystemMonitor.ps1
    Get-SystemMonitor.ps1 -Resource storage
    ```

2.  **Mit dem kurzen Alias (praktisch, f√ºr interaktives Arbeiten):**
    ```powershell
    sysmon
    sysmon -Resource memory
    ```

Sie haben Ihr Skript erfolgreich auf die professionellste und flexibelste Weise im System "registriert".

N√ºtzlich? Abonnieren Sie.
Gef√§llt es Ihnen ‚Äì geben Sie ein ‚Äû+‚Äú
Viel Gl√ºck! üöÄ

Weitere Artikel √ºber PowerShell: