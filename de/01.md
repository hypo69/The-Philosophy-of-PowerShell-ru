# PowerShell-Philosophie.
## Teil 0.
Was war vor PowerShell?
1981 erschien MS-DOS 1.0 mit dem Kommandozeileninterpreter `COMMAND.COM`. Zur Automatisierung von Aufgaben wurden **Batch-Dateien (`.bat`)** verwendet ‚Äì einfache Textdateien mit einer Abfolge von Konsolenbefehlen. Ein erstaunlicher Asketismus der Kommandozeile im Vergleich zu POSIX-kompatiblen Systemen, wo bereits seit 1979 die **Bourne-Shell (`sh`)** existierte.

### üìÖ Zustand des Shell-Marktes zum Zeitpunkt der Ver√∂ffentlichung von **MS-DOS 1.0** (August 1981)

Hier ist eine zusammenfassende Tabelle der damals popul√§ren Betriebssysteme und ihrer Shell-Unterst√ºtzung (`sh`, `csh` usw.):

| Betriebssystem         | Shell-Unterst√ºtzung (`sh`, `csh`, usw.) | Kommentar                                                  |
| ---------------------------- | ------------------------------------- | ------------------------------------------------------------ |
| **UNIX Version 7 (V7)**      | `sh`                                  | Letztes klassisches UNIX von Bell Labs, weit verbreitet  |
| **UNIX/32V**                 | `sh`, `csh`                           | UNIX-Version f√ºr die VAX-Architektur                              |
| **4BSD / 3BSD**              | `sh`, `csh`                           | Universit√§ts-UNIX-Zweig von Berkeley                       |
| **UNIX System III**          | `sh`                                  | Erste kommerzielle Version von AT\&T, Vorg√§nger von System V |
| **Xenix (von Microsoft)**     | `sh`                                  | Lizenzierte UNIX-Version, von Microsoft seit 1980 verkauft |
| **IDRIS**                    | `sh`                                  | UNIX-√§hnliches Betriebssystem f√ºr PDP-11 und Intel          |
| **Coherent (Mark Williams)** | `sh` (√§hnlich)                        | Preiswerte UNIX-Alternative f√ºr PCs                           |
| **CP/M (Digital Research)**  | ‚ùå (Kein `sh`, nur einfachster CLI)   | Kein UNIX, beliebtestes Betriebssystem f√ºr 8-Bit-PCs                 |
| **MS-DOS 1.0**               | ‚ùå (nur `COMMAND.COM`)              | Minimale Kommandozeilen-Shell, keine Skripte oder Pipes    |

---

### üí° Was sind `sh`, `csh`

* `sh` ‚Äî **Bourne Shell**, der wichtigste Skript-Interpreter von UNIX seit 1977.
* `csh` ‚Äî **C Shell**, eine verbesserte Shell mit C-√§hnlicher Syntax und Komfortfunktionen f√ºr die interaktive Arbeit.
* Diese Shells **unterst√ºtzten Umleitungen, Pipes, Variablen, Funktionen und Bedingungen** ‚Äì alles, was UNIX zu einem m√§chtigen Automatisierungswerkzeug machte.

---

Microsoft konzentrierte sich auf **g√ºnstige 16-Bit-IBM-PCs**, die **wenig Speicher** (normalerweise 64‚Äì256 KB) hatten, keine Multitasking-F√§higkeiten besa√üen und f√ºr den **Heim- und B√ºrogebrauch** bestimmt waren, nicht f√ºr Server. UNIX war kostenpflichtig, erforderte komplexe Architektur und Erfahrung, und Buchhalter und Ingenieure, keine Systemadministratoren, ben√∂tigten ein schnelles und einfaches Betriebssystem.

Die DOS-Oberfl√§che, anstelle der komplexen `sh`, pr√§sentierte eine einzige Datei command.com mit einem sp√§rlichen Satz interner Befehle [ (dir, copy, del usw.)](https://www.techgeekbuzz.com/blog/dos-commands/){:target="_blank"} ohne Funktionen, Schleifen und Module.

Es gab auch externe Befehle ‚Äì separate ausf√ºhrbare Dateien (.exe oder .com). Beispiele: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Ausf√ºhrungsskripte wurden in Textdateien mit der Erweiterung .bat (Batch-Datei) gespeichert.

Beispiele f√ºr Konfigurationsdateien:

- AUTOEXEC.BAT

```bash
:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Automatische Konfiguration und Start von Windows 3.11
:: Autor: hypo69
:: Jahr: ca. 1993
:: Zweck: Initialisiert die DOS-Umgebung, l√§dt Netzwerktreiber und startet Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Eingabeaufforderung konfigurieren
PROMPT $p$g

:: Umgebungsvariablen setzen
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Treiber und Dienstprogramme in den oberen Speicher laden
LH C:\DOS\SMARTDRV.EXE       :: Festplatten-Cache
LH C:\DOS\MOUSE.COM          :: Maustreiber

:: Netzwerkdienste laden (relevant f√ºr Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Automatischer Start von Windows
WIN

```
- CONFIG.SYS
```bash
:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî DOS-Speicher- und Treiberkonfiguration f√ºr Windows 3.11
:: Autor: hypo69
:: Jahr: ca. 1993
:: Zweck: Initialisierung von Speichertreibern, Konfiguration von Systemparametern
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE

```

Parallel zu DOS begann Microsoft fast sofort mit der Entwicklung eines prinzipiell neuen Kernels.

Der [**Windows NT**](https://www.wikiwand.com/ru/articles/Windows_NT){:target="_blank"}-Kernel (New Technology) erschien erstmals mit der Ver√∂ffentlichung des Betriebssystems:

> **Windows NT 3.1 ‚Äî 27. Juli 1993**

---

* **Entwicklung begann**: im **Jahr 1988** unter der Leitung von **Dave Cutler** (ehemaliger DEC-Ingenieur, Sch√∂pfer von VMS) mit dem Ziel, ein v√∂llig neues, gesch√ºtztes, portables und Multitasking-f√§higes Betriebssystem zu schaffen, das nicht mit MS-DOS auf Kernelebene kompatibel war.
* **NT 3.1** ‚Äî wurde so genannt, um die Kompatibilit√§t mit **Windows 3.1** auf Schnittstellenebene zu betonen, war aber eine **v√∂llig neue Architektur**.

---

#### üß† Was der NT-Kernel brachte:

| Besonderheit                        | Beschreibung                                                              |
| ---------------------------------- | --------------------------------------------------------------------- |
| **32-Bit-Architektur**          | Im Gegensatz zu MS-DOS und Windows 3.x, die 16-Bit waren.           |
| **Multitasking**                | Echtes pr√§emptives Multitasking.                                    |
| **Gesch√ºtzter Speicher**              | Programme konnten den Speicher anderer Programme nicht besch√§digen.                       |
| **Modularit√§t**                    | Mehrschichtige Kernel-Architektur: HAL, Executive, Kernel, Treiber.    |
| **Multiplattform-Unterst√ºtzung** | NT 3.1 lief auf x86, MIPS und Alpha.                                 |
| **POSIX-Kompatibilit√§t**          | NT wurde mit einem **POSIX-Subsystem** geliefert, das nach POSIX.1 zertifiziert war. |

---

#### üìú NT-Reihe:

| NT-Version     | Jahr       | Kommentar                      |
| ------------- | --------- | -------------------------------- |
| NT 3.1        | 1993      | Erste NT-Ver√∂ffentlichung                  |
| NT 3.5 / 3.51 | 1994‚Äì1995 | Verbesserungen, Optimierung           |
| NT 4.0        | 1996      | Windows 95-Oberfl√§che, aber NT-Kernel |
| Windows 2000  | 2000      | NT 5.0                           |
| Windows XP    | 2001      | NT 5.1                           |
| Windows Vista | 2007      | NT 6.0                           |
| Windows 10    | 2015      | NT 10.0                          |
| Windows 11    | 2021      | Auch NT 10.0 (Marketing üòä)      |

---

Unterschiede in den Funktionen der Betriebssysteme:

| Merkmal                  | **MS-DOS** (1981)                       | **Windows NT** (1993)                               |
| ------------------------------- | --------------------------------------- | --------------------------------------------------- |
| **Systemtyp**                 | Monolithisch, Single-Tasking                | Mikrokernel/Hybrid, Multitasking               |
| **Bit-Breite**                 | 16-Bit                                  | 32-Bit (mit 64-Bit-Unterst√ºtzung ab NT 5.2 / XP x64)      |
| **Multitasking**             | ‚ùå Nicht vorhanden (ein Prozess gleichzeitig)     | ‚úÖ Pr√§emptives Multitasking                           |
| **Gesch√ºtzter Speicher**           | ‚ùå Nein                                   | ‚úÖ Ja (jeder Prozess in eigenem Adressraum) |
| **Mehrbenutzerbetrieb** | ‚ùå Nein                                   | ‚úÖ Teilweise (in NT Workstation/Server)                |
| **POSIX-Kompatibilit√§t**       | ‚ùå Nein                                   | ‚úÖ Integriertes POSIX-Subsystem in NT 3.1‚Äì5.2          |
| **Portabilit√§t des Kernels**          | ‚ùå Nur x86                            | ‚úÖ x86, MIPS, Alpha, PowerPC                         |
| **Treiber**                    | Direkter Hardwarezugriff            | √úber HAL und Kernel-Mode-Treiber                     |
| **Zugriffsebene von Anwendungen**  | Anwendungen = Systemebene          | Benutzer-/Kernel-Ebene getrennt        |
| **Sicherheit**                | ‚ùå Nicht vorhanden                           | ‚úÖ Sicherheitsmodell: SID, ACL, Zugriffstoken     |
| **Stabilit√§t**                | ‚ùå Abh√§ngigkeit eines Programms = Systemabsturz | ‚úÖ Prozessisolation, Kernelschutz                   |

---

Aber es gab ein gro√ües ABER! Den Automatisierungs- und Verwaltungstools wurde bis 2002 keine geb√ºhrende Aufmerksamkeit geschenkt.

---

Microsoft verwendete v√∂llig unterschiedliche Ans√§tze, Strategien und Tools f√ºr die Verwaltung. All dies war **fragmentiert**, oft GUI-orientiert und nicht immer automatisierbar.

---

##### üìå Liste einiger Tools:

| Tool                      | Zweck                                                      |
| ----------------------------- | --------------------------------------------------------------- |
| `cmd.exe`                     | Verbesserter Kommandozeileninterpreter (Ersatz f√ºr `COMMAND.COM`)       |
| `.bat`, `.cmd`                | Kommandozeilen-Skripte                                        |
| **Windows Script Host (WSH)** | Unterst√ºtzung f√ºr VBScript und JScript zur Automatisierung                  |
| `reg.exe`                     | Registrierungsverwaltung √ºber die Kommandozeile                         |
| `net.exe`                     | Arbeit mit Benutzern, Netzwerk, Druckern                      |
| `sc.exe`                      | Diensteverwaltung                                             |
| `tasklist`, `taskkill`        | Prozessverwaltung                                           |
| `gpedit.msc`                  | Gruppenrichtlinien (lokal)                                   |
| `MMC`                         | Konsole mit Snap-Ins zur Verwaltung                            |
| `WMI`                         | Zugriff auf Systeminformationen (√ºber `wmic`, VBScript oder COM) |
| `WbemTest.exe`                | GUI zum Testen von WMI-Abfragen                               |
| `eventvwr`                    | Ereignisprotokollanzeige                                       |
| `perfmon`                     | Ressourcen√ºberwachung                                             |

##### üõ† Beispiele f√ºr Automatisierung:

* VBScript-Dateien (`*.vbs`) zur Verwaltung von Benutzern, Netzwerken, Druckern und Diensten.
* `WMIC` ‚Äî Kommandozeilen-Schnittstelle zu WMI (z.B.: `wmic process list brief`).
* `.cmd`-Skripte mit Aufrufen von `net`, `sc`, `reg`, `wmic` usw.

---

### ‚öôÔ∏è Windows Scripting Host (WSH)

* Erschien erstmals in **Windows 98**, wurde aktiv in **Windows 2000 und XP** verwendet.
* Erm√∂glichte die Ausf√ºhrung von VBScript- und JScript-Dateien √ºber die Kommandozeile:

  ```vbscript
  Set objShell = WScript.CreateObject("WScript.Shell")
  objShell.Run "notepad.exe"
  ```

---
## Teil 1.

Erst im Jahr 2002 formulierte das Unternehmen das Projekt <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>,
das sp√§ter zu PowerShell wurde:

Beginn der Entwicklung: ungef√§hr im Jahr 2002

√ñffentliche Ank√ºndigung: 2003, als "Monad Shell"

Erste Beta-Versionen: erschienen bis 2005

Endg√ºltige Ver√∂ffentlichung (PowerShell 1.0): November 2006

Autor und Hauptarchitekt des Projekts Monad / PowerShell ist Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a>

Heute l√§uft PowerShell Core auf
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a>

Parallel dazu wurde das .NET-Framework entwickelt, und PowerShell war tief darin integriert. In den folgenden Kapiteln werde ich Beispiele zeigen.

Und nun ‚Äì das Wichtigste!

Der Hauptvorteil von PowerShell gegen√ºber klassischen Kommandozeilen-Shells ist, dass es mit *Objekten* und nicht mit Text arbeitet. Wenn Sie einen Befehl ausf√ºhren, gibt er Ihnen nicht nur Text zur√ºck, sondern ein strukturiertes Objekt (oder eine Sammlung von Objekten) mit klar definierten Eigenschaften (Properties) und Methoden (Methods).

Sehen Sie, wie PowerShell klassische Shells dank der **Arbeit mit Objekten** √ºbertrifft.

### üìÅ Wie es war: `dir` und manuelles Parsen

In **CMD** (sowohl im alten `COMMAND.COM` als auch in `cmd.exe`) gibt der Befehl `dir` das Ergebnis als einfachen Text zur√ºck. Beispielausgabe:

```
24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
```

Angenommen, Sie m√∂chten den **Dateinamen** und die **Gr√∂√üe** jeder Datei extrahieren. Sie m√ºssten die Zeilen manuell parsen:
```cmd
for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
```

* Das ist furchtbar schwer zu lesen, h√§ngt von der Locale, dem Datumsformat und der Schriftart ab. Und es bricht bei Leerzeichen in Namen.

---

### ‚úÖ PowerShell: Objekte statt Text

#### ‚úî Einfaches und lesbares Beispiel:

```powershell
Get-ChildItem | Select-Object Name, Length
```

**Ergebnis:**

```
Name          Length
----          ------
my_script.js   1428
report.html    3980
```

* `Get-ChildItem` gibt ein **Array von Datei-/Ordnerobjekten** zur√ºck
* `Select-Object` erm√∂glicht das einfache Abrufen der gew√ºnschten **Eigenschaften**

---

### üîç Was gibt `Get-ChildItem` wirklich zur√ºck?

```powershell
$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
```

**Ergebnis:**

```
TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
```

PowerShell gibt **Objekte vom Typ `System.IO.FileInfo`** zur√ºck, die Folgendes haben:

* üß± Eigenschaften (`Name`, `Length`, `CreationTime`, `Extension`, ‚Ä¶)
* üõ† Methoden (`Delete()`, `CopyTo()`, `MoveTo()` usw.)

Sie arbeiten **mit vollwertigen Objekten**, nicht mit Zeichenfolgen.

---

### Syntax "Verb-Nomen":

PowerShell verwendet eine **strenge und logische Befehlssyntax**:
`Verb-Nomen` (Verb-Noun)

| Verb    | Was es tut |
| --------- | ---------- |
| `Get-`    | Abrufen   |
| `Set-`    | Festlegen |
| `New-`    | Erstellen    |
| `Remove-` | Entfernen    |
| `Start-`  | Starten  |
| `Stop-`   | Stoppen |

| Nomen | Woran es arbeitet |
| --------------- | ---------------- |
| `Process`       | Prozess          |
| `Service`       | Dienst           |
| `Item`          | Datei/Ordner       |
| `EventLog`      | Ereignisprotokoll  |
| `Computer`      | Computer        |

#### üîÑ Beispiele:

| Was zu tun ist         | Befehl         |
| ------------------------- | --------------- |
| Prozesse abrufen         | `Get-Process`   |
| Dienst stoppen         | `Stop-Service`  |
| Neue Datei erstellen        | `New-Item`      |
| Ordnerinhalt abrufen | `Get-ChildItem` |
| Datei l√∂schen              | `Remove-Item`   |

‚û° Selbst wenn Sie die **genaue Befehls nicht kennen**, k√∂nnen Sie sie **erraten** ‚Äì und fast immer richtig liegen.

---

Das Cmdlet `Get-Help` ist Ihr wichtigster Helfer.

1.  **Holen Sie sich Hilfe zur Hilfe selbst:**
    ```powershell
    Get-Help Get-Help
    ```
2.  **Holen Sie sich grundlegende Hilfe zu einem Befehl f√ºr die Prozessverwaltung:**
    ```powershell
    Get-Help Get-Process
    ```
3.  **Sehen Sie sich Beispiele f√ºr die Verwendung dieses Befehls an:**
    ```powershell
    Get-Help Get-Process -Examples
    ```
    Dies ist ein unglaublich n√ºtzlicher Parameter, der oft fertige L√∂sungen f√ºr Ihre Aufgaben liefert.
4.  **Holen Sie sich die maximal detaillierten Informationen zu einem Befehl:**
    ```powershell
    Get-Help Get-Process -Full
    ```
Im n√§chsten Teil: Pipeline oder Befehlskette (PipeLines)