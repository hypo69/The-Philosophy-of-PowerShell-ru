{
  "post_title": "[:en]PowerShell Philosophy. Part 2: Pipeline, Variables, Get-Member, .ps1 Files, and Exporting Results[:]",
  "post_status": "publish",
  "post_author": 1,
  "_seo_description": "[:en]Explore the core concepts of PowerShell Part 2: mastering the pipeline, variables, Get-Member for object inspection, creating .ps1 scripts, and exporting results in various formats like CSV, HTML, and JSON. Learn how to automate system tasks efficiently.[:]",
  "_seo_keywords": "[:en]PowerShell, Pipeline, Get-Member, Variables, PS1 scripts, Export-Csv, ConvertTo-Html, ConvertTo-Json, PowerShell 7, object-oriented scripting, system automation[:]",
  "post_content": "[:en]<!-- wp:paragraph -->\n<p><strong>❗ Important:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>I am writing about PS7 (PowerShell 7). It differs from PS5 (PowerShell 5). Starting from the seventh version, PowerShell became cross-platform. Because of this, the behavior of some commands changed.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In the first part, we established a key principle: PowerShell works with <strong>objects</strong>, not text. This post is dedicated to some important PowerShell tools: we will learn how to pass objects through the <strong>pipeline</strong>, analyze them with <code>Get-Member</code>, save results to <strong>variables</strong>, and automate all of this in <strong>script files (<code>.ps1</code>)</strong> with <strong>exporting</strong> results to convenient formats.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3 class=\"wp-block-heading\">1. What is the Pipeline (<code>|</code>)?</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The PowerShell pipeline is a mechanism for passing full-fledged .NET objects (not just text) from one command to another, where each subsequent cmdlet receives structured objects with all their properties and methods.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The <code>|</code> (vertical bar) symbol is the pipeline operator. Its task is to take the result (output) of the command on its left and pass it as input to the command on its right.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><code>Command 1 (creates objects)</code> → <code>|</code> → <code>Command 2 (receives and processes objects)</code> → <code>|</code> → <code>Command 3 (receives processed objects)</code> → <code>|</code> ...</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Classic UNIX-Pipeline: Text Stream</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In <code>bash</code>, the pipeline passes a <strong>byte stream</strong>, which is usually interpreted as text.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-bash\"># Find all 'nginx' processes and count them\nps -ef | grep 'nginx' | wc -l\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>Here, <code>ps</code> outputs text, <code>grep</code> filters this text, and <code>wc</code> counts lines. Each utility knows nothing about \"processes\"; it only works with strings.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">PowerShell-Pipeline: Object Stream</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong>Example:</strong> Let's get all processes, sort them by CPU usage, and select the 5 most \"resource-intensive\" ones.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/1.png\" alt=\"PowerShell pipeline example 1\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Here, <code>Get-Process</code> creates <strong>process objects</strong>. <code>Sort-Object</code> receives these <strong>objects</strong> and sorts them by the <code>CPU</code> property. <code>Select-Object</code> receives the sorted <strong>objects</strong> and selects the first 5.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>You've probably noticed words in the command starting with a hyphen (-): <code>-Property</code>, <code>-Descending</code>, <code>-First</code>. These are parameters.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Parameters are settings, switches, and instructions for a cmdlet. They allow you to control <strong>HOW</strong> a command performs its work. Without parameters, the command operates in default mode; with parameters, you provide specific instructions.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Main types of parameters:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Parameter with a value: requires additional information.\n<ul><!-- wp:list-item -->\n<li><code>-Property CPU</code>: We tell <code>Sort-Object</code> which property to sort by. <code>CPU</code> is the parameter value.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><code>-First 5</code>: We tell <code>Select-Object</code> how many objects to select. <code>5</code> is the parameter value.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Switch parameter (flag): Does not require a value. Its mere presence in the command enables or disables specific behavior.\n<ul><!-- wp:list-item -->\n<li><code>-Descending</code>: This flag tells <code>Sort-Object</code> to reverse the sort order (from greatest to least). It doesn't need an additional value — it's an instruction in itself.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Get-Process -Name 'svchost' | Measure-Object\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/2.png\" alt=\"Measure-Object example\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This command answers a very simple question:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>\"Exactly how many processes named <code>svchost.exe</code> are currently running on my system?\"</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Step-by-Step Breakdown</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\"><strong>Step 1: <code>Get-Process -Name 'svchost'</code></strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>This part of the command queries the operating system and requests <strong>all</strong> running processes whose executable name is <code>svchost.exe</code>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Unlike processes like <code>notepad</code> (of which there are usually one or two), there are always <strong>many</strong> <code>svchost</code> processes in the system. The command will return an <strong>array (collection) of objects</strong>, where each object is a separate, full-fledged <code>svchost</code> process with its unique ID, memory usage, etc.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>PowerShell found, for example, 90 <code>svchost</code> processes in the system and now holds a collection of 90 objects.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\"><strong>Step 2: <code>|</code> (Pipeline Operator)</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>This symbol takes the collection of 90 <code>svchost</code> objects obtained in the first step and begins passing them <strong>one by one</strong> as input to the next command.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\"><strong>Step 3: <code>Measure-Object</code></strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Since we called <code>Measure-Object</code> without parameters (such as <code>-Property</code>, <code>-Sum</code>, etc.), it performs its <strong>default</strong> operation — simply counting the number of \"items\" passed to it.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>One, two, three... After all objects are counted, <code>Measure-Object</code> creates <strong>its own result object</strong>, which has a <code>Count</code> property equal to the final number.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><code>Count: 90</code></strong> — this is the answer to our question. 90 <code>svchost</code> processes are running.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The other fields are empty because we did not ask <code>Measure-Object</code> to perform more complex calculations.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Example with <code>svchost</code> and Parameters</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let's change our task. Now we want not just to count <code>svchost</code> processes, but to find out <strong>how much total RAM (in megabytes) they consume together</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><code>-Property WorkingSet64</code>: This instruction tells <code>Measure-Object</code>: \"From each <code>svchost</code> object that comes to you, take the numerical value from the property <code>WorkingSet64</code> (this is memory usage in bytes).\"</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><code>-Sum</code>: This flag instruction says: \"Add up all these values that you took from the property <code>WorkingSet64</code>.\"</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Our new command will look like this:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/3.png\" alt=\"Measure-Object with parameters example\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><!-- wp:list-item -->\n<li><code>Get-Process</code> will find the number of <code>svchost</code> objects.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>The pipeline <code>|</code> will pass them to <code>Measure-Object</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>But now <code>Measure-Object</code> works differently:\n<ul><!-- wp:list-item -->\n<li>It takes the first <code>svchost</code> object, looks at its <code>.WorkingSet64</code> property (e.g., <code>25000000</code> bytes), and remembers this number.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>It takes the second object, looks at its <code>.WorkingSet64</code> (e.g., <code>15000000</code> bytes), and adds it to the previous one.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>...and so on for all objects.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Ultimately, <code>Measure-Object</code> will create a result object, but it will be different this time.</li>\n<!-- /wp:list-item --></ol>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong><code>Count: 92</code></strong>: Number of objects.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Sum: 1661890560</code></strong>: This is the total sum of all <code>WorkingSet64</code> values in bytes.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Property: WorkingSet64</code></strong>: This field is now also populated, informing us which specific property was used for the calculations.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3 class=\"wp-block-heading\">2. Variables (Regular and the Special <code>$_</code>)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>A variable is a named storage location in memory that holds a value.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This value can be anything: text, a number, a date, or, most importantly for PowerShell, an entire object or even a collection of objects. A variable name in PowerShell always begins with a dollar sign (<code>$</code>).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Examples: <code>$name</code>, <code>$counter</code>, <code>$processList</code>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The special variable <code>$_</code>?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><code>$_</code> is short for \"current object\" or \"this thing\".</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Imagine a conveyor belt in a factory. Different parts (objects) travel along it.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><code>$_</code> is the very part that is currently in front of you (or in front of a processing robot).</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>The source (<code>Get-Process</code>) — dumps a whole box of parts (all processes) onto the conveyor.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>The conveyor (<code>|</code>) — makes these parts move along the belt one by one.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>The handler (<code>Where-Object</code> or <code>ForEach-Object</code>) — is a robot that looks at each part.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>The variable <code>$_</code> — is that very part that is currently in the robot's \"hands\".</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>When the robot finishes with one part, the conveyor feeds it the next, and <code>$_</code> will now point to it.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Let's calculate how much total memory <code>svchost</code> processes use and display the result on the monitor.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\"># 1. Execute the command and save its complex result object to the $svchostMemory variable\n$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum\n\n# 2. Now we can work with the saved object. Extract the Sum property from it\n$memoryInMB = $svchostMemory.Sum / 1MB\n\n# 3. Display the result on the screen using the new variable\nWrite-Host \"All svchost processes use $memoryInMB MB of memory.\"\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/4.png\" alt=\"svchost memory usage example\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><code>Write-Host</code> — is a specialized cmdlet whose sole task is to <strong>display text directly to the user in the console</strong>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>String in double quotes: <code>\"...\"</code> - a text string that we pass to the <code>Write-Host</code> cmdlet as an argument. Why double instead of single quotes?<br>In PowerShell, there are two types of quotes:\n<ul><!-- wp:list-item -->\n<li><strong>Single (<code>'...'</code>):</strong> Create a <strong>literal string</strong>. Everything inside them is treated as plain text, without exceptions.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Double (<code>\"...\"</code>):</strong> Create an <strong>expandable (or substitutable) string</strong>. PowerShell \"scans\" such a string for variables (starting with <code>$</code>) and substitutes their values in their place.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><code>$memoryInMB</code>. This is a variable where we <strong>in the previous step</strong> of our script stored the calculation result. When <code>Write-Host</code> receives a string in double quotes, a process called <strong>\"String Expansion\"</strong> occurs:\n<ol><!-- wp:list-item -->\n<li>PowerShell sees the text <code>\"All svchost processes use \"</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Then it encounters the construct <code>$memoryInMB</code>. It understands that this is not just text but a variable.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>It looks into memory, finds the value stored in <code>$memoryInMB</code> (e.g., <code>1585.52</code>).</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>It <strong>substitutes this value</strong> directly into the string.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Then it adds the remaining part of the text: <code>\" MB of memory.\"</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>As a result, the ready, assembled string is passed to <code>Write-Host</code>: <code>\"All svchost processes use 1585.52 MB of memory.\"</code>.</li>\n<!-- /wp:list-item --></ol>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Launch Notepad:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><!-- wp:list-item -->\n<li>Find the Notepad process and save it to the <code>$notepadProcess</code> variable\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">$notepadProcess = Get-Process -Name notepad\n</code></pre>\n<!-- /wp:code -->\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Access the 'Id' property of this object using dot notation and display it\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Write-Host \"ID of the 'Notepad' process is: $($notepadProcess.Id)\"\n</code></pre>\n<!-- /wp:code -->\n</li>\n<!-- /wp:list-item --></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/5.png\" alt=\"Notepad process ID example\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>❗ Important:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><code>Write-Host</code> \"breaks\" the pipeline. Text output by it cannot be passed further down the pipeline for processing. It is intended only for display.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3 class=\"wp-block-heading\">3. Get-Member (Object Inspector)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We know that objects \"flow\" through the pipeline. But how do we know what they consist of? What properties do they have, and what actions (methods) can be performed with them?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The cmdlet <strong><code>Get-Member</code></strong> (alias: <code>gm</code>) is the primary tool for investigation. Before working with an object, pass it through <code>Get-Member</code> to see all its capabilities.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let's analyze the objects created by <code>Get-Process</code>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Get-Process | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/6.png\" alt=\"Get-Member output for Get-Process\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><em>Let's break down each part of the Get-Member output.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><code>TypeName: System.Diagnostics.Process</code> - This is the full, official \".NET type name\" of the object from the .NET library. It's its \"passport\".</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This line tells you that all objects returned by <code>Get-Process</code> are of type <code>System.Diagnostics.Process</code>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This ensures that they all have the same set of properties and methods.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>You can <a href=\"https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com\">Google</a> \"System.Diagnostics.Process\" to find official Microsoft documentation with even more detailed information.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Column 1: <code>Name</code><br>This is the simple, human-readable <strong>name</strong> of a property, method, or other \"member\" of the object. This is the name you will use in your code to access data or perform actions.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Column 2: <code>MemberType</code> (Object Type)<br>This is the most important column for understanding. It classifies <strong>what</strong> each object is. It's its \"role,\" which tells you <strong>HOW</strong> to use it.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong><code>Property</code>:</strong> <strong>characteristic</strong> or <strong>piece of data</strong> stored within an object. You can \"read\" its value.\n<ul><!-- wp:list-item -->\n<li><em>Examples in the screenshot:</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. These are simply data that can be viewed.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Method</code>:</strong> <strong>ACTION</strong> that can be performed with an object. Methods are always called with parentheses <code>()</code>.\n<ul><!-- wp:list-item -->\n<li><em>Examples in the screenshot:</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. You would write <code>$process.Kill()</code> or <code>$process.Refresh()</code>.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>AliasProperty</code>:</strong> a <strong>friendly alias</strong> for another, longer property. PowerShell adds them for convenience and brevity.\n<ul><!-- wp:list-item -->\n<li><em>Examples in the screenshot:</em> <code>WS</code> is a short alias for <code>WorkingSet64</code>. <code>Name</code> is for <code>ProcessName</code>. <code>VM</code> is for <code>VirtualMemorySize64</code>.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Event</code>:</strong> <strong>NOTIFICATION</strong> that something has occurred, which you can \"subscribe\" to.\n<ul><!-- wp:list-item -->\n<li><em>Example in the screenshot:</em> <code>Exited</code>. Your script can \"listen\" to this event to perform an action immediately after the process exits.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>CodeProperty</code> and <code>NoteProperty</code>:</strong> special types of properties, often added by PowerShell itself for convenience. <code>CodeProperty</code> calculates its value \"on the fly\", while <code>NoteProperty</code> is a simple note property added to the object.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Column 3: <code>Definition</code><br>This is the <strong>technical definition</strong> or \"signature\" of the member. It gives you precise details for its use. Its content depends on the <code>MemberType</code>:</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong>For <code>AliasProperty</code>:</strong> Shows <strong>what the alias is equivalent to</strong>. This is incredibly useful!\n<ul><!-- wp:list-item -->\n<li><em>Example in the screenshot:</em> <code>WS = WorkingSet64</code>. You immediately see that <code>WS</code> is just a shorthand for <code>WorkingSet64</code>.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>For <code>Property</code>:</strong> Shows the <strong>data type</strong> stored in the property (e.g., <code>int</code> for integer, <code>string</code> for text, <code>datetime</code> for date and time), and what can be done with it (<code>{get;}</code> — read-only, <code>{get;set;}</code> — read and modify).\n<ul><!-- wp:list-item -->\n<li><em>Example in the screenshot:</em> <code>int BasePriority {get;}</code>. This is an integer property that can only be read.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>For <code>Method</code>:</strong> Shows what the method returns (e.g., <code>void</code> — nothing, <code>bool</code> — true/false) and what <strong>parameters</strong> (input data) it accepts in parentheses.\n<ul><!-- wp:list-item -->\n<li><em>Example in the screenshot:</em> <code>void Kill()</code>. This means that the <code>Kill</code> method returns nothing and can be called without parameters. There is also a second version <code>void Kill(bool entireProcessTree)</code>, which takes a boolean value (true/false).</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">In Table Form</h4>\n<!-- /wp:heading -->\n\n<!-- wp:table {\"hasBorders\":true,\"className\":\"is-style-stripes\"} -->\n<figure class=\"wp-block-table is-style-stripes\"><table><thead class=\"has-text-align-left\"><tr><th>Column</th><th>What is it?</th><th>Example from screenshot</th><th>For what purpose?</th></tr></thead><tbody><tr><td><strong>Name</strong></td><td>The name you use in code.</td><td><code>Kill</code>, <code>WS</code>, <code>Name</code></td><td>to access a property or method (<code>$process.WS</code>, <code>$process.Kill()</code>).</td></tr><tr><td><strong>MemberType</strong></td><td>Type of member (data, action, etc.).</td><td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td><td><strong>how</strong> to use it (read value or call with <code>()</code>).</td></tr><tr><td><strong>Definition</strong></td><td>Technical details.</td><td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td><td>what is behind the alias and what parameters the method needs.</td></tr></tbody></table></figure>\n<!-- /wp:table -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Example: Working with Process Windows</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">1. Problem:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>\"I have opened many Notepad windows. How can I programmatically minimize all but the main one, and then close only those whose title contains the word 'Untitled'?\"</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">2. Research with <code>Get-Member</code>:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We need to find properties related to the window and its title.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Get-Process -Name notepad | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/7.png\" alt=\"Get-Member output for Notepad\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Analysis of <code>Get-Member</code> result:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Scrolling through properties, we find <code>MainWindowTitle</code>. Type <code>string</code>. Excellent, this is the main window title!</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Among the methods, we see <code>CloseMainWindow()</code>. This is a \"softer\" way to close a window than <code>Kill()</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Also in the methods is <code>WaitForInputIdle()</code>. Sounds interesting; perhaps this can help wait until the process is ready for interaction.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><code>Get-Member</code> showed us the <code>MainWindowTitle</code> property, which is key to solving the task and allows interaction with processes based on their window state, not just by name.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">3. Solution:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Now we can build logic based on the window title.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\"># 1. Find all Notepad processes\n$notepads = Get-Process -Name notepad\n\n# 2. Iterate through each and check the title\nforeach ($pad in $notepads) {\n    # For each process ($pad), check its MainWindowTitle property\n    if ($pad.MainWindowTitle -like '*Untitled*') {\n        Write-Host \"Found unsaved Notepad (ID: $($pad.Id)). Closing its window...\"\n        # $pad.CloseMainWindow() # Uncomment to actually close\n        Write-Host \"Window '$($pad.MainWindowTitle)' would have been closed.\" -ForegroundColor Yellow\n    } else {\n        Write-Host \"Skipping Notepad with title: $($pad.MainWindowTitle)\"\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/8.png\" alt=\"Notepad window closing example 1\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/9.png\" alt=\"Notepad window closing example 2\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Example: Find Parent Process</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">1. Problem:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>\"Sometimes I see many child <code>chrome.exe</code> processes in the system. How can I find out which one is the main, 'parent' process that launched all of them?\"</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">2. Research with <code>Get-Member</code>:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We need to find something that links one process to another.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Get-Process -Name chrome | Select-Object -First 1 | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/10.png\" alt=\"Get-Member output for Chrome\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Analysis of <code>Get-Member</code> result:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Carefully reviewing the list, we find a <code>CodeProperty</code> type property named <code>Parent</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Its definition (<code>Definition</code>) is <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>.<br>This is a calculated property that, when accessed, returns the <strong>parent process object</strong>.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">3. Solution:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Now we can write a script that will output information about each <code>chrome</code> process and its parent.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\"># 1. Get all chrome processes\n$chromeProcesses = Get-Process -Name chrome\n\n# 2. For each of them, output information about it and its parent\n$chromeProcesses | Select-Object -First 5 | ForEach-Object {\n    # Get the parent process\n    $parent = $_.Parent\n    \n    # Format the output nicely\n    Write-Host \"Process:\" -ForegroundColor Green\n    Write-Host \"  - Name: $($_.ProcessName), ID: $($_.Id)\"\n    Write-Host \"Its parent:\" -ForegroundColor Yellow\n    Write-Host \"  - Name: $($parent.ProcessName), ID: $($parent.Id)\"\n    Write-Host \"-----------------------------\"\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/11.png\" alt=\"Chrome parent processes example 1\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/12.png\" alt=\"Chrome parent processes example 2\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We immediately see that processes with IDs 4756, 7936, 8268, and 9752 were launched by process ID 14908. We can also note an interesting case with process ID 7252, for which the parent process was not defined (possibly the parent had already exited by the time of checking). Modifying the script with an <code>if ($parent)</code> check gracefully handles this case, without causing an error.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><code>Get-Member</code> helped us discover the \"hidden\" <code>Parent</code> property, which provides powerful capabilities for analyzing process hierarchy.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3 class=\"wp-block-heading\">4. <code>.ps1</code> Files (Script Creation)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>When your chain of commands becomes useful, you will want to save it for repeated use. This is where <strong>scripts</strong> come in — text files with the <strong><code>.ps1</code></strong> extension.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">Script Execution Policy</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>By default, local script execution is disabled in Windows. To fix this <strong>for the current user</strong>, run the following command once in PowerShell <strong>as an administrator</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>This is a safe setting that allows you to run your own scripts and scripts signed by a trusted publisher.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">Example Script <code>system_monitor.ps1</code></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Create a file with this name and insert the code below into it. This script collects system information and generates reports.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\"># system_monitor.ps1\n#requires -Version 5.1\n\n&lt;#\n.SYNOPSIS\n    Script for creating a system status report.\n.DESCRIPTION\n    Collects information about processes, services, and disk space and generates reports.\n.PARAMETER OutputPath\n    Path for saving reports. Defaults to 'C:\\Temp'.\n.EXAMPLE\n    .\\system_monitor.ps1 -OutputPath \"C:\\Reports\"\n#&gt;\nparam(\n    &#91;Parameter(Mandatory=$false)]\n    &#91;string]$OutputPath = \"C:\\Temp\"\n)\n\n# --- Block 1: Preparation ---\nWrite-Host \"Preparing to create report...\" -ForegroundColor Cyan\nif (!(Test-Path $OutputPath)) {\n    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null\n}\n\n# --- Block 2: Data Collection ---\nWrite-Host \"Collecting information...\" -ForegroundColor Green\n$processes = Get-Process | Sort-Object CPU -Descending\n$services = Get-Service | Group-Object Status | Select-Object Name, Count\n\n# --- Block 3: Call export function (see next section) ---\nExport-Results -Processes $processes -Services $services -OutputPath $OutputPath\n\nWrite-Host \"Reports successfully saved to $OutputPath\" -ForegroundColor Magenta\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><em>Note: The <code>Export-Results</code> function will be defined in the next section as an example of good practice.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">5. Exporting Results</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Raw data is good, but often it needs to be presented in a format convenient for humans or other programs. PowerShell offers many cmdlets for exporting.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:table {\"hasBorders\":true,\"className\":\"is-style-stripes\"} -->\n<figure class=\"wp-block-table is-style-stripes\"><table><thead class=\"has-text-align-left\"><tr><th>Method</th><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><strong>Plain Text</strong></td><td><code>... | Out-File C:\\Temp\\data.txt</code></td><td>Redirects the text representation to a file.</td></tr><tr><td><strong>CSV (for Excel)</strong></td><td><code>... | Export-Csv C:\\Temp\\data.csv -NoTypeInfo</code></td><td>Exports objects to CSV. <code>-NoTypeInfo</code> removes the service first line.</td></tr><tr><td><strong>HTML Report</strong></td><td><code>... | ConvertTo-Html -Title \"Report\"</code></td><td>Creates HTML code from objects.</td></tr><tr><td><strong>JSON (for API, web)</strong></td><td><code>... | ConvertTo-Json</code></td><td>Converts objects to JSON format.</td></tr><tr><td><strong>XML (native PowerShell format)</strong></td><td><code>... | Export-Clixml C:\\Temp\\data.xml</code></td><td>Saves objects with all data types. They can be perfectly restored via <code>Import-Clixml</code>.</td></tr></tbody></table></figure>\n<!-- /wp:table -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">Supplement to the script: export function</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let's add a function to our <code>system_monitor.ps1</code> script that will handle exporting. Place this code <strong>before</strong> the <code>Export-Results</code> call.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"line-numbers\"><code class=\"language-powershell\">function Export-Results {\n    param(\n        $Processes,\n        $Services,\n        $OutputPath\n    )\n\n    $timestamp = Get-Date -Format \"yyyy-MM-dd_HH-mm\"\n\n    # Export to CSV\n    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath \"processes_$timestamp.csv\") -NoTypeInformation\n    $Services | Export-Csv (Join-Path $OutputPath \"services_$timestamp.csv\") -NoTypeInformation\n\n    # Create a nice HTML report\n    $htmlReportPath = Join-Path $OutputPath \"report_$timestamp.html\"\n    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent \"&lt;h2&gt;Top 10 Processes by CPU&lt;/h2&gt;\"\n    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent \"&lt;h2&gt;Service Statistics&lt;/h2&gt;\"\n\n    ConvertTo-Html -Head \"&lt;title&gt;System Report&lt;/title&gt;\" -Body \"&lt;h1&gt;System Report from $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)\" | Out-File $htmlReportPath\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>Now our script not only collects data but also carefully saves it in two formats: CSV for analysis and HTML for quick viewing.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Conclusion</h4>\n<!-- /wp:heading -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><!-- wp:list-item -->\n<li><strong>Pipeline (<code>|</code>)</strong> — the main tool for combining commands and processing objects.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Get-Member</code></strong> — object analysis, showing what they consist of.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Variables (<code>$var</code>, <code>$_</code>)</strong> allow saving data and referring to the current object in the pipeline.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>.ps1</code> files</strong> turn commands into reusable automation tools.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Export cmdlets</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) Export data in the corresponding format.</li>\n<!-- /wp:list-item --></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>In the next part, we will apply this knowledge to navigate and manage the file system, exploring <code>System.IO.DirectoryInfo</code> and <code>System.IO.FileInfo</code> objects.</strong></p>\n<!-- /wp:paragraph -->[:]"\n}
{
  "post_title": "[:fr]Philosophie PowerShell. Partie 2 : Le pipeline, les variables, Get-Member, le fichier *.ps1 et l'exportation des résultats[:]",
  "post_name": "philosophie-powershell-partie-2-pipeline-variables-get-member-fichier-ps1-exportation-resultats",
  "post_content": "[:fr]<!-- wp:paragraph -->\n<p><strong>❗ Important :</strong> Je parle de PS7 (PowerShell 7). Il diffère de PS5 (PowerShell 5). À partir de la septième version, PowerShell est devenu multiplateforme, ce qui a modifié le comportement de certaines commandes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Dans la première partie, nous avons établi un principe clé : PowerShell fonctionne avec des <strong>objets</strong>, et non pas avec du texte. Cet article est consacré à des outils PowerShell importants : nous allons apprendre à passer des objets via le <strong>pipeline</strong>, à les analyser avec <code>Get-Member</code>, à sauvegarder les résultats dans des <strong>variables</strong> et à automatiser tout cela dans des <strong>fichiers de script (<code>.ps1</code>)</strong> avec <strong>exportation</strong> des résultats dans des formats pratiques.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":3} -->\n<h3 class=\"wp-block-heading\">1. Qu'est-ce que le pipeline (<code>|</code>) ?</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Le pipeline dans PowerShell est un mécanisme de transfert d'objets .NET complets (et non pas seulement de texte) d'une commande à l'autre, où chaque cmdlet suivant reçoit des objets structurés avec toutes leurs propriétés et méthodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Le symbole <code>|</code> (barre verticale) est l'opérateur de pipeline. Sa tâche est de prendre le résultat (la sortie) de la commande située à sa gauche et de le transmettre en entrée à la commande située à sa droite.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><code>Commande 1 (crée des objets)</code> → <code>|</code> → <code>Commande 2 (reçoit et traite des objets)</code> → <code>|</code> → <code>Commande 3 (reçoit des objets traités)</code> → | ...</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">Pipeline UNIX classique : Flux de texte</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Dans <code>bash</code>, le pipeline transmet un <strong>flux d'octets</strong>, qui est généralement interprété comme du texte.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># Trouver tous les processus 'nginx' et compter leur nombre\nps -ef | grep 'nginx' | wc -l\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>Ici, <code>ps</code> affiche du texte, <code>grep</code> filtre ce texte, et <code>wc</code> compte les lignes. Chaque utilitaire ne sait rien des « processus », il ne fonctionne qu'avec des chaînes de caractères.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">Pipeline PowerShell : Flux d'objets</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong>Exemple :</strong> Obtenons tous les processus, trions-les par utilisation du CPU et sélectionnons les 5 les plus gourmands.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/1.png\" alt=\"Exemple de pipeline PowerShell\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Ici, <code>Get-Process</code> crée des <strong>objets</strong> processus. <code>Sort-Object</code> reçoit ces <strong>objets</strong> et les trie par la propriété <code>CPU</code>. <code>Select-Object</code> reçoit les <strong>objets</strong> triés et sélectionne les 5 premiers.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Vous avez sûrement remarqué des mots commençant par un tiret (-) dans la commande : <code>-Property</code>, <code>-Descending</code>, <code>-First</code>. Ce sont des paramètres. Les paramètres sont des réglages, des commutateurs et des instructions pour un cmdlet. Ils permettent de contrôler <strong>COMMENT</strong> la commande exécutera sa tâche. Sans paramètres, la commande fonctionne en mode par défaut, tandis qu'avec des paramètres, vous lui donnez des instructions spécifiques.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Principaux types de paramètres :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Paramètre avec valeur : nécessite des informations supplémentaires.\n<ul><!-- wp:list-item -->\n<li><code>-Property CPU</code> : Nous indiquons à <code>Sort-Object</code> par quelle propriété trier. <code>CPU</code> est la valeur du paramètre.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><code>-First 5</code> : Nous indiquons à <code>Select-Object</code> combien d'objets sélectionner. <code>5</code> est la valeur du paramètre.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Paramètre-commutateur (drapeau) : Ne nécessite pas de valeur. Sa seule présence dans la commande active ou désactive un comportement spécifique.\n<ul><!-- wp:list-item -->\n<li><code>-Descending</code> : Ce drapeau indique à <code>Sort-Object</code> de changer l'ordre de tri à l'inverse (du plus grand au plus petit). Il n'a pas besoin de valeur supplémentaire — il est une instruction en soi.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name 'svchost' | Measure-Object\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/2.png\" alt=\"Exemple de Measure-Object\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Cette commande répond à une question très simple : <strong>« Combien de processus nommés <code>svchost.exe</code> sont actuellement en cours d'exécution sur mon système ? »</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">Analyse étape par étape</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\"><strong>Étape 1 : <code>Get-Process -Name 'svchost'</code></strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Cette partie de la commande s'adresse au système d'exploitation et lui demande de trouver <strong>tous, sans exception</strong>, les processus en cours d'exécution dont le nom du fichier exécutable est <code>svchost.exe</code>. Contrairement aux processus de type <code>notepad</code> (dont il n'y en a généralement qu'un ou deux), il y a toujours <strong>beaucoup</strong> de processus <code>svchost</code> dans le système. La commande renverra un <strong>tableau (collection) d'objets</strong>, où chaque objet est un processus <code>svchost</code> distinct et complet avec son ID unique, son utilisation de la mémoire, etc. PowerShell a trouvé dans le système, par exemple, 90 processus <code>svchost</code> et détient maintenant une collection de 90 objets.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\"><strong>Étape 2 : <code>|</code> (Opérateur de pipeline)</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Ce symbole prend la collection de 90 objets <code>svchost</code>, obtenue à la première étape, et commence à les transmettre <strong>un par un</strong> en entrée à la commande suivante.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\"><strong>Étape 3 : <code>Measure-Object</code></strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Étant donné que nous avons appelé <code>Measure-Object</code> sans paramètres (tels que <code>-Property</code>, <code>-Sum</code> et d'autres), il effectue son opération <strong>par défaut</strong> – il compte simplement le nombre d'« éléments » qui lui ont été transmis. Un, deux, trois... Une fois tous les objets comptés, <code>Measure-Object</code> crée <strong>son propre objet-résultat</strong>, qui contient une propriété <code>Count</code> égale au nombre final.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><code>Count: 90</code></strong> – c'est la réponse à notre question. 90 processus <code>svchost</code> sont en cours d'exécution. Les autres champs sont vides car nous n'avons pas demandé à <code>Measure-Object</code> d'effectuer des calculs plus complexes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">Exemple avec <code>svchost</code> et les paramètres</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Changeons notre tâche. Maintenant, nous ne voulons pas simplement compter les processus <code>svchost</code>, mais savoir <strong>combien de mémoire vive (en mégaoctets) ils consomment ensemble</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><code>-Property WorkingSet64</code> : Cette instruction dit à <code>Measure-Object</code> : « De chaque objet <code>svchost</code> qui t'arrive, prends la valeur numérique de la propriété <code>WorkingSet64</code> (c'est l'utilisation de la mémoire en octets) ».</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><code>-Sum</code> : Cette instruction-drapeau dit : « Additionne toutes ces valeurs que tu as prises de la propriété <code>WorkingSet64</code> ».</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Notre nouvelle commande ressemblera à ceci :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/3.png\" alt=\"Measure-Object avec paramètres\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:list {"ordered":true} -->\n<ol><!-- wp:list-item -->\n<li><code>Get-Process</code> trouvera le nombre d'objets <code>svchost</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Le pipeline <code>|</code> les transmettra à <code>Measure-Object</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Mais maintenant, <code>Measure-Object</code> fonctionne différemment :\n<ul><!-- wp:list-item -->\n<li>Il prend le premier objet <code>svchost</code>, examine sa propriété <code>.WorkingSet64</code> (par exemple, <code>25000000</code> octets) et mémorise ce nombre.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Il prend le deuxième objet, examine sa propriété <code>.WorkingSet64</code> (par exemple, <code>15000000</code> octets) et l'ajoute au précédent.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>...et ainsi de suite pour tous les objets.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Finalement, <code>Measure-Object</code> créera un objet-résultat, mais celui-ci sera différent.</li>\n<!-- /wp:list-item --></ol>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong><code>Count: 92</code></strong> : Nombre d'objets.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Sum: 1661890560</code></strong> : C'est la somme totale de toutes les valeurs de <code>WorkingSet64</code> en octets.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Property: WorkingSet64</code></strong> : Ce champ est également rempli maintenant, il nous informe de la propriété exacte utilisée pour les calculs.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {"level":3} -->\n<h3 class=\"wp-block-heading\">2. Variables (ordinaires et spéciales <code>$_</code>)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Une variable est un emplacement nommé en mémoire qui contient une valeur. Cette valeur peut être n'importe quoi : du texte, un nombre, une date ou, ce qui est le plus important pour PowerShell, un objet entier ou même une collection d'objets. Le nom d'une variable dans PowerShell commence toujours par un signe dollar (<span dir=\"ltr\">$</span>). Exemples : <span dir=\"ltr\">$name</span>, <span dir=\"ltr\">$counter</span>, <span dir=\"ltr\">$processList</span>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>La variable spéciale <span dir=\"ltr\">$_</span> ?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><span dir=\"ltr\">$_</span> est l'abréviation de « objet actuel » ou « cette chose-ci ». Imaginez un tapis roulant dans une usine. Différentes pièces (objets) y circulent. <span dir=\"ltr\">$_</span> est la pièce qui se trouve actuellement devant vous (ou devant le robot de traitement). La source (<span dir=\"ltr\"><code>Get-Process</code></span>) déverse une boîte entière de pièces (tous les processus) sur le tapis roulant. Le tapis roulant (<code>|</code>) fait avancer ces pièces une par une. Le processeur (<span dir=\"ltr\"><code>Where-Object</code></span> ou <span dir=\"ltr\"><code>ForEach-Object</code></span>) est un robot qui examine chaque pièce. La variable <span dir=\"ltr\">$_</span> est la pièce qui se trouve actuellement entre les « mains » du robot. Une fois que le robot a fini avec une pièce, le tapis roulant lui en présente une autre, et <span dir=\"ltr\">$_</span> pointera alors vers celle-ci.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Calculons la quantité totale de mémoire utilisée par les processus <code>svchost</code> et affichons le résultat à l'écran.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># 1. Exécutons la commande et sauvegardons son objet-résultat complexe dans la variable $svchostMemory\n$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum\n\n# 2. Nous pouvons maintenant travailler avec l'objet sauvegardé. Nous en extrayons la propriété Sum\n$memoryInMB = $svchostMemory.Sum / 1MB\n\n# 3. Affichons le résultat à l'écran en utilisant la nouvelle variable\nWrite-Host \"Tous les processus svchost utilisent $memoryInMB Mo de mémoire.\"\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/4.png\" alt=\"Exemple de variables et Write-Host\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><code>Write-Host</code> – est un cmdlet spécialisé dont la seule tâche est d'<strong>afficher du texte directement à l'utilisateur dans la console</strong>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Chaîne entre guillemets doubles : <code>\"...\"</code> - une chaîne de texte que nous passons au cmdlet <code>Write-Host</code> comme argument. Pourquoi des guillemets doubles et non des guillemets simples ?\n<ul><!-- wp:list-item -->\n<li><strong>Simples (<code>'...'</code>) :</strong> Créent une <strong>chaîne littérale</strong>. Tout ce qui se trouve à l'intérieur est interprété comme du texte ordinaire, sans exceptions.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Doubles (<code>\"...\"</code>) :</strong> Créent une <strong>chaîne extensible (ou de substitution)</strong>. PowerShell « scanne » une telle chaîne à la recherche de variables (commençant par <span dir=\"ltr\">$</span>) et substitue leurs valeurs à leur place.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><span dir=\"ltr\">$memoryInMB</span>. C'est une variable dans laquelle nous avons placé le résultat des calculs <strong>à l'étape précédente</strong> de notre script. Lorsque <code>Write-Host</code> reçoit une chaîne entre guillemets doubles, un processus appelé <strong>« expansion de chaîne » (String Expansion)</strong> se produit :\n<ol><!-- wp:list-item -->\n<li>PowerShell voit le texte <code>\"Tous les processus svchost utilisent \"</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Ensuite, il rencontre la construction <span dir=\"ltr\">$memoryInMB</span>. Il comprend que ce n'est pas seulement du texte, mais une variable.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Il consulte la mémoire, trouve la valeur stockée dans <span dir=\"ltr\">$memoryInMB</span> (par exemple, <code>1585.52</code>).</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Il <strong>substitue cette valeur</strong> directement dans la chaîne.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Ensuite, il ajoute la partie restante du texte : <code>\" Mo de mémoire.\"</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Au final, la chaîne prête à l'emploi est transmise à <code>Write-Host</code> : <code>\"Tous les processus svchost utilisent 1585.52 Mo de mémoire.\"</code>.</li>\n<!-- /wp:list-item --></ol>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Lancez le Bloc-notes :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {"ordered":true} -->\n<ol><!-- wp:list-item -->\n<li>Trouvons le processus du Bloc-notes et sauvegardons-le dans la variable <span dir=\"ltr\">$notepadProcess</span></li>\n<!-- /wp:list-item --></ol>\n<!-- /wp:list -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>$notepadProcess = Get-Process -Name notepad\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:list {"ordered":true,"start":2} -->\n<ol start=\"2\"><!-- wp:list-item -->\n<li>Accédons à la propriété 'Id' de cet objet via un point et affichons-la</li>\n<!-- /wp:list-item --></ol>\n<!-- /wp:list -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Write-Host \"L'ID du processus 'Bloc-notes' est : $($notepadProcess.Id)\"\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/5.png\" alt=\"ID du processus Bloc-notes\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>❗ Important :</strong> <code>Write-Host</code> « rompt » le pipeline. Le texte qu'il affiche ne peut pas être transmis plus loin dans le pipeline pour traitement. Il est uniquement destiné à l'affichage.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":3} -->\n<h3 class=\"wp-block-heading\">3. Get-Member (Inspecteur d'objets)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Nous savons que des objets « circulent » dans le pipeline. Mais comment savoir de quoi ils sont faits ? Quelles propriétés possèdent-ils et quelles actions (méthodes) peuvent être effectuées avec eux ? Le cmdlet <strong><code>Get-Member</code></strong> (alias : <code>gm</code>) est l'outil principal pour l'exploration. Avant de travailler avec un objet, passez-le via <code>Get-Member</code> pour voir toutes ses capacités.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Analysons les objets créés par <code>Get-Process</code> :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/6.png\" alt=\"Sortie de Get-Member\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>*Décomposons chaque partie de la sortie de <code>Get-Member</code>.*</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><code>TypeName: System.Diagnostics.Process</code> - C'est le « nom de type » complet et officiel de l'objet de la bibliothèque .NET. C'est son « passeport ». Cette ligne vous indique que tous les objets renvoyés par <code>Get-Process</code> sont des objets de type <code>System.Diagnostics.Process</code>. Cela garantit qu'ils auront tous le même ensemble de propriétés et de méthodes. Vous pouvez <a href=\"https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com\">rechercher sur Google</a> « <code>System.Diagnostics.Process</code> » pour trouver la documentation officielle de Microsoft avec des informations encore plus détaillées.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Colonne 1 : <code>Name</code></li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>C'est le <strong>nom</strong> simple et lisible par l'homme d'une propriété, d'une méthode ou d'un autre « membre » de l'objet. C'est ce nom que vous utiliserez dans votre code pour accéder aux données ou effectuer des actions.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Colonne 2 : <code>MemberType</code> (Type d'objet)</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>C'est la colonne la plus importante à comprendre. Elle classifie <strong>ce qu'est</strong> chaque objet. C'est sa « fonction », qui vous dit <strong>COMMENT</strong> l'utiliser.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong><code>Property</code> (Propriété) :</strong> <strong>caractéristique</strong> ou <strong>partie de données</strong> stockée à l'intérieur de l'objet. Vous pouvez « lire » sa valeur.\n<ul><!-- wp:list-item -->\n<li><em>Exemples sur la capture d'écran :</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. Ce sont juste des données que l'on peut consulter.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Method</code> (Méthode) :</strong> <strong>ACTION</strong> qui peut être effectuée sur l'objet. Les méthodes sont toujours appelées avec des parenthèses <code>()</code>.\n<ul><!-- wp:list-item -->\n<li><em>Exemples sur la capture d'écran :</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. Vous écririez <span dir=\"ltr\">$process.Kill()</span> ou <span dir=\"ltr\">$process.Refresh()</span>.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>AliasProperty</code> (Propriété d'alias) :</strong> <strong>alias convivial</strong> pour une autre propriété plus longue. PowerShell les ajoute pour plus de commodité et de concision.\n<ul><!-- wp:list-item -->\n<li><em>Exemples sur la capture d'écran :</em> <code>WS</code> est un alias court pour <code>WorkingSet64</code>. <code>Name</code> – pour <code>ProcessName</code>. <code>VM</code> – pour <code>VirtualMemorySize64</code>.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Event</code> (Événement) :</strong> <strong>NOTIFICATION</strong> qu'un événement s'est produit, auquel on peut « s'abonner ».\n<ul><!-- wp:list-item -->\n<li><em>Exemple sur la capture d'écran :</em> <code>Exited</code>. Votre script peut « écouter » cet événement pour effectuer une action immédiatement après la fin du processus.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>CodeProperty</code> et <code>NoteProperty</code> :</strong> types de propriétés spéciales, souvent ajoutées par PowerShell lui-même pour plus de commodité. <code>CodeProperty</code> calcule sa valeur « à la volée », tandis que <code>NoteProperty</code> est une simple propriété-note ajoutée à l'objet.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Colonne 3 : <code>Definition</code> (Définition)</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>C'est la <strong>définition technique</strong> ou la « signature » du membre. Elle vous donne les détails exacts de son utilisation. Son contenu dépend du <code>MemberType</code> :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong>Pour <code>AliasProperty</code> :</strong> Montre <strong>à quoi l'alias est égal</strong>. C'est incroyablement utile !\n<ul><!-- wp:list-item -->\n<li><em>Exemple sur la capture d'écran :</em> <code>WS = WorkingSet64</code>. Vous voyez immédiatement que <code>WS</code> est simplement une forme abrégée de <code>WorkingSet64</code>.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Pour <code>Property</code> :</strong> Montre le <strong>type de données</strong> stocké dans la propriété (par exemple, <code>int</code> pour un entier, <code>string</code> pour du texte, <code>datetime</code> pour une date et une heure), et ce que l'on peut en faire (<code>{get;}</code> – lecture seule, <code>{get;set;}</code> – lecture et modification).\n<ul><!-- wp:list-item -->\n<li><em>Exemple sur la capture d'écran :</em> <code>int BasePriority {get;}</code>. C'est une propriété entière qui ne peut être que lue.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Pour <code>Method</code> :</strong> Montre ce que la méthode retourne (par exemple, <code>void</code> – rien, <code>bool</code> – vrai/faux) et quels <strong>paramètres</strong> (données d'entrée) elle accepte entre parenthèses.\n<ul><!-- wp:list-item -->\n<li><em>Exemple sur la capture d'écran :</em> <code>void Kill()</code>. Cela signifie que la méthode <code>Kill</code> ne retourne rien et peut être appelée sans paramètres. Il existe également une deuxième version, <code>void Kill(bool entireProcessTree)</code>, qui accepte une valeur booléenne (vrai/faux).</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">En tableau</h4>\n<!-- /wp:heading -->\n\n<!-- wp:table -->\n<figure class=\"wp-block-table\">\n<table><thead><tr><th>Colonne</th><th>Qu'est-ce que c'est ?</th><th>Exemple de la capture d'écran</th><th>Pour quoi faire ?</th></tr></thead><tbody><tr><td><strong>Name</strong></td><td>Le nom que vous utilisez dans le code.</td><td><code>Kill</code>, <code>WS</code>, <code>Name</code></td><td>Accéder à une propriété ou une méthode (<span dir=\"ltr\">$process.WS</span>, <span dir=\"ltr\">$process.Kill()</span>).</td></tr><tr><td><strong>MemberType</strong></td><td>Le type de membre (données, action, etc.).</td><td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td><td><strong>Comment</strong> l'utiliser (lire la valeur ou l'appeler avec <code>()</code>).</td></tr><tr><td><strong>Definition</strong></td><td>Détails techniques.</td><td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td><td>Ce qui se cache derrière l'alias et quels paramètres sont nécessaires à la méthode.</td></tr></tbody></table>\n</figure>\n<!-- /wp:table -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">Exemple : Travailler avec les fenêtres de processus</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">1. Problème :</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>« J'ai ouvert de nombreuses fenêtres du Bloc-notes. Comment puis-je minimiser toutes celles qui ne sont pas la fenêtre principale, puis fermer uniquement celles dont le titre contient le mot 'Sans titre' ? »</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">2. Exploration avec <code>Get-Member</code> :</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Nous devons trouver les propriétés liées à la fenêtre et à son titre.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name notepad | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Analyse du résultat de <code>Get-Member</code> :</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>En parcourant les propriétés, nous trouvons <code>MainWindowTitle</code>. Type <code>string</code>. Excellent, c'est le titre de la fenêtre principale !</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Dans les méthodes, nous voyons <code>CloseMainWindow()</code>. C'est un moyen plus « doux » de fermer une fenêtre que <code>Kill()</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Il y a aussi <code>WaitForInputIdle()</code> dans les méthodes. Cela semble intéressant, cela pourrait aider à attendre que le processus soit prêt pour l'interaction.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/7.png\" alt=\"Get-Member pour Notepad\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><code>Get-Member</code> nous a montré la propriété <code>MainWindowTitle</code>, qui est la clé de la résolution du problème et permet d'interagir avec les processus en fonction de l'état de leurs fenêtres, et non pas seulement de leur nom.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">3. Solution :</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Nous pouvons maintenant construire une logique basée sur le titre de la fenêtre.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># 1. Trouvons tous les processus du Bloc-notes\n$notepads = Get-Process -Name notepad\n\n# 2. Parcourons chacun d'eux et vérifions le titre\nforeach ($pad in $notepads) {\n    # Pour chaque processus ($pad), vérifions sa propriété MainWindowTitle\n    if ($pad.MainWindowTitle -like '*Untitled*') {\n        Write-Host \"Bloc-notes non sauvegardé trouvé (ID : $($pad.Id)). Fermeture de sa fenêtre...\" -ForegroundColor Red\n        # $pad.CloseMainWindow() # Décommenter pour fermer réellement\n        Write-Host \"La fenêtre '$($pad.MainWindowTitle)' aurait été fermée.\" -ForegroundColor Yellow\n    } else {\n        Write-Host \"Ignorons le Bloc-notes avec le titre : $($pad.MainWindowTitle)\" -ForegroundColor Gray\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/8.png\" alt=\"Exemple de script de fermeture de Notepad 1\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/9.png\" alt=\"Exemple de script de fermeture de Notepad 2\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<hr />\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">Exemple : Trouver le processus parent</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">1. Problème :</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>« Parfois, je vois de nombreux processus enfants <code>chrome.exe</code> dans le système. Comment savoir lequel est le processus principal, le processus « parent » qui les a tous lancés ? »</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">2. Exploration avec <code>Get-Member</code> :</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Nous devons trouver quelque chose qui relie un processus à un autre.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name chrome | Select-Object -First 1 | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/10.png\" alt=\"Get-Member pour Chrome\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Analyse du résultat de <code>Get-Member</code> :</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>En parcourant attentivement la liste, nous trouvons une propriété de type <code>CodeProperty</code> nommée <code>Parent</code>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Sa définition (<code>Definition</code>) — <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>. C'est une propriété calculée qui, lorsqu'on y accède, renvoie l'<strong>objet du processus parent</strong>.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">3. Solution :</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Nous pouvons maintenant écrire un script qui affichera des informations sur le processus parent de chaque processus <code>chrome</code>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># 1. Obtenons tous les processus chrome\n$chromeProcesses = Get-Process -Name chrome\n\n# 2. Pour chacun d'eux, affichons des informations sur celui-ci et son parent\n$chromeProcesses | Select-Object -First 5 | ForEach-Object {\n    # Obtenons le processus parent\n    $parent = $_.Parent\n    \n    # Formons une belle sortie\n    Write-Host \"Processus :\" -ForegroundColor Green\n    Write-Host \"  - Nom : $($_.ProcessName), ID : $($_.Id)\"\n    Write-Host \"Son parent :\" -ForegroundColor Yellow\n    Write-Host \"  - Nom : $($parent.ProcessName), ID : $($parent.Id)\"\n    Write-Host \"-----------------------------\"\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/11.png\" alt=\"Exemple de script parent Chrome 1\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"assets/02/12.png\" alt=\"Exemple de script parent Chrome 2\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Nous voyons immédiatement que les processus avec les ID 4756, 7936, 8268 et 9752 ont été lancés par le processus avec l'ID 14908. On peut également noter un cas intéressant avec le processus ID : 7252, pour lequel le processus parent n'a pas été défini (le parent a peut-être déjà terminé avant la vérification). Une modification du script avec une vérification <code>if ($parent)</code> gère ce cas avec élégance, sans provoquer d'erreur. <code>Get-Member</code> nous a aidés à découvrir la propriété « cachée » <code>Parent</code>, qui offre de puissantes capacités pour analyser la hiérarchie des processus.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">4. Fichier <code>*.ps1</code> (Création de scripts)</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Lorsque votre chaîne de commandes devient utile, vous voudrez la sauvegarder pour une utilisation répétée. C'est à cela que servent les <strong>scripts</strong> — des fichiers texte avec l'extension <strong><code>.ps1</code></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">Autorisation d'exécution des scripts</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Par défaut, l'exécution des scripts locaux est interdite sous Windows. Pour y remédier <strong>pour l'utilisateur actuel</strong>, exécutez une seule fois dans PowerShell <strong>en tant qu'administrateur</strong> :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>C'est un paramètre sûr qui permet d'exécuter vos propres scripts et les scripts signés par un éditeur de confiance.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">Exemple de script <code>system_monitor.ps1</code></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Créez un fichier avec ce nom et insérez-y le code ci-dessous. Ce script collecte des informations sur le système et génère des rapports.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># system_monitor.ps1\n#requires -Version 5.1\n\n<#\n.SYNOPSIS\n    Script pour créer un rapport d'état du système.\n.DESCRIPTION\n    Collecte des informations sur les processus, les services et l'espace disque, et génère des rapports.\n.PARAMETER OutputPath\n    Chemin de sauvegarde des rapports. Par défaut : 'C:\\Temp'.\n.EXAMPLE\n    .\\system_monitor.ps1 -OutputPath \"C:\\Reports\"\n#>\nparam(\n    [Parameter(Mandatory=$false)]\n    [string]$OutputPath = \"C:\\Temp\"\n)\n\n# --- Bloc 1 : Préparation ---\nWrite-Host \"Préparation à la création du rapport...\" -ForegroundColor Cyan\nif (!(Test-Path $OutputPath)) {\n    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null\n}\n\n# --- Bloc 2 : Collecte des données ---\nWrite-Host \"Collecte des informations...\" -ForegroundColor Green\n$processes = Get-Process | Sort-Object CPU -Descending\n$services = Get-Service | Group-Object Status | Select-Object Name, Count\n\n# --- Bloc 3 : Appel de la fonction d'exportation (voir section suivante) ---\nExport-Results -Processes $processes -Services $services -OutputPath $OutputPath\n\nWrite-Host \"Les rapports ont été enregistrés avec succès dans le dossier $OutputPath\" -ForegroundColor Magenta\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>*Note : la fonction <code>Export-Results</code> sera définie dans la section suivante comme un exemple de bonne pratique.*</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">5. Exportation des résultats</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Les données brutes sont une bonne chose, mais il est souvent nécessaire de les présenter sous une forme pratique pour les humains ou d'autres programmes. PowerShell offre de nombreux cmdlets pour l'exportation.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:table -->\n<figure class=\"wp-block-table\">\n<table><thead><tr><th>Méthode</th><th>Commande</th><th>Description</th></tr></thead><tbody><tr><td><strong>Texte simple</strong></td><td><code>... | Out-File C:\\Temp\\data.txt</code></td><td>Redirige la représentation textuelle vers un fichier.</td></tr><tr><td><strong>CSV (pour Excel)</strong></td><td><code>... | Export-Csv C:\\Temp\\data.csv -NoTypeInfo</code></td><td>Exporte les objets au format CSV. <code>-NoTypeInfo</code> supprime la première ligne de service.</td></tr><tr><td><strong>Rapport HTML</strong></td><td><code>... | ConvertTo-Html -Title \"Rapport\"</code></td><td>Crée du code HTML à partir d'objets.</td></tr><tr><td><strong>JSON (pour API, web)</strong></td><td><code>... | ConvertTo-Json</code></td><td>Convertit les objets au format JSON.</td></tr><tr><td><strong>XML (format natif PowerShell)</strong></td><td><code>... | Export-Clixml C:\\Temp\\data.xml</code></td><td>Enregistre les objets avec tous les types de données. Ils peuvent être parfaitement restaurés via <code>Import-Clixml</code>.</td></tr></tbody></table>\n</figure>\n<!-- /wp:table -->\n\n<!-- wp:heading {"level":5} -->\n<h5 class=\"wp-block-heading\">Ajout au script : fonction d'exportation</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Ajoutons une fonction à notre script <code>system_monitor.ps1</code> qui gérera l'exportation. Placez ce code <strong>avant</strong> l'appel à <code>Export-Results</code>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>function Export-Results {\n    param(\n        $Processes,\n        $Services,\n        $OutputPath\n    )\n\n    $timestamp = Get-Date -Format \"yyyy-MM-dd_HH-mm\"\n\n    # Exportation vers CSV\n    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath \"processes_$timestamp.csv\") -NoTypeInformation\n    $Services | Export-Csv (Join-Path $OutputPath \"services_$timestamp.csv\") -NoTypeInformation\n\n    # Création d'un beau rapport HTML\n    $htmlReportPath = Join-Path $OutputPath \"report_$timestamp.html\"\n    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent \"<h2>Top 10 des processus par CPU</h2>\"\n    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent \"<h2>Statistiques des services</h2>\"\n\n    ConvertTo-Html -Head \"<title>Rapport système</title>\" -Body \"<h1>Rapport système du $(Get-Date)</h1> $($processesHtml) $($servicesHtml)\" | Out-File $htmlReportPath\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>Maintenant, notre script ne se contente pas de collecter des données, il les sauvegarde aussi soigneusement dans deux formats : CSV pour l'analyse et HTML pour une consultation rapide.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {"level":4} -->\n<h4 class=\"wp-block-heading\">Conclusion</h4>\n<!-- /wp:heading -->\n\n<!-- wp:list {"ordered":true} -->\n<ol><!-- wp:list-item -->\n<li><strong>Le pipeline (<code>|</code>)</strong> – l'outil principal pour combiner des commandes et traiter des objets.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><code>Get-Member</code></strong> – l'analyse des objets qui montre de quoi ils sont composés.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Les variables (<span dir=\"ltr\">$var</span>, <span dir=\"ltr\">$_</span>)</strong> permettent de sauvegarder des données et d'accéder à l'objet actuel dans le pipeline.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Les fichiers <code>.ps1</code></strong> transforment les commandes en outils d'automatisation réutilisables.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Les cmdlets d'exportation</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) exportent les données dans le format correspondant.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Dans la prochaine partie, nous appliquerons ces connaissances à la navigation et à la gestion du système de fichiers, en explorant les objets <code>System.IO.DirectoryInfo</code> et <code>System.IO.FileInfo</code>.</strong></li>\n<!-- /wp:list-item --></ol>\n<!-- /wp:list -->[:]",
  "post_status": "publish",
  "post_author": 1,
  "_seo_description": "[:fr]Apprenez la philosophie de PowerShell : le pipeline, les variables (y compris $_), Get-Member pour inspecter les objets, la création de scripts .ps1 et l'exportation des résultats vers CSV, HTML ou JSON.[:] ",
  "_seo_keywords": "[:fr]PowerShell, pipeline, variables, Get-Member, scripts .ps1, exporter les résultats, objets, automatisation, cmdlets, System.Diagnostics.Process, Windows, Linux, macOS[:]"
}
{
  "lang": "es",
  "post_title": "[:es]Filosofía de PowerShell. Parte 2: La Tubería (Pipeline), variables, Get-Member, el archivo *.ps1* y la exportación de resultados[:]",
  "post_content": "[:es]<!-- wp:paragraph -->\n<p><strong>❗ Importante:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Estoy escribiendo sobre PS7 (PowerShell 7), el cual difiere de PS5 (PowerShell 5). A partir de la séptima versión, PowerShell se volvió multiplataforma, lo que ha modificado el comportamiento de algunos comandos.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>En la primera parte, establecimos un principio clave: PowerShell trabaja con <strong>objetos</strong>, no con texto. Esta publicación se dedica a algunas herramientas importantes de PowerShell: aprenderemos a pasar objetos a través de la <strong>tubería</strong> (pipeline), a analizarlos con <span dir=\"ltr\"><code>Get-Member</code></span>, a guardar resultados en <strong>variables</strong> y a automatizar todo esto en <strong>archivos de script (<span dir=\"ltr\"><code>.ps1</code></span>)</strong> con la <strong>exportación</strong> de resultados a formatos convenientes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3 class=\"wp-block-heading\">1. ¿Qué es la tubería (<span dir=\"ltr\"><code>|</code></span>)?</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>La tubería (pipeline) en PowerShell es un mecanismo para transferir objetos .NET completos (y no solo texto) de un comando a otro, donde cada cmdlet siguiente recibe objetos estructurados con todas sus propiedades y métodos.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>El símbolo <span dir=\"ltr\"><code>|</code></span> (barra vertical) es el operador de tubería. Su función es tomar el resultado (salida) del comando situado a su izquierda y pasarlo como entrada al comando situado a su derecha.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><span dir=\"ltr\"><code>Comando 1 (crea objetos)</code></span> → <span dir=\"ltr\"><code>|</code></span> → <span dir=\"ltr\"><code>Comando 2 (recibe y procesa objetos)</code></span> → <span dir=\"ltr\"><code>|</code></span> → <span dir=\"ltr\"><code>Comando 3 (recibe objetos procesados)</code></span> → | ...</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Tubería clásica de UNIX: Flujo de texto</h4>\n<!-- /wp:heading -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># Buscar todos los procesos 'nginx' y contar su número\nps -ef | grep 'nginx' | wc -l\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>Aquí <span dir=\"ltr\"><code>ps</code></span> imprime texto, <span dir=\"ltr\"><code>grep</code></span> filtra este texto y <span dir=\"ltr\"><code>wc</code></span> cuenta las líneas. Cada utilidad no sabe nada sobre \"procesos\"; solo trabaja con líneas.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Tubería de PowerShell: Flujo de objetos</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong>Ejemplo:</strong> Obtengamos todos los procesos, ordenémoslos por uso de CPU y seleccionemos los 5 que más recursos consumen.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/1.png\" alt=\"1\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Aquí <span dir=\"ltr\"><code>Get-Process</code></span> crea <strong>objetos</strong> de proceso. <span dir=\"ltr\"><code>Sort-Object</code></span> recibe estos <strong>objetos</strong> y los ordena por la propiedad <span dir=\"ltr\"><code>CPU</code></span>. <span dir=\"ltr\"><code>Select-Object</code></span> recibe los <strong>objetos</strong> ordenados y selecciona los 5 primeros.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Seguramente habrá notado en el comando palabras que comienzan con un guion (-): <span dir=\"ltr\"><code>-Property</code></span>, <span dir=\"ltr\"><code>-Descending</code></span>, <span dir=\"ltr\"><code>-First</code></span>. Estos son parámetros. Los parámetros son configuraciones, interruptores e instrucciones para un cmdlet. Permiten controlar <strong>CÓMO</strong> el comando realizará su trabajo. Sin parámetros, el comando funciona en modo predeterminado; con parámetros, le proporciona instrucciones específicas.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Tipos principales de parámetros:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Parámetro con valor: requiere información adicional.\n<ul><!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>-Property CPU</code></span>: Le indicamos a <span dir=\"ltr\"><code>Sort-Object</code></span> por qué propiedad ordenar. <span dir=\"ltr\"><code>CPU</code></span> es el valor del parámetro.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>-First 5</code></span>: Le indicamos a <span dir=\"ltr\"><code>Select-Object</code></span> cuántos objetos seleccionar. <span dir=\"ltr\"><code>5</code></span> es el valor del parámetro.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Parámetro de interruptor (flag): No requiere valor. Su mera presencia en el comando activa o desactiva un comportamiento específico.\n<ul><!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>-Descending</code></span>: Este flag le indica a <span dir=\"ltr\"><code>Sort-Object</code></span> que cambie el orden de clasificación a inverso (de mayor a menor). No necesita un valor adicional; es una instrucción por sí mismo.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name 'svchost' | Measure-Object\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/2.png\" alt=\"1\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Esta comando responde a una pregunta muy sencilla: <strong>\"¿Cuántos procesos con el nombre <span dir=\"ltr\"><code>svchost.exe</code></span> están ejecutándose actualmente en mi sistema?\"</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Análisis paso a paso</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\"><strong>Paso 1: <span dir=\"ltr\"><code>Get-Process -Name 'svchost'</code></span></strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Esta parte del comando se comunica con el sistema operativo y le pide que encuentre <strong>todos sin excepción</strong> los procesos en ejecución cuyo nombre de archivo ejecutable sea <span dir=\"ltr\"><code>svchost.exe</code></span>. A diferencia de los procesos como <span dir=\"ltr\"><code>notepad</code></span> (de los cuales suele haber uno o dos), los procesos <span dir=\"ltr\"><code>svchost</code></span> son siempre <strong>muchos</strong> en el sistema. El comando devolverá un <strong>array (colección) de objetos</strong>, donde cada objeto es un proceso <span dir=\"ltr\"><code>svchost</code></span> individual y completo con su ID único, uso de memoria, etc. PowerShell encontró en el sistema, por ejemplo, 90 procesos <span dir=\"ltr\"><code>svchost</code></span> y ahora tiene en sus manos una colección de 90 objetos.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\"><strong>Paso 2: <span dir=\"ltr\"><code>|</code></span> (Operador de tubería)</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Este símbolo toma la colección de 90 objetos <span dir=\"ltr\"><code>svchost</code></span>, obtenida en el primer paso, y comienza a pasarlos <strong>uno por uno</strong> como entrada al siguiente comando.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\"><strong>Paso 3: <span dir=\"ltr\"><code>Measure-Object</code></span></strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Dado que invocamos <span dir=\"ltr\"><code>Measure-Object</code></span> sin parámetros (como <span dir=\"ltr\"><code>-Property</code></span>, <span dir=\"ltr\"><code>-Sum</code></span>, etc.), realiza su operación <strong>por defecto</strong>: simplemente cuenta el número de \"ítems\" que se le pasaron. Uno, dos, tres ... Después de contar todos los objetos, <span dir=\"ltr\"><code>Measure-Object</code></span> crea <strong>su propio objeto de resultado</strong>, que tiene una propiedad <span dir=\"ltr\"><code>Count</code></span> igual al número total.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><span dir=\"ltr\"><code>Count: 90</code></span></strong>: esta es la respuesta a nuestra pregunta. Hay 90 procesos <span dir=\"ltr\"><code>svchost</code></span> en ejecución. Los demás campos están vacíos porque no le pedimos a <span dir=\"ltr\"><code>Measure-Object</code></span> que realizara cálculos más complejos.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Ejemplo con <span dir=\"ltr\"><code>svchost</code></span> y parámetros</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Cambiemos nuestra tarea. Ahora no solo queremos contar los procesos <span dir=\"ltr\"><code>svchost</code></span>, sino saber <strong>cuánta memoria RAM (en megabytes) consumen en total juntos</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Para ello, necesitaremos los siguientes parámetros:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>-Property WorkingSet64</code></span>: Esta instrucción le dice a <span dir=\"ltr\"><code>Measure-Object</code></span>: \"De cada objeto <span dir=\"ltr\"><code>svchost</code></span> que te llegue, toma el valor numérico de la propiedad <span dir=\"ltr\"><code>WorkingSet64</code></span> (este es el uso de memoria en bytes)\".</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>-Sum</code></span>: Esta instrucción de bandera dice: \"Suma todos estos valores que tomaste de la propiedad <span dir=\"ltr\"><code>WorkingSet64</code></span>\".</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Nuestro nuevo comando se verá así:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/3.png\" alt=\"3\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>Get-Process</code></span> encontrará el número de objetos <span dir=\"ltr\"><code>svchost</code></span>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>La tubería <span dir=\"ltr\"><code>|</code></span> los pasará a <span dir=\"ltr\"><code>Measure-Object</code></span>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Pero ahora <span dir=\"ltr\"><code>Measure-Object</code></span> funciona de una nueva manera:\n<ul><!-- wp:list-item -->\n<li>Toma el primer objeto <span dir=\"ltr\"><code>svchost</code></span>, mira su propiedad <span dir=\"ltr\"><code>.WorkingSet64</code></span> (por ejemplo, <span dir=\"ltr\"><code>25000000</code></span> bytes) y memoriza este número.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Toma el segundo objeto, mira su <span dir=\"ltr\"><code>.WorkingSet64</code></span> (por ejemplo, <span dir=\"ltr\"><code>15000000</code></span> bytes) y lo suma al anterior.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>...y así sucesivamente para todos los objetos.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Finalmente, <span dir=\"ltr\"><code>Measure-Object</code></span> creará un objeto de resultado, pero ahora será diferente.</li>\n<!-- /wp:list-item -->\n</ol>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>Count: 92</code></span></strong>: Número de objetos.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>Sum: 1661890560</code></span></strong>: Es la suma total de todos los valores de <span dir=\"ltr\"><code>WorkingSet64</code></span> en bytes.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>Property: WorkingSet64</code></span></strong>: Este campo también está lleno ahora, informándonos qué propiedad se utilizó para los cálculos.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3 class=\"wp-block-heading\">2. Variables (Normales y la especial <span dir=\"ltr\"><code>$_</code></span>)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Una variable es un almacenamiento con nombre en la memoria que contiene algún valor. Este valor puede ser cualquier cosa: texto, número, fecha o, lo más importante para PowerShell, un objeto completo o incluso una colección de objetos. El nombre de una variable en PowerShell siempre comienza con el signo de dólar (<span dir=\"ltr\"><code>$</code></span>).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Ejemplos: <span dir=\"ltr\"><code>$name</code></span>, <span dir=\"ltr\"><code>$counter</code></span>, <span dir=\"ltr\"><code>$processList</code></span>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>¿Variable especial <span dir=\"ltr\"><code>$_</code></span>?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><span dir=\"ltr\"><code>$_</code></span> es la abreviatura de \"el objeto actual\" o \"esta cosa\".</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Imagine una cinta transportadora en una fábrica. Por ella circulan diferentes piezas (objetos).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><span dir=\"ltr\"><code>$_</code></span> es esa pieza que está justo ahora frente a usted (o frente al robot procesador).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Fuente (<span dir=\"ltr\"><code>Get-Process</code></span>): vierte una caja entera de piezas (todos los procesos) en la cinta transportadora.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Tubería (<span dir=\"ltr\"><code>|</code></span>): hace que estas piezas se muevan por la cinta una por una.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Procesador (<span dir=\"ltr\"><code>Where-Object</code></span> o <span dir=\"ltr\"><code>ForEach-Object</code></span>): es un robot que examina cada pieza.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>La variable <span dir=\"ltr\"><code>$_</code></span>: es esa pieza que ahora está en las \"manos\" del robot.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Cuando el robot termina con una pieza, la cinta transportadora le entrega la siguiente, y <span dir=\"ltr\"><code>$_</code></span> ahora apuntará a esa.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Calculemos cuánta memoria total utilizan los procesos <span dir=\"ltr\"><code>svchost</code></span> y mostremos el resultado en la pantalla.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># 1. Ejecutamos el comando y guardamos su complejo objeto de resultado en la variable $svchostMemory\n$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum\n\n# 2. Ahora podemos trabajar con el objeto guardado. Extraemos su propiedad Sum\n$memoryInMB = $svchostMemory.Sum / 1MB\n\n# 3. Mostramos el resultado en pantalla usando la nueva variable\nWrite-Host \"Todos los procesos svchost utilizan $memoryInMB MB de memoria.\"\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/4.png\" alt=\"3\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>Write-Host</code></span>: es un cmdlet especializado cuya única tarea es <strong>mostrar texto directamente al usuario en la consola</strong>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Cadena entre comillas dobles: <span dir=\"ltr\"><code>\"...\"</code></span> es una cadena de texto que pasamos al cmdlet <span dir=\"ltr\"><code>Write-Host</code></span> como argumento. ¿Por qué comillas dobles y no simples? En PowerShell hay dos tipos de comillas:\n<ul><!-- wp:list-item -->\n<li><strong>Simples (<span dir=\"ltr\"><code>'...'</code></span>):</strong> Crean una <strong>cadena literal</strong>. Todo lo que está dentro de ellas se interpreta como texto plano, sin excepciones.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Dobles (<span dir=\"ltr\"><code>\"...\"</code></span>):</strong> Crean una <strong>cadena expandible (o de sustitución)</strong>. PowerShell \"escanea\" esta cadena en busca de variables (que comienzan con <span dir=\"ltr\"><code>$</code></span>) y sustituye sus valores en su lugar.</li>\n<!-- /wp:list-item --></ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><span dir=\"ltr\"><code>$memoryInMB</code></span>: Esta es la variable en la que, <strong>en el paso anterior</strong> de nuestro script, almacenamos el resultado de los cálculos. Cuando <span dir=\"ltr\"><code>Write-Host</code></span> recibe una cadena entre comillas dobles, se produce un proceso llamado <strong>\"expansión de cadenas\" (String Expansion)</strong>:\n<ol><!-- wp:list-item -->\n<li>PowerShell ve el texto <span dir=\"ltr\"><code>\"Todos los procesos svchost utilizan \"</code></span>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Luego se encuentra con la construcción <span dir=\"ltr\"><code>$memoryInMB</code></span>. Entiende que no es solo texto, sino una variable.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Busca en la memoria, encuentra el valor almacenado en <span dir=\"ltr\"><code>$memoryInMB</code></span> (por ejemplo, <span dir=\"ltr\"><code>1585.52</code></span>).</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Sustituye este valor</strong> directamente en la cadena.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Luego añade la parte restante del texto: <span dir=\"ltr\"><code>\" MB de memoria.\"</code></span>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Finalmente, a <span dir=\"ltr\"><code>Write-Host</code></span> se le pasa la cadena ya preparada y ensamblada: <span dir=\"ltr\"><code>\"Todos los procesos svchost utilizan 1585.52 MB de memoria.\"</code></span>.</li>\n<!-- /wp:list-item -->\n</ol>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Inicie el Bloc de notas:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><!-- wp:list-item -->\n<li>Encontramos el proceso del Bloc de notas y lo guardamos en la variable <span dir=\"ltr\"><code>$notepadProcess</code></span></li>\n<!-- /wp:list-item -->\n</ol>\n<!-- /wp:list -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>$notepadProcess = Get-Process -Name notepad\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol start=\"2\"><!-- wp:list-item -->\n<li>Accedemos a la propiedad <span dir=\"ltr\"><code>'Id'</code></span> de este objeto a través del punto y la mostramos.</li>\n<!-- /wp:list-item -->\n</ol>\n<!-- /wp:list -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Write-Host \"El ID del proceso 'Bloc de notas' es: $($notepadProcess.Id)\"\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/5.png\" alt=\"5\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>❗ Importante:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><span dir=\"ltr\"><code>Write-Host</code></span> \"rompe\" la tubería (pipeline). El texto que produce no puede ser pasado a lo largo de la tubería para su procesamiento. Está destinado únicamente a la visualización.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3 class=\"wp-block-heading\">3. <span dir=\"ltr\"><code>Get-Member</code></span> (Inspector de objetos)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Sabemos que los objetos \"fluyen\" a través de la tubería. Pero, ¿cómo saber de qué están compuestos? ¿Qué propiedades tienen y qué acciones (métodos) se pueden realizar con ellos?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>El cmdlet <strong><span dir=\"ltr\"><code>Get-Member</code></span></strong> (alias: <span dir=\"ltr\"><code>gm</code></span>) es la herramienta principal para la investigación. Antes de trabajar con un objeto, páselo por <span dir=\"ltr\"><code>Get-Member</code></span> para ver todas sus capacidades.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Analicemos los objetos que crea <span dir=\"ltr\"><code>Get-Process</code></span>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/6.png\" alt=\"6\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><em>Desglosemos cada parte de la salida de <span dir=\"ltr\"><code>Get-Member</code></span>.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><span dir=\"ltr\"><code>TypeName: System.Diagnostics.Process</code></span>: Este es el \"nombre de tipo\" completo y oficial del objeto de la biblioteca .NET. Es su \"pasaporte\". Esta cadena le indica que todos los objetos que devuelve <span dir=\"ltr\"><code>Get-Process</code></span> son objetos de tipo <span dir=\"ltr\"><code>System.Diagnostics.Process</code></span>. Esto garantiza que todos ellos tendrán el mismo conjunto de propiedades y métodos. Puede <a href=\"https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com\">buscar en Google</a> \"System.Diagnostics.Process\" para encontrar la documentación oficial de Microsoft con información aún más detallada.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Columna 1: <span dir=\"ltr\"><code>Name</code></span></li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Este es el <strong>nombre</strong> simple y legible por humanos de una propiedad, método u otro \"miembro\" del objeto. Este es el nombre que usará en su código para acceder a los datos o realizar acciones.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Columna 2: <span dir=\"ltr\"><code>MemberType</code></span> (Tipo de miembro)</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Esta es la columna más importante para entender. Clasifica <strong>qué es</strong> cada objeto. Es su \"rol\", que le indica <strong>CÓMO</strong> usarlo.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>Property</code></span> (Propiedad):</strong> una <strong>característica</strong> o <strong>porción de datos</strong> almacenada dentro del objeto. Puede \"leer\" su valor.\n<ul><!-- wp:list-item -->\n<li><em>Ejemplos en la captura de pantalla:</em> <span dir=\"ltr\"><code>BasePriority</code></span>, <span dir=\"ltr\"><code>HandleCount</code></span>, <span dir=\"ltr\"><code>ExitCode</code></span>. Estos son simplemente datos que se pueden ver.</li>\n<!-- /wp:list-item -->\n</ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>Method</code></span> (Método):</strong> una <strong>ACCIÓN</strong> que se puede realizar con el objeto. Los métodos siempre se invocan con paréntesis <span dir=\"ltr\"><code>()</code></span>.\n<ul><!-- wp:list-item -->\n<li><em>Ejemplos en la captura de pantalla:</em> <span dir=\"ltr\"><code>Kill</code></span>, <span dir=\"ltr\"><code>Refresh</code></span>, <span dir=\"ltr\"><code>WaitForExit</code></span>. Escribiría <span dir=\"ltr\"><code>$process.Kill()</code></span> o <span dir=\"ltr\"><code>$process.Refresh()</code></span>.</li>\n<!-- /wp:list-item -->\n</ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>AliasProperty</code></span> (Propiedad de alias):</strong> un <strong>alias amigable</strong> para otra propiedad más larga. PowerShell los añade por conveniencia y brevedad.\n<ul><!-- wp:list-item -->\n<li><em>Ejemplos en la captura de pantalla:</em> <span dir=\"ltr\"><code>WS</code></span> es un alias corto para <span dir=\"ltr\"><code>WorkingSet64</code></span>. <span dir=\"ltr\"><code>Name</code></span> para <span dir=\"ltr\"><code>ProcessName</code></span>. <span dir=\"ltr\"><code>VM</code></span> para <span dir=\"ltr\"><code>VirtualMemorySize64</code></span>.</li>\n<!-- /wp:list-item -->\n</ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>Event</code></span> (Evento):</strong> una <strong>NOTIFICACIÓN</strong> de que algo ha ocurrido, a la que se puede \"suscribir\".\n<ul><!-- wp:list-item -->\n<li><em>Ejemplo en la captura de pantalla:</em> <span dir=\"ltr\"><code>Exited</code></span>. Su script puede \"escuchar\" este evento para realizar alguna acción inmediatamente después de que el proceso finalice.</li>\n<!-- /wp:list-item -->\n</ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>CodeProperty</code></span> y <span dir=\"ltr\"><code>NoteProperty</code></span>:</strong> tipos especiales de propiedades, a menudo añadidas por el propio PowerShell para mayor comodidad. <span dir=\"ltr\"><code>CodeProperty</code></span> calcula su valor \"sobre la marcha\", mientras que <span dir=\"ltr\"><code>NoteProperty</code></span> es una propiedad simple de nota añadida al objeto.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Columna 3: <span dir=\"ltr\"><code>Definition</code></span> (Definición)</li>\n<!-- /wp:list-item -->\n</ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Esta es la <strong>definición técnica</strong> o \"firma\" del miembro. Le proporciona los detalles exactos para su uso. Su contenido depende de <span dir=\"ltr\"><code>MemberType</code></span>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li><strong>Para <span dir=\"ltr\"><code>AliasProperty</code></span>:</strong> Muestra <strong>a qué equivale el alias</strong>. ¡Esto es increíblemente útil!\n<ul><!-- wp:list-item -->\n<li><em>Ejemplo en la captura de pantalla:</em> <span dir=\"ltr\"><code>WS = WorkingSet64</code></span>. Inmediatamente ve que <span dir=\"ltr\"><code>WS</code></span> es simplemente una forma abreviada de <span dir=\"ltr\"><code>WorkingSet64</code></span>.</li>\n<!-- /wp:list-item -->\n</ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Para <span dir=\"ltr\"><code>Property</code></span>:</strong> Muestra el <strong>tipo de datos</strong> que se almacena en la propiedad (por ejemplo, <span dir=\"ltr\"><code>int</code></span> para un número entero, <span dir=\"ltr\"><code>string</code></span> para texto, <span dir=\"ltr\"><code>datetime</code></span> para fecha y hora), y lo que se puede hacer con él (<span dir=\"ltr\"><code>{get;}</code></span> - solo leer, <span dir=\"ltr\"><code>{get;set;}</code></span> - leer y modificar).\n<ul><!-- wp:list-item -->\n<li><em>Ejemplo en la captura de pantalla:</em> <span dir=\"ltr\"><code>int BasePriority {get;}</code></span>. Esta es una propiedad de tipo entero que solo se puede leer.</li>\n<!-- /wp:list-item -->\n</ul>\n</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Para <span dir=\"ltr\"><code>Method</code></span>:</strong> Muestra lo que devuelve el método (por ejemplo, <span dir=\"ltr\"><code>void</code></span> - nada, <span dir=\"ltr\"><code>bool</code></span> - true/false) y qué <strong>parámetros</strong> (datos de entrada) acepta entre paréntesis.\n<ul><!-- wp:list-item -->\n<li><em>Ejemplo en la captura de pantalla:</em> <span dir=\"ltr\"><code>void Kill()</code></span>. Esto significa que el método <span dir=\"ltr\"><code>Kill</code></span> no devuelve nada y puede invocarse sin parámetros. También hay una segunda versión <span dir=\"ltr\"><code>void Kill(bool entireProcessTree)</code></span>, que acepta un valor booleano (true/false).</li>\n<!-- /wp:list-item -->\n</ul>\n</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">En formato de tabla</h4>\n<!-- /wp:heading -->\n\n<!-- wp:table -->\n<figure class=\"wp-block-table\"><table><thead><tr><th>Método</th><th>¿Qué es?</th><th>Ejemplo de captura de pantalla</th><th>¿Para qué sirve?</th></tr></thead><tbody><tr><td><strong><span dir=\"ltr\"><code>Name</code></span></strong></td><td>El nombre que usa en el código.</td><td><span dir=\"ltr\"><code>Kill</code></span>, <span dir=\"ltr\"><code>WS</code></span>, <span dir=\"ltr\"><code>Name</code></span></td><td>Acceder a una propiedad o método (<span dir=\"ltr\"><code>$process.WS</code></span>, <span dir=\"ltr\"><code>$process.Kill()</code></span>).</td></tr><tr><td><strong><span dir=\"ltr\"><code>MemberType</code></span></strong></td><td>Tipo de miembro (datos, acción, etc.).</td><td><span dir=\"ltr\"><code>Method</code></span>, <span dir=\"ltr\"><code>Property</code></span>, <span dir=\"ltr\"><code>AliasProperty</code></span></td><td><strong>Cómo</strong> usarlo (leer valor o invocar con <span dir=\"ltr\"><code>()</code></span>).</td></tr><tr><td><strong><span dir=\"ltr\"><code>Definition</code></span></strong></td><td>Detalles técnicos.</td><td><span dir=\"ltr\"><code>WS = WorkingSet64</code></span>, <span dir=\"ltr\"><code>void Kill()</code></span></td><td>Qué hay detrás del alias y qué parámetros necesita el método.</td></tr></tbody></table></figure>\n<!-- /wp:table -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Ejemplo: Trabajar con ventanas de proceso</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">1. Problema:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>\"He abierto muchas ventanas del Bloc de notas. ¿Cómo puedo minimizar todas, excepto la principal, y luego cerrar solo las que tienen la palabra 'Untitled' en su título?\"</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">2. Investigación con <span dir=\"ltr\"><code>Get-Member</code></span>:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Necesitamos encontrar propiedades relacionadas con la ventana y su título.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name notepad | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Análisis del resultado de <span dir=\"ltr\"><code>Get-Member</code></span>:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Al revisar las propiedades, encontramos <span dir=\"ltr\"><code>MainWindowTitle</code></span>. Tipo <span dir=\"ltr\"><code>string</code></span>. ¡Excelente, este es el título de la ventana principal!</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>En los métodos, vemos <span dir=\"ltr\"><code>CloseMainWindow()</code></span>. Esta es una forma más \"suave\" de cerrar una ventana que <span dir=\"ltr\"><code>Kill()</code></span>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>También en los métodos está <span dir=\"ltr\"><code>WaitForInputIdle()</code></span>. Suena interesante; quizás ayude a esperar hasta que el proceso esté listo para interactuar.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/7.png\" alt=\"7\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><span dir=\"ltr\"><code>Get-Member</code></span> nos mostró la propiedad <span dir=\"ltr\"><code>MainWindowTitle</code></span>, que es clave para resolver la tarea y permite interactuar con los procesos basándose en el estado de sus ventanas, y no solo por su nombre.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">3. Solución:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Ahora podemos construir la lógica basada en el título de la ventana.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># 1. Encontramos todos los procesos de Bloc de notas\n$notepads = Get-Process -Name notepad\n\n# 2. Recorremos cada uno y verificamos el título\nforeach ($pad in $notepads) {\n    # Para cada proceso ($pad), verificamos su propiedad MainWindowTitle\n    if ($pad.MainWindowTitle -like '*Untitled*') {\n        Write-Host \"Se ha encontrado un Bloc de notas sin guardar (ID: $($pad.Id)). Cerrando su ventana...\"\n        # $pad.CloseMainWindow() # Descomente para cerrar realmente\n        Write-Host \"La ventana '$($pad.MainWindowTitle)' se habría cerrado.\" -ForegroundColor Yellow\n    } else {\n        Write-Host \"Saltando Bloc de notas con título: $($pad.MainWindowTitle)\"\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/8.png\" alt=\"8\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/9.png\" alt=\"9\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:separator -->\n<hr class=\"wp-block-separator has-alpha-channel-opacity\"/>\n<!-- /wp:separator -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Ejemplo: Encontrar el proceso padre</h4>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">1. Problema:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>\"A veces veo muchos procesos hijo <span dir=\"ltr\"><code>chrome.exe</code></span> en el sistema. ¿Cómo puedo saber cuál es el principal, el proceso 'padre' que los lanzó a todos?\"</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">2. Investigación con <span dir=\"ltr\"><code>Get-Member</code></span>:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Necesitamos encontrar algo que conecte un proceso con otro.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Get-Process -Name chrome | Select-Object -First 1 | Get-Member\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/10.png\" alt=\"10\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Análisis del resultado de <span dir=\"ltr\"><code>Get-Member</code></span>:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><!-- wp:list-item -->\n<li>Examinando cuidadosamente la lista, encontramos una propiedad de tipo <span dir=\"ltr\"><code>CodeProperty</code></span> con el nombre <span dir=\"ltr\"><code>Parent</code></span>.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li>Su definición (<span dir=\"ltr\"><code>Definition</code></span>) es <span dir=\"ltr\"><code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code></span>. Esta es una propiedad calculada que, al ser accedida, devuelve el <strong>objeto del proceso padre</strong>.</li>\n<!-- /wp:list-item --></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">3. Solución:</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Ahora podemos escribir un script que, para cada proceso <span dir=\"ltr\"><code>chrome</code></span>, mostrará información sobre su padre.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># 1. Obtenemos todos los procesos de Chrome\n$chromeProcesses = Get-Process -Name chrome\n\n# 2. Para cada uno de ellos, mostramos información sobre él y su padre\n$chromeProcesses | Select-Object -First 5 | ForEach-Object {\n    # Obtenemos el proceso padre\n    $parent = $_.Parent\n    \n    # Formateamos una salida atractiva\n    Write-Host \"Proceso:\" -ForegroundColor Green\n    Write-Host \"  - Nombre: $($_.ProcessName), ID: $($_.Id)\"\n    Write-Host \"Su padre:\" -ForegroundColor Yellow\n    Write-Host \"  - Nombre: $($parent.ProcessName), ID: $($parent.Id)\"\n    Write-Host \"-----------------------------\"\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/11.png\" alt=\"11\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img src=\"assets/02/12.png\" alt=\"12\"/></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Vemos inmediatamente que los procesos con ID 4756, 7936, 8268 y 9752 fueron iniciados por el proceso con ID 14908. También se puede observar un caso interesante con el proceso ID: 7252, cuyo proceso padre no se pudo determinar (posiblemente el padre ya había terminado en el momento de la verificación). Una modificación del script con una comprobación <span dir=\"ltr\"><code>if ($parent)</code></span> manejaría este caso elegantemente sin causar un error. <span dir=\"ltr\"><code>Get-Member</code></span> nos ayudó a descubrir la propiedad \"oculta\" <span dir=\"ltr\"><code>Parent</code></span>, que proporciona potentes capacidades para analizar la jerarquía de procesos.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">4. Archivo <span dir=\"ltr\"><code>*.ps1</code></span> (Creación de scripts)</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Cuando su cadena de comandos se vuelve útil, querrá guardarla para usarla varias veces. Para ello sirven los <strong>scripts</strong>: archivos de texto con la extensión <strong><span dir=\"ltr\"><code>.ps1</code></span></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">Permiso para ejecutar scripts</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Por defecto, Windows prohíbe la ejecución de scripts locales. Para solucionar esto <strong>para el usuario actual</strong>, ejecute una vez en PowerShell <strong>como administrador</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>Esta es una configuración segura que permite ejecutar sus propios scripts y aquellos firmados por un editor de confianza.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">Ejemplo de script <span dir=\"ltr\"><code>system_monitor.ps1</code></span></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Cree un archivo con este nombre e inserte el código a continuación. Este script recopila información del sistema y genera informes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code># system_monitor.ps1\n#requires -Version 5.1\n\n&lt;#\n.SYNOPSIS\n    Script para crear un informe sobre el estado del sistema.\n.DESCRIPTION\n    Recopila información sobre procesos, servicios y espacio en disco y genera informes.\n.PARAMETER OutputPath\n    Ruta para guardar los informes. Por defecto 'C:\\Temp'.\n.EXAMPLE\n    .\\system_monitor.ps1 -OutputPath \"C:\\Reports\"\n#&gt;\nparam(\n    &#91;Parameter(Mandatory=$false)]\n    &#91;string]$OutputPath = \"C:\\Temp\"\n)\n\n# --- Bloque 1: Preparación ---\nWrite-Host \"Preparando para crear el informe...\" -ForegroundColor Cyan\nif (!(Test-Path $OutputPath)) {\n    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null\n}\n\n# --- Bloque 2: Recopilación de datos ---\nWrite-Host \"Recopilando información...\" -ForegroundColor Green\n$processes = Get-Process | Sort-Object CPU -Descending\n$services = Get-Service | Group-Object Status | Select-Object Name, Count\n\n# --- Bloque 3: Invocación de la función de exportación (ver sección siguiente) ---\nExport-Results -Processes $processes -Services $services -OutputPath $OutputPath\n\nWrite-Host \"Los informes se han guardado correctamente en la carpeta $OutputPath\" -ForegroundColor Magenta\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><em>Nota: La función <span dir=\"ltr\"><code>Export-Results</code></span> se definirá en la siguiente sección como un ejemplo de buena práctica.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">5. Exportación de resultados</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Los datos limpios son buenos, pero a menudo necesitan presentarse de una forma conveniente para una persona u otro programa. PowerShell ofrece numerosos cmdlets para la exportación.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:table -->\n<figure class=\"wp-block-table\"><table><thead><tr><th>Método</th><th>Comando</th><th>Descripción</th></tr></thead><tbody><tr><td><strong>Texto simple</strong></td><td><span dir=\"ltr\"><code>... | Out-File C:\\Temp\\data.txt</code></span></td><td>Redirecciona la representación de texto a un archivo.</td></tr><tr><td><strong>CSV (para Excel)</strong></td><td><span dir=\"ltr\"><code>... | Export-Csv C:\\Temp\\data.csv -NoTypeInfo</code></span></td><td>Exporta objetos a CSV. <span dir=\"ltr\"><code>-NoTypeInfo</code></span> elimina la primera línea de servicio.</td></tr><tr><td><strong>Informe HTML</strong></td><td><span dir=\"ltr\"><code>... | ConvertTo-Html -Title \"Informe\"</code></span></td><td>Crea código HTML a partir de objetos.</td></tr><tr><td><strong>JSON (para API, web)</strong></td><td><span dir=\"ltr\"><code>... | ConvertTo-Json</code></span></td><td>Convierte objetos a formato JSON.</td></tr><tr><td><strong>XML (formato nativo de PowerShell)</strong></td><td><span dir=\"ltr\"><code>... | Export-Clixml C:\\Temp\\data.xml</code></span></td><td>Guarda objetos con todos los tipos de datos. Se pueden restaurar perfectamente a través de <span dir=\"ltr\"><code>Import-Clixml</code></span>.</td></tr></tbody></table></figure>\n<!-- /wp:table -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5 class=\"wp-block-heading\">Complemento del script: función de exportación</h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Añadamos una función a nuestro script <span dir=\"ltr\"><code>system_monitor.ps1</code></span> que se encargue de la exportación. Coloque este código <strong>antes</strong> de la llamada a <span dir=\"ltr\"><code>Export-Results</code></span>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code>function Export-Results {\n    param(\n        $Processes,\n        $Services,\n        $OutputPath\n    )\n\n    $timestamp = Get-Date -Format \"yyyy-MM-dd_HH-mm\"\n\n    # Exportación a CSV\n    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath \"processes_$timestamp.csv\") -NoTypeInformation\n    $Services | Export-Csv (Join-Path $OutputPath \"services_$timestamp.csv\") -NoTypeInformation\n\n    # Creación de un informe HTML atractivo\n    $htmlReportPath = Join-Path $OutputPath \"report_$timestamp.html\"\n    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent \"&lt;h2&gt;Top 10 procesos por CPU&lt;/h2&gt;\"\n    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent \"&lt;h2&gt;Estadísticas de servicios&lt;/h2&gt;\"\n\n    ConvertTo-Html -Head \"&lt;title&gt;Informe del sistema&lt;/title&gt;\" -Body \"&lt;h1&gt;Informe del sistema de $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)\" | Out-File $htmlReportPath\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p>Ahora nuestro script no solo recopila datos, sino que también los guarda de forma ordenada en dos formatos: CSV para análisis y HTML para una visualización rápida.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4 class=\"wp-block-heading\">Conclusión</h4>\n<!-- /wp:heading -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><!-- wp:list-item -->\n<li><strong>La tubería (<span dir=\"ltr\"><code>|</code></span>)</strong> — la herramienta principal para combinar comandos y procesar objetos.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong><span dir=\"ltr\"><code>Get-Member</code></span></strong> — análisis de objetos que muestra de qué están compuestos.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Variables (<span dir=\"ltr\"><code>$var</code></span>, <span dir=\"ltr\"><code>$_</code></span>)</strong> permiten guardar datos y referirse al objeto actual en la tubería.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Archivos <span dir=\"ltr\"><code>.ps1</code></span></strong> transforman los comandos en herramientas de automatización reutilizables.</li>\n<!-- /wp:list-item -->\n<!-- wp:list-item -->\n<li><strong>Cmdlets de exportación</strong> (<span dir=\"ltr\"><code>Export-Csv</code></span>, <span dir=\"ltr\"><code>ConvertTo-Html</code></span>) exportan datos en el formato correspondiente.</li>\n<!-- /wp:list-item -->\n</ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>En la próxima parte, aplicaremos estos conocimientos para la navegación y gestión del sistema de archivos, explorando los objetos <span dir=\"ltr\"><code>System.IO.DirectoryInfo</code></span> y <span dir=\"ltr\"><code>System.IO.FileInfo</code></span>.</strong></p>\n<!-- /wp:paragraph -->[:]",
  "post_status": "publish",
  "post_author": 1,
  "_seo_description": "[:es]Explore la segunda parte de la filosofía de PowerShell, centrándose en el pipeline, variables, Get-Member, scripts .ps1 y la exportación de resultados a CSV y HTML.[:]",
  "_seo_keywords": "[:es]PowerShell, filosofía, pipeline, tubería, Get-Member, variables, scripts .ps1, exportar resultados, CSV, HTML, automatización, objetos PowerShell, cmdlets[:]"
}
