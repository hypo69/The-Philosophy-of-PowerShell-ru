[:en]<h2 class="wp-block-heading">PowerShell Philosophy</h2>
<!-- /wp:heading -->

<!-- wp:heading -->
<h2 class="wp-block-heading">Part 2: Pipeline, Variables, Get-Member, *.ps1 Files, and Exporting Results</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>❗ Important:</strong> I am writing about PS7 (PowerShell 7). It differs from PS5 (PowerShell 5). Starting from the seventh version, PowerShell became cross-platform. Due to this, the behavior of some commands has changed.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the first part, we established a key principle: PowerShell works with <strong>objects</strong>, not text. This post is dedicated to some important PowerShell tools: we will learn how to pass objects through the <strong>pipeline</strong>, analyze them using <strong><code>Get-Member</code></strong>, save results in <strong>variables</strong>, and automate all of this in <strong>script files (<code>.ps1</code>)</strong> with <strong>exporting</strong> results into convenient formats.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">1. What is the Pipeline (<code>|</code>)?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The pipeline in PowerShell is a mechanism for passing full-fledged .NET objects (not just text) from one command to another, where each subsequent cmdlet receives structured objects with all their properties and methods.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The <code>|</code> (vertical bar) symbol is the pipeline operator. Its task is to take the result (output) of the command to its left and pass it as input to the command to its right.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Command 1 (creates objects)</code> → <code>|</code> → <code>Command 2 (receives and processes objects)</code> → <code>|</code> → <code>Command 3 (receives processed objects)</code> → | ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Classic UNIX Pipeline: Text Stream</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In <code>bash</code>, a <strong>byte stream</strong>, which is usually interpreted as text, is passed through the pipeline.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># Find all 'nginx' processes and count them
ps -ef | grep 'nginx' | wc -l
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Here, <code>ps</code> outputs text, <code>grep</code> filters that text, and <code>wc</code> counts lines. Each utility knows nothing about "processes"; it only works with strings.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">PowerShell Pipeline: Object Stream</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Example:</strong> Let's get all processes, sort them by CPU usage, and select the 5 most "resource-intensive" ones.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/1.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Here, <code>Get-Process</code> creates process <strong>objects</strong>. <code>Sort-Object</code> receives these <strong>objects</strong> and sorts them by the <code>CPU</code> property. <code>Select-Object</code> receives the sorted <strong>objects</strong> and selects the first 5.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You've probably noticed words in the command starting with a hyphen (-): <code>-Property</code>, <code>-Descending</code>, <code>-First</code>. These are parameters.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Parameters are settings, switches, and instructions for a cmdlet. They allow you to control <strong>HOW</strong> a command performs its work. Without parameters, a command operates in its default mode; with parameters, you provide it with specific instructions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Main parameter types:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>Parameter with a value: requires additional information.
<ul>
<li><code>-Property CPU</code>: We tell <code>Sort-Object</code> which property to sort by. <code>CPU</code> is the parameter value.</li>
<li><code>-First 5</code>: We tell <code>Select-Object</code> how many objects to select. <code>5</code> is the parameter value.</li>
</ul>
</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Switch parameter (flag): Does not require a value. Its mere presence in the command enables or disables specific behavior.
<ul>
<li><code>-Descending</code>: This flag tells <code>Sort-Object</code> to change the sort order to descending (from largest to smallest). It doesn't need an additional value — it's an instruction in itself.</li>
</ul>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/2.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This command answers a very simple question: <strong>"How many processes named <code>svchost.exe</code> are currently running on my system?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Step-by-Step Breakdown</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Step 1: <code>Get-Process -Name 'svchost'</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This part of the command queries the operating system and asks to find <strong>all</strong> running processes whose executable file name is <code>svchost.exe</code>. Unlike processes like <code>notepad</code> (of which there are usually one or two), there are always <strong>many</strong> <code>svchost</code> processes in the system. The command will return an <strong>array (collection) of objects</strong>, where each object is a separate, full-fledged <code>svchost</code> process with its unique ID, memory usage, etc. PowerShell found, for example, 90 <code>svchost</code> processes in the system and now holds a collection of 90 objects.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Step 2: <code>|</code> (Pipeline Operator)</strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This symbol takes the collection of 90 <code>svchost</code> objects obtained in the first step and begins to pass them <strong>one by one</strong> as input to the next command.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Step 3: <code>Measure-Object</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Since we called <code>Measure-Object</code> without parameters (such as <code>-Property</code>, <code>-Sum</code>, etc.), it performs its <strong>default</strong> operation — simply counting the number of "items" passed to it. One, two, three... After all objects are counted, <code>Measure-Object</code> creates <strong>its own result object</strong>, which has a <code>Count</code> property equal to the final number.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong><code>Count: 90</code></strong> — this is the answer to our question. 90 <code>svchost</code> processes are running. The other fields are empty because we did not ask <code>Measure-Object</code> to perform more complex calculations.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Example with <code>svchost</code> and Parameters</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's change our task. Now we don't just want to count <code>svchost</code> processes, but to find out <strong>how much total RAM (in megabytes) they consume together</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For this, we will need parameters:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><code>-Property WorkingSet64</code>: This instruction tells <code>Measure-Object</code>: "From each <code>svchost</code> object that comes to you, take the numerical value from the <code>WorkingSet64</code> property (this is memory usage in bytes)".</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>-Sum</code>: This flag instruction says: "Sum all these values you took from the <code>WorkingSet64</code> property".</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Our new command will look like this:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/3.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><!-- wp:list-item -->
<li><code>Get-Process</code> will find the number of <code>svchost</code> objects.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>The pipeline <code>|</code> will pass them to <code>Measure-Object</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>But now <code>Measure-Object</code> works differently:<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>It takes the first <code>svchost</code> object, looks at its <code>.WorkingSet64</code> property (e.g., <code>25000000</code> bytes), and remembers this number.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>It takes the second object, looks at its <code>.WorkingSet64</code> (e.g., <code>15000000</code> bytes), and adds it to the previous one.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>...and so on for all objects.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Ultimately, <code>Measure-Object</code> will create a result object, but it will be different this time.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><strong><code>Count: 92</code></strong>: Number of objects.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Sum: 1661890560</code></strong>: This is the total sum of all <code>WorkingSet64</code> values in bytes.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Property: WorkingSet64</code></strong>: This field is now also filled, informing us exactly which property was used for the calculations.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">2. Variables (Regular and the special <code>$_</code>)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>A variable is a named storage location in memory that holds a value. This value can be anything: text, a number, a date, or, most importantly for PowerShell, an entire object or even a collection of objects. A variable name in PowerShell always starts with a dollar sign ($). Examples: <code>$name</code>, <code>$counter</code>, <code>$processList</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Special variable <code>$_</code>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>$_</code> is shorthand for "current object" or "this thing." Imagine a conveyor belt in a factory. Various parts (objects) travel along it. <code>$_</code> is that very part that is currently in front of you (or in front of the processing robot). The source (<code>Get-Process</code>) — spills a whole box of parts (all processes) onto the conveyor. The conveyor (<code>|</code>) — makes these parts move along the belt one by one. The processor (<code>Where-Object</code> or <code>ForEach-Object</code>) — is a robot that looks at each part. The variable <code>$_</code> — is that very part that is currently in the robot's "hands." When the robot finishes with one part, the conveyor feeds it the next, and <code>$_</code> will now point to it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's calculate how much total memory <code>svchost</code> processes use and display the result on the monitor.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Execute the command and save its complex result object into the $svchostMemory variable
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Now we can work with the saved object. We extract its Sum property
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Display the result on the screen using the new variable
Write-Host "All svchost processes use $memoryInMB MB of memory."
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/4.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><code>Write-Host</code> — is a specialized cmdlet whose sole task is to <strong>display text directly to the user in the console</strong>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>String in double quotes: <code>"..."</code> - a text string that we pass to the <code>Write-Host</code> cmdlet as an argument. Why double quotes and not single quotes? In PowerShell, there are two types of quotes:<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><strong>Single (<code>'...'</code>):</strong> Create a <strong>literal string</strong>. Everything inside them is treated as plain text, without exceptions.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Double (<code>"..."</code>):</strong> Create an <strong>expandable (or substitutable) string</strong>. PowerShell "scans" such a string for variables (starting with <code>$</code>) and substitutes their values in their place.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>$memoryInMB</code>. This is a variable into which we, <strong>in the previous step</strong> of our script, put the result of calculations. When <code>Write-Host</code> receives a string in double quotes, a process called <strong>"String Expansion"</strong> occurs:<!-- wp:list {"ordered":true} -->
<ol><!-- wp:list-item -->
<li>PowerShell sees the text <code>"All svchost processes use "</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Then it encounters the <code>$memoryInMB</code> construct. It understands that this is not just text, but a variable.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>It looks into memory, finds the value stored in <code>$memoryInMB</code> (e.g., <code>1585.52</code>).</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>It <strong>substitutes this value</strong> directly into the string.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Then it adds the remaining text: <code>" MB of memory."</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>As a result, the ready-made, assembled string is passed to <code>Write-Host</code>: <code>"All svchost processes use 1585.52 MB of memory."</code>.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Launch Notepad:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><!-- wp:list-item -->
<li>Find the Notepad process and save it to the <code>$notepadProcess</code> variable</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>$notepadProcess = Get-Process -Name notepad
</code></pre>
<!-- /wp:code -->

<!-- wp:list {"ordered":true,"start":2} -->
<ol><!-- wp:list-item -->
<li>Access the 'Id' property of this object via a dot and display it</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Write-Host "ID of 'Notepad' process is: $($notepadProcess.Id)"
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/5.png" alt="5"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>❗ Important:</strong> <code>Write-Host</code> "breaks" the pipeline. Text output by it cannot be passed further down the pipeline for processing. It is intended only for display.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">3. Get-Member (Object Inspector)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We know that objects "flow" through the pipeline. But how do we know what they consist of? What properties do they have, and what actions (methods) can be performed with them?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The cmdlet <strong><code>Get-Member</code></strong> (alias: <code>gm</code>) is the main tool for investigation. Before working with an object, pass it through <code>Get-Member</code> to see all its capabilities.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's analyze the objects that <code>Get-Process</code> creates:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/6.png" alt="6"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>*Let's break down each part of the <code>Get-Member</code> output.*</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>TypeName: System.Diagnostics.Process</code> - This is the full, official "type name" of the object from the .NET library. It's its "passport." This line tells you that all objects returned by <code>Get-Process</code> are of type <code>System.Diagnostics.Process</code>. This ensures that they all have the same set of properties and methods. You can <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">Google</a> "<code>System.Diagnostics.Process</code>" to find official Microsoft documentation with even more detailed information.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>- Column 1: <code>Name</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the simple, human-readable <strong>name</strong> of a property, method, or other "member" of an object. This is the name you will use in your code to access data or perform actions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>- Column 2: <code>MemberType</code> (Object Type)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the most important column for understanding. It classifies <strong>what each object is</strong>. This is its "role," which tells you <strong>HOW</strong> to use it.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><strong><code>Property</code> (Property):</strong> A <strong>characteristic</strong> or <strong>piece of data</strong> stored inside the object. You can "read" its value.<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><em>Examples in the screenshot:</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. These are simply data that can be viewed.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Method</code> (Method):</strong> An <strong>ACTION</strong> that can be performed with the object. Methods are always called with parentheses <code>()</code>.<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><em>Examples in the screenshot:</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. You would write <code>$process.Kill()</code> or <code>$process.Refresh()</code>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>AliasProperty</code> (Property Alias):</strong> A <strong>friendly alias</strong> for another, longer property. PowerShell adds them for convenience and brevity.<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><em>Examples in the screenshot:</em> <code>WS</code> — is a short alias for <code>WorkingSet64</code>. <code>Name</code> — for <code>ProcessName</code>. <code>VM</code> — for <code>VirtualMemorySize64</code>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Event</code> (Event):</strong> A <strong>NOTIFICATION</strong> that something has occurred, which you can "subscribe" to.<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><em>Example in the screenshot:</em> <code>Exited</code>. Your script can "listen" to this event to perform an action immediately after the process exits.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>CodeProperty</code> and <code>NoteProperty</code>:</strong> special types of properties, often added by PowerShell itself for convenience. <code>CodeProperty</code> computes its value "on the fly," while <code>NoteProperty</code> is a simple note-property added to an object.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>- Column 3: <code>Definition</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the <strong>technical definition</strong> or "signature" of the member. It gives you precise details for its use. Its content depends on the <code>MemberType</code>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><strong>For <code>AliasProperty</code>:</strong> Shows <strong>what the alias equals</strong>. This is incredibly useful!<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><em>Example in the screenshot:</em> <code>WS = WorkingSet64</code>. You immediately see that <code>WS</code> is simply a shorthand for <code>WorkingSet64</code>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>For <code>Property</code>:</strong> Shows the <strong>data type</strong> stored in the property (e.g., <code>int</code> for an integer, <code>string</code> for text, <code>datetime</code> for date and time), and what can be done with it (<code>{get;}</code> — read only, <code>{get;set;}</code> — read and modify).<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><em>Example in the screenshot:</em> <code>int BasePriority {get;}</code>. This is an integer property that can only be read.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>For <code>Method</code>:</strong> Shows what the method returns (e.g., <code>void</code> — nothing, <code>bool</code> — true/false) and what <strong>parameters</strong> (input data) it accepts in parentheses.<!-- wp:list -->
<ul><!-- wp:list-item -->
<li><em>Example in the screenshot:</em> <code>void Kill()</code>. This means the <code>Kill</code> method returns nothing and can be called without parameters. There is also a second version, <code>void Kill(bool entireProcessTree)</code>, which takes a boolean value (true/false).</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">As a Table</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table">
<table>
<thead>
<tr>
<th>Column</th>
<th>What is it?</th>
<th>Example from screenshot</th>
<th>For what purpose?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td>The name you use in code.</td>
<td><code>Kill</code>, <code>WS</code>, <code>Name</code></td>
<td>to access a property or method (<code>$process.WS</code>, <code>$process.Kill()</code>).</td>
</tr>
<tr>
<td><strong>MemberType</strong></td>
<td>Member type (data, action, etc.).</td>
<td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td>
<td><strong>how</strong> to use it (read value or call with <code>()</code>).</td>
</tr>
<tr>
<td><strong>Definition</strong></td>
<td>Technical details.</td>
<td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td>
<td>what is hidden behind the alias and what parameters a method needs.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Example: Working with Process Windows</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problem:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"I've opened many Notepad windows. How do I programmatically minimize all but the main one, and then close only the one that has 'Untitled' in its title?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Investigation with <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We need to find properties related to the window and its title.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name notepad | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/7.png" alt="7"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Analysis of <code>Get-Member</code> result:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>Scrolling through the properties, we find <code>MainWindowTitle</code>. Type <code>string</code>. Excellent, this is the title of the main window!</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>In the methods, we see <code>CloseMainWindow()</code>. This is a "softer" way to close a window than <code>Kill()</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Also, in the methods, there's <code>WaitForInputIdle()</code>. Sounds interesting, perhaps this will help wait for the process to be ready for interaction.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><code>Get-Member</code> showed us the <code>MainWindowTitle</code> property, which is key to solving the task and allows interaction with processes based on their window state, rather than just by name.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Solution:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now we can build logic based on the window title.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Find all Notepad processes
$notepads = Get-Process -Name notepad

# 2. Iterate through each and check the title
foreach ($pad in $notepads) {
    # For each process ($pad), check its MainWindowTitle property
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Unsaved Notepad found (ID: $($pad.Id)). Closing its window..."
        # $pad.CloseMainWindow() # Uncomment to actually close
        Write-Host "Window '$($pad.MainWindowTitle)' would have been closed." -ForegroundColor Yellow
    } else {
        Write-Host "Skipping Notepad with title: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/8.png" alt="8"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/9.png" alt="9"></p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Example: Find a Parent Process</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problem:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Sometimes I see many child <code>chrome.exe</code> processes in the system. How do I find out which one is the main, 'parent' process that launched all of them?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Investigation with <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We need to find something that links one process to another.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/10.png" alt="10"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Analysis of <code>Get-Member</code> result:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><!-- wp:list-item -->
<li>Carefully reviewing the list, we find a <code>CodeProperty</code> type property named <code>Parent</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Its definition (<code>Definition</code>) is <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>. This is a calculated property that, when accessed, returns the <strong>parent process object</strong>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Solution:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now we can write a script that will output information about each <code>chrome</code> process and its parent.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Get all chrome processes
$chromeProcesses = Get-Process -Name chrome

# 2. For each of them, output information about it and its parent
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Get the parent process
    $parent = $_.Parent
    
    # Formulate nice output
    Write-Host "Process:" -ForegroundColor Green
    Write-Host "  - Name: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Its parent:" -ForegroundColor Yellow
    Write-Host "  - Name: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/11.png" alt="11"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/12.png" alt="12"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We immediately see that processes with IDs 4756, 7936, 8268, and 9752 were launched by process ID 14908. An interesting case can also be noted with process ID: 7252, whose parent process was not defined (perhaps the parent had already terminated by the time of the check). Modifying the script with an <code>if ($parent)</code> check elegantly handles this case without causing an error. <code>Get-Member</code> helped us discover the "hidden" <code>Parent</code> property, which provides powerful capabilities for analyzing process hierarchy.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">4. *.ps1 File (Script Creation)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>When your command chain becomes useful, you'll want to save it for repeated use. This is what <strong>scripts</strong> are for — text files with the <strong><code>.ps1</code></strong> extension.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Script Execution Policy</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>By default, Windows prohibits running local scripts. To fix this <strong>for the current user</strong>, run the following once in PowerShell <strong>as an administrator</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>This is a safe setting that allows you to run your own scripts and scripts signed by a trusted publisher.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Example Script: <code>system_monitor.ps1</code></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Create a file with this name and paste the code below into it. This script collects system information and generates reports.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Script for creating a system status report.
.DESCRIPTION
    Collects information about processes, services, and disk space and generates reports.
.PARAMETER OutputPath
    Path to save reports. Defaults to 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Block 1: Preparation ---
Write-Host "Preparing to create report..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Block 2: Data Collection ---
Write-Host "Collecting information..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Block 3: Call function for export (see next section) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Reports successfully saved to folder $OutputPath" -ForegroundColor Magenta
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><em>Note: The <code>Export-Results</code> function will be defined in the next section as an example of good practice.</em></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">5. Exporting Results</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Clean data is good, but often it needs to be presented in a format convenient for humans or other programs. PowerShell offers many cmdlets for exporting.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table">
<table>
<thead>
<tr>
<th>Method</th>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Plain Text</strong></td>
<td><code>... | Out-File C:\Temp\data.txt</code></td>
<td>Redirects text representation to a file.</td>
</tr>
<tr>
<td><strong>CSV (for Excel)</strong></td>
<td><code>... | Export-Csv C:\Temp\data.csv -NoTypeInfo</code></td>
<td>Exports objects to CSV. <code>-NoTypeInfo</code> removes the header type information.</td>
</tr>
<tr>
<td><strong>HTML Report</strong></td>
<td><code>... | ConvertTo-Html -Title "Report"</code></td>
<td>Creates HTML code from objects.</td>
</tr>
<tr>
<td><strong>JSON (for API, web)</strong></td>
<td><code>... | ConvertTo-Json</code></td>
<td>Converts objects to JSON format.</td>
</tr>
<tr>
<td><strong>XML (native PowerShell format)</strong></td>
<td><code>... | Export-Clixml C:\Temp\data.xml</code></td>
<td>Saves objects with all data types. They can be perfectly restored via <code>Import-Clixml</code>.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Script Enhancement: Export Function</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's add an export function to our <code>system_monitor.ps1</code> script. Place this code <strong>before</strong> the <code>Export-Results</code> call.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Export to CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Create a nice HTML report
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Top 10 processes by CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Service Statistics&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;System Report&lt;/title&gt;" -Body "&lt;h1&gt;System Report from $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Now our script not only collects data but also neatly saves it in two formats: CSV for analysis and HTML for quick viewing.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Conclusion</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol><!-- wp:list-item -->
<li><strong>Pipeline (<code>|</code>)</strong> — the main tool for combining commands and processing objects.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Get-Member</code></strong> — object analysis, which shows what they consist of.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Variables (<code>$var</code>, <code>$_</code>)</strong> allow you to save data and refer to the current object in the pipeline.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>.ps1</code> files</strong> turn commands into reusable automation tools.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Export cmdlets</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) export data in the appropriate format.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>In the next part, we will apply this knowledge to navigate and manage the file system, exploring <code>System.IO.DirectoryInfo</code> and <code>System.IO.FileInfo</code> objects.</strong></p>
<!-- /wp:paragraph -->[:fr]<h1 class="wp-block-heading" dir="ltr">Philosophie PowerShell.</h1>
<!-- /wp:heading -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" dir="ltr">Partie 2 : Le Pipeline, les variables, Get-Member, les fichiers *.ps1 et l'exportation des résultats</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr"><strong>❗ Important :</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">J'écris sur PS7 (PowerShell 7). Il est différent de PS5 (PowerShell 5). Depuis la septième version, PowerShell est devenu multiplateforme. En conséquence, le comportement de certaines commandes a changé.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Dans la <a href="lien-vers-premiere-partie">première partie</a>, nous avons établi un principe clé : PowerShell fonctionne avec des <strong>objets</strong>, et non avec du texte. Cet article est dédié à quelques outils importants de PowerShell : nous apprendrons à passer des objets via le <strong>pipeline</strong>, à les analyser avec <code><span dir="ltr">Get-Member</span></code>, à stocker les résultats dans des <strong>variables</strong> et à automatiser tout cela dans des <strong>fichiers de scripts (<span dir="ltr">.ps1</span>)</strong> avec <strong>l'exportation</strong> des résultats dans des formats pratiques.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="ltr">1. Qu'est-ce que le pipeline (<code><span dir="ltr">|</span></code>) ?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Le pipeline dans PowerShell est un mécanisme de transfert d'objets .NET complets (et non pas seulement du texte) d'une commande à l'autre, où chaque cmdlet suivant reçoit des objets structurés avec toutes leurs propriétés et méthodes.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Le symbole <code><span dir="ltr">|</span></code> (barre verticale) est l'opérateur de pipeline. Sa tâche est de prendre le résultat (la sortie) de la commande située à sa gauche et de le transmettre en entrée à la commande située à sa droite.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><code><span dir="ltr">Commande 1 (crée des objets)</span></code> → <code><span dir="ltr">|</span></code> → <code><span dir="ltr">Commande 2 (reçoit et traite des objets)</span></code> → <code><span dir="ltr">|</span></code> → <code><span dir="ltr">Commande 3 (reçoit des objets traités)</span></code> → <code><span dir="ltr">|</span></code> ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Pipeline UNIX classique : Flux de texte</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Dans <code><span dir="ltr">bash</span></code>, le pipeline transmet un <strong>flux d'octets</strong>, qui est généralement interprété comme du texte.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-bash" dir="ltr"># Trouver tous les processus 'nginx' et compter leur nombre
ps -ef | grep 'nginx' | wc -l
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="ltr">Ici, <code><span dir="ltr">ps</span></code> affiche du texte, <code><span dir="ltr">grep</span></code> filtre ce texte, et <code><span dir="ltr">wc</span></code> compte les lignes. Chaque utilitaire ne sait rien des "processus", il travaille uniquement avec des chaînes de caractères.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Pipeline PowerShell : Flux d'objets</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr"><strong>Exemple :</strong> Obtenons tous les processus, trions-les par utilisation du CPU et sélectionnons les 5 plus "gourmands".</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/1.png" alt="Capture d'écran PowerShell montrant des processus triés par CPU" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Ici, <code><span dir="ltr">Get-Process</span></code> crée des <strong>objets</strong> de processus. <code><span dir="ltr">Sort-Object</span></code> reçoit ces <strong>objets</strong> et les trie par la propriété <code><span dir="ltr">CPU</span></code>. <code><span dir="ltr">Select-Object</span></code> reçoit les <strong>objets</strong> triés et sélectionne les 5 premiers.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Vous avez sûrement remarqué dans la commande des mots commençant par un tiret (-) : <code><span dir="ltr">-Property</span></code>, <code><span dir="ltr">-Descending</span></code>, <code><span dir="ltr">-First</span></code>. Ce sont des paramètres.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Les paramètres sont des réglages, des commutateurs et des instructions pour un cmdlet. Ils permettent de contrôler la manière dont une commande exécutera son travail. Sans paramètres, une commande fonctionne en mode par défaut, tandis qu'avec des paramètres, vous lui donnez des instructions spécifiques.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Principaux types de paramètres :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li>Paramètre avec valeur : nécessite des informations supplémentaires.
<ul><!-- wp:list-item -->
<li><code><span dir="ltr">-Property CPU</span></code> : Nous disons à <code><span dir="ltr">Sort-Object</span></code> quelle propriété utiliser pour le tri. <code><span dir="ltr">CPU</span></code> est la valeur du paramètre.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code><span dir="ltr">-First 5</span></code> : Nous disons à <code><span dir="ltr">Select-Object</span></code> combien d'objets sélectionner. <code><span dir="ltr">5</span></code> est la valeur du paramètre.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Paramètre-commutateur (drapeau) : Ne nécessite pas de valeur. Sa simple présence dans la commande active ou désactive un certain comportement.
<ul><!-- wp:list-item -->
<li><code><span dir="ltr">-Descending</span></code> : Ce drapeau indique à <code><span dir="ltr">Sort-Object</span></code> de changer l'ordre de tri pour être inverse (du plus grand au plus petit). Il n'a pas besoin de valeur supplémentaire – il est une instruction en soi.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/2.png" alt="Capture d'écran PowerShell montrant le nombre de processus svchost" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Cette commande répond à une question très simple : <strong>"Combien de processus avec le nom <code><span dir="ltr">svchost.exe</span></code> sont actuellement en cours d'exécution sur mon système ?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Analyse étape par étape</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">Étape 1 : <code><span dir="ltr">Get-Process -Name 'svchost'</span></code></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Cette partie de la commande s'adresse au système d'exploitation et lui demande de trouver <strong>tous les processus en cours d'exécution</strong> dont le nom de l'exécutable est <code><span dir="ltr">svchost.exe</span></code>. Contrairement aux processus de type <code><span dir="ltr">notepad</span></code> (dont il y en a généralement un ou deux), il y a toujours <strong>beaucoup</strong> de processus <code><span dir="ltr">svchost</span></code> dans le système. La commande renverra un <strong>tableau (collection) d'objets</strong>, où chaque objet est un processus <code><span dir="ltr">svchost</span></code> distinct et complet avec son ID unique, son utilisation de la mémoire, etc.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">PowerShell a trouvé, par exemple, 90 processus <code><span dir="ltr">svchost</span></code> dans le système et détient maintenant une collection de 90 objets.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">Étape 2 : <code><span dir="ltr">|</span></code> (Opérateur de pipeline)</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Ce symbole prend la collection de 90 objets <code><span dir="ltr">svchost</span></code>, obtenue à la première étape, et commence à les transmettre <strong>un par un</strong> à la commande suivante.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">Étape 3 : <code><span dir="ltr">Measure-Object</span></code></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Puisque nous avons appelé <code><span dir="ltr">Measure-Object</span></code> sans paramètres (tels que <code><span dir="ltr">-Property</span></code>, <code><span dir="ltr">-Sum</span></code>, etc.), il effectue son opération <strong>par défaut</strong> — il compte simplement le nombre "d'éléments" qui lui ont été transmis.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Un, deux, trois... Une fois que tous les objets sont comptés, <code><span dir="ltr">Measure-Object</span></code> crée <strong>son propre objet-résultat</strong>, qui contient une propriété <code><span dir="ltr">Count</span></code>, égale au nombre total.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><strong><code><span dir="ltr">Count: 90</span></code></strong> — c'est la réponse à notre question. 90 processus <code><span dir="ltr">svchost</span></code> sont en cours d'exécution. Les autres champs sont vides car nous n'avons pas demandé à <code><span dir="ltr">Measure-Object</span></code> d'effectuer des calculs plus complexes.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Exemple avec <code><span dir="ltr">svchost</span></code> et paramètres</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Changeons notre tâche. Maintenant, nous ne voulons pas simplement compter les processus <code><span dir="ltr">svchost</span></code>, mais savoir <strong>combien de mémoire vive (en mégaoctets) ils consomment ensemble</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Pour cela, nous aurons besoin de paramètres :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li><code><span dir="ltr">-Property WorkingSet64</span></code> : Cette instruction dit à <code><span dir="ltr">Measure-Object</span></code> : "Pour chaque objet <code><span dir="ltr">svchost</span></code> qui te parviendra, prends la valeur numérique de la propriété <code><span dir="ltr">WorkingSet64</span></code> (c'est l'utilisation de la mémoire en octets)".</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code><span dir="ltr">-Sum</span></code> : Cette instruction-drapeau dit : "Additionne toutes ces valeurs que tu as prises de la propriété <code><span dir="ltr">WorkingSet64</span></code>".</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="ltr">Notre nouvelle commande ressemblera à ceci :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/3.png" alt="Capture d'écran PowerShell montrant le nombre et la somme de la mémoire utilisée par les processus svchost" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol dir="ltr"><!-- wp:list-item -->
<li><code><span dir="ltr">Get-Process</span></code> trouvera le nombre d'objets <code><span dir="ltr">svchost</span></code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Le pipeline <code><span dir="ltr">|</span></code> les transmettra à <code><span dir="ltr">Measure-Object</span></code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Mais maintenant, <code><span dir="ltr">Measure-Object</span></code> fonctionne différemment :
<ul><!-- wp:list-item -->
<li>Il prend le premier objet <code><span dir="ltr">svchost</span></code>, examine sa propriété <code><span dir="ltr">.WorkingSet64</span></code> (par exemple, <code><span dir="ltr">25000000</span></code> octets) et mémorise ce nombre.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Il prend le deuxième objet, examine sa propriété <code><span dir="ltr">.WorkingSet64</span></code> (par exemple, <code><span dir="ltr">15000000</span></code> octets) et l'ajoute au précédent.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>...et ainsi de suite pour tous les objets.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Finalement, <code><span dir="ltr">Measure-Object</span></code> créera un objet-résultat, mais il sera différent.
<ul><!-- wp:list-item -->
<li><strong><code><span dir="ltr">Count: 92</span></code></strong> : Nombre d'objets.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code><span dir="ltr">Sum: 1661890560</span></code></strong> : C'est la somme totale de toutes les valeurs <code><span dir="ltr">WorkingSet64</span></code> en octets.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code><span dir="ltr">Property: WorkingSet64</span></code></strong> : Ce champ est maintenant également rempli, il nous informe quelle propriété a été utilisée pour les calculs.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="ltr">2. Variables (ordinaires et spéciale <code><span dir="ltr">$_</span></code>)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Une variable est un espace de stockage nommé en mémoire qui contient une valeur quelconque. Cette valeur peut être n'importe quoi : du texte, un nombre, une date ou, ce qui est le plus important pour PowerShell, un objet entier ou même une collection d'objets. Le nom d'une variable dans PowerShell commence toujours par le signe dollar (<code><span dir="ltr">$</span></code>). Exemples : <code><span dir="ltr">$name</span></code>, <code><span dir="ltr">$counter</span></code>, <code><span dir="ltr">$processList</span></code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Variable spéciale <code><span dir="ltr">$_</span></code> ?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><code><span dir="ltr">$_</span></code> — est l'abréviation de "l'objet actuel" ou "cette chose". Imaginez un pipeline dans une usine. Différentes pièces (objets) y circulent. <code><span dir="ltr">$_</span></code> — c'est la pièce qui est actuellement devant vous (ou devant le robot-opérateur).</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li>Source (<code><span dir="ltr">Get-Process</span></code>) — déverse sur le pipeline une boîte entière de pièces (tous les processus).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Pipeline (<code><span dir="ltr">|</span></code>) — fait avancer ces pièces une par une sur la bande.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Opérateur (<code><span dir="ltr">Where-Object</span></code> ou <code><span dir="ltr">ForEach-Object</span></code>) — c'est un robot qui regarde chaque pièce.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Variable <code><span dir="ltr">$_</span></code> — c'est la pièce qui est actuellement entre les "mains" du robot.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="ltr">Quand le robot a fini avec une pièce, le pipeline lui en fournit une autre, et <code><span dir="ltr">$_</span></code> pointera alors sur celle-ci.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Comptons la quantité totale de mémoire utilisée par les processus <code><span dir="ltr">svchost</span></code> et affichons le résultat à l'écran.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># 1. Exécute la commande et stocke son objet-résultat complexe dans la variable $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Nous pouvons maintenant travailler avec l'objet sauvegardé. Nous en extrayons la propriété Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Affichons le résultat à l'écran, en utilisant la nouvelle variable
Write-Host "Tous les processus svchost utilisent $memoryInMB Mo de mémoire."
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/4.png" alt="Capture d'écran PowerShell affichant la mémoire totale utilisée par svchost" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li><code><span dir="ltr">Write-Host</span></code> — est un cmdlet spécialisé dont la seule tâche est d'<strong>afficher du texte directement à l'utilisateur dans la console</strong>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Chaîne entre guillemets doubles : <code><span dir="ltr">"..."</span></code> - une chaîne de texte que nous passons au cmdlet <code><span dir="ltr">Write-Host</span></code> comme argument. Pourquoi des guillemets doubles et non simples ? PowerShell a deux types de guillemets :
<ul><!-- wp:list-item -->
<li><strong>Simples (<code><span dir="ltr">'...'</span></code>) :</strong> Créent une <strong>chaîne littérale</strong>. Tout ce qui est à l'intérieur est traité comme du texte ordinaire, sans exceptions.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Doubles (<code><span dir="ltr">"..."</span></code>) :</strong> Créent une <strong>chaîne extensible (ou de substitution)</strong>. PowerShell "analyse" cette chaîne pour détecter les variables (commençant par <code><span dir="ltr">$</span></code>) et substitue leurs valeurs.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code><span dir="ltr">$memoryInMB</span></code>. C'est la variable dans laquelle nous avons placé le résultat des calculs à l'étape précédente de notre script. Lorsque <code><span dir="ltr">Write-Host</span></code> reçoit une chaîne entre guillemets doubles, un processus appelé <strong>"expansion de chaîne" (<span dir="ltr">String Expansion</span>)</strong> se produit :
<ol dir="ltr"><!-- wp:list-item -->
<li>PowerShell voit le texte <code><span dir="ltr">"Tous les processus svchost utilisent "</span></code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Puis il rencontre la construction <code><span dir="ltr">$memoryInMB</span></code>. Il comprend que ce n'est pas seulement du texte, mais une variable.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Il consulte la mémoire, trouve la valeur stockée dans <code><span dir="ltr">$memoryInMB</span></code> (par exemple, <code><span dir="ltr">1585.52</span></code>).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Il <strong>substitue cette valeur</strong> directement dans la chaîne.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Puis il ajoute le reste du texte : <code><span dir="ltr">" Mo de mémoire."</span></code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Au final, la chaîne prête et assemblée est passée à <code><span dir="ltr">Write-Host</span></code> : <code><span dir="ltr">"Tous les processus svchost utilisent 1585.52 Mo de mémoire."</span></code>.</li>
<!-- /wp:list-item --></ol></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="ltr">Lancez le bloc-notes :</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol dir="ltr"><!-- wp:list-item -->
<li>Nous trouvons le processus du Bloc-notes et le sauvegardons dans la variable <code><span dir="ltr">$notepadProcess</span></code>
<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">$notepadProcess = Get-Process -Name notepad
</code></pre>
<!-- /wp:code --></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Nous accédons à la propriété 'Id' de cet objet via le point et l'affichons
<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Write-Host "L'ID du processus 'Bloc-notes' est : $($notepadProcess.Id)"
</code></pre>
<!-- /wp:code --></li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><img src="assets/02/5.png" alt="Capture d'écran PowerShell affichant l'ID du processus Bloc-notes" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><strong>❗ Important :</strong> <code><span dir="ltr">Write-Host</span></code> "casse" le pipeline. Le texte affiché par celui-ci ne peut pas être transmis plus loin dans le pipeline pour être traité. Il est destiné uniquement à l'affichage.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="ltr">3. Get-Member (L'inspecteur d'objets)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Nous savons que des objets "circulent" dans le pipeline. Mais comment savoir de quoi ils sont faits ? Quelles sont leurs propriétés et quelles actions (méthodes) peuvent être effectuées avec eux ?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Le cmdlet <strong><code><span dir="ltr">Get-Member</span></code></strong> (alias : <code><span dir="ltr">gm</span></code>) est l'outil principal pour l'exploration. Avant de travailler avec un objet, passez-le par <code><span dir="ltr">Get-Member</span></code> pour voir toutes ses capacités.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Analysons les objets créés par <code><span dir="ltr">Get-Process</span></code> :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/6.png" alt="Capture d'écran de la sortie de Get-Member pour les objets Get-Process" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">*Décomposons chaque partie de la sortie de <span dir="ltr">Get-Member</span>.*</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><code><span dir="ltr">TypeName: System.Diagnostics.Process</span></code> - C'est le "nom de type" complet et officiel de l'objet de la bibliothèque .NET. C'est son "passeport". Cette ligne vous indique que tous les objets renvoyés par <code><span dir="ltr">Get-Process</span></code> sont des objets de type <code><span dir="ltr">System.Diagnostics.Process</span></code>. Cela garantit qu'ils auront tous le même ensemble de propriétés et de méthodes. Vous pouvez <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com" dir="ltr">rechercher sur Google</a> "<code><span dir="ltr">System.Diagnostics.Process</span></code>" pour trouver la documentation officielle de Microsoft avec des informations encore plus détaillées.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li><p dir="ltr">Colonne 1 : <code><span dir="ltr">Name</span></code></p>
<p dir="ltr">C'est le <strong>nom</strong> simple et lisible par l'homme d'une propriété, d'une méthode ou d'un autre "membre" de l'objet. C'est ce nom que vous utiliserez dans votre code pour accéder aux données ou effectuer des actions.</p></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><p dir="ltr">Colonne 2 : <code><span dir="ltr">MemberType</span></code> (Type d'objet)</p>
<p dir="ltr">C'est la colonne la plus importante pour la compréhension. Elle classe <strong>ce qu'est</strong> chaque objet. C'est sa "fonction", qui vous indique <strong>COMMENT</strong> l'utiliser.</p>
<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li><strong><code><span dir="ltr">Property</span></code> (Propriété) :</strong> une <strong>caractéristique</strong> ou une <strong>portion de données</strong>, stockée à l'intérieur de l'objet. Vous pouvez "lire" sa valeur.
<ul><!-- wp:list-item -->
<li><em>Exemples sur la capture d'écran :</em> <code><span dir="ltr">BasePriority</span></code>, <code><span dir="ltr">HandleCount</span></code>, <code><span dir="ltr">ExitCode</span></code>. Ce sont simplement des données qui peuvent être consultées.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code><span dir="ltr">Method</span></code> (Méthode) :</strong> une <strong>ACTION</strong> qui peut être effectuée avec l'objet. Les méthodes sont toujours appelées avec des parenthèses <code><span dir="ltr">()</span></code>.
<ul><!-- wp:list-item -->
<li><em>Exemples sur la capture d'écran :</em> <code><span dir="ltr">Kill</span></code>, <code><span dir="ltr">Refresh</span></code>, <code><span dir="ltr">WaitForExit</span></code>. Vous écririez <code><span dir="ltr">$process.Kill()</span></code> ou <code><span dir="ltr">$process.Refresh()</span></code>.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code><span dir="ltr">AliasProperty</span></code> (Alias de propriété) :</strong> un <strong>alias convivial</strong> pour une autre propriété plus longue. PowerShell les ajoute pour plus de commodité et de concision.
<ul><!-- wp:list-item -->
<li><em>Exemples sur la capture d'écran :</em> <code><span dir="ltr">WS</span></code> — est un alias court pour <code><span dir="ltr">WorkingSet64</span></code>. <code><span dir="ltr">Name</span></code> — pour <code><span dir="ltr">ProcessName</span></code>. <code><span dir="ltr">VM</span></code> — pour <code><span dir="ltr">VirtualMemorySize64</span></code>.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code><span dir="ltr">Event</span></code> (Événement) :</strong> une <strong>NOTIFICATION</strong> qu'un événement s'est produit, à laquelle on peut "s'abonner".
<ul><!-- wp:list-item -->
<li><em>Exemple sur la capture d'écran :</em> <code><span dir="ltr">Exited</span></code>. Votre script peut "écouter" cet événement pour effectuer une action immédiatement après la fin du processus.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code><span dir="ltr">CodeProperty</span></code> et <code><span dir="ltr">NoteProperty</span></code> :</strong> types spéciaux de propriétés, souvent ajoutées par PowerShell lui-même pour plus de commodité. <code><span dir="ltr">CodeProperty</span></code> calcule sa valeur "à la volée", tandis que <code><span dir="ltr">NoteProperty</span></code> est une simple propriété-note ajoutée à l'objet.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><p dir="ltr">Colonne 3 : <code><span dir="ltr">Definition</span></code> (Définition)</p>
<p dir="ltr">C'est la <strong>définition technique</strong> ou "signature" du membre. Elle vous donne les détails précis pour son utilisation. Son contenu dépend du <code><span dir="ltr">MemberType</span></code> :</p>
<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li><strong>Pour <code><span dir="ltr">AliasProperty</span></code> :</strong> Indique <strong>à quoi correspond l'alias</strong>. C'est incroyablement utile !
<ul><!-- wp:list-item -->
<li><em>Exemple sur la capture d'écran :</em> <code><span dir="ltr">WS = WorkingSet64</span></code>. Vous voyez immédiatement que <code><span dir="ltr">WS</span></code> est simplement une forme courte pour <code><span dir="ltr">WorkingSet64</span></code>.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Pour <code><span dir="ltr">Property</span></code> :</strong> Indique le <strong>type de données</strong> stocké dans la propriété (par exemple, <code><span dir="ltr">int</span></code> pour un nombre entier, <code><span dir="ltr">string</span></code> pour du texte, <code><span dir="ltr">datetime</span></code> pour une date et une heure), et ce que l'on peut faire avec (<code><span dir="ltr">{get;}</span></code> — seulement lire, <code><span dir="ltr">{get;set;}</span></code> — lire et modifier).
<ul><!-- wp:list-item -->
<li><em>Exemple sur la capture d'écran :</em> <code><span dir="ltr">int BasePriority {get;}</span></code>. C'est une propriété entière qui peut seulement être lue.</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Pour <code><span dir="ltr">Method</span></code> :</strong> Indique ce que la méthode retourne (par exemple, <code><span dir="ltr">void</span></code> — rien, <code><span dir="ltr">bool</span></code> — vrai/faux) et quels <strong>paramètres</strong> (données d'entrée) elle accepte entre parenthèses.
<ul><!-- wp:list-item -->
<li><em>Exemple sur la capture d'écran :</em> <code><span dir="ltr">void Kill()</span></code>. Cela signifie que la méthode <code><span dir="ltr">Kill</span></code> ne renvoie rien et peut être appelée sans paramètres. Il existe également une deuxième version <code><span dir="ltr">void Kill(bool entireProcessTree)</span></code>, qui accepte une valeur booléenne (vrai/faux).</li>
<!-- /wp:list-item --></ul></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Sous forme de tableau</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table" dir="ltr">
<table class="has-fixed-layout">
<thead>
<tr>
<th>Colonne</th>
<th>Qu'est-ce que c'est ?</th>
<th>Exemple de capture d'écran</th>
<th>Pour quoi faire ?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><span dir="ltr">Name</span></strong></td>
<td>Nom que vous utilisez dans le code.</td>
<td><code><span dir="ltr">Kill</span></code>, <code><span dir="ltr">WS</span></code>, <code><span dir="ltr">Name</span></code></td>
<td>Accéder à la propriété ou à la méthode (<code><span dir="ltr">$process.WS</span></code>, <code><span dir="ltr">$process.Kill()</span></code>).</td>
</tr>
<tr>
<td><strong><span dir="ltr">MemberType</span></strong></td>
<td>Type de membre (données, action, etc.).</td>
<td><code><span dir="ltr">Method</span></code>, <code><span dir="ltr">Property</span></code>, <code><span dir="ltr">AliasProperty</span></code></td>
<td><strong>Comment</strong> l'utiliser (lire la valeur ou appeler avec <code><span dir="ltr">()</span></code>).</td>
</tr>
<tr>
<td><strong><span dir="ltr">Definition</span></strong></td>
<td>Détails techniques.</td>
<td><code><span dir="ltr">WS = WorkingSet64</span></code>, <code><span dir="ltr">void Kill()</span></code></td>
<td>Ce qui se cache derrière l'alias et quels paramètres la méthode nécessite.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Exemple : Travailler avec les fenêtres des processus</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">1. Problème :</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">"J'ai ouvert de nombreuses fenêtres du Bloc-notes. Comment puis-je minimiser toutes celles qui ne sont pas la principale, puis fermer uniquement celle dont le titre contient le mot 'Untitled' ?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">2. Recherche avec <code><span dir="ltr">Get-Member</span></code> :</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Nous devons trouver les propriétés liées à la fenêtre et à son titre.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name notepad | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="ltr"><strong>Analyse du résultat de <code><span dir="ltr">Get-Member</span></code> :</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li>En parcourant les propriétés, nous trouvons <code><span dir="ltr">MainWindowTitle</span></code>. Type <code><span dir="ltr">string</span></code>. Excellent, c'est le titre de la fenêtre principale !</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Dans les méthodes, nous voyons <code><span dir="ltr">CloseMainWindow()</span></code>. C'est une manière plus "douce" de fermer la fenêtre que <code><span dir="ltr">Kill()</span></code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Il y a aussi <code><span dir="ltr">WaitForInputIdle()</span></code> dans les méthodes. Cela semble intéressant, cela pourrait aider à attendre que le processus soit prêt à interagir.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><img src="assets/02/7.png" alt="Capture d'écran de Get-Member montrant MainWindowTitle et CloseMainWindow" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><code><span dir="ltr">Get-Member</span></code> nous a montré la propriété <code><span dir="ltr">MainWindowTitle</span></code>, qui est la clé pour résoudre le problème et permet d'interagir avec les processus en fonction de l'état de leurs fenêtres, et non pas simplement par leur nom.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">3. Solution :</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Maintenant, nous pouvons construire une logique basée sur le titre de la fenêtre.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># 1. Trouve tous les processus du Bloc-notes
$notepads = Get-Process -Name notepad

# 2. Parcourt chacun d'eux et vérifie le titre
foreach ($pad in $notepads) {
    # Pour chaque processus ($pad), vérifie sa propriété MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Bloc-notes non sauvegardé trouvé (ID: $($pad.Id)). Fermeture de sa fenêtre..."
        # $pad.CloseMainWindow() # Décommentez pour fermer réellement
        Write-Host "La fenêtre '$($pad.MainWindowTitle)' aurait été fermée." -ForegroundColor Yellow
    } else {
        Write-Host "Ignorer le Bloc-notes avec le titre : $($pad.MainWindowTitle)"
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/8.png" alt="Capture d'écran de l'exécution du script de fermeture du Bloc-notes non sauvegardé" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/9.png" alt="Capture d'écran des fenêtres du Bloc-notes après l'exécution du script (simulation)" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/><!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Exemple : Trouver le processus parent</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">1. Problème :</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">"Parfois, je vois de nombreux processus enfants <code><span dir="ltr">chrome.exe</span></code> dans le système. Comment puis-je savoir lequel est le processus "parent" principal qui les a tous lancés ?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">2. Recherche avec <code><span dir="ltr">Get-Member</span></code> :</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Nous devons trouver quelque chose qui lie un processus à un autre.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/10.png" alt="Capture d'écran de Get-Member pour un processus Chrome montrant la propriété Parent" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><strong>Analyse du résultat de <code><span dir="ltr">Get-Member</span></code> :</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="ltr"><!-- wp:list-item -->
<li>En examinant attentivement la liste, nous trouvons une propriété de type <code><span dir="ltr">CodeProperty</span></code> nommée <code><span dir="ltr">Parent</span></code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Sa définition (<code><span dir="ltr">Definition</span></code>) — <code><span dir="ltr">System.Diagnostics.Process Parent{get=GetParentProcess;}</span></code>. C'est une propriété calculée qui, lorsqu'elle est appelée, renvoie l'<strong>objet du processus parent</strong>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="ltr">3. Solution :</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Nous pouvons maintenant écrire un script qui, pour chaque processus <code><span dir="ltr">chrome</span></code>, affichera des informations sur celui-ci et son parent.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># 1. Obtient tous les processus chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Pour chacun d'eux, affiche des informations sur lui-même et son parent
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Obtient le processus parent
    $parent = $_.Parent

    # Formate une belle sortie
    Write-Host "Processus :" -ForegroundColor Green
    Write-Host "  - Nom: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Son parent :" -ForegroundColor Yellow
    Write-Host "  - Nom: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/11.png" alt="Capture d'écran du script PowerShell affichant les processus Chrome et leurs parents" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/12.png" alt="Capture d'écran de la sortie du script montrant l'arborescence des processus Chrome" dir="ltr"/></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr">Nous voyons immédiatement que les processus avec les ID 4756, 7936, 8268 et 9752 ont été lancés par le processus avec l'ID 14908. Nous pouvons également remarquer un cas intéressant avec le processus ID : 7252, dont le processus parent n'a pas été défini (le parent a peut-être déjà terminé avant la vérification). La modification du script avec une vérification <code><span dir="ltr">if ($parent)</span></code> gère ce cas avec élégance, sans provoquer d'erreur.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="ltr"><code><span dir="ltr">Get-Member</span></code> nous a aidés à découvrir la propriété "cachée" <code><span dir="ltr">Parent</span></code>, qui offre de puissantes capacités pour analyser la hiérarchie des processus.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="ltr">4. Fichier <span dir="ltr">*.ps1</span> (Création de scripts)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Lorsque votre chaîne de commandes devient utile, vous voudrez la sauvegarder pour une utilisation répétée. C'est à cela que servent les <strong>scripts</strong> — des fichiers texte avec l'extension <strong><code><span dir="ltr">.ps1</span></code></strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Autorisation d'exécution des scripts</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Par défaut, l'exécution des scripts locaux est désactivée dans Windows. Pour y remédier <strong>pour l'utilisateur actuel</strong>, exécutez une seule fois dans PowerShell <strong>en tant qu'administrateur</strong> :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="ltr">C'est un paramètre sûr qui permet d'exécuter vos propres scripts et ceux signés par un éditeur de confiance.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Exemple de script <code><span dir="ltr">system_monitor.ps1</span></code></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Créez un fichier avec ce nom et insérez-y le code ci-dessous. Ce script collecte des informations sur le système et génère des rapports.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Script pour créer un rapport sur l'état du système.
.DESCRIPTION
    Collecte des informations sur les processus, services et l'espace disque et génère des rapports.
.PARAMETER OutputPath
    Chemin pour sauvegarder les rapports. Par défaut 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Bloc 1: Préparation ---
Write-Host "Préparation à la création du rapport..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Bloc 2: Collecte de données ---
Write-Host "Collecte d'informations..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Bloc 3: Appel de la fonction pour l'exportation (voir section suivante) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Rapports sauvegardés avec succès dans le dossier $OutputPath" -ForegroundColor Magenta
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="ltr">*Note : la fonction <code><span dir="ltr">Export-Results</span></code> sera définie dans la section suivante comme un exemple de bonne pratique.*</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="ltr">5. Exportation des résultats</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Les données brutes sont bonnes, mais il est souvent nécessaire de les présenter sous une forme pratique pour un être humain ou un autre programme. PowerShell offre de nombreux cmdlets pour l'exportation.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table" dir="ltr">
<table class="has-fixed-layout">
<thead>
<tr>
<th>Méthode</th>
<th>Commande</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Texte simple</strong></td>
<td><code><span dir="ltr">... | Out-File C:\Temp\data.txt</span></code></td>
<td>Redirige la représentation textuelle vers un fichier.</td>
</tr>
<tr>
<td><strong>CSV (pour Excel)</strong></td>
<td><code><span dir="ltr">... | Export-Csv C:\Temp\data.csv -NoTypeInfo</span></code></td>
<td>Exporte des objets en CSV. <code><span dir="ltr">-NoTypeInfo</span></code> supprime la première ligne de service.</td>
</tr>
<tr>
<td><strong>Rapport HTML</strong></td>
<td><code><span dir="ltr">... | ConvertTo-Html -Title "Rapport"</span></code></td>
<td>Crée du code HTML à partir d'objets.</td>
</tr>
<tr>
<td><strong>JSON (pour API, web)</strong></td>
<td><code><span dir="ltr">... | ConvertTo-Json</span></code></td>
<td>Convertit des objets au format JSON.</td>
</tr>
<tr>
<td><strong>XML (format natif PowerShell)</strong></td>
<td><code><span dir="ltr">... | Export-Clixml C:\Temp\data.xml</span></code></td>
<td>Sauvegarde des objets avec tous les types de données. Ils peuvent être restaurés parfaitement via <code><span dir="ltr">Import-Clixml</span></code>.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Ajout au script : fonction d'exportation</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="ltr">Ajoutons à notre script <code><span dir="ltr">system_monitor.ps1</span></code> une fonction qui se chargera de l'exportation. Placez ce code <strong>avant</strong> l'appel de <code><span dir="ltr">Export-Results</span></code>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Exportation en CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Création d'un rapport HTML esthétique
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Top 10 des processus par CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Statistiques des services&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;Rapport système&lt;/title&gt;" -Body "&lt;h1&gt;Rapport système du $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="ltr">Maintenant, notre script ne se contente pas de collecter des données, il les sauvegarde également soigneusement dans deux formats : CSV pour l'analyse et HTML pour une visualisation rapide.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="ltr">Conclusion</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol dir="ltr"><!-- wp:list-item -->
<li>Le <strong>Pipeline (<code><span dir="ltr">|</span></code>)</strong> — est l'outil principal pour combiner des commandes et traiter des objets.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code><span dir="ltr">Get-Member</span></code></strong> — analyse les objets et montre de quoi ils sont faits.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Les <strong>variables (<code><span dir="ltr">$var</span></code>, <code><span dir="ltr">$_</span></code>)</strong> permettent de stocker des données et d'accéder à l'objet actuel dans le pipeline.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Les <strong>fichiers <code><span dir="ltr">.ps1</span></code></strong> transforment les commandes en outils d'automatisation réutilisables.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Les <strong>cmdlets d'exportation</strong> (<code><span dir="ltr">Export-Csv</span></code>, <code><span dir="ltr">ConvertTo-Html</span></code>) exportent les données dans le format approprié.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="ltr"><strong>Dans la prochaine partie, nous appliquerons ces connaissances pour naviguer et gérer le système de fichiers, en explorant les objets <code><span dir="ltr">System.IO.DirectoryInfo</span></code> et <code><span dir="ltr">System.IO.FileInfo</span></code>.</strong></p>
<!-- /wp:paragraph -->[:es]<h2 class="wp-block-heading">1. ¿Qué es la tubería (<code>|</code>)?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>La tubería (pipeline) en PowerShell es un mecanismo para pasar objetos .NET completos (y no solo texto) de un comando a otro, donde cada cmdlet siguiente recibe objetos estructurados con todas sus propiedades y métodos.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>El símbolo <code>|</code> (barra vertical) es el operador de tubería. Su tarea es tomar el resultado (salida) del comando a su izquierda y pasarlo como entrada al comando a su derecha.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Comando 1 (crea objetos)</code> → <code>|</code> → <code>Comando 2 (recibe y procesa objetos)</code> → <code>|</code> → <code>Comando 3 (recibe objetos procesados)</code> → <code>|</code> ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Tubería (Pipeline) clásica de UNIX: Flujo de texto</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>En <code>bash</code>, la tubería transfiere un <strong>flujo de bytes</strong>, que generalmente se interpreta como texto.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-bash"># Encontrar todos los procesos 'nginx' y contar su número
ps -ef | grep 'nginx' | wc -l
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Aquí <code>ps</code> produce texto, <code>grep</code> filtra ese texto y <code>wc</code> cuenta las líneas. Cada utilidad no sabe nada de "procesos", solo trabaja con líneas.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Tubería (Pipeline) de PowerShell: Flujo de objetos</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Ejemplo:</strong> Obtengamos todos los procesos, ordenémoslos por uso de CPU y seleccionemos los 5 más "consumidores".</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/1.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Aquí <code>Get-Process</code> crea <strong>objetos</strong> de procesos. <code>Sort-Object</code> recibe estos <strong>objetos</strong> y los ordena por la propiedad <code>CPU</code>. <code>Select-Object</code> recibe los <strong>objetos</strong> ordenados y selecciona los primeros 5.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Seguramente ha notado en el comando palabras que comienzan con un guion (-): <code>-Property</code>, <code>-Descending</code>, <code>-First</code>. Estos son parámetros.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Los parámetros son configuraciones, interruptores e instrucciones para un cmdlet. Permiten controlar <strong>CÓMO</strong> un comando realizará su trabajo. Sin parámetros, el comando funciona en modo predeterminado, y con parámetros, le da instrucciones específicas.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Principales tipos de parámetros:</h5>
<!-- /wp:heading -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Parámetro con valor: requiere información adicional.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>-Property CPU</code>: Decimos a <code>Sort-Object</code> por qué propiedad ordenar. <code>CPU</code> es el valor del parámetro.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>-First 5</code>: Decimos a <code>Select-Object</code> cuántos objetos seleccionar. <code>5</code> es el valor del parámetro.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Parámetro-interruptor (flag): No requiere valor. Su sola presencia en el comando activa o desactiva un comportamiento específico.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>-Descending</code>: Este flag le dice a <code>Sort-Object</code> que cambie el orden de clasificación a inverso (de mayor a menor). No necesita un valor adicional, es una instrucción por sí mismo.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/2.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Esta instrucción responde a una pregunta muy simple: <strong>"¿Cuántos procesos con el nombre <code>svchost.exe</code> están actualmente ejecutándose en mi sistema?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Análisis paso a paso</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Paso 1: <code>Get-Process -Name 'svchost'</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Esta parte del comando se comunica con el sistema operativo y le pide que encuentre <strong>todos sin excepción</strong> los procesos en ejecución cuyo nombre de archivo ejecutable sea <code>svchost.exe</code>.<br>A diferencia de los procesos como <code>notepad</code> (de los cuales suele haber uno o dos), siempre hay <strong>muchos</strong> procesos <code>svchost</code> en el sistema. El comando devolverá un <strong>array (colección) de objetos</strong>, donde cada objeto es un proceso <code>svchost</code> individual y completo con su ID único, uso de memoria, etc.<br>PowerShell encontró en el sistema, por ejemplo, 90 procesos <code>svchost</code> y ahora tiene en sus manos una colección de 90 objetos.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Paso 2: <code>|</code> (Operador de tubería)</strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Este símbolo toma la colección de 90 objetos <code>svchost</code>, obtenida en el primer paso, y comienza a pasarlos <strong>uno por uno</strong> a la siguiente instrucción.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Paso 3: <code>Measure-Object</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Dado que llamamos a <code>Measure-Object</code> sin parámetros (como <code>-Property</code>, <code>-Sum</code>, etc.), realiza su operación <strong>predeterminada</strong>: simplemente cuenta la cantidad de "elementos" que se le pasaron.<br>Uno, dos, tres ... Después de contar todos los objetos, <code>Measure-Object</code> crea <strong>su propio objeto de resultado</strong>, que tiene una propiedad <code>Count</code>, igual al número total.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong><code>Count: 90</code></strong> — esta es la respuesta a nuestra pregunta. Hay 90 procesos <code>svchost</code> en ejecución.<br>Los otros campos están vacíos porque no le pedimos a <code>Measure-Object</code> que realizara cálculos más complejos.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Ejemplo con <code>svchost</code> y parámetros</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Cambiemos nuestra tarea. Ahora no solo queremos contar los procesos <code>svchost</code>, sino saber <strong>cuánta memoria RAM (en megabytes) consumen en total</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Para esto, necesitaremos parámetros:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>-Property WorkingSet64</code>: Esta instrucción le dice a <code>Measure-Object</code>: "De cada objeto <code>svchost</code> que te llegue, toma el valor numérico de la propiedad <code>WorkingSet64</code> (es el uso de memoria en bytes)".</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>-Sum</code>: Esta instrucción-flag dice: "Suma todos estos valores que tomaste de la propiedad <code>WorkingSet64</code>".</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Nuestro nuevo comando se verá así:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/3.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><code>Get-Process</code> encontrará el número de objetos <code>svchost</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>La tubería <code>|</code> los pasará a <code>Measure-Object</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Pero ahora <code>Measure-Object</code> funciona de una nueva manera:
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Toma el primer objeto <code>svchost</code>, mira su propiedad <code>.WorkingSet64</code> (por ejemplo, <code>25000000</code> bytes) y memoriza este número.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Toma el segundo objeto, mira su <code>.WorkingSet64</code> (por ejemplo, <code>15000000</code> bytes) y lo suma al anterior.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>...y así sucesivamente para todos los objetos.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Al final, <code>Measure-Object</code> creará un objeto-resultado, pero ahora será diferente.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><code>Count: 92</code></strong>: Número de objetos.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>Sum: 1661890560</code></strong>: Es la suma total de todos los valores de <code>WorkingSet64</code> en bytes.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>Property: WorkingSet64</code></strong>: Este campo ahora también está lleno, nos informa qué propiedad se utilizó para los cálculos.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2 class="wp-block-heading">2. Variables (Normales y la especial <code>$_</code>)</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Una variable es un almacenamiento con nombre en la memoria que contiene algún valor.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Este valor puede ser cualquier cosa: texto, número, fecha o, lo que es más importante para PowerShell, un objeto completo o incluso una colección de objetos. El nombre de una variable en PowerShell siempre comienza con un signo de dólar (<code>$</code>).<br>Ejemplos: <code>$name</code>, <code>$counter</code>, <code>$processList</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>¿Variable especial <code>$_</code>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>$_</code> — es la abreviatura de "objeto actual" o "esta cosa".<br>Imagine una línea de producción en una fábrica. Diferentes piezas (objetos) se mueven a lo largo de ella.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>$_</code> — es la pieza que está justo ahora frente a usted (o frente al robot procesador).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Fuente (<code>Get-Process</code>) — vierte en la línea una caja entera con piezas (todos los procesos).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Tubería (<code>|</code>) — hace que estas piezas se muevan a lo largo de la cinta una por una.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Procesador (<code>Where-Object</code> o <code>ForEach-Object</code>) — es un robot que mira cada pieza.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>La variable <code>$_</code> — es la pieza que ahora está en las "manos" del robot.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Cuando el robot termina con una pieza, la línea le suministra la siguiente, y <code>$_</code> ahora apuntará a ella.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Contemos cuánta memoria total utilizan los procesos <code>svchost</code> y mostremos el resultado en el monitor.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># 1. Ejecutamos el comando y guardamos su complejo objeto-resultado en la variable $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Ahora podemos trabajar con el objeto guardado. Extraemos de él la propiedad Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Mostramos el resultado en pantalla, usando la nueva variable
Write-Host "Todos los procesos svchost utilizan $memoryInMB MB de memoria."
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/4.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>Write-Host</code> — es un cmdlet especializado, cuya única tarea es <strong>mostrar texto directamente al usuario en la consola</strong>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Cadena entre comillas dobles: <code>"..."</code> - una cadena de texto que pasamos al cmdlet <code>Write-Host</code> como argumento. ¿Por qué comillas dobles y no simples?
<ul class="wp-block-list"><!-- wp:list-item -->
<li>En PowerShell hay dos tipos de comillas:</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Simples (<code>'...'</code>):</strong> Crean una <strong>cadena literal</strong>. Todo lo que hay dentro de ellas se percibe como texto normal, sin excepciones.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Dobles (<code>"..."</code>):</strong> Crean una <strong>cadena expandible (o de sustitución)</strong>. PowerShell "escanea" dicha cadena en busca de variables (que comienzan con <code>$</code>) y sustituye sus valores en su lugar.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>$memoryInMB</code>. Es una variable en la que <strong>en el paso anterior</strong> de nuestro script pusimos el resultado de los cálculos. Cuando <code>Write-Host</code> recibe una cadena entre comillas dobles, se produce un proceso llamado <strong>"expansión de cadenas" (String Expansion)</strong>:
<ol class="wp-block-list"><!-- wp:list-item -->
<li>PowerShell ve el texto <code>"Todos los procesos svchost utilizan "</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Luego se encuentra con la construcción <code>$memoryInMB</code>. Entiende que no es solo texto, sino una variable.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Mira en la memoria, encuentra el valor almacenado en <code>$memoryInMB</code> (por ejemplo, <code>1585.52</code>).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Sustituye este valor</strong> directamente en la cadena.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Luego añade el resto del texto: <code>" MB de memoria."</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Como resultado, a <code>Write-Host</code> se le pasa una cadena ya lista y ensamblada: <code>"Todos los procesos svchost utilizan 1585.52 MB de memoria."</code>.</li>
<!-- /wp:list-item --></ol>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Inicie el bloc de notas:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li>Encontramos el proceso del Bloc de Notas y lo guardamos en la variable <code>$notepadProcess</code></li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Accedemos a la propiedad 'Id' de este objeto a través del punto y lo mostramos</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">$notepadProcess = Get-Process -Name notepad
Write-Host "ID del proceso 'Bloc de Notas' es: $($notepadProcess.Id)"
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/5.png" alt="5"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>❗ Importante:</strong><br><code>Write-Host</code> "rompe" la tubería. El texto que produce no se puede pasar más allá por la tubería para su procesamiento. Está destinado solo para mostrar.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading">3. Get-Member (Inspector de objetos)</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Sabemos que los objetos "fluyen" a través de la tubería. Pero, ¿cómo saber de qué están compuestos? ¿Qué propiedades tienen y qué acciones (métodos) se pueden realizar con ellos?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>El cmdlet <code>Get-Member</code> (alias: <code>gm</code>) es la herramienta principal para la investigación.<br>Antes de trabajar con un objeto, páselo por <code>Get-Member</code> para ver todas sus capacidades.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Analicemos los objetos que crea <code>Get-Process</code>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/6.png" alt="6"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Analicemos cada parte de la salida de <code>Get-Member</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>TypeName: System.Diagnostics.Process</code> - Este es el "nombre de tipo" completo y oficial del objeto de la biblioteca .NET. Es su "pasaporte".<br>Esta línea le dice que todos los objetos que devuelve <code>Get-Process</code> son objetos de tipo <code>System.Diagnostics.Process</code>. Esto garantiza que todos tendrán el mismo conjunto de propiedades y métodos.<br>Puede <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">buscar en Google</a> "<code>System.Diagnostics.Process</code>" para encontrar la documentación oficial de Microsoft con información aún más detallada.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Columna 1: <code>Name</code><br>Es el nombre simple y legible de la propiedad, método u otro "miembro" del objeto. Este es el nombre que utilizará en su código para acceder a los datos o realizar acciones.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Columna 2: <code>MemberType</code> (Tipo de miembro)<br>Esta es la columna más importante para entender. Clasifica <strong>qué es</strong> cada objeto. Es su "rol", que le dice <strong>CÓMO</strong> usarlo.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><code>Property</code> (Propiedad):</strong> <strong>característica</strong> o <strong>porción de datos</strong> almacenada dentro del objeto. Puede "leer" su valor.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Ejemplos en la captura de pantalla:</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. Son simplemente datos que se pueden ver.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>Method</code> (Método):</strong> <strong>ACCIÓN</strong> que se puede realizar con el objeto. Los métodos siempre se invocan con paréntesis <code>()</code>.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Ejemplos en la captura de pantalla:</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. Escribiría <code>$process.Kill()</code> o <code>$process.Refresh()</code>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>AliasProperty</code> (Propiedad de alias):</strong> <strong>alias amigable</strong> para otra propiedad más larga. PowerShell los agrega para mayor comodidad y brevedad.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Ejemplos en la captura de pantalla:</em> <code>WS</code> — es un alias corto para <code>WorkingSet64</code>. <code>Name</code> — para <code>ProcessName</code>. <code>VM</code> — para <code>VirtualMemorySize64</code>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>Event</code> (Evento):</strong> <strong>NOTIFICACIÓN</strong> de que algo ha ocurrido, a la que se puede "suscribir".
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Ejemplo en la captura de pantalla:</em> <code>Exited</code>. Su script puede "escuchar" este evento para realizar alguna acción inmediatamente después de que el proceso finalice.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>CodeProperty</code> y <code>NoteProperty</code>:</strong> tipos especiales de propiedades, a menudo añadidas por el propio PowerShell para mayor comodidad. <code>CodeProperty</code> calcula su valor "sobre la marcha", mientras que <code>NoteProperty</code> es una propiedad de nota simple añadida al objeto.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Columna 3: <code>Definition</code> (Definición)<br>Es la <strong>definición técnica</strong> o "firma" del miembro. Le proporciona los detalles exactos para su uso. Su contenido depende de <code>MemberType</code>:
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Para <code>AliasProperty</code>:</strong> Muestra <strong>a qué equivale el alias</strong>. ¡Esto es increíblemente útil!
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Ejemplo en la captura de pantalla:</em> <code>WS = WorkingSet64</code>. Inmediatamente ve que <code>WS</code> — es simplemente una forma abreviada de <code>WorkingSet64</code>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Para <code>Property</code>:</strong> Muestra el <strong>tipo de datos</strong> que se almacena en la propiedad (por ejemplo, <code>int</code> para un número entero, <code>string</code> para texto, <code>datetime</code> para fecha y hora), y lo que se puede hacer con ella (<code>{get;}</code> — solo leer, <code>{get;set;}</code> — leer y modificar).
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Ejemplo en la captura de pantalla:</em> <code>int BasePriority {get;}</code>. Esta es una propiedad de tipo entero que solo se puede leer.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Para <code>Method</code>:</strong> Muestra lo que devuelve el método (por ejemplo, <code>void</code> — nada, <code>bool</code> — true/false) y qué <strong>parámetros</strong> (datos de entrada) acepta entre paréntesis.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Ejemplo en la captura de pantalla:</em> <code>void Kill()</code>. Esto significa que el método <code>Kill</code> no devuelve nada y puede ser llamado sin parámetros. También hay una segunda versión <code>void Kill(bool entireProcessTree)</code>, que acepta un valor booleano (true/false).</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">En formato de tabla</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>Columna</th><th>¿Qué es?</th><th>Ejemplo de la captura de pantalla</th><th>¿Para qué sirve?</th></tr></thead><tbody><tr><td><strong>Name</strong></td><td>Nombre que usa en el código.</td><td><code>Kill</code>, <code>WS</code>, <code>Name</code></td><td>acceder a una propiedad o método (<code>$process.WS</code>, <code>$process.Kill()</code>).</td></tr><tr><td><strong>MemberType</strong></td><td>Tipo de miembro (datos, acción, etc.).</td><td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td><td><strong>cómo</strong> usarlo (leer un valor o llamar con <code>()</code>).</td></tr><tr><td><strong>Definition</strong></td><td>Detalles técnicos.</td><td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td><td>qué hay detrás del alias y qué parámetros necesita el método.</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Ejemplo: Trabajar con ventanas de procesos</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problema:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Abrí muchas ventanas del Bloc de Notas. ¿Cómo puedo minimizarlas programáticamente todas excepto la principal, y luego cerrar solo aquella cuyo título contenga la palabra 'Untitled'?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Investigación con <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Necesitamos encontrar propiedades relacionadas con la ventana y su título.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name notepad | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><strong>Análisis del resultado de <code>Get-Member</code>:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Al revisar las propiedades, encontramos <code>MainWindowTitle</code>. Tipo <code>string</code>. ¡Genial, es el título de la ventana principal!</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>En los métodos, vemos <code>CloseMainWindow()</code>. Esta es una forma "más suave" de cerrar una ventana que <code>Kill()</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>También en los métodos está <code>WaitForInputIdle()</code>. Suena interesante, quizás esto nos ayude a esperar hasta que el proceso esté listo para interactuar.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><img src="assets/02/7.png" alt="7"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Get-Member</code> nos mostró la propiedad <code>MainWindowTitle</code>, que es la clave para resolver la tarea y permite interactuar con los procesos basándose en el estado de sus ventanas, y no solo por su nombre.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Solución:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ahora podemos construir la lógica basada en el título de la ventana.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># 1. Encontramos todos los procesos del Bloc de Notas
$notepads = Get-Process -Name notepad

# 2. Recorremos cada uno y verificamos el título
foreach ($pad in $notepads) {
    # Para cada proceso ($pad) verificamos su propiedad MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Encontrado Bloc de Notas sin guardar (ID: $($pad.Id)). Cerrando su ventana..."
        # $pad.CloseMainWindow() # Descomente para cerrar realmente
        Write-Host "La ventana '$($pad.MainWindowTitle)' se cerraría." -ForegroundColor Yellow
    } else {
        Write-Host "Saltando Bloc de Notas con título: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/8.png" alt="8"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/9.png" alt="9"></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Ejemplo: Encontrar el proceso padre</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problema:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"A veces veo muchos procesos hijos de <code>chrome.exe</code> en el sistema. ¿Cómo puedo saber cuál es el proceso principal, el 'padre' que los inició a todos?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Investigación con <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Necesitamos encontrar algo que vincule un proceso con otro.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/10.png" alt="10"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Análisis del resultado de <code>Get-Member</code>:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Al revisar cuidadosamente la lista, encontramos una propiedad de tipo <code>CodeProperty</code> llamada <code>Parent</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Su definición (<code>Definition</code>) — <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>. Esta es una propiedad calculada que, al ser accedida, devuelve un <strong>objeto del proceso padre</strong>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Solución:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ahora podemos escribir un script que, para cada proceso de <code>chrome</code>, muestre información sobre él y su padre.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># 1. Obtenemos todos los procesos de chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Para cada uno de ellos, mostramos información sobre él y su padre
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Obtenemos el proceso padre
    $parent = $_.Parent

    # Formamos una salida bonita
    Write-Host "Proceso:" -ForegroundColor Green
    Write-Host "  - Nombre: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Su padre:" -ForegroundColor Yellow
    Write-Host "  - Nombre: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/11.png" alt="11"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/12.png" alt="12"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Vemos inmediatamente que los procesos con ID 4756, 7936, 8268 y 9752 fueron iniciados por el proceso con ID 14908. También se puede notar un caso interesante con el proceso ID: 7252, cuyo proceso padre no se pudo determinar (posiblemente el padre ya había terminado en el momento de la verificación). La modificación del script con la verificación <code>if ($parent)</code> maneja este caso de forma elegante, sin causar errores. <code>Get-Member</code> nos ayudó a descubrir la propiedad "oculta" <code>Parent</code>, que proporciona potentes capacidades para analizar la jerarquía de procesos.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading -->
<h2 class="wp-block-heading">4. Archivo <code>.ps1</code> (Creación de scripts)</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Cuando su cadena de comandos se vuelve útil, querrá guardarla para usarla varias veces. Para eso están los <strong>scripts</strong>: archivos de texto con la extensión <code>.ps1</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Permiso para ejecutar scripts</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Por defecto, Windows prohíbe la ejecución de scripts locales. Para solucionarlo <strong>para el usuario actual</strong>, ejecute una vez en PowerShell <strong>como administrador</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Esta es una configuración segura que permite ejecutar sus propios scripts y scripts firmados por un editor de confianza.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Ejemplo de script <code>system_monitor.ps1</code></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Cree un archivo con este nombre e inserte el código de abajo. Este script recopila información del sistema y genera informes.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Script para crear un informe sobre el estado del sistema.
.DESCRIPTION
    Recopila información sobre procesos, servicios y espacio en disco y genera informes.
.PARAMETER OutputPath
    Ruta para guardar los informes. Por defecto 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Bloque 1: Preparación ---
Write-Host "Preparación para crear el informe..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Bloque 2: Recopilación de datos ---
Write-Host "Recopilando información..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Bloque 3: Llamada a la función para exportar (ver la siguiente sección) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Informes guardados exitosamente en la carpeta $OutputPath" -ForegroundColor Magenta
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><em>Nota: la función <code>Export-Results</code> se definirá en la siguiente sección como ejemplo de buena práctica.</em></p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading -->
<h2 class="wp-block-heading">5. Exportación de resultados</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Los datos limpios son buenos, pero a menudo necesitan presentarse de una manera que sea conveniente para una persona u otro programa. PowerShell ofrece muchos cmdlets para la exportación.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>Método</th><th>Comando</th><th>Descripción</th></tr></thead><tbody><tr><td><strong>Texto plano</strong></td><td><code>... | Out-File C:\Temp\data.txt</code></td><td>Redirige la representación de texto a un archivo.</td></tr><tr><td><strong>CSV (para Excel)</strong></td><td><code>... | Export-Csv C:\Temp\data.csv -NoTypeInfo</code></td><td>Exporta objetos a CSV. <code>-NoTypeInfo</code> elimina la primera línea de servicio.</td></tr><tr><td><strong>Informe HTML</strong></td><td><code>... | ConvertTo-Html -Title "Informe"</code></td><td>Crea código HTML a partir de objetos.</td></tr><tr><td><strong>JSON (para API, web)</strong></td><td><code>... | ConvertTo-Json</code></td><td>Transforma objetos al formato JSON.</td></tr><tr><td><strong>XML (formato nativo de PowerShell)</strong></td><td><code>... | Export-Clixml C:\Temp\data.xml</code></td><td>Guarda objetos con todos los tipos de datos. Se pueden restaurar perfectamente a través de <code>Import-Clixml</code>.</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Adición al script: función de exportación</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Agreguemos una función a nuestro script <code>system_monitor.ps1</code> que se encargará de la exportación. Coloque este código <strong>antes</strong> de la llamada a <code>Export-Results</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Exportar a CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Creación de un informe HTML bonito
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Top-10 procesos por CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Estadísticas de servicios&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;Informe del sistema&lt;/title&gt;" -Body "&lt;h1&gt;Informe del sistema de $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Ahora nuestro script no solo recopila datos, sino que también los guarda cuidadosamente en dos formatos: CSV para análisis y HTML para una visualización rápida.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Conclusión</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Tubería (<code>|</code>)</strong> — la herramienta principal para combinar comandos y procesar objetos.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>Get-Member</code></strong> — análisis de objetos que muestra de qué están compuestos.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Variables (<code>$var</code>, <code>$_</code>)</strong> permiten guardar datos y acceder al objeto actual en la tubería.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Archivos <code>.ps1</code></strong> transforman comandos en herramientas de automatización reutilizables.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Cmdlets de exportación</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) exportan datos en el formato correspondiente.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>En la siguiente parte aplicaremos estos conocimientos para navegar y administrar el sistema de archivos, explorando los objetos <code>System.IO.DirectoryInfo</code> y <code>System.IO.FileInfo</code>.</strong></p>
<!-- /wp:paragraph -->[:he]<h2 class="wp-block-heading">פילוסופיית <span dir="ltr">PowerShell</span>.</h2>
<!-- /wp:heading -->

<!-- wp:heading -->
<h2 class="wp-block-heading">חלק 2: קונסולת (<span dir="ltr">Pipeline</span>), משתנים, <span dir="ltr">Get-Member</span>, קובץ <span dir="ltr">.ps1</span> וייצוא תוצאות</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>❗ חשוב:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>אני כותב על <span dir="ltr">PS7</span> (<span dir="ltr">PowerShell 7</span>). הוא שונה מ-<span dir="ltr">PS5</span> (<span dir="ltr">PowerShell 5</span>). החל מהגרסה השביעית, <span dir="ltr">PowerShell</span> הפך לחוצה פלטפורמות. עקב כך, השתנה אופן הפעולה של כמה פקודות.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>בחלק הראשון קבענו עיקרון מפתח: <span dir="ltr">PowerShell</span> עובד עם <strong>אובייקטים</strong>, ולא עם טקסט. פוסט זה מוקדש לכמה כלי <span dir="ltr">PowerShell</span> חשובים: נלמד כיצד להעביר אובייקטים דרך <strong>קונסולה</strong> (<span dir="ltr">Pipeline</span>), לנתח אותם באמצעות <span dir="ltr"><code>Get-Member</code></span>, לשמור תוצאות <strong>במשתנים</strong> ולאוטומט את כל זה <strong>בקובצי סקריפט (<span dir="ltr"><code>.ps1</code></span>)</strong> עם <strong>ייצוא</strong> התוצאות לפורמטים נוחים.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">1. מהו קונסולה (<span dir="ltr">Pipeline</span>)?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>קונסולה ב-<span dir="ltr">PowerShell</span> הוא מנגנון להעברת אובייקטי <span dir="ltr">.NET</span> מלאים (ולא רק טקסט) מפונקציה אחת לאחרת, כאשר כל <span dir="ltr">cmdlet</span> מקבל אובייקטים מובנים עם כל המאפיינים והשיטות שלהם.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>הסמל <span dir="ltr"><code>|</code></span> (קו אנכי) – הוא אופרטור הקונסולה. מטרתו היא לקחת את הפלט (תוצאה) של הפקודה הממוקמת משמאלו ולהעביר אותה כקלט לפקודה הממוקמת מימינו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>פקודה 1 (יוצרת אובייקטים)</code></span> → <span dir="ltr"><code>|</code></span> → <span dir="ltr"><code>פקודה 2 (מקבלת ומעבדת אובייקטים)</code></span> → <span dir="ltr"><code>|</code></span> → <span dir="ltr"><code>פקודה 3 (מקבלת אובייקטים מעובדים)</code></span> → <span dir="ltr">|</span> <span dir="ltr">...</span></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">קונסולת <span dir="ltr">UNIX</span> קלאסית: זרם טקסט</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>ב-<span dir="ltr"><code>bash</code></span>, הקונסולה מעבירה <strong>זרם בתים</strong>, אשר בדרך כלל מתפרש כטקסט.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># מצא את כל תהליכי 'nginx' וספור את כמותם
ps -ef | grep 'nginx' | wc -l
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>כאן <span dir="ltr"><code>ps</code></span> פולט טקסט, <span dir="ltr"><code>grep</code></span> מסנן את הטקסט הזה, ו-<span dir="ltr"><code>wc</code></span> סופר שורות. כל כלי עזר לא יודע דבר על "תהליכים", הוא עובד רק עם מחרוזות.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">קונסולת <span dir="ltr">PowerShell</span>: זרם אובייקטים</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>דוגמה:</strong> בואו נקבל את כל התהליכים, נמיין אותם לפי שימוש ב-<span dir="ltr">CPU</span> ונבחר את 5 ה"רעבים" ביותר.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/1.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>כאן <span dir="ltr"><code>Get-Process</code></span> יוצר <strong>אובייקטים</strong> של תהליכים. <span dir="ltr"><code>Sort-Object</code></span> מקבל את ה<strong>אובייקטים</strong> הללו וממיין אותם לפי המאפיין <span dir="ltr"><code>CPU</code></span>. <span dir="ltr"><code>Select-Object</code></span> מקבל את ה<strong>אובייקטים</strong> הממוינים ובוחר את 5 הראשונים.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>בטח שמתם לב בפקודה למילים שמתחילות במקף (<span dir="ltr">-</span>): <span dir="ltr">-Property</span>, <span dir="ltr">-Descending</span>, <span dir="ltr">-First</span>. אלה פרמטרים.<br>פרמטרים הם הגדרות, מתגים והוראות ל-<span dir="ltr">cmdlet</span>. הם מאפשרים לשלוט באופן שבו הפקודה תבצע את עבודתה. ללא פרמטרים, הפקודה עובדת במצב ברירת מחדל, ועם פרמטרים אתם נותנים לה הוראות ספציפיות.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>סוגי פרמטרים עיקריים:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>פרמטר עם ערך: דורש מידע נוסף.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>-Property CPU</code></span>: אנחנו אומרים ל-<span dir="ltr"><code>Sort-Object</code></span> לפי איזה מאפיין למיין. <span dir="ltr"><code>CPU</code></span> – זה ערך הפרמטר.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><span dir="ltr"><code>-First 5</code></span>: אנחנו אומרים ל-<span dir="ltr"><code>Select-Object</code></span> כמה אובייקטים לבחור. <span dir="ltr"><code>5</code></span> – זה ערך הפרמטר.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>פרמטר-מתג (<span dir="ltr">flag</span>): אינו דורש ערך. עצם נוכחותו בפקודה מפעילה או מכבה התנהגות מסוימת.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>-Descending</code></span>: הדגל הזה אומר ל-<span dir="ltr"><code>Sort-Object</code></span> לשנות את סדר המיון לסדר הפוך (מהגדול לקטן). הוא לא צריך ערך נוסף – הוא בעצמו הוראה.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/2.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>פקודה זו עונה על שאלה פשוטה מאוד:<br><strong>"כמה בדיוק תהליכים בשם <span dir="ltr"><code>svchost.exe</code></span> פועלים כעת במערכת שלי?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">פירוט שלבים</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>שלב 1: <span dir="ltr"><code>Get-Process -Name 'svchost'</code></span></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>חלק זה של הפקודה פונה למערכת ההפעלה ומבקש למצוא <strong>את כל ללא יוצא מן הכלל</strong> התהליכים הפועלים, ששם קובץ ההרצה שלהם הוא <span dir="ltr"><code>svchost.exe</code></span>.<br>בניגוד לתהליכים מסוג <span dir="ltr"><code>notepad</code></span> (שבדרך כלל יש אחד או שניים מהם), תהליכי <span dir="ltr"><code>svchost</code></span> תמיד <strong>רבים</strong> במערכת. הפקודה תחזיר <strong>מערך (אוסף) אובייקטים</strong>, כאשר כל אובייקט הוא תהליך <span dir="ltr"><code>svchost</code></span> נפרד ומלא עם <span dir="ltr">ID</span> ייחודי משלו, שימוש בזיכרון וכו'.<br><span dir="ltr">PowerShell</span> מצא במערכת, לדוגמה, 90 תהליכי <span dir="ltr"><code>svchost</code></span> וכעת מחזיק בידיו אוסף של 90 אובייקטים.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>שלב 2: <span dir="ltr"><code>|</code></span> (אופרטור הקונסולה)</strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>סמל זה לוקח את אוסף 90 אובייקטי <span dir="ltr"><code>svchost</code></span>, שהתקבלו בשלב הראשון, ומתחיל להעביר אותם <strong>אחד אחד</strong> כקלט לפקודה הבאה.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>שלב 3: <span dir="ltr"><code>Measure-Object</code></span></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>מכיוון שקראנו ל-<span dir="ltr"><code>Measure-Object</code></span> ללא פרמטרים (כגון <span dir="ltr"><code>-Property</code></span>, <span dir="ltr"><code>-Sum</code></span> וכו'), הוא מבצע את פעולתו <strong>כברירת מחדל</strong> – פשוט סופר את כמות ה"פריטים" שהועברו אליו.<br>אחד, שניים, שלושה... לאחר שכל האובייקטים נספרו, <span dir="ltr"><code>Measure-Object</code></span> יוצר <strong>אובייקט תוצאה משלו</strong>, ובו קיים מאפיין <span dir="ltr"><code>Count</code></span>, השווה למספר הסופי.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong><span dir="ltr"><code>Count: 90</code></span></strong> – זוהי התשובה לשאלתנו. 90 תהליכי <span dir="ltr"><code>svchost</code></span> פועלים.<br>שאר השדות ריקים, משום שלא ביקשנו מ-<span dir="ltr"><code>Measure-Object</code></span> לבצע חישובים מורכבים יותר.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">דוגמה עם <span dir="ltr">svchost</span> ופרמטרים</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>בואו נשנה את המשימה שלנו. עכשיו אנחנו רוצים לא רק לספור את תהליכי <span dir="ltr"><code>svchost</code></span>, אלא לדעת <strong>כמה סך הכל זיכרון <span dir="ltr">RAM</span> (במגה-בייטים) הם צורכים יחד</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>לשם כך נצטרך פרמטרים:</p>
<!-- /wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>-Property WorkingSet64</code></span>: הוראה זו אומרת ל-<span dir="ltr"><code>Measure-Object</code></span>: "מכל אובייקט <span dir="ltr"><code>svchost</code></span> שיגיע אליך, קח את הערך המספרי מהמאפיין <span dir="ltr"><code>WorkingSet64</code></span> (זהו שימוש בזיכרון בבתים)".</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><span dir="ltr"><code>-Sum</code></span>: הוראת-דגל זו אומרת: "סכום את כל הערכים האלה שלקחת מהמאפיין <span dir="ltr"><code>WorkingSet64</code></span>".</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>הפקודה החדשה שלנו תיראה כך:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/3.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>Get-Process</code></span> ימצא את כמות אובייקטי <span dir="ltr"><code>svchost</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>הקונסולה <span dir="ltr"><code>|</code></span> תעביר אותם ל-<span dir="ltr"><code>Measure-Object</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>אבל עכשיו <span dir="ltr"><code>Measure-Object</code></span> עובד באופן חדש:
<ul class="wp-block-list"><!-- wp:list-item -->
<li>הוא לוקח את אובייקט <span dir="ltr"><code>svchost</code></span> הראשון, מסתכל על המאפיין <span dir="ltr"><code>.WorkingSet64</code></span> שלו (לדוגמה, <span dir="ltr"><code>25000000</code></span> בתים) וזוכר את המספר הזה.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>לוקח את האובייקט השני, מסתכל על המאפיין <span dir="ltr"><code>.WorkingSet64</code></span> שלו (לדוגמה, <span dir="ltr"><code>15000000</code></span> בתים) ומוסיף אותו לקודם.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>...וכן הלאה עבור כל האובייקטים.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>בסופו של דבר, <span dir="ltr"><code>Measure-Object</code></span> ייצור אובייקט-תוצאה, אך כעת הוא יהיה שונה.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Count: 92</code></span></strong>: כמות האובייקטים.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Sum: 1661890560</code></span></strong>: זהו הסכום הכולל של כל ערכי <span dir="ltr"><code>WorkingSet64</code></span> בבתים.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Property: WorkingSet64</code></span></strong>: שדה זה כעת גם מלא, והוא מודיע לנו איזה מאפיין ספציפי שימש לחישובים.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">2. משתנים (רגילים ו-<span dir="ltr"><code>$_</code></span> מיוחד)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>משתנה הוא אחסון בעל שם בזיכרון, המכיל ערך כלשהו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>ערך זה יכול להיות כל דבר: טקסט, מספר, תאריך או, מה שהכי חשוב ל-<span dir="ltr">PowerShell</span>, אובייקט שלם או אפילו אוסף של אובייקטים. שם המשתנה ב-<span dir="ltr">PowerShell</span> תמיד מתחיל בסימן דולר (<span dir="ltr"><code>$</code></span>).<br>דוגמאות: <span dir="ltr"><code>$name</code></span>, <span dir="ltr"><code>$counter</code></span>, <span dir="ltr"><code>$processList</code></span>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>משתנה מיוחד <span dir="ltr"><code>$_</code></span>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>$_</code></span> הוא קיצור ל"האובייקט הנוכחי" או "הדבר הזה".<br>דמיינו קונסולה במפעל. עליו נעות חלקים שונים (אובייקטים).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>$_</code></span> – זהו החלק שנמצא כרגע מולכם (או מול הרובוט המעבד).<br>מקור (<span dir="ltr">Get-Process</span>) – מפזר על הקונסולה קופסה שלמה עם חלקים (כל התהליכים).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>קונסולה (<span dir="ltr">|</span>) – גורם לחלקים אלה לנוע על הסרט אחד אחד.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>מעבד (<span dir="ltr">Where-Object</span> או <span dir="ltr">ForEach-Object</span>) – זהו רובוט שמסתכל על כל חלק.<br>המשתנה <span dir="ltr"><code>$_</code></span> – זהו החלק שנמצא כעת ב"ידיו" של הרובוט.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>כאשר הרובוט מסיים עם חלק אחד, הקונסולה מזין לו את הבא, ו-<span dir="ltr"><code>$_</code></span> יצביע כעת עליו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>בואו נספור כמה זיכרון בסך הכל צורכים תהליכי <span dir="ltr"><code>svchost</code></span>, ונציג את התוצאה על המסך.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. מבצעים את הפקודה ושומרים את אובייקט התוצאה המורכב שלה במשתנה $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. כעת אנו יכולים לעבוד עם האובייקט השמור. אנו שולפים ממנו את המאפיין Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. מציגים את התוצאה על המסך, באמצעות המשתנה החדש
Write-Host "כל תהליכי svchost משתמשים ב- $memoryInMB מ"&#91;PSCustomObject]@{B זיכרון."
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/4.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>Write-Host</code></span> – זהו <span dir="ltr">cmdlet</span> מיוחד, שמשימתו היחידה היא <strong>להציג טקסט ישירות למשתמש בקונסולה</strong>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>שורה בגרשיים כפולים: <span dir="ltr"><code>"..."</code></span> - מחרוזת טקסט שאנו מעבירים ל-<span dir="ltr">cmdlet</span> <span dir="ltr"><code>Write-Host</code></span> כארגומנט. מדוע גרשיים כפולים ולא בודדים?
<p>ב-<span dir="ltr">PowerShell</span> יש שני סוגי גרשיים:</p>
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>גרשיים בודדים (<span dir="ltr"><code>'...'</code></span>):</strong> יוצרים <strong>מחרוזת מילולית</strong>. כל מה שבתוכם נתפס כטקסט רגיל, ללא יוצא מן הכלל.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>גרשיים כפולים (<span dir="ltr"><code>"..."</code></span>):</strong> יוצרים <strong>מחרוזת ניתנת להרחבה (או החלפה)</strong>. <span dir="ltr">PowerShell</span> "סורק" מחרוזת כזו כדי למצוא משתנים (שמתחילים ב-<span dir="ltr"><code>$</code></span>) ומחליף אותם בערכיהם.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><span dir="ltr"><code>$memoryInMB</code></span>. זהו משתנה, שבשלב הקודם של הסקריפט שלנו הכנסנו לתוכו את תוצאת החישובים. כאשר <span dir="ltr"><code>Write-Host</code></span> מקבל מחרוזת בגרשיים כפולים, מתרחש תהליך הנקרא <strong>"הרחבת מחרוזות" (<span dir="ltr">String Expansion</span>)</strong>:
<ol class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr">PowerShell</span> רואה את הטקסט <span dir="ltr"><code>"כל תהליכי svchost משתמשים ב- "</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>לאחר מכן הוא נתקל במבנה <span dir="ltr"><code>$memoryInMB</code></span>. הוא מבין שזה לא רק טקסט, אלא משתנה.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>הוא מביט בזיכרון, מוצא את הערך השמור ב-<span dir="ltr"><code>$memoryInMB</code></span> (לדוגמה, <span dir="ltr"><code>1585.52</code></span>).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>הוא <strong>מחליף את הערך הזה</strong> ישירות לתוך המחרוזת.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>לאחר מכן הוא מוסיף את שאר הטקסט: <span dir="ltr"><code>" מ"</code></span><span dir="ltr"><code>[PSCustomObject]@{B זיכרון."</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>בסופו של דבר, ל-<span dir="ltr"><code>Write-Host</code></span> מועברת המחרוזת המוכנה והמורכבת: <span dir="ltr"><code>"כל תהליכי svchost משתמשים ב- 1585.52 מ"</code></span><span dir="ltr"><code>[PSCustomObject]@{B זיכרון."</code></span>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>הפעל את הפנקס:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li>מוצאים את תהליך הפנקס ושומרים אותו במשתנה <span dir="ltr"><code>$notepadProcess</code></span></li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>$notepadProcess = Get-Process -Name notepad
</code></pre>
<!-- /wp:code -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li>פונים למאפיין '<span dir="ltr">Id</span>' של אובייקט זה דרך נקודה ומציגים אותו</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Write-Host "ID של תהליך 'פנקס רשימות' הוא: $($notepadProcess.Id)"
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/5.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>❗ חשוב:</strong><br><span dir="ltr">Write-Host</span> "שובר" את הקונסולה. טקסט שמוצג באמצעותו לא ניתן להעביר הלאה בקונסולה לצורך עיבוד. הוא מיועד רק לתצוגה.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">3. <span dir="ltr">Get-Member</span> (מפקח אובייקטים)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>אנו יודעים כי אובייקטים "זורמים" דרך הקונסולה. אך כיצד לדעת ממה הם מורכבים? אילו מאפיינים יש להם ואילו פעולות (שיטות) ניתן לבצע עליהם?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr">cmdlet</span> <strong><span dir="ltr"><code>Get-Member</code></span></strong> (כינוי: <span dir="ltr"><code>gm</code></span>) הוא הכלי העיקרי לחקירה.<br>לפני שתעבדו עם אובייקט, העבירו אותו דרך <span dir="ltr"><code>Get-Member</code></span> כדי לראות את כל יכולותיו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>בואו ננתח את האובייקטים ש-<span dir="ltr"><code>Get-Process</code></span> יוצר:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/6.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><em>ננתח כל חלק מפלט <span dir="ltr">Get-Member</span>.</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>TypeName: System.Diagnostics.Process</code></span> - זהו "שם סוג" מלא ורשמי של האובייקט מספריית <span dir="ltr">.NET</span>. זהו ה"דרכון" שלו.<br>שורה זו אומרת לכם שכל האובייקטים ש-<span dir="ltr">Get-Process</span> מחזיר הם אובייקטים מסוג <span dir="ltr">System.Diagnostics.Process</span>. זה מבטיח שלכולם יהיה סט זהה של מאפיינים ושיטות.<br>אתם יכולים <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com"><span dir="ltr">לגגל</span></a> "<span dir="ltr">System.Diagnostics.Process</span>" כדי למצוא את התיעוד הרשמי של <span dir="ltr">Microsoft</span> עם מידע מפורט אף יותר.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>עמודה 1: <span dir="ltr"><code>Name</code></span><br>זהו פשוט <strong>שם</strong> קריא לאדם של מאפיין, שיטה או "חבר" אחר של האובייקט. זהו השם שתשתמשו בו בקוד שלכם כדי לגשת לנתונים או לבצע פעולות.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>עמודה 2: <span dir="ltr"><code>MemberType</code></span> (סוג אובייקט)<br>זוהי העמודה החשובה ביותר להבנה. היא מסווגת <strong>מהו</strong> כל אובייקט. זהו ה"תפקיד" שלו, שאומר לכם <strong>כיצד</strong> להשתמש בו.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Property</code></span> (מאפיין):</strong> <strong>מאפיין</strong> או <strong>חלק נתונים</strong> השמור בתוך האובייקט. אתם יכולים "לקרוא" את ערכו.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>דוגמאות בצילום המסך:</em> <span dir="ltr"><code>BasePriority</code></span>, <span dir="ltr"><code>HandleCount</code></span>, <span dir="ltr"><code>ExitCode</code></span>. אלו פשוט נתונים שניתן לצפות בהם.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Method</code></span> (שיטה):</strong> <strong>פעולה</strong> שניתן לבצע עם האובייקט. שיטות תמיד נקראות עם סוגריים עגולים <span dir="ltr"><code>()</code></span>.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>דוגמאות בצילום המסך:</em> <span dir="ltr"><code>Kill</code></span>, <span dir="ltr"><code>Refresh</code></span>, <span dir="ltr"><code>WaitForExit</code></span>. הייתם כותבים <span dir="ltr"><code>$process.Kill()</code></span> או <span dir="ltr"><code>$process.Refresh()</code></span>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>AliasProperty</code></span> (כינוי מאפיין):</strong> <strong>כינוי ידידותי</strong> למאפיין אחר, ארוך יותר. <span dir="ltr">PowerShell</span> מוסיף אותם לנוחות וקיצור.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>דוגמאות בצילום המסך:</em> <span dir="ltr"><code>WS</code></span> – זהו כינוי קצר עבור <span dir="ltr"><code>WorkingSet64</code></span>. <span dir="ltr"><code>Name</code></span> – עבור <span dir="ltr"><code>ProcessName</code></span>. <span dir="ltr"><code>VM</code></span> – עבור <span dir="ltr"><code>VirtualMemorySize64</code></span>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Event</code></span> (אירוע):</strong> <strong>הודעה</strong> על כך שמשהו קרה, שאליה ניתן "להירשם".
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>Exited</code></span>. הסקריפט שלכם יכול "להקשיב" לאירוע זה כדי לבצע פעולה כלשהי מיד לאחר שהתהליך מסתיים.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>CodeProperty</code></span> ו-<span dir="ltr"><code>NoteProperty</code></span>:</strong> סוגי מאפיינים מיוחדים, לרוב מתווספים על ידי <span dir="ltr">PowerShell</span> עצמו לנוחות. <span dir="ltr"><code>CodeProperty</code></span> מחשב את ערכו "תוך כדי תנועה", ו-<span dir="ltr"><code>NoteProperty</code></span> – זהו מאפיין-הערה פשוט, שנוסף לאובייקט.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>עמודה 3: <span dir="ltr"><code>Definition</code></span> (הגדרה)<br>זוהי <strong>ההגדרה הטכנית</strong> או ה"חתימה" של החבר. היא מספקת לכם את הפרטים המדויקים לשימוש בו. תוכנה תלויה ב-<span dir="ltr"><code>MemberType</code></span>:
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>עבור <span dir="ltr"><code>AliasProperty</code></span>:</strong> מראה <strong>למה שווה הכינוי</strong>. זה שימושי להפליא!
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>WS = WorkingSet64</code></span>. אתם רואים מיד ש-<span dir="ltr"><code>WS</code></span> – זו פשוט כתיבה מקוצרת עבור <span dir="ltr"><code>WorkingSet64</code></span>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>עבור <span dir="ltr"><code>Property</code></span>:</strong> מראה <strong>את סוג הנתונים</strong> השמור במאפיין (לדוגמה, <span dir="ltr"><code>int</code></span> למספר שלם, <span dir="ltr"><code>string</code></span> לטקסט, <span dir="ltr"><code>datetime</code></span> לתאריך ושעה), ומה ניתן לעשות איתו (<span dir="ltr"><code>{get;}</code></span> – רק לקרוא, <span dir="ltr"><code>{get;set;}</code></span> – לקרוא ולשנות).
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>int BasePriority {get;}</code></span>. זהו מאפיין מסוג מספר שלם, שניתן רק לקרוא.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>עבור <span dir="ltr"><code>Method</code></span>:</strong> מראה מה השיטה מחזירה (לדוגמה, <span dir="ltr"><code>void</code></span> – כלום, <span dir="ltr"><code>bool</code></span> – אמת/שקר) ואילו <strong>פרמטרים</strong> (נתוני קלט) היא מקבלת בסוגריים.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>void Kill()</code></span>. זה אומר שהשיטה <span dir="ltr"><code>Kill</code></span> לא מחזירה כלום וניתן לקרוא לה ללא פרמטרים. כמו כן, קיימת גרסה שנייה <span dir="ltr"><code>void Kill(bool entireProcessTree)</code></span>, שמקבלת ערך בוליאני (אמת/שקר).</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">בטבלה</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table">
<table>
<thead>
<tr>
<th>עמודה</th>
<th>מה זה?</th>
<th>דוגמה מצילום המסך</th>
<th>לשם מה?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><span dir="ltr">Name</span></strong></td>
<td>השם שבו אתם משתמשים בקוד.</td>
<td><span dir="ltr"><code>Kill</code></span>, <span dir="ltr"><code>WS</code></span>, <span dir="ltr"><code>Name</code></span></td>
<td>לגשת למאפיין או שיטה (<span dir="ltr"><code>$process.WS</code></span>, <span dir="ltr"><code>$process.Kill()</code></span>).</td>
</tr>
<tr>
<td><strong><span dir="ltr">MemberType</span></strong></td>
<td>סוג החבר (נתונים, פעולה וכו').</td>
<td><span dir="ltr"><code>Method</code></span>, <span dir="ltr"><code>Property</code></span>, <span dir="ltr"><code>AliasProperty</code></span></td>
<td><strong>כיצד</strong> להשתמש בו (לקרוא ערך או לקרוא לו עם <span dir="ltr"><code>()</code></span>).</td>
</tr>
<tr>
<td><strong><span dir="ltr">Definition</span></strong></td>
<td>פרטים טכניים.</td>
<td><span dir="ltr"><code>WS = WorkingSet64</code></span>, <span dir="ltr"><code>void Kill()</code></span></td>
<td>מה מסתתר מאחורי הכינוי ואילו פרמטרים נחוצים לשיטה.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">דוגמה: עבודה עם חלונות תהליכים</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. בעיה:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"פתחתי הרבה חלונות 'פנקס רשימות'. איך אוכל למזער את כולם, מלבד הראשי, ואז לסגור רק את זה שיש בכותרתו את המילה '<span dir="ltr">Untitled</span>'?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. חקירה עם <span dir="ltr">Get-Member</span>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>עלינו למצוא מאפיינים הקשורים לחלון ולכותרתו.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name notepad | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><strong>ניתוח תוצאת <span dir="ltr">Get-Member</span>:</strong></p>
<!-- /wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>במעבר על המאפיינים, אנו מוצאים את <span dir="ltr"><code>MainWindowTitle</code></span>. סוג <span dir="ltr"><code>string</code></span>. מצוין, זו כותרת החלון הראשי!</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>בשיטות אנו רואים <span dir="ltr"><code>CloseMainWindow()</code></span>. זו דרך "רכה" יותר לסגור חלון מאשר <span dir="ltr"><code>Kill()</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>כמו כן בשיטות יש <span dir="ltr"><code>WaitForInputIdle()</code></span>. נשמע מעניין, אולי זה יעזור לחכות שהתהליך יהיה מוכן לאינטראקציה.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/7.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><span dir="ltr">Get-Member</span> הראה לנו את המאפיין <span dir="ltr">MainWindowTitle</span>, שהוא המפתח לפתרון הבעיה ומאפשר לקיים אינטראקציה עם תהליכים על בסיס מצב החלונות שלהם, ולא רק לפי שם.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. פתרון:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>כעת נוכל לבנות את הלוגיקה, המבוססת על כותרת החלון.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. מוצאים את כל תהליכי הפנקס
$notepads = Get-Process -Name notepad

# 2. עוברים על כל אחד ובודקים את הכותרת
foreach ($pad in $notepads) {
    # עבור כל תהליך ($pad) בודקים את המאפיין MainWindowTitle שלו
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "נמצא פנקס רשימות לא שמור (ID: $($pad.Id)). סוגרים את חלונו..."
        # $pad.CloseMainWindow() # הסירו את ההערה כדי לסגור באמת
        Write-Host "החלון '$($pad.MainWindowTitle)' היה נסגר." -ForegroundColor Yellow
    } else {
        Write-Host "מדלגים על פנקס רשימות עם כותרת: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/8.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/9.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">דוגמה: מציאת תהליך אב</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. בעיה:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"לפעמים אני רואה במערכת הרבה תהליכי צאצא של <span dir="ltr"><code>chrome.exe</code></span>. איך אוכל לדעת איזה מהם הוא התהליך הראשי, ה'הורי' שפתח את כולם?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. חקירה עם <span dir="ltr">Get-Member</span>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>עלינו למצוא משהו שמקשר תהליך אחד לאחר.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/10.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>ניתוח תוצאת <span dir="ltr">Get-Member</span>:</strong></p>
<!-- /wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>בבחינה מדוקדקת של הרשימה, אנו מוצאים מאפיין מסוג <span dir="ltr"><code>CodeProperty</code></span> בשם <span dir="ltr"><code>Parent</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>ההגדרה (<span dir="ltr">Definition</span>) שלו – <span dir="ltr"><code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code></span>. זהו מאפיין מחושב, שכאשר פונים אליו מחזיר <strong>אובייקט של תהליך האב</strong>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. פתרון:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>כעת אנו יכולים לכתוב סקריפט, שיציג עבור כל תהליך <span dir="ltr"><code>chrome</code></span> מידע אודותיו ואודות אביו.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. מקבלים את כל תהליכי chrome
$chromeProcesses = Get-Process -Name chrome

# 2. עבור כל אחד מהם מציגים מידע עליו ועל האב שלו
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # מקבלים את תהליך האב
    $parent = $_.Parent
    
    # יוצרים פלט יפה
    Write-Host "תהליך:" -ForegroundColor Green
    Write-Host "  - שם: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "האב שלו:" -ForegroundColor Yellow
    Write-Host "  - שם: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<!-- /wp:code -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/11.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:image -->
<figure class="wp-block-image size-large"><img src="assets/02/12.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>אנו רואים מיד כי תהליכים עם <span dir="ltr">ID</span> 4756, 7936, 8268 ו-9752 הופעלו על ידי תהליך עם <span dir="ltr">ID</span> 14908. ניתן גם לשים לב למקרה מעניין עם תהליך <span dir="ltr">ID</span>: 7252, שתהליך האב שלו לא זוהה (יתכן שהאב כבר הסתיים עד למועד הבדיקה). שינוי הסקריפט עם בדיקה <span dir="ltr"><code>if ($parent)</code></span> מטפל במקרה זה בעדינות, מבלי לגרום לשגיאה.<br><span dir="ltr">Get-Member</span> עזר לנו לגלות את מאפיין <span dir="ltr">Parent</span> ה"נסתר", המספק יכולות עוצמתיות לניתוח היררכיית התהליכים.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">4. קובץ <span dir="ltr"><code>.ps1</code></span> (יצירת סקריפטים)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>כאשר שרשרת הפקודות שלכם הופכת לשימושית, תרצו לשמור אותה לשימוש חוזר. לשם כך נועדו <strong>סקריפטים</strong> – קובצי טקסט עם סיומת <strong><span dir="ltr"><code>.ps1</code></span></strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">הרשאה להפעלת סקריפטים</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>כברירת מחדל, <span dir="ltr">Windows</span> אוסרת הפעלת סקריפטים מקומיים. כדי לתקן זאת <strong>עבור המשתמש הנוכחי</strong>, הפעילו פעם אחת ב-<span dir="ltr">PowerShell</span> <strong>כמנהל מערכת</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>זוהי הגדרה בטוחה, המאפשרת להפעיל את הסקריפטים שלכם וסקריפטים החתומים על ידי מפרסם מהימן.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">דוגמת סקריפט <span dir="ltr"><code>system_monitor.ps1</code></span></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>צרו קובץ בשם זה והדביקו בו את הקוד שלהלן. סקריפט זה אוסף מידע על המערכת ומפיק דוחות.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    סקריפט ליצירת דוח על מצב המערכת.
.DESCRIPTION
    אוסף מידע על תהליכים, שירותים ושטח דיסק ומפיק דוחות.
.PARAMETER OutputPath
    נתיב לשמירת הדוחות. ברירת המחדל היא 'C:\Temp'.
.EXAMPLE
    .&#92;system_monitor.ps1 -OutputPath "C:&#92;Reports"
#&gt;
param(
    &#91;Parameter(Mandatory=$false)]
    &#91;string]$OutputPath = "C:&#92;Temp"
)

# --- בלוק 1: הכנה ---
Write-Host "הכנה ליצירת דוח..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- בלוק 2: איסוף נתונים ---
Write-Host "איסוף מידע..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- בלוק 3: קריאה לפונקציית הייצוא (ראו סעיף הבא) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "הדוחות נשמרו בהצלחה בתיקייה $OutputPath" -ForegroundColor Magenta
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><em>הערה: הפונקציה <span dir="ltr"><code>Export-Results</code></span> תוגדר בסעיף הבא כדוגמה לפרקטיקה טובה.</em></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">5. ייצוא תוצאות</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>נתונים נקיים זה טוב, אך לעיתים קרובות יש צורך להציג אותם בצורה נוחה לאדם או לתוכנה אחרת. <span dir="ltr">PowerShell</span> מציע מגוון רחב של <span dir="ltr">cmdlets</span> לייצוא.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table">
<table>
<thead>
<tr>
<th>שיטה</th>
<th>פקודה</th>
<th>תיאור</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>טקסט פשוט</strong></td>
<td><span dir="ltr"><code>... | Out-File C:&#92;Temp&#92;data.txt</code></span></td>
<td>מנתב ייצוג טקסטואלי לקובץ.</td>
</tr>
<tr>
<td><strong><span dir="ltr">CSV</span> (עבור <span dir="ltr">Excel</span>)</strong></td>
<td><span dir="ltr"><code>... | Export-Csv C:&#92;Temp&#92;data.csv -NoTypeInfo</code></span></td>
<td>מייצא אובייקטים ל-<span dir="ltr">CSV</span>. <span dir="ltr"><code>-NoTypeInfo</code></span> מסיר את השורה הראשונה השירותית.</td>
</tr>
<tr>
<td><strong>דוח <span dir="ltr">HTML</span></strong></td>
<td><span dir="ltr"><code>... | ConvertTo-Html -Title "דוח"</code></span></td>
<td>יוצר קוד <span dir="ltr">HTML</span> מאובייקטים.</td>
</tr>
<tr>
<td><strong><span dir="ltr">JSON</span> (עבור <span dir="ltr">API</span>, אינטרנט)</strong></td>
<td><span dir="ltr"><code>... | ConvertTo-Json</code></span></td>
<td>ממיר אובייקטים לפורמט <span dir="ltr">JSON</span>.</td>
</tr>
<tr>
<td><strong><span dir="ltr">XML</span> (פורמט מקורי של <span dir="ltr">PowerShell</span>)</strong></td>
<td><span dir="ltr"><code>... | Export-Clixml C:&#92;Temp&#92;data.xml</code></span></td>
<td>שומר אובייקטים עם כל סוגי הנתונים. ניתן לשחזר אותם באופן מושלם באמצעות <span dir="ltr"><code>Import-Clixml</code></span>.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">תוספת לסקריפט: פונקציית ייצוא</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>בואו נוסיף לסקריפט <span dir="ltr"><code>system_monitor.ps1</code></span> שלנו פונקציה שתעסוק בייצוא. מקמו את הקוד הזה <strong>לפני</strong> הקריאה ל-<span dir="ltr"><code>Export-Results</code></span>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # ייצוא ל-CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # יצירת דוח HTML יפה
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;10 התהליכים המובילים לפי CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;סטטיסטיקת שירותים&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;דוח מערכת&lt;/title&gt;" -Body "&lt;h1&gt;דוח מערכת מ-$(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>כעת הסקריפט שלנו לא רק אוסף נתונים, אלא גם שומר אותם בקפידה בשני פורמטים: <span dir="ltr">CSV</span> לניתוח ו-<span dir="ltr">HTML</span> לצפייה מהירה.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">מסקנה</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>קונסולה (<span dir="ltr"><code>|</code></span>)</strong> – הכלי העיקרי לחיבור פקודות ועיבוד אובייקטים.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Get-Member</code></span></strong> – ניתוח אובייקטים, המציג ממה הם מורכבים.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>משתנים (<span dir="ltr"><code>$var</code></span>, <span dir="ltr"><code>$_</code></span>)</strong> מאפשרים לשמור נתונים ולפנות לאובייקט הנוכחי בקונסולה.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>קבצי <span dir="ltr"><code>.ps1</code></span></strong> הופכים פקודות לכלים אוטומטיים הניתנים לשימוש חוזר.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr">Cmdlets</span> ייצוא</strong> (<span dir="ltr"><code>Export-Csv</code></span>, <span dir="ltr"><code>ConvertTo-Html</code></span>) מייצאים נתונים בפורמט המתאים.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>בחלק הבא נשתמש בידע זה לניווט וניהול מערכת הקבצים, תוך חקירת אובייקטי <span dir="ltr"><code>System.IO.DirectoryInfo</code></span> ו-<span dir="ltr"><code>System.IO.FileInfo</code></span>.</strong></li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->[:ua]<h2 class="wp-block-heading">Філософія PowerShell.</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading">Частина 2: Конвеєр (<span dir="ltr">Pipeline</span>), змінні, <span dir="ltr">Get-Member</span>, файл <span dir="ltr">*.ps1*</span> та експорт результатів</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>❗ Важливо:</strong><br>Я пишу про <span dir="ltr">PS7 (PowerShell 7)</span>. Він відрізняється від <span dir="ltr">PS5 (PowerShell 5)</span>. Починаючи з сьомої версії <span dir="ltr">PS</span> став кросплатформним. Через це змінилася поведінка деяких команд.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>У першій частині ми встановили ключовий принцип: <span dir="ltr">PowerShell</span> працює з <strong>об'єктами</strong>, а не з текстом. Цей допис присвячений деяким важливим інструментам <span dir="ltr">PowerShell</span>: навчимося передавати об'єкти по <strong>конвеєру</strong>, аналізувати їх за допомогою <strong><span dir="ltr"><code>Get-Member</code></span></strong>, зберігати результати в <strong>змінні</strong> та автоматизувати все це у <strong>файлах скриптів (<span dir="ltr"><code>.ps1</code></span>)</strong> з <strong>експортом</strong> результатів у зручні формати.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">1. Що таке конвеєр (<span dir="ltr"><code>|</code></span>)?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Конвеєр у <span dir="ltr">PowerShell</span> — це механізм передачі повноцінних <span dir="ltr">.NET</span> об'єктів (а не просто тексту) від однієї команди до іншої, де кожен наступний командлет отримує структуровані об'єкти з усіма їхніми властивостями та методами.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Символ <span dir="ltr"><code>|</code></span> (вертикальна риска) — це оператор конвеєра. Його завдання — взяти результат (виведення) команди, що стоїть ліворуч від нього, і передати його на вхід команді, що стоїть праворуч.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>Команда 1 (створює об'єкти)</code></span> → <span dir="ltr"><code>|</code></span> → <span dir="ltr"><code>Команда 2 (отримує та обробляє об'єкти)</code></span> → <span dir="ltr"><code>|</code></span> → <span dir="ltr"><code>Команда 3 (отримує оброблені об'єкти)</code></span> → <span dir="ltr"><code>|</code></span> ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Класичний <span dir="ltr">UNIX</span>-конвеєр: Потік тексту</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>У <span dir="ltr"><code>bash</code></span> по конвеєру передається <strong>потік байтів</strong>, який зазвичай інтерпретується як текст.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># Найти все процессы 'nginx' и посчитать их количество
ps -ef | grep 'nginx' | wc -l
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Тут <span dir="ltr"><code>ps</code></span> виводить текст, <span dir="ltr"><code>grep</code></span> фільтрує цей текст, а <span dir="ltr"><code>wc</code></span> рахує рядки. Кожна утиліта нічого не знає про "процеси", вона працює тільки зі рядками.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading"><span dir="ltr">PowerShell</span>-конвеєр: Потік об'єктів</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Приклад:</strong> Давайте отримаємо всі процеси, відсортуємо їх за використанням <span dir="ltr">CPU</span> і виберемо 5 най"ненажерливіших".</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/1.png"} -->
<figure class="wp-block-image"><img src="assets/02/1.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Тут <span dir="ltr"><code>Get-Process</code></span> створює <strong>об'єкти</strong> процесів. <span dir="ltr"><code>Sort-Object</code></span> отримує ці <strong>об'єкти</strong> та сортує їх за властивістю <span dir="ltr"><code>CPU</code></span>. <span dir="ltr"><code>Select-Object</code></span> отримує відсортовані <strong>об'єкти</strong> та вибирає перші 5.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ви, напевно, помітили в команді слова, що починаються з дефіса (<span dir="ltr">-</span>): <span dir="ltr">-Property</span>, <span dir="ltr">-Descending</span>, <span dir="ltr">-First</span>. Це параметри.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Параметри — це налаштування, перемикачі та інструкції для командлета. Вони дозволяють керувати тим, <strong>ЯК</strong> команда виконуватиме свою роботу. Без параметрів команда працює в режимі за замовчуванням, а з параметрами ви даєте їй конкретні вказівки.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Основні типи параметрів:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Параметр зі значенням: вимагає додаткової інформації.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>-Property CPU</code></span>: Ми кажемо <span dir="ltr"><code>Sort-Object</code></span>, за якою властивістю сортувати. <span dir="ltr"><code>CPU</code></span> — це значення параметра.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><span dir="ltr"><code>-First 5</code></span>: Ми кажемо <span dir="ltr"><code>Select-Object</code></span>, скільки об'єктів вибрати. <span dir="ltr"><code>5</code></span> — це значення параметра.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Параметр-перемикач (прапорець): Не вимагає значення. Сама його наявність у команді вмикає або вимикає певну поведінку.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>-Descending</code></span>: Цей прапорець говорить <span dir="ltr"><code>Sort-Object</code></span> змінити порядок сортування на зворотний (від більшого до меншого). Йому не потрібне додаткове значення — він сам по собі інструкція.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/2.png"} -->
<figure class="wp-block-image"><img src="assets/02/2.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ця команда відповідає на дуже просте питання: <strong>"Скільки саме процесів з іменем <span dir="ltr"><code>svchost.exe</code></span> зараз запущено в моїй системі?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Розбір по кроках</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Крок 1: <span dir="ltr"><code>Get-Process -Name 'svchost'</code></span></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ця частина команди звертається до операційної системи і просить знайти <strong>всі без винятку</strong> запущені процеси, у яких ім'я виконуваного файлу — <span dir="ltr"><code>svchost.exe</code></span>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>На відміну від процесів типу <span dir="ltr"><code>notepad</code></span> (яких зазвичай один або два), процесів <span dir="ltr"><code>svchost</code></span> в системі завжди <strong>багато</strong>. Команда поверне <strong>масив (колекцію) об'єктів</strong>, де кожен об'єкт — це окремий, повноцінний процес <span dir="ltr"><code>svchost</code></span> зі своїм унікальним <span dir="ltr">ID</span>, використанням пам'яті тощо.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr">PowerShell</span> знайшов у системі, наприклад, 90 процесів <span dir="ltr"><code>svchost</code></span> і тепер тримає в руках колекцію з 90 об'єктів.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Крок 2: <span dir="ltr"><code>|</code></span> (Оператор конвеєра)</strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Цей символ бере колекцію з 90 об'єктів <span dir="ltr"><code>svchost</code></span>, отриману на першому кроці, і починає передавати їх <strong>по одному</strong> на вхід наступної команді.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Крок 3: <span dir="ltr"><code>Measure-Object</code></span></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Оскільки ми викликали <span dir="ltr"><code>Measure-Object</code></span> без параметрів (таких як <span dir="ltr"><code>-Property</code></span>, <span dir="ltr"><code>-Sum</code></span> тощо), він виконує свою операцію <strong>за замовчуванням</strong> — просто рахує кількість "предметів", які йому передали.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Раз, два, три ... Після того, як всі об'єкти пораховані, <span dir="ltr"><code>Measure-Object</code></span> створює <strong>свій власний об'єкт-результат</strong>, в якому є властивість <span dir="ltr"><code>Count</code></span>, що дорівнює підсумковому числу.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong><span dir="ltr"><code>Count: 90</code></span></strong> — це і є відповідь на наше питання. Запущено 90 процесів <span dir="ltr"><code>svchost</code></span>. Інші поля порожні, тому що ми не просили <span dir="ltr"><code>Measure-Object</code></span> виконувати більш складні обчислення.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Приклад з <span dir="ltr"><code>svchost</code></span> та параметрами</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Давайте змінимо наше завдання. Тепер ми хочемо не просто порахувати процеси <span dir="ltr"><code>svchost</code></span>, а дізнатися, <strong>скільки всього оперативної пам'яті (у мегабайтах) вони споживають разом</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Для цього нам знадобляться параметри:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>-Property WorkingSet64</code></span>: Ця інструкція говорить <span dir="ltr"><code>Measure-Object</code></span>: "З кожного об'єкта <span dir="ltr"><code>svchost</code></span>, який до тебе прийде, візьми числове значення з властивості <span dir="ltr"><code>WorkingSet64</code></span> (це використання пам'яті в байтах)".</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><span dir="ltr"><code>-Sum</code></span>: Ця інструкція-прапорець говорить: "Склади всі ці значення, які ти взяв з властивості <span dir="ltr"><code>WorkingSet64</code></span>".</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Наша нова команда буде виглядати так:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/3.png"} -->
<figure class="wp-block-image"><img src="assets/02/3.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>Get-Process</code></span> знайде кількість об'єктів <span dir="ltr"><code>svchost</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Конвеєр <span dir="ltr"><code>|</code></span> передасть їх у <span dir="ltr"><code>Measure-Object</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Але тепер <span dir="ltr"><code>Measure-Object</code></span> працює по-новому:
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Він бере перший об'єкт <span dir="ltr"><code>svchost</code></span>, дивиться його властивість <span dir="ltr"><code>.WorkingSet64</code></span> (наприклад, <span dir="ltr"><code>25000000</code></span> байт) і запам'ятовує це число.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Бере другий об'єкт, дивиться його <span dir="ltr"><code>.WorkingSet64</code></span> (наприклад, <span dir="ltr"><code>15000000</code></span> байт) і додає до попереднього.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>...і так далі для всіх об'єктів.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>У підсумку <span dir="ltr"><code>Measure-Object</code></span> створить об'єкт-результат, але тепер він буде іншим.</li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Count: 92</code></span></strong>: Кількість об'єктів.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Sum: 1661890560</code></span></strong>: Це загальна сума всіх значень <span dir="ltr"><code>WorkingSet64</code></span> у байтах.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Property: WorkingSet64</code></span></strong>: Це поле тепер теж заповнене, воно інформує нас, яке саме властивість було використано для обчислень.</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">2. Змінні (Звичайні та спеціальна <span dir="ltr"><code>$_</code></span>)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Змінна — це іменоване сховище в пам'яті, яке містить будь-яке значення.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Цим значенням може бути що завгодно: текст, число, дата або, що найважливіше для <span dir="ltr">PowerShell</span>, цілий об'єкт або навіть колекція об'єктів. Ім'я змінної в <span dir="ltr">PowerShell</span> завжди починається зі знака долара (<span dir="ltr">$</span>). Приклади: <span dir="ltr"><code>$name</code></span>, <span dir="ltr"><code>$counter</code></span>, <span dir="ltr"><code>$processList</code></span>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Спеціальна змінна <span dir="ltr"><code>$_</code></span>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>$_</code></span> — це скорочення для "поточний об'єкт" або "ось ця штука".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Уявіть собі конвеєр на заводі. По ньому їдуть різні деталі (об'єкти).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>$_</code></span> — це та сама деталь, яка знаходиться прямо зараз перед вами (або перед роботом-обробником).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Джерело (<span dir="ltr"><code>Get-Process</code></span>) — висипає на конвеєр цілу коробку з деталями (усіма процесами).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Конвеєр (<span dir="ltr"><code>|</code></span>) — змушує ці деталі рухатися по стрічці по одній.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Обробник (<span dir="ltr"><code>Where-Object</code></span> або <span dir="ltr"><code>ForEach-Object</code></span>) — це робот, який дивиться на кожну деталь.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Змінна <span dir="ltr"><code>$_</code></span> — це та сама деталь, яка зараз знаходиться в "руках" у робота.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Коли робот закінчить з однією деталлю, конвеєр подає йому наступну, і <span dir="ltr"><code>$_</code></span> тепер вказуватиме вже на неї.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Давайте порахуємо, скільки всього пам'яті використовують процеси <span dir="ltr"><code>svchost</code></span>, і виведемо результат на монітор.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Виконуємо команду та зберігаємо її складний об'єкт-результат у змінну $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Тепер ми можемо працювати зі збереженим об'єктом. Дістаємо з нього властивість Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Виводимо результат на екран, використовуючи нову змінну
Write-Host "Всі процеси svchost використовують $memoryInMB МБ пам'яті."
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/4.png"} -->
<figure class="wp-block-image"><img src="assets/02/4.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr"><code>Write-Host</code></span> — це спеціалізований командлет, чиє єдине завдання — <strong>показати текст безпосередньо користувачеві в консолі</strong>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Рядок у подвійних лапках: <span dir="ltr"><code>"..."</code></span> — текстовий рядок, який ми передаємо командлету <span dir="ltr"><code>Write-Host</code></span> як аргумент. Чому подвійні, а не одинарні лапки?
<p><span dir="ltr">PowerShell</span> має два типи лапок:</p>
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Одинарні (<span dir="ltr"><code>'...'</code></span>):</strong> Створюють <strong>буквальний рядок</strong>. Все, що всередині них, сприймається як звичайний текст, без винятків.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Подвійні (<span dir="ltr"><code>"..."</code></span>):</strong> Створюють <strong>розширюваний (або підстановочний) рядок</strong>. <span dir="ltr">PowerShell</span> "сканує" такий рядок на предмет змінних (що починаються з <span dir="ltr"><code>$</code></span>) і підставляє на їхнє місце їхні значення.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><span dir="ltr"><code>$memoryInMB</code></span>. Це змінна, в яку ми <strong>на попередньому кроці</strong> нашого скрипта поклали результат обчислень. Коли <span dir="ltr"><code>Write-Host</code></span> отримує рядок у подвійних лапках, відбувається процес, який називається <strong>"підстановка змінних" (<span dir="ltr">String Expansion</span>)</strong>:
<ol class="wp-block-list"><!-- wp:list-item -->
<li><span dir="ltr">PowerShell</span> бачить текст <span dir="ltr"><code>"Всі процеси svchost використовують "</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Потім він натрапляє на конструкцію <span dir="ltr"><code>$memoryInMB</code></span>. Він розуміє, що це не просто текст, а змінна.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Він заглядає в пам'ять, знаходить значення, що зберігається в <span dir="ltr"><code>$memoryInMB</code></span> (наприклад, <span dir="ltr"><code>1585.52</code></span>).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Він <strong>підставляє це значення</strong> прямо в рядок.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Потім він додає решту тексту: <span dir="ltr"><code>" МБ пам'яті."</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>У підсумку, в <span dir="ltr"><code>Write-Host</code></span> передається вже готовий, зібраний рядок: <span dir="ltr"><code>"Всі процеси svchost використовують 1585.52 МБ пам'яті."</code></span>.</li>
<!-- /wp:list-item -->
</ol>
</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Запустіть блокнот:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li>Находимо процес Блокнота і зберігаємо його в змінну <span dir="ltr"><code>$notepadProcess</code></span></li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>$notepadProcess = Get-Process -Name notepad
</code></pre>
<!-- /wp:code -->

<!-- wp:list {"ordered":true,"start":2} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li>Звертаємося до властивості <span dir="ltr"><code>'Id'</code></span> цього об'єкта через крапку і виводимо його</li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Write-Host "ID процесу 'Блокнот' дорівнює: $($notepadProcess.Id)"
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/5.png"} -->
<figure class="wp-block-image"><img src="assets/02/5.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>❗ Важливо:</strong><br><span dir="ltr"><code>Write-Host</code></span> "ламає" конвеєр. Текст, виведений ним, не можна передати далі по конвеєру для обробки. Він призначений тільки для відображення.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">3. <span dir="ltr">Get-Member</span> (Інспектор об'єктів)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ми знаємо, що по конвеєру "течуть" об'єкти. Але як дізнатися, з чого вони складаються? Які у них є властивості і які дії (методи) з ними можна здійснювати?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Командлет <strong><span dir="ltr"><code>Get-Member</code></span></strong> (псевдонім: <span dir="ltr"><code>gm</code></span>) — головний інструмент для дослідження. Перш ніж працювати з об'єктом, пропустіть його через <span dir="ltr"><code>Get-Member</code></span>, щоб побачити всі його можливості.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Давайте проаналізуємо об'єкти, які створює <span dir="ltr"><code>Get-Process</code></span>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/6.png"} -->
<figure class="wp-block-image"><img src="assets/02/6.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><em>Розберемо кожну частину виведення <span dir="ltr">Get-Member</span>.</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>TypeName: System.Diagnostics.Process</code></span> - Це повне, офіційне "ім'я типу" об'єкта з бібліотеки <span dir="ltr">.NET</span>. Це його "паспорт".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Цей рядок говорить вам, що всі об'єкти, які повертає <span dir="ltr"><code>Get-Process</code></span>, є об'єктами типу <span dir="ltr"><code>System.Diagnostics.Process</code></span>. Це гарантує, що у них у всіх буде однаковий набір властивостей і методів. Ви можете <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com"><span dir="ltr">загуглити</span></a> "<span dir="ltr">System.Diagnostics.Process</span>", щоб знайти офіційну документацію <span dir="ltr">Microsoft</span> з ще більш детальною інформацією.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Колонка 1: <span dir="ltr"><code>Name</code></span>
<p>Це просте, людинозрозуміле <strong>ім'я</strong> властивості, методу або іншого "члена" об'єкта. Саме це ім'я ви будете використовувати у своєму коді для доступу до даних або виконання дій.</p>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Колонка 2: <span dir="ltr"><code>MemberType</code></span> (Тип об'єкта)
<p>Це найважливіша для розуміння колонка. Вона класифікує, <strong>чим є</strong> кожен об'єкт. Це його "посада", яка говорить вам, <strong>ЯК</strong> його використовувати.</p>
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Property</code></span> (Властивість):</strong> <strong>характеристика</strong> або <strong>порція даних</strong>, що зберігається всередині об'єкта. Ви можете "прочитати" її значення.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Приклади на скріншоті:</em> <span dir="ltr"><code>BasePriority</code></span>, <span dir="ltr"><code>HandleCount</code></span>, <span dir="ltr"><code>ExitCode</code></span>. Це просто дані, які можна переглянути.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Method</code></span> (Метод):</strong> <strong>ДІЯ</strong>, яку можна здійснити з об'єктом. Методи завжди викликаються з круглими дужками <span dir="ltr"><code>()</code></span>.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Приклади на скріншоті:</em> <span dir="ltr"><code>Kill</code></span>, <span dir="ltr"><code>Refresh</code></span>, <span dir="ltr"><code>WaitForExit</code></span>. Ви б написали <span dir="ltr"><code>$process.Kill()</code></span> або <span dir="ltr"><code>$process.Refresh()</code></span>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>AliasProperty</code></span> (Псевдонім властивості):</strong> <strong>дружній псевдонім</strong> для іншої, довшої властивості. <span dir="ltr">PowerShell</span> додає їх для зручності та стислості.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Приклади на скріншоті:</em> <span dir="ltr"><code>WS</code></span> — це короткий псевдонім для <span dir="ltr"><code>WorkingSet64</code></span>. <span dir="ltr"><code>Name</code></span> — для <span dir="ltr"><code>ProcessName</code></span>. <span dir="ltr"><code>VM</code></span> — для <span dir="ltr"><code>VirtualMemorySize64</code></span>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Event</code></span> (Подія):</strong> <strong>ПОВІДОМЛЕННЯ</strong> про те, що щось сталося, на яке можна "підписатися".
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Приклад на скріншоті:</em> <span dir="ltr"><code>Exited</code></span>. Ваш скрипт може "слухати" цю подію, щоб виконати якусь дію відразу після того, як процес завершиться.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>CodeProperty</code></span></strong> та <strong><span dir="ltr"><code>NoteProperty</code></span>:</strong> спеціальні типи властивостей, часто додані самим <span dir="ltr">PowerShell</span> для зручності. <span dir="ltr"><code>CodeProperty</code></span> обчислює своє значення "на льоту", а <span dir="ltr"><code>NoteProperty</code></span> — це проста властивість-примітка, додана до об'єкта.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Колонка 3: <span dir="ltr"><code>Definition</code></span> (Визначення)
<p>Це <strong>технічне визначення</strong> або "підпис" члена. Вона дає вам точні деталі для його використання. Її вміст залежить від <span dir="ltr"><code>MemberType</code></span>:</p>
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Для <span dir="ltr"><code>AliasProperty</code></span>:</strong> Показує, <strong>чому дорівнює псевдонім</strong>. Це неймовірно корисно!
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Приклад на скріншоті:</em> <span dir="ltr"><code>WS = WorkingSet64</code></span>. Ви відразу бачите, що <span dir="ltr"><code>WS</code></span> — це просто короткий запис для <span dir="ltr"><code>WorkingSet64</code></span>.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Для <span dir="ltr"><code>Property</code></span>:</strong> Показує <strong>тип даних</strong>, який зберігається у властивості (наприклад, <span dir="ltr"><code>int</code></span> для цілого числа, <span dir="ltr"><code>string</code></span> для тексту, <span dir="ltr"><code>datetime</code></span> для дати та часу), і що можна з ним робити (<span dir="ltr"><code>{get;}</code></span> — тільки читати, <span dir="ltr"><code>{get;set;}</code></span> — читати та змінювати).
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Приклад на скріншоті:</em> <span dir="ltr"><code>int BasePriority {get;}</code></span>. Це цілочисельна властивість, яку можна тільки прочитати.</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Для <span dir="ltr"><code>Method</code></span>:</strong> Показує, що метод повертає (наприклад, <span dir="ltr"><code>void</code></span> — нічого, <span dir="ltr"><code>bool</code></span> — true/false) і які <strong>параметри</strong> (вхідні дані) він приймає в дужках.
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Приклад на скріншоті:</em> <span dir="ltr"><code>void Kill()</code></span>. Це означає, що метод <span dir="ltr"><code>Kill</code></span> нічого не повертає і може бути викликаний без параметрів. Також є друга версія <span dir="ltr"><code>void Kill(bool entireProcessTree)</code></span>, яка приймає логічне значення (<span dir="ltr">true/false</span>).</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item --></ul>
</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">У вигляді таблиці</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>Колонка</th><th>Що це?</th><th>Приклад зі скріншота</th><th>Для чого?</th></tr></thead><tbody><tr><td><strong><span dir="ltr">Name</span></strong></td><td>Ім'я, яке ви використовуєте в коді.</td><td><span dir="ltr"><code>Kill</code></span>, <span dir="ltr"><code>WS</code></span>, <span dir="ltr"><code>Name</code></span></td><td>звернутися до властивості або методу (<span dir="ltr"><code>$process.WS</code></span>, <span dir="ltr"><code>$process.Kill()</code></span>).</td></tr><tr><td><strong><span dir="ltr">MemberType</span></strong></td><td>Тип члена (дані, дія тощо).</td><td><span dir="ltr"><code>Method</code></span>, <span dir="ltr"><code>Property</code></span>, <span dir="ltr"><code>AliasProperty</code></span></td><td><strong>як</strong> його використовувати (читати значення або викликати з <span dir="ltr"><code>()</code></span>).</td></tr><tr><td><strong><span dir="ltr">Definition</span></strong></td><td>Технічні деталі.</td><td><span dir="ltr"><code>WS = WorkingSet64</code></span>, <span dir="ltr"><code>void Kill()</code></span></td><td>що приховується за псевдонімом і які параметри потрібні методу.</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Приклад: Робота з вікнами процесів</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Проблема:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Я відкрив багато вікон Блокнота. Як мені програмно згорнути всі, крім головного, а потім закрити тільки те, у якого в заголовку є слово '<span dir="ltr">Untitled</span>'?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Дослідження з <span dir="ltr"><code>Get-Member</code></span>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Нам потрібно знайти властивості, пов'язані з вікном та його заголовком.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name notepad | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><strong>Аналіз результату <span dir="ltr"><code>Get-Member</code></span>:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Гортаючи властивості, ми знаходимо <span dir="ltr"><code>MainWindowTitle</code></span>. Тип <span dir="ltr"><code>string</code></span>. Чудово, це заголовок головного вікна!</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>У методах ми бачимо <span dir="ltr"><code>CloseMainWindow()</code></span>. Це більш "м'який" спосіб закрити вікно, ніж <span dir="ltr"><code>Kill()</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Також у методах є <span dir="ltr"><code>WaitForInputIdle()</code></span>. Звучить цікаво, можливо, це допоможе дочекатися, поки процес буде готовий до взаємодії.</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:image {"alt":"","url":"assets/02/7.png"} -->
<figure class="wp-block-image"><img src="assets/02/7.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>Get-Member</code></span> показав нам властивість <span dir="ltr"><code>MainWindowTitle</code></span>, яка є ключем до вирішення завдання і дозволяє взаємодіяти з процесами на основі стану їхніх вікон, а не просто за іменем.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Рішення:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Тепер ми можемо побудувати логіку, засновану на заголовку вікна.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Знаходимо всі процеси Блокнота
$notepads = Get-Process -Name notepad

# 2. Проходимося по кожному та перевіряємо заголовок
foreach ($pad in $notepads) {
    # Для кожного процесу ($pad) перевіряємо його властивість MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Знайдено незбережений Блокнот (ID: $($pad.Id)). Закриваємо його вікно..."
        # $pad.CloseMainWindow() # Розкоментуйте, щоб дійсно закрити
        Write-Host "Вікно '$($pad.MainWindowTitle)' було б закрито." -ForegroundColor Yellow
    } else {
        Write-Host "Пропускаємо Блокнот із заголовком: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/8.png"} -->
<figure class="wp-block-image"><img src="assets/02/8.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:image {"alt":"","url":"assets/02/9.png"} -->
<figure class="wp-block-image"><img src="assets/02/9.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Приклад: Знайти батьківський процес</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Проблема:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Іноді я бачу в системі багато дочірніх процесів <span dir="ltr"><code>chrome.exe</code></span>. Як мені дізнатися, який з них є головним, "батьківським" процесом, що їх усіх запустив?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Дослідження з <span dir="ltr"><code>Get-Member</code></span>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Нам потрібно знайти щось, що пов'язує один процес з іншим.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/10.png"} -->
<figure class="wp-block-image"><img src="assets/02/10.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>Аналіз результату <span dir="ltr"><code>Get-Member</code></span>:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Уважно переглядаючи список, ми знаходимо властивість типу <span dir="ltr"><code>CodeProperty</code></span> з іменем <span dir="ltr"><code>Parent</code></span>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Його визначення (<span dir="ltr"><code>Definition</code></span>) — <span dir="ltr"><code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code></span>. Це обчислювана властивість, яка при зверненні до неї повертає <strong>об'єкт батьківського процесу</strong>.</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Рішення:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Тепер ми можемо написати скрипт, який для кожного процесу <span dir="ltr"><code>chrome</code></span> буде виводити інформацію про його батька.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Отримуємо всі процеси chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Для кожного з них виводимо інформацію про нього та його батька
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Отримуємо батьківський процес
    $parent = $_.Parent

    # Формуємо красиве виведення
    Write-Host "Процес:" -ForegroundColor Green
    Write-Host "  - Ім'я: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Його батько:" -ForegroundColor Yellow
    Write-Host "  - Ім'я: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"alt":"","url":"assets/02/11.png"} -->
<figure class="wp-block-image"><img src="assets/02/11.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:image {"alt":"","url":"assets/02/12.png"} -->
<figure class="wp-block-image"><img src="assets/02/12.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ми одразу бачимо, що процеси з <span dir="ltr">ID 4756</span>, <span dir="ltr">7936</span>, <span dir="ltr">8268</span> та <span dir="ltr">9752</span> були запущені процесом з <span dir="ltr">ID 14908</span>. Також можна помітити цікавий випадок з процесом <span dir="ltr">ID: 7252</span>, у якого батьківський процес не визначився (можливо, батько вже встиг завершитися до моменту перевірки). Модифікація скрипта з перевіркою <span dir="ltr"><code>if ($parent)</code></span> акуратно обробляє цей випадок, не викликаючи помилки.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span dir="ltr"><code>Get-Member</code></span> допоміг нам виявити "приховану" властивість <span dir="ltr"><code>Parent</code></span>, яка надає потужні можливості для аналізу ієрархії процесів.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">4. Файл <span dir="ltr"><code>*.ps1</code></span> (Створення скриптів)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Коли ваш ланцюжок команд стає корисним, ви захочете зберегти його для багаторазового використання. Для цього й потрібні <strong>скрипти</strong> — текстові файли з розширенням <strong><span dir="ltr"><code>.ps1</code></span></strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Дозвіл на запуск скриптів</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>За замовчуванням у <span dir="ltr">Windows</span> заборонено запуск локальних скриптів. Щоб це виправити <strong>для поточного користувача</strong>, виконайте один раз у <span dir="ltr">PowerShell</span> <strong>від імені адміністратора</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Це безпечне налаштування, яке дозволяє запускати ваші власні скрипти та скрипти, підписані довіреним видавцем.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Приклад скрипта <span dir="ltr"><code>system_monitor.ps1</code></span></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Створіть файл з таким іменем і вставте в нього код нижче. Цей скрипт збирає інформацію про систему та генерує звіти.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Скрипт для створення звіту про стан системи.
.DESCRIPTION
    Збирає інформацію про процеси, служби та дисковий простір і генерує звіти.
.PARAMETER OutputPath
    Шлях для збереження звітів. За замовчуванням 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Блок 1: Підготовка ---
Write-Host "Підготовка до створення звіту..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Блок 2: Збір даних ---
Write-Host "Збір інформації..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Блок 3: Виклик функції для експорту (див. наступний розділ) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Звіти успішно збережено в папці $OutputPath" -ForegroundColor Magenta
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><em>Примітка: функція <span dir="ltr"><code>Export-Results</code></span> буде визначена в наступному розділі як приклад хорошої практики.</em></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">5. Експорт результатів</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Чисті дані — це добре, але часто їх потрібно представити у зручному для людини або іншої програми вигляді. <span dir="ltr">PowerShell</span> пропонує безліч командлетів для експорту.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>Метод</th><th>Команда</th><th>Опис</th></tr></thead><tbody><tr><td><strong>Простий текст</strong></td><td><span dir="ltr"><code>... | Out-File C:\Temp\data.txt</code></span></td><td>Перенаправляє текстове представлення у файл.</td></tr><tr><td><strong><span dir="ltr">CSV</span> (для <span dir="ltr">Excel</span>)</strong></td><td><span dir="ltr"><code>... | Export-Csv C:\Temp\data.csv -NoTypeInfo</code></span></td><td>Експортує об'єкти в <span dir="ltr">CSV</span>. <span dir="ltr"><code>-NoTypeInfo</code></span> прибирає службовий перший рядок.</td></tr><tr><td><strong><span dir="ltr">HTML</span>-звіт</strong></td><td><span dir="ltr"><code>... | ConvertTo-Html -Title "Звіт"</code></span></td><td>Створює <span dir="ltr">HTML</span>-код з об'єктів.</td></tr><tr><td><strong><span dir="ltr">JSON</span> (для <span dir="ltr">API</span>, веб)</strong></td><td><span dir="ltr"><code>... | ConvertTo-Json</code></span></td><td>Перетворює об'єкти у формат <span dir="ltr">JSON</span>.</td></tr><tr><td><strong><span dir="ltr">XML</span> (рідний формат <span dir="ltr">PowerShell</span>)</strong></td><td><span dir="ltr"><code>... | Export-Clixml C:\Temp\data.xml</code></span></td><td>Зберігає об'єкти з усіма типами даних. Їх можна ідеально відновити через <span dir="ltr"><code>Import-Clixml</code></span>.</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Доповнення до скрипта: функція експорту</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Давайте додамо в наш скрипт <span dir="ltr"><code>system_monitor.ps1</code></span> функцію, яка буде займатися експортом. Розмістіть цей код <strong>перед</strong> викликом <span dir="ltr"><code>Export-Results</code></span>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Експорт у CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Створення красивого HTML-звіту
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Топ-10 процесів за CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Статистика служб</h2>"

    ConvertTo-Html -Head "&lt;title&gt;Звіт про систему&lt;/title&gt;" -Body "&lt;h1&gt;Звіт про систему від $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Тепер наш скрипт не просто збирає дані, а й акуратно зберігає їх у двох форматах: <span dir="ltr">CSV</span> для аналізу та <span dir="ltr">HTML</span> для швидкого перегляду.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Висновок</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Конвеєр (<span dir="ltr"><code>|</code></span>)</strong> — головний інструмент для об'єднання команд та обробки об'єктів.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><span dir="ltr"><code>Get-Member</code></span></strong> — аналіз об'єктів, який показує, з чого вони складаються.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Змінні (<span dir="ltr"><code>$var</code></span>, <span dir="ltr"><code>$_</code></span>)</strong> дозволяють зберігати дані та звертатися до поточного об'єкта в конвеєрі.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Файли <span dir="ltr"><code>.ps1</code></span></strong> перетворюють команди на інструменти автоматизації, що можуть бути використані повторно.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Командлети експорту</strong> (<span dir="ltr"><code>Export-Csv</code></span>, <span dir="ltr"><code>ConvertTo-Html</code></span>) експортують дані у відповідному форматі.</li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>У наступній частині ми застосуємо ці знання для навігації та керування файловою системою, досліджуючи об'єкти <span dir="ltr"><code>System.IO.DirectoryInfo</code></span> та <span dir="ltr"><code>System.IO.FileInfo</code></span>.</strong></p>
<!-- /wp:paragraph -->[:pl]```html
<!-- wp:heading {"level":1} -->
<h1 class="wp-block-heading">Filozofia PowerShell.</h1>
<!-- /wp:heading -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading">Część 2: Potok (Pipeline), zmienne, Get-Member, plik <code>*.ps1</code> i eksport wyników</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>❗ Ważne:</strong><br>Piszę o PS7 (PowerShell 7). Różni się on od PS5 (PowerShell 5). Od siódmej wersji PowerShell stał się multiplatformowy. Z tego powodu<br>zmieniło się zachowanie niektórych poleceń.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>W pierwszej części ustaliliśmy kluczową zasadę: PowerShell działa z <strong>obiektami</strong>, a nie tekstem.<br>Ten post poświęcony jest kilku ważnym narzędziom PowerShell:<br>nauczymy się przekazywać obiekty przez <strong>potok</strong>, analizować je za pomocą <code>Get-Member</code>,<br>zapisywać wyniki w <strong>zmiennych</strong> i automatyzować to wszystko w <strong>plikach skryptów (<code>.ps1</code>)</strong> z <strong>eksportem</strong><br>wyników do wygodnych formatów.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">1. Co to jest potok (<code>|</code>)?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Potok w PowerShell to mechanizm przekazywania pełnoprawnych obiektów .NET (a nie tylko tekstu) od jednego polecenia<br>do drugiego, gdzie każde kolejne polecenie otrzymuje ustrukturyzowane obiekty ze wszystkimi ich właściwościami i metodami.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Symbol <code>|</code> (pionowa kreska) — to operator potoku. Jego zadaniem jest pobranie wyniku (wyjścia) polecenia znajdującego się po jego lewej stronie i przekazanie go jako wejścia do polecenia znajdującego się po prawej stronie.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Polecenie 1 (tworzy obiekty)</code> → <code>|</code> → <code>Polecenie 2 (otrzymuje i przetwarza obiekty)</code> → <code>|</code> → <code>Polecenie 3 (otrzymuje przetworzone obiekty)</code> → <code>|</code> ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Klasyczny potok UNIX: Strumień tekstu</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>W <code>bash</code> przez potok przekazywany jest <strong>strumień bajtów</strong>, który zazwyczaj jest interpretowany jako tekst.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># Znajdź wszystkie procesy 'nginx' i zlicz je
ps -ef | grep 'nginx' | wc -l</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Tutaj <code>ps</code> wyprowadza tekst, <code>grep</code> filtruje ten tekst, a <code>wc</code> zlicza wiersze. Każde narzędzie nic nie wie o "procesach", pracuje tylko z wierszami.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Potok PowerShell: Strumień obiektów</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Przykład:</strong> Pobierzmy wszystkie procesy, posortujmy je według użycia CPU i wybierzmy 5 najbardziej "żarłocznych".</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/1.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Tutaj <code>Get-Process</code> tworzy <strong>obiekty</strong> procesów. <code>Sort-Object</code> otrzymuje te <strong>obiekty</strong> i sortuje je według właściwości <code>CPU</code>. <code>Select-Object</code> otrzymuje posortowane <strong>obiekty</strong> i wybiera pierwsze 5.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Z pewnością zauważyliście w poleceniu słowa zaczynające się od myślnika (-): <code>-Property</code>, <code>-Descending</code>, <code>-First</code>. To są parametry.<br>Parametry — to ustawienia, przełączniki i instrukcje dla polecenia cmdlet. Pozwalają one kontrolować, <strong>JAK</strong> polecenie wykona swoją pracę.<br>Bez parametrów polecenie działa w trybie domyślnym, a z parametrami dajesz mu konkretne wskazówki.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list">
<!-- wp:list-item -->
<li>Parametr z wartością: wymaga dodatkowych informacji.
<ul>
<li><code>-Property CPU</code>: Mówimy <code>Sort-Object</code>, według jakiej właściwości ma sortować. <code>CPU</code> — to wartość parametru.</li>
<li><code>-First 5</code>: Mówimy <code>Select-Object</code>, ile obiektów ma wybrać. <code>5</code> — to wartość parametru.</li>
</ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Parametr-przełącznik (flaga): Nie wymaga wartości. Sama jego obecność w poleceniu włącza lub wyłącza określone zachowanie.
<ul>
<li><code>-Descending</code>: Ta flaga mówi <code>Sort-Object</code>, aby zmienić kolejność sortowania na odwrotną (od większego do mniejszego). Nie potrzebuje dodatkowej wartości — jest sama w sobie instrukcją.</li>
</ul>
</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/2.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To polecenie odpowiada na bardzo proste pytanie:<br><strong>"Ile dokładnie procesów o nazwie <code>svchost.exe</code> jest obecnie uruchomionych w moim systemie?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Analiza krok po kroku</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Krok 1: <code>Get-Process -Name 'svchost'</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ta część polecenia zwraca się do systemu operacyjnego i prosi o znalezienie <strong>wszystkich bez wyjątku</strong> uruchomionych procesów, których nazwa pliku wykonywalnego to <code>svchost.exe</code>.<br>W przeciwieństwie do procesów typu <code>notepad</code> (których zazwyczaj jest jeden lub dwa), procesów <code>svchost</code> w systemie jest zawsze <strong>wiele</strong>. Polecenie zwróci <strong>tablicę (kolekcję) obiektów</strong>,<br>gdzie każdy obiekt to oddzielny, pełnoprawny proces <code>svchost</code> ze swoim unikalnym ID, wykorzystaniem pamięci itp.<br>PowerShell znalazł w systemie, na przykład, 90 procesów <code>svchost</code> i teraz trzyma w rękach kolekcję 90 obiektów.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Krok 2: <code>|</code> (Operator potoku)</strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ten symbol pobiera kolekcję 90 obiektów <code>svchost</code>, uzyskanych w pierwszym kroku, i zaczyna przekazywać je <strong>pojedynczo</strong> na wejście następnego polecenia.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Krok 3: <code>Measure-Object</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ponieważ wywołaliśmy <code>Measure-Object</code> bez parametrów (takich jak <code>-Property</code>, <code>-Sum</code> itp.), wykonuje on swoją operację <strong>domyślną</strong> — po prostu zlicza liczbę "elementów", które mu przekazano.<br>Jeden, dwa, trzy... Po zliczeniu wszystkich obiektów, <code>Measure-Object</code> tworzy <strong>swój własny obiekt wynikowy</strong>, w którym znajduje się właściwość <code>Count</code>, równa końcowej liczbie.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong><code>Count: 90</code></strong> — to jest odpowiedź na nasze pytanie. Uruchomiono 90 procesów <code>svchost</code>.<br>Pozostałe pola są puste, ponieważ nie prosiliśmy <code>Measure-Object</code> o wykonywanie bardziej skomplikowanych obliczeń.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Przykład z <code>svchost</code> i parametrami</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Zmieńmy nasze zadanie. Teraz chcemy nie tylko zliczyć procesy <code>svchost</code>,<br>ale dowiedzieć się, <strong>ile łącznie pamięci RAM (w megabajtach) zużywają</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Do tego będą nam potrzebne parametry:<br>
<ul><li><code>-Property WorkingSet64</code>: Ta instrukcja mówi <code>Measure-Object</code>: "Z każdego obiektu <code>svchost</code>, który do ciebie trafi, weź wartość liczbową z właściwości <code>WorkingSet64</code> (to zużycie pamięci w bajtach)".</li><li><code>-Sum</code>: Ta flaga-instrukcja mówi: "Zsumuj wszystkie te wartości, które wziąłeś z właściwości <code>WorkingSet64</code>".</li></ul></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Nasze nowe polecenie będzie wyglądać tak:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/3.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list">
<!-- wp:list-item -->
<li><code>Get-Process</code> znajdzie liczbę obiektów <code>svchost</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Potok <code>|</code> przekaże je do <code>Measure-Object</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Ale teraz <code>Measure-Object</code> działa w nowy sposób:
<ul>
<li>Pobiera pierwszy obiekt <code>svchost</code>, sprawdza jego właściwość <code>.WorkingSet64</code> (na przykład <code>25000000</code> bajtów) i zapamiętuje tę liczbę.</li>
<li>Pobiera drugi obiekt, sprawdza jego <code>.WorkingSet64</code> (na przykład <code>15000000</code> bajtów) i dodaje do poprzedniego.</li>
<li>...i tak dalej dla wszystkich obiektów.</li>
</ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>W rezultacie <code>Measure-Object</code> stworzy obiekt wynikowy, ale tym razem będzie on inny.</li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:list -->
<ul class="wp-block-list">
<!-- wp:list-item -->
<li><strong><code>Count: 92</code></strong>: Liczba obiektów.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>Sum: 1661890560</code></strong>: To całkowita suma wszystkich wartości <code>WorkingSet64</code> w bajtach.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong><code>Property: WorkingSet64</code></strong>: To pole również jest teraz wypełnione, informuje nas, która właściwość została użyta do obliczeń.</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">2. Zmienne (Zwykłe i specjalna <code>$_</code>)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Zmienna — to nazwane miejsce w pamięci, które przechowuje jakąś wartość.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Tą wartością może być wszystko: tekst, liczba, data, lub, co najważniejsze dla PowerShell,<br>cały obiekt, a nawet kolekcja obiektów. Nazwa zmiennej w PowerShell zawsze zaczyna się od znaku dolara ($).<br>Przykłady: <code>$name</code>, <code>$counter</code>, <code>$processList</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Specjalna zmienna <code>$_</code>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>$_</code> — to skrót od "bieżącego obiektu" lub "ten oto element".<br>Wyobraź sobie taśmociąg w fabryce. Po nim jadą różne części (obiekty).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>$_</code> — to ta konkretna część, która znajduje się teraz przed tobą (lub przed robotem-przetwarzającym).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Źródło (<code>Get-Process</code>) — wysypuje na taśmociąg całe pudełko części (wszystkie procesy).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Potok (<code>|</code>) — sprawia, że te części przesuwają się po taśmie jedna po drugiej.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Przetwarzający (<code>Where-Object</code> lub <code>ForEach-Object</code>) — to robot, który ogląda każdą część.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Zmienna <code>$_</code> — to ta konkretna część, która znajduje się teraz w "rękach" robota.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Kiedy robot skończy z jedną częścią, taśmociąg podaje mu następną, a <code>$_</code> będzie wskazywać już na nią.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Policzmy, ile łącznie pamięci zużywają procesy <code>svchost</code>, i wyświetlmy wynik na monitorze.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Wykonujemy polecenie i zapisujemy jego złożony obiekt wynikowy do zmiennej $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Teraz możemy pracować z zapisanym obiektem. Wyciągamy z niego właściwość Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Wyświetlamy wynik na ekranie, używając nowej zmiennej
Write-Host "Wszystkie procesy svchost zużywają $memoryInMB MB pamięci."</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/4.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list">
<!-- wp:list-item -->
<li><code>Write-Host</code> — to wyspecjalizowany cmdlet, którego jedynym zadaniem jest <strong>wyświetlanie tekstu bezpośrednio użytkownikowi w konsoli</strong>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Łańcuch w podwójnych cudzysłowach: <code>"..."</code> - to łańcuch tekstowy, który przekazujemy cmdletowi <code>Write-Host</code> jako argument. Dlaczego podwójne, a nie pojedyncze cudzysłowy?
<ul>
<li><strong>Pojedyncze (<code>'...'</code>):</strong> Tworzą <strong>dosłowny łańcuch</strong>. Wszystko, co się w nich znajduje, jest traktowane jako zwykły tekst, bez wyjątków.</li>
<li><strong>Podwójne (<code>"..."</code>):</strong> Tworzą <strong>rozszerzalny (lub podstawialny) łańcuch</strong>. PowerShell "skanuje" taki łańcuch w poszukiwaniu zmiennych (zaczynających się od <code>$</code>) i podstawia w ich miejsce ich wartości.</li>
</ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>$memoryInMB</code>. To zmienna, do której <strong>w poprzednim kroku</strong> naszego skryptu włożyliśmy wynik obliczeń. Gdy <code>Write-Host</code> otrzymuje łańcuch w podwójnych cudzysłowach,
następuje proces zwany <strong>"rozszerzaniem zmiennych" (String Expansion)</strong>:
<ol>
<li>PowerShell widzi tekst <code>"Wszystkie procesy svchost zużywają "</code>.</li>
<li>Następnie napotyka konstrukcję <code>$memoryInMB</code>. Rozumie, że to nie jest zwykły tekst, lecz zmienna.</li>
<li>Zagłębia się w pamięć, znajduje wartość przechowywaną w <code>$memoryInMB</code> (na przykład <code>1585.52</code>).</li>
<li><strong>Podstawia tę wartość</strong> bezpośrednio do łańcucha.</li>
<li>Następnie dodaje pozostałą część tekstu: <code>" MB pamięci."</code>.</li>
<li>W rezultacie, do <code>Write-Host</code> przekazywany jest już gotowy, złożony łańcuch: <code>"Wszystkie procesy svchost zużywają 1585.52 MB pamięci."</code>.</li>
</ol>
</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Uruchom Notatnik:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list">
<!-- wp:list-item -->
<li>Znajdujemy proces Notatnika i zapisujemy go do zmiennej <code>$notepadProcess</code>
<pre class="wp-block-code"><code>$notepadProcess = Get-Process -Name notepad</code></pre>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Odwołujemy się do właściwości 'Id' tego obiektu przez kropkę i wyświetlamy ją
<pre class="wp-block-code"><code>Write-Host "ID procesu 'Notatnik' wynosi: $($notepadProcess.Id)"</code></pre>
</li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><img src="assets/02/5.png" alt="5"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>❗ Ważne:</strong><br><code>Write-Host</code> "łamie" potok. Tekst przez niego wyprowadzony nie może być dalej przekazany przez potok do przetworzenia. Służy on wyłącznie do wyświetlania.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">3. Get-Member (Inspektor obiektów)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Wiemy, że przez potok "płyną" obiekty. Ale jak dowiedzieć się, z czego się składają? Jakie mają właściwości i jakie działania (metody) można na nich wykonywać?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Cmdlet <strong><code>Get-Member</code></strong> (alias: <code>gm</code>) to główne narzędzie do badania.<br>Zanim zaczniesz pracować z obiektem, przepuść go przez <code>Get-Member</code>, aby zobaczyć wszystkie jego możliwości.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Przeanalizujmy obiekty, które tworzy <code>Get-Process</code>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process | Get-Member</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/6.png" alt="6"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>*Przeanalizujmy każdą część wyjścia <code>Get-Member</code>.*</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>TypeName: System.Diagnostics.Process</code> - To pełna, oficjalna "nazwa typu" obiektu z biblioteki .NET. To jego "paszport".<br>Ten wiersz informuje, że wszystkie obiekty zwracane przez <code>Get-Process</code> są obiektami typu <code>System.Diagnostics.Process</code>.<br>Gwarantuje to, że wszystkie będą miały identyczny zestaw właściwości i metod.<br>Możesz <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">wyszukać w Google</a> "System.Diagnostics.Process", aby znaleźć oficjalną dokumentację Microsoft z jeszcze bardziej szczegółowymi informacjami.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list">
<!-- wp:list-item -->
<li>Kolumna 1: <code>Name</code>
<p>To prosta, czytelna dla człowieka <strong>nazwa</strong> właściwości, metody lub innego "członka" obiektu. Właśnie tej nazwy będziesz używać w swoim kodzie do dostępu do danych lub wykonywania działań.</p>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Kolumna 2: <code>MemberType</code> (Typ obiektu)
<p>To najważniejsza kolumna do zrozumienia. Klasyfikuje ona, <strong>czym jest</strong> każdy obiekt. To jego "stanowisko", które mówi ci, <strong>JAK</strong> go używać.</p>
<ul>
<li><strong><code>Property</code> (Właściwość):</strong> <strong>cecha</strong> lub <strong>fragment danych</strong> przechowywany w obiekcie. Możesz "odczytać" jego wartość.
<ul>
<li><em>Przykłady na zrzucie ekranu:</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. To po prostu dane, które można zobaczyć.</li>
</ul>
</li>
<li><strong><code>Method</code> (Metoda):</strong> <strong>DZIAŁANIE</strong>, które można wykonać na obiekcie. Metody zawsze są wywoływane z okrągłymi nawiasami <code>()</code>.
<ul>
<li><em>Przykłady na zrzucie ekranu:</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. Napisałbyś <code>$process.Kill()</code> lub <code>$process.Refresh()</code>.</li>
</ul>
</li>
<li><strong><code>AliasProperty</code> (Alias właściwości):</strong> <strong>przyjazny alias</strong> dla innej, dłuższej właściwości. PowerShell dodaje je dla wygody i zwięzłości.
<ul>
<li><em>Przykłady na zrzucie ekranu:</em> <code>WS</code> — to krótki alias dla <code>WorkingSet64</code>. <code>Name</code> — dla <code>ProcessName</code>. <code>VM</code> — dla <code>VirtualMemorySize64</code>.</li>
</ul>
</li>
<li><strong><code>Event</code> (Zdarzenie):</strong> <strong>POWIADOMIENIE</strong> o tym, że coś się wydarzyło, na które można się "zasubskrybować".
<ul>
<li><em>Przykłady na zrzucie ekranu:</em> <code>Exited</code>. Twój skrypt może "nasłuchiwać" tego zdarzenia, aby wykonać jakieś działanie natychmiast po zakończeniu procesu.</li>
</ul>
</li>
<li><strong><code>CodeProperty</code> i <code>NoteProperty</code>:</strong> specjalne typy właściwości, często dodawane przez sam PowerShell dla wygody. <code>CodeProperty</code> oblicza swoją wartość "na bieżąco", a <code>NoteProperty</code> — to prosta właściwość-notatka dodana do obiektu.</li>
</ul>
</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Kolumna 3: <code>Definition</code> (Definicja)
<p>To <strong>techniczna definicja</strong> lub "sygnatura" członka. Podaje ona dokładne szczegóły dotyczące jego użycia. Jej zawartość zależy od <code>MemberType</code>:</p>
<ul>
<li><strong>Dla <code>AliasProperty</code>:</strong> Pokazuje, <strong>czemu równa się alias</strong>. To niezwykle przydatne!
<ul>
<li><em>Przykład na zrzucie ekranu:</em> <code>WS = WorkingSet64</code>. Od razu widzisz, że <code>WS</code> — to po prostu skrócony zapis dla <code>WorkingSet64</code>.</li>
</ul>
</li>
<li><strong>Dla <code>Property</code>:</strong> Pokazuje <strong>typ danych</strong>, który jest przechowywany w właściwości (na przykład <code>int</code> dla liczby całkowitej, <code>string</code> dla tekstu, <code>datetime</code> dla daty i godziny), oraz co można z nim robić (<code>{get;}</code> — tylko odczyt, <code>{get;set;}</code> — odczyt i modyfikacja).
<ul>
<li><em>Przykład na zrzucie ekranu:</em> <code>int BasePriority {get;}</code>. To właściwość całkowita, którą można tylko odczytać.</li>
</ul>
</li>
<li><strong>Dla <code>Method</code>:</strong> Pokazuje, co metoda zwraca (na przykład <code>void</code> — nic, <code>bool</code> — true/false) i jakie <strong>parametry</strong> (dane wejściowe) przyjmuje w nawiasach.
<ul>
<li><em>Przykład na zrzucie ekranu:</em> <code>void Kill()</code>. Oznacza to, że metoda <code>Kill</code> nic nie zwraca i może być wywołana bez parametrów. Istnieje również druga wersja <code>void Kill(bool entireProcessTree)</code>, która przyjmuje wartość logiczną (true/false).</li>
</ul>
</li>
</ul>
</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">W formie tabeli</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table">
<table><thead><tr><th>Kolumna</th><th>Co to jest?</th><th>Przykład ze zrzutu ekranu</th><th>Do czego służy?</th></tr></thead><tbody><tr><td><strong>Name</strong></td><td>Nazwa, której używasz w kodzie.</td><td><code>Kill</code>, <code>WS</code>, <code>Name</code></td><td>odwołanie do właściwości lub metody (<code>$process.WS</code>, <code>$process.Kill()</code>).</td></tr><tr><td><strong>MemberType</strong></td><td>Typ członka (dane, działanie itp.).</td><td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td><td><strong>jak</strong> go używać (odczytać wartość lub wywołać z <code>()</code>).</td></tr><tr><td><strong>Definition</strong></td><td>Szczegóły techniczne.</td><td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td><td>co kryje się za aliasem i jakie parametry są potrzebne metodzie.</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Przykład: Praca z oknami procesów</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problem:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Otworzyłem wiele okien Notatnika. Jak programowo zminimalizować wszystkie oprócz głównego, a następnie zamknąć tylko te, które w tytule mają słowo 'Untitled'?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Badanie z <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Musimy znaleźć właściwości związane z oknem i jego tytułem.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name notepad | Get-Member</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/7.png" alt="7"></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list">
<!-- wp:list-item -->
<li>Analiza wyniku <code>Get-Member</code>:
<ul>
<li>Przeglądając właściwości, znajdujemy <code>MainWindowTitle</code>. Typ <code>string</code>. Świetnie, to tytuł głównego okna!</li>
<li>W metodach widzimy <code>CloseMainWindow()</code>. To łagodniejszy sposób zamknięcia okna niż <code>Kill()</code>.</li>
<li>W metodach jest również <code>WaitForInputIdle()</code>. Brzmi ciekawie, być może to pomoże poczekać, aż proces będzie gotowy do interakcji.</li>
</ul>
</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><code>Get-Member</code> pokazał nam właściwość <code>MainWindowTitle</code>, która jest kluczem do rozwiązania problemu i pozwala na interakcję z procesami na podstawie stanu ich okien, a nie tylko nazwy.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Rozwiązanie:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Teraz możemy zbudować logikę opartą na tytule okna.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Znajdujemy wszystkie procesy Notatnika
$notepads = Get-Process -Name notepad

# 2. Przechodzimy przez każdy i sprawdzamy tytuł
foreach ($pad in $notepads) {
    # Dla każdego procesu ($pad) sprawdzamy jego właściwość MainWindowTitle
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Znaleziono niezapisany Notatnik (ID: $($pad.Id)). Zamykamy jego okno..."
        # $pad.CloseMainWindow() # Odkomentuj, aby rzeczywiście zamknąć
        Write-Host "Okno '$($pad.MainWindowTitle)' zostałoby zamknięte." -ForegroundColor Yellow
    } else {
        Write-Host "Pomijamy Notatnik z tytułem: $($pad.MainWindowTitle)"
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/8.png" alt="8"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/9.png" alt="9"></p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Przykład: Znalezienie procesu nadrzędnego</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problem:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Czasami widzę w systemie wiele procesów potomnych <code>chrome.exe</code>. Jak mogę dowiedzieć się, który z nich jest głównym, "nadrzędnym" procesem, który je wszystkie uruchomił?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Badanie z <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Musimy znaleźć coś, co łączy jeden proces z drugim.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Get-Process -Name chrome | Select-Object -First 1 | Get-Member</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/10.png" alt="10"></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list">
<!-- wp:list-item -->
<li>Analiza wyniku <code>Get-Member</code>:
<ul>
<li>Uważnie przeglądając listę, znajdujemy właściwość typu <code>CodeProperty</code> o nazwie <code>Parent</code>.</li>
<li>Jej definicja (<code>Definition</code>) — <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>.<br>To właściwość obliczeniowa, która po odwołaniu się do niej zwraca <strong>obiekt procesu nadrzędnego</strong>.</li>
</ul>
</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Rozwiązanie:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Teraz możemy napisać skrypt, który dla każdego procesu <code>chrome</code> będzie wyświetlać informacje o jego rodzicu.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 1. Pobieramy wszystkie procesy chrome
$chromeProcesses = Get-Process -Name chrome

# 2. Dla każdego z nich wyświetlamy informacje o nim i jego rodzicu
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Pobieramy proces nadrzędny
    $parent = $_.Parent
    
    # Tworzymy ładne wyjście
    Write-Host "Proces:" -ForegroundColor Green
    Write-Host "  - Nazwa: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Jego rodzic:" -ForegroundColor Yellow
    Write-Host "  - Nazwa: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/11.png" alt="11"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/12.png" alt="12"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Od razu widzimy, że procesy o ID 4756, 7936, 8268 i 9752 zostały uruchomione przez proces o ID 14908. Można również zauważyć ciekawy przypadek z procesem o ID: 7252, u którego proces nadrzędny nie został określony (być może rodzic zdążył już zakończyć działanie do momentu sprawdzenia). Modyfikacja skryptu z warunkiem <code>if ($parent)</code> elegancko radzi sobie z tym przypadkiem, nie powodując błędu.<br><code>Get-Member</code> pomógł nam odkryć "ukrytą" właściwość <code>Parent</code>, która zapewnia potężne możliwości analizy hierarchii procesów.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">4. Plik <code>.ps1</code> (Tworzenie skryptów)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Kiedy twój łańcuch poleceń staje się użyteczny, będziesz chciał go zapisać do wielokrotnego użytku. Do tego służą <strong>skrypty</strong> — pliki tekstowe z rozszerzeniem <strong><code>.ps1</code></strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Zezwolenie na uruchamianie skryptów</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Domyślnie w systemie Windows uruchamianie lokalnych skryptów jest zabronione. Aby to naprawić <strong>dla bieżącego użytkownika</strong>, wykonaj jednorazowo w PowerShell <strong>jako administrator</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>To bezpieczne ustawienie, które pozwala na uruchamianie własnych skryptów oraz skryptów podpisanych przez zaufanego wydawcę.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Przykład skryptu <code>system_monitor.ps1</code></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Utwórz plik o tej nazwie i wklej do niego poniższy kod. Ten skrypt zbiera informacje o systemie i generuje raporty.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Skrypt do tworzenia raportu o stanie systemu.
.DESCRIPTION
    Zbiera informacje o procesach, usługach i przestrzeni dyskowej oraz generuje raporty.
.PARAMETER OutputPath
    Ścieżka do zapisu raportów. Domyślnie 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    &#91;Parameter(Mandatory=$false)]
    &#91;string]$OutputPath = "C:\Temp"
)

# --- Blok 1: Przygotowanie ---
Write-Host "Przygotowanie do tworzenia raportu..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Blok 2: Zbieranie danych ---
Write-Host "Zbieranie informacji..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Blok 3: Wywołanie funkcji eksportu (patrz następna sekcja) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Raporty pomyślnie zapisano w folderze $OutputPath" -ForegroundColor Magenta</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>*Uwaga: Funkcja <code>Export-Results</code> zostanie zdefiniowana w następnej sekcji jako przykład dobrej praktyki.*</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">5. Eksport wyników</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Surowe dane są dobre, ale często trzeba je przedstawić w formie wygodnej dla człowieka lub innego programu. PowerShell oferuje wiele cmdletów do eksportu.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table">
<table><thead><tr><th>Metoda</th><th>Polecenie</th><th>Opis</th></tr></thead><tbody><tr><td><strong>Prosty tekst</strong></td><td><code>... | Out-File C:\Temp\data.txt</code></td><td>Przekierowuje tekstową reprezentację do pliku.</td></tr><tr><td><strong>CSV (dla Excela)</strong></td><td><code>... | Export-Csv C:\Temp\data.csv -NoTypeInfo</code></td><td>Eksportuje obiekty do CSV. <code>-NoTypeInfo</code> usuwa służbowy pierwszy wiersz.</td></tr><tr><td><strong>Raport HTML</strong></td><td><code>... | ConvertTo-Html -Title "Raport"</code></td><td>Tworzy kod HTML z obiektów.</td></tr><tr><td><strong>JSON (dla API, web)</strong></td><td><code>... | ConvertTo-Json</code></td><td>Konwertuje obiekty do formatu JSON.</td></tr><tr><td><strong>XML (natywny format PowerShell)</strong></td><td><code>... | Export-Clixml C:\Temp\data.xml</code></td><td>Zapisuje obiekty ze wszystkimi typami danych. Można je idealnie odtworzyć za pomocą <code>Import-Clixml</code>.</td></tr></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Uzupełnienie skryptu: funkcja eksportu</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Dodajmy do naszego skryptu <code>system_monitor.ps1</code> funkcję, która będzie zajmować się eksportem. Umieść ten kod <strong>przed</strong> wywołaniem <code>Export-Results</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Eksport do CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Tworzenie ładnego raportu HTML
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Top-10 procesów według CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Statystyki usług&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;Raport o systemie&lt;/title&gt;" -Body "&lt;h1&gt;Raport o systemie od $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Teraz nasz skrypt nie tylko zbiera dane, ale także starannie zapisuje je w dwóch formatach: CSV do analizy i HTML do szybkiego przeglądania.</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Podsumowanie</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list">
<!-- wp:list-item -->
<li><strong>Potok (<code>|</code>)</strong> — to główne narzędzie do łączenia poleceń i przetwarzania obiektów.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>Get-Member</code> — analiza obiektów, która pokazuje, z czego się składają.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Zmienne (<code>$var</code>, <code>$_</code>)</strong> pozwalają na zapisywanie danych i odwoływanie się do bieżącego obiektu w potoku.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Pliki <code>.ps1</code></strong> przekształcają polecenia w narzędzia automatyzacji wielokrotnego użytku.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Cmdlety eksportu</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) eksportują dane w odpowiednim formacie.</li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>W następnej części zastosujemy tę wiedzę do nawigacji i zarządzania systemem plików, badając obiekty <code>System.IO.DirectoryInfo</code> i <code>System.IO.FileInfo</code>.</strong></p>
<!-- /wp:paragraph -->[:de]<h2 class="wp-block-heading">Die PowerShell-Philosophie.</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">Teil 2: Pipeline, Variablen, <code>Get-Member</code>, die <code>*.ps1</code>-Datei und der Export von Ergebnissen</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>❗ Wichtig:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ich schreibe über PS7 (PowerShell 7). Es unterscheidet sich von PS5 (PowerShell 5). Seit der siebten Version ist PowerShell plattformübergreifend. Dadurch hat sich das Verhalten einiger Befehle geändert.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Im ersten Teil haben wir ein Schlüsselprinzip festgelegt: PowerShell arbeitet mit <strong>Objekten</strong>, nicht mit Text. Dieser Beitrag widmet sich einigen wichtigen PowerShell-Tools: Wir lernen, Objekte über die <strong>Pipeline</strong> zu übergeben, sie mit <code>Get-Member</code> zu analysieren, Ergebnisse in <strong>Variablen</strong> zu speichern und all dies in <strong>Skriptdateien (<code>.ps1</code>)</strong> zu automatisieren, einschließlich des <strong>Exports</strong> von Ergebnissen in praktische Formate.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">1. Was ist die Pipeline (<code>|</code>)?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Die Pipeline in PowerShell ist ein Mechanismus zur Übergabe vollständiger .NET-Objekte (und nicht nur Text) von einem Befehl zum nächsten, wobei jedes nachfolgende Cmdlet strukturierte Objekte mit all ihren Eigenschaften und Methoden erhält.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Das Zeichen <code>|</code> (vertikaler Strich) ist der Pipeline-Operator. Seine Aufgabe ist es, das Ergebnis (die Ausgabe) des Befehls auf seiner linken Seite zu nehmen und es als Eingabe an den Befehl auf seiner rechten Seite weiterzugeben.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Befehl 1 (erstellt Objekte)</code> → <code>|</code> → <code>Befehl 2 (empfängt und verarbeitet Objekte)</code> → <code>|</code> → <code>Befehl 3 (empfängt verarbeitete Objekte)</code> → | ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Klassische UNIX-Pipeline: Textfluss</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In <code>bash</code> wird über die Pipeline ein <strong>Byte-Strom</strong> übertragen, der normalerweise als Text interpretiert wird.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-bash"># Alle 'nginx'-Prozesse finden und ihre Anzahl zählen
ps -ef | grep 'nginx' | wc -l
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Hier gibt <code>ps</code> Text aus, <code>grep</code> filtert diesen Text, und <code>wc</code> zählt die Zeilen. Jedes Dienstprogramm weiß nichts über "Prozesse", es arbeitet nur mit Zeilen.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">PowerShell-Pipeline: Objektfluss</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Beispiel:</strong> Lassen Sie uns alle Prozesse abrufen, sie nach CPU-Nutzung sortieren und die 5 "ressourcenhungrigsten" auswählen.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":1} -->
<figure class="wp-block-image"><img src="assets/02/1.png" alt="1"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Hier erstellt <code>Get-Process</code> <strong>Prozessobjekte</strong>. <code>Sort-Object</code> empfängt diese <strong>Objekte</strong> und sortiert sie nach der Eigenschaft <code>CPU</code>. <code>Select-Object</code> empfängt die sortierten <strong>Objekte</strong> und wählt die ersten 5 aus.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Sie haben sicherlich Wörter in den Befehlen bemerkt, die mit einem Bindestrich (-) beginnen: <code>-Property</code>, <code>-Descending</code>, <code>-First</code>. Dies sind Parameter.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Parameter sind Einstellungen, Schalter und Anweisungen für ein Cmdlet. Sie ermöglichen es Ihnen, zu steuern, <strong>WIE</strong> ein Befehl seine Aufgabe ausführt. Ohne Parameter arbeitet ein Befehl im Standardmodus, mit Parametern geben Sie ihm spezifische Anweisungen.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Haupttypen von Parametern:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Parameter mit Wert: Erfordert zusätzliche Informationen.
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>-Property CPU</code>: Wir weisen <code>Sort-Object</code> an, nach welcher Eigenschaft sortiert werden soll. <code>CPU</code> ist der Wert des Parameters.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>-First 5</code>: Wir weisen <code>Select-Object</code> an, wie viele Objekte ausgewählt werden sollen. <code>5</code> ist der Wert des Parameters.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Schalterparameter (Flag): Erfordert keinen Wert. Seine bloße Anwesenheit im Befehl schaltet ein bestimmtes Verhalten ein oder aus.
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>-Descending</code>: Dieses Flag weist <code>Sort-Object</code> an, die Sortierreihenfolge umzukehren (vom Größten zum Kleinsten). Es benötigt keinen zusätzlichen Wert – es ist eine Anweisung an sich.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":2} -->
<figure class="wp-block-image"><img src="assets/02/2.png" alt="2"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Dieser Befehl beantwortet eine sehr einfache Frage: <strong>"Wie viele Prozesse mit dem Namen <code>svchost.exe</code> laufen derzeit auf meinem System?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Schrittweise Analyse</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Schritt 1: <code>Get-Process -Name 'svchost'</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Dieser Teil des Befehls kontaktiert das Betriebssystem und fordert es auf, <strong>alle</strong> laufenden Prozesse zu finden, deren ausführbarer Dateiname <code>svchost.exe</code> ist. Im Gegensatz zu Prozessen wie <code>notepad</code> (von denen es normalerweise ein oder zwei gibt), gibt es in einem System immer <strong>viele</strong> <code>svchost</code>-Prozesse. Der Befehl gibt ein <strong>Array (eine Sammlung) von Objekten</strong> zurück, wobei jedes Objekt ein separater, vollständiger <code>svchost</code>-Prozess mit seiner eindeutigen ID, Speichernutzung usw. ist. PowerShell hat im System beispielsweise 90 <code>svchost</code>-Prozesse gefunden und hält nun eine Sammlung von 90 Objekten in der Hand.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Schritt 2: <code>|</code> (Pipeline-Operator)</strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Dieses Zeichen nimmt die Sammlung von 90 <code>svchost</code>-Objekten, die im ersten Schritt erhalten wurde, und beginnt, sie <strong>einzeln</strong> an den nächsten Befehl zu übergeben.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading"><strong>Schritt 3: <code>Measure-Object</code></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Da wir <code>Measure-Object</code> ohne Parameter (wie <code>-Property</code>, <code>-Sum</code> usw.) aufgerufen haben, führt es seine <strong>Standardoperation</strong> aus – es zählt einfach die Anzahl der "Elemente", die ihm übergeben wurden. Eins, zwei, drei ... Nachdem alle Objekte gezählt wurden, erstellt <code>Measure-Object</code> <strong>sein eigenes Ergebnisobjekt</strong>, das eine Eigenschaft <code>Count</code> enthält, die der Gesamtzahl entspricht.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong><code>Count: 90</code></strong> — das ist die Antwort auf unsere Frage. 90 <code>svchost</code>-Prozesse sind gestartet. Die restlichen Felder sind leer, weil wir <code>Measure-Object</code> nicht aufgefordert haben, komplexere Berechnungen durchzuführen.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Beispiel mit <code>svchost</code> und Parametern</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Lassen Sie uns unsere Aufgabe ändern. Jetzt möchten wir nicht nur die <code>svchost</code>-Prozesse zählen, sondern herausfinden, <strong>wie viel Arbeitsspeicher (in Megabyte) sie insgesamt verbrauchen</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Dazu benötigen wir Parameter:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>-Property WorkingSet64</code>: Diese Anweisung weist <code>Measure-Object</code> an: "Nehmen Sie aus jedem <code>svchost</code>-Objekt, das bei Ihnen ankommt, den numerischen Wert aus der Eigenschaft <code>WorkingSet64</code> (dies ist die Speichernutzung in Bytes)."</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>-Sum</code>: Diese Schalteranweisung besagt: "Addieren Sie alle Werte, die Sie aus der Eigenschaft <code>WorkingSet64</code> entnommen haben."</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Unser neuer Befehl sieht dann so aus:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":3} -->
<figure class="wp-block-image"><img src="assets/02/3.png" alt="3"/></figure>
<!-- /wp:image -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><code>Get-Process</code> findet die Anzahl der <code>svchost</code>-Objekte.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Die Pipeline <code>|</code> übergibt sie an <code>Measure-Object</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Doch nun arbeitet <code>Measure-Object</code> anders:
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Es nimmt das erste <code>svchost</code>-Objekt, prüft seine Eigenschaft <code>.WorkingSet64</code> (z.B. <code>25000000</code> Bytes) und speichert diese Zahl.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Es nimmt das zweite Objekt, prüft sein <code>.WorkingSet64</code> (z.B. <code>15000000</code> Bytes) und addiert es zum vorherigen Wert.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>...und so weiter für alle Objekte.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Am Ende erstellt <code>Measure-Object</code> ein Ergebnisobjekt, das jedoch anders aussehen wird.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><code>Count: 92</code></strong>: Die Anzahl der Objekte.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Sum: 1661890560</code></strong>: Dies ist die Gesamtsumme aller <code>WorkingSet64</code>-Werte in Bytes.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Property: WorkingSet64</code></strong>: Dieses Feld ist nun ebenfalls gefüllt und informiert uns, welche Eigenschaft für die Berechnungen verwendet wurde.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">2. Variablen (Reguläre und spezielle <code>$_</code>)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Eine Variable ist ein benannter Speicherort im Arbeitsspeicher, der einen bestimmten Wert enthält. Dieser Wert kann alles sein: Text, eine Zahl, ein Datum oder, was für PowerShell am wichtigsten ist, ein ganzes Objekt oder sogar eine Sammlung von Objekten. Der Name einer Variablen in PowerShell beginnt immer mit einem Dollarzeichen (<code>$</code>).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Beispiele: <code>$name</code>, <code>$counter</code>, <code>$processList</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Spezielle Variable <code>$_</code>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>$_</code> ist die Abkürzung für "aktuelles Objekt" oder "dieses Ding hier".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Stellen Sie sich ein Fließband in einer Fabrik vor. Darauf bewegen sich verschiedene Teile (Objekte).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>$_</code> ist genau das Teil, das sich gerade vor Ihnen (oder vor einem Roboter-Verarbeiter) befindet.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Quelle (<code>Get-Process</code>) — schüttet eine ganze Kiste mit Teilen (allen Prozessen) auf das Fließband.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Pipeline (<code>|</code>) — lässt diese Teile einzeln auf dem Band bewegen.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Verarbeiter (<code>Where-Object</code> oder <code>ForEach-Object</code>) — ist ein Roboter, der jedes Teil betrachtet.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Variable <code>$_</code> — ist genau das Teil, das sich gerade in den "Händen" des Roboters befindet.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Wenn der Roboter mit einem Teil fertig ist, schiebt die Pipeline das nächste nach, und <code>$_</code> wird nun auf dieses verweisen.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lassen Sie uns die gesamte Speichernutzung der <code>svchost</code>-Prozesse berechnen und das Ergebnis auf dem Monitor ausgeben.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># 1. Befehl ausführen und das komplexe Ergebnisobjekt in der Variablen $svchostMemory speichern
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Nun können wir mit dem gespeicherten Objekt arbeiten. Wir extrahieren die Eigenschaft Sum daraus.
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Das Ergebnis auf dem Bildschirm ausgeben, unter Verwendung der neuen Variablen
Write-Host "Alle svchost-Prozesse verwenden $memoryInMB MB Speicher."
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":4} -->
<figure class="wp-block-image"><img src="assets/02/4.png" alt="4"/></figure>
<!-- /wp:image -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>Write-Host</code> — ist ein spezialisiertes Cmdlet, dessen einzige Aufgabe es ist, <strong>Text direkt in der Konsole dem Benutzer anzuzeigen</strong>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Zeichenkette in doppelten Anführungszeichen: <code>"..."</code> - eine Textzeichenkette, die wir dem Cmdlet <code>Write-Host</code> als Argument übergeben. Warum doppelte und nicht einfache Anführungszeichen?
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Einfache (<code>'...'</code>):</strong> Erzeugen eine <strong>buchstäbliche Zeichenkette</strong>. Alles, was sich darin befindet, wird ohne Ausnahmen als normaler Text interpretiert.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Doppelte (<code>"..."</code>):</strong> Erzeugen eine <strong>erweiterbare (oder substituierbare) Zeichenkette</strong>. PowerShell "scannt" eine solche Zeichenkette nach Variablen (beginnend mit <code>$</code>) und ersetzt sie durch deren Werte.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>$memoryInMB</code>. Dies ist eine Variable, in die wir <strong>im vorherigen Schritt</strong> unseres Skripts das Ergebnis der Berechnungen gelegt haben. Wenn <code>Write-Host</code> eine Zeichenkette in doppelten Anführungszeichen erhält, erfolgt ein Prozess, der als <strong>"Variablensubstitution" (String Expansion)</strong> bezeichnet wird:
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>PowerShell sieht den Text <code>"Alle svchost-Prozesse verwenden "</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Dann stößt es auf die Konstruktion <code>$memoryInMB</code>. Es versteht, dass dies nicht nur Text, sondern eine Variable ist.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Es schaut im Speicher nach und findet den in <code>$memoryInMB</code> gespeicherten Wert (z.B. <code>1585.52</code>).</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Es <strong>fügt diesen Wert</strong> direkt in die Zeichenkette ein.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Dann fügt es den restlichen Text hinzu: <code>" MB Speicher."</code>.</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Am Ende wird an <code>Write-Host</code> die bereits fertige, zusammengesetzte Zeichenkette übergeben: <code>"Alle svchost-Prozesse verwenden 1585.52 MB Speicher."</code>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Starten Sie Notepad:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li>Suchen Sie den Notepad-Prozess und speichern Sie ihn in der Variablen <code>$notepadProcess</code>.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">$notepadProcess = Get-Process -Name notepad
</code></pre>
<!-- /wp:code -->

<!-- wp:list {"ordered":true,"start":2} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li>Greifen Sie auf die Eigenschaft 'Id' dieses Objekts über den Punktoperator zu und geben Sie sie aus.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Write-Host "Die ID des Prozesses 'Notepad' lautet: $($notepadProcess.Id)"
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":5} -->
<figure class="wp-block-image"><img src="assets/02/5.png" alt="5"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>❗ Wichtig:</strong><br><code>Write-Host</code> "bricht" die Pipeline. Der von ihm ausgegebene Text kann nicht weiter über die Pipeline zur Verarbeitung übergeben werden. Er dient lediglich der Anzeige.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading">3. <code>Get-Member</code> (Der Objektinspektor)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Wir wissen, dass Objekte durch die Pipeline "fließen". Aber wie erfahren wir, woraus sie bestehen? Welche Eigenschaften sie haben und welche Aktionen (Methoden) mit ihnen ausgeführt werden können?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Das Cmdlet <strong><code>Get-Member</code></strong> (Alias: <code>gm</code>) ist das Hauptwerkzeug für die Untersuchung. Bevor Sie mit einem Objekt arbeiten, leiten Sie es durch <code>Get-Member</code>, um alle seine Möglichkeiten zu sehen.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lassen Sie uns die Objekte analysieren, die <code>Get-Process</code> erstellt:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":6} -->
<figure class="wp-block-image"><img src="assets/02/6.png" alt="6"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><em>Lassen Sie uns jeden Teil der <code>Get-Member</code>-Ausgabe analysieren.</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>TypeName: System.Diagnostics.Process</code> - Dies ist der vollständige, offizielle "Typname" des Objekts aus der .NET-Bibliothek. Es ist sein "Pass".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Diese Zeile sagt Ihnen, dass alle Objekte, die <code>Get-Process</code> zurückgibt, Objekte vom Typ <code>System.Diagnostics.Process</code> sind. Dies gewährleistet, dass sie alle denselben Satz von Eigenschaften und Methoden haben. Sie können "System.Diagnostics.Process" <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">googeln</a>, um die offizielle Microsoft-Dokumentation mit noch detaillierteren Informationen zu finden.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Spalte 1: <code>Name</code></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Dies ist der einfache, menschenlesbare <strong>Name</strong> einer Eigenschaft, Methode oder eines anderen "Elements" des Objekts. Diesen Namen werden Sie in Ihrem Code verwenden, um auf Daten zuzugreifen oder Aktionen auszuführen.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Spalte 2: <code>MemberType</code> (Objekttyp)</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Dies ist die wichtigste Spalte für das Verständnis. Sie klassifiziert, <strong>was</strong> jedes Objekt ist. Es ist seine "Rolle", die Ihnen sagt, <strong>WIE</strong> es zu verwenden ist.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong><code>Property</code> (Eigenschaft):</strong> Eine <strong>Charakteristik</strong> oder <strong>ein Datenstück</strong>, das innerhalb des Objekts gespeichert ist. Sie können ihren Wert "lesen".
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Beispiele im Screenshot:</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. Dies sind einfach Daten, die man betrachten kann.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Method</code> (Methode):</strong> Eine <strong>AKTION</strong>, die mit dem Objekt ausgeführt werden kann. Methoden werden immer mit runden Klammern <code>()</code>.
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Beispiele im Screenshot:</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. Sie würden <code>$process.Kill()</code> oder <code>$process.Refresh()</code> schreiben.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>AliasProperty</code> (Eigenschaftenalias):</strong> Ein <strong>freundlicher Alias</strong> für eine andere, längere Eigenschaft. PowerShell fügt diese zur Bequemlichkeit und Kürze hinzu.
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Beispiele im Screenshot:</em> <code>WS</code> — ist ein kurzer Alias für <code>WorkingSet64</code>. <code>Name</code> — für <code>ProcessName</code>. <code>VM</code> — für <code>VirtualMemorySize64</code>.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Event</code> (Ereignis):</strong> Eine <strong>BENACHRICHTIGUNG</strong>, dass etwas passiert ist, auf die man sich "abonnieren" kann.
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Beispiel im Screenshot:</em> <code>Exited</code>. Ihr Skript kann dieses Ereignis "abhorchen", um eine Aktion auszuführen, sobald der Prozess beendet ist.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>CodeProperty</code> und <code>NoteProperty</code>:</strong> Spezielle Eigenschaftstypen, die oft von PowerShell selbst zur Vereinfachung hinzugefügt werden. <code>CodeProperty</code> berechnet seinen Wert "on the fly", während <code>NoteProperty</code> eine einfache Notizeigenschaft ist, die einem Objekt hinzugefügt wird.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Spalte 3: <code>Definition</code> (Definition)</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Dies ist die <strong>technische Definition</strong> oder "Signatur" eines Elements. Sie gibt Ihnen die genauen Details für seine Verwendung. Ihr Inhalt hängt vom <code>MemberType</code> ab:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Für <code>AliasProperty</code>:</strong> Zeigt an, <strong>womit der Alias gleichwertig ist</strong>. Das ist unglaublich nützlich!
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Beispiel im Screenshot:</em> <code>WS = WorkingSet64</code>. Sie sehen sofort, dass <code>WS</code> — das ist einfach eine kurze Schreibweise für <code>WorkingSet64</code> ist.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Für <code>Property</code>:</strong> Zeigt den <strong>Datentyp</strong> an, der in der Eigenschaft gespeichert ist (z.B. <code>int</code> für eine ganze Zahl, <code>string</code> für Text, <code>datetime</code> für Datum und Uhrzeit), und was man damit machen kann (<code>{get;}</code> — nur lesen, <code>{get;set;}</code> — lesen und ändern).
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Beispiel im Screenshot:</em> <code>int BasePriority {get;}</code>. Dies ist eine Ganzzahleigenschaft, die nur gelesen werden kann.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Für <code>Method</code>:</strong> Zeigt an, was die Methode zurückgibt (z.B. <code>void</code> — nichts, <code>bool</code> — wahr/falsch) und welche <strong>Parameter</strong> (Eingabedaten) sie in Klammern akzeptiert.
<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><em>Beispiel im Screenshot:</em> <code>void Kill()</code>. Dies bedeutet, dass die Methode <code>Kill</code> nichts zurückgibt und ohne Parameter aufgerufen werden kann. Es gibt auch eine zweite Version <code>void Kill(bool entireProcessTree)</code>, die einen booleschen Wert (true/false) akzeptiert.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">In Tabellenform</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table">
<table>
<thead>
<tr>
<th>Spalte</th>
<th>Was ist das?</th>
<th>Beispiel aus dem Screenshot</th>
<th>Wofür?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td>Der Name, den Sie im Code verwenden.</td>
<td><code>Kill</code>, <code>WS</code>, <code>Name</code></td>
<td>zum Zugriff auf eine Eigenschaft oder Methode (<code>$process.WS</code>, <code>$process.Kill()</code>).</td>
</tr>
<tr>
<td><strong>MemberType</strong></td>
<td>Der Typ des Elements (Daten, Aktion usw.).</td>
<td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td>
<td><strong>wie</strong> es zu verwenden ist (Wert lesen oder mit <code>()</code>).</td>
</tr>
<tr>
<td><strong>Definition</strong></td>
<td>Technische Details.</td>
<td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td>
<td>was hinter dem Alias steckt und welche Parameter die Methode benötigt.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Beispiel: Arbeiten mit Prozessfenstern</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problem:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Ich habe viele Notepad-Fenster geöffnet. Wie kann ich alle bis auf das Hauptfenster programmatisch minimieren und dann nur das schließen, dessen Titel das Wort 'Untitled' enthält?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Untersuchung mit <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Wir müssen Eigenschaften finden, die mit dem Fenster und dessen Titel zusammenhängen.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name notepad | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":7} -->
<figure class="wp-block-image"><img src="assets/02/7.png" alt="7"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>Analyse des <code>Get-Member</code>-Ergebnisses:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Beim Durchblättern der Eigenschaften finden wir <code>MainWindowTitle</code>. Typ <code>string</code>. Ausgezeichnet, das ist der Titel des Hauptfensters!</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>In den Methoden sehen wir <code>CloseMainWindow()</code>. Dies ist eine "sanftere" Methode zum Schließen eines Fensters als <code>Kill()</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>In den Methoden gibt es auch <code>WaitForInputIdle()</code>. Das klingt interessant, möglicherweise hilft es, zu warten, bis der Prozess zur Interaktion bereit ist.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:image {"id":8} -->
<figure class="wp-block-image"><img src="assets/02/7.png" alt="7"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><code>Get-Member</code> zeigte uns die Eigenschaft <code>MainWindowTitle</code>, die der Schlüssel zur Problemlösung ist und es ermöglicht, mit Prozessen basierend auf dem Status ihrer Fenster zu interagieren, nicht nur nach dem Namen.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Lösung:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Jetzt können wir eine Logik aufbauen, die auf dem Fenstertitel basiert.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># 1. Alle Notepad-Prozesse finden
$notepads = Get-Process -Name notepad

# 2. Jeden Prozess durchlaufen und den Titel überprüfen
foreach ($pad in $notepads) {
    # Für jeden Prozess ($pad) dessen Eigenschaft MainWindowTitle überprüfen
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Unbenanntes Notepad gefunden (ID: $($pad.Id)). Schließe sein Fenster..."
        # $pad.CloseMainWindow() # Auskommentierung entfernen, um tatsächlich zu schließen
        Write-Host "Fenster '$($pad.MainWindowTitle)' wäre geschlossen worden." -ForegroundColor Yellow
    } else {
        Write-Host "Überspringe Notepad mit Titel: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":9} -->
<figure class="wp-block-image"><img src="assets/02/8.png" alt="8"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":10} -->
<figure class="wp-block-image"><img src="assets/02/9.png" alt="9"/></figure>
<!-- /wp:image -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Beispiel: Den übergeordneten Prozess finden</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">1. Problem:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>"Manchmal sehe ich viele Kindprozesse von <code>chrome.exe</code> im System. Wie finde ich heraus, welcher davon der Haupt-, der 'übergeordnete' Prozess ist, der sie alle gestartet hat?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">2. Untersuchung mit <code>Get-Member</code>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Wir müssen etwas finden, das einen Prozess mit einem anderen verbindet.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":11} -->
<figure class="wp-block-image"><img src="assets/02/10.png" alt="10"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>Analyse des <code>Get-Member</code>-Ergebnisses:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Beim sorgfältigen Durchsehen der Liste finden wir eine Eigenschaft vom Typ <code>CodeProperty</code> mit dem Namen <code>Parent</code>.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Ihre Definition (<code>Definition</code>) — <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>. Dies ist eine berechnete Eigenschaft, die bei Zugriff ein <strong>Objekt des übergeordneten Prozesses</strong> zurückgibt.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">3. Lösung:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Jetzt können wir ein Skript schreiben, das für jeden <code>chrome</code>-Prozess Informationen über ihn und seinen Elternprozess ausgibt.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># 1. Alle Chrome-Prozesse abrufen
$chromeProcesses = Get-Process -Name chrome

# 2. Für jeden davon Informationen über ihn und seinen Elternprozess ausgeben
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Den übergeordneten Prozess abrufen
    $parent = $_.Parent
    
    # Eine schöne Ausgabe formatieren
    Write-Host "Prozess:" -ForegroundColor Green
    Write-Host "  - Name: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Sein Elternprozess:" -ForegroundColor Yellow
    Write-Host "  - Name: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<!-- /wp:code -->

<!-- wp:image {"id":12} -->
<figure class="wp-block-image"><img src="assets/02/11.png" alt="11"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":13} -->
<figure class="wp-block-image"><img src="assets/02/12.png" alt="12"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Wir sehen sofort, dass die Prozesse mit den IDs 4756, 7936, 8268 und 9752 vom Prozess mit der ID 14908 gestartet wurden. Es ist auch ein interessanter Fall mit dem Prozess ID: 7252 zu beobachten, dessen übergeordneter Prozess nicht definiert wurde (möglicherweise hatte sich der Elternprozess zum Zeitpunkt der Überprüfung bereits beendet). Eine Modifikation des Skripts mit einer <code>if ($parent)</code>-Prüfung behandelt diesen Fall sauber, ohne einen Fehler zu verursachen.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Get-Member</code> hat uns geholfen, die "versteckte" Eigenschaft <code>Parent</code> zu entdecken, die mächtige Möglichkeiten zur Analyse der Prozesshierarchie bietet.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">4. Die <code>*.ps1</code>-Datei (Skripterstellung)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Wenn Ihre Befehlskette nützlich wird, möchten Sie diese für die wiederholte Verwendung speichern. Dafür sind <strong>Skripte</strong> da — Textdateien mit der Erweiterung <strong><code>.ps1</code></strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Ausführungsberechtigung für Skripte</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Standardmäßig ist das Ausführen lokaler Skripte in Windows verboten. Um dies <strong>für den aktuellen Benutzer</strong> zu beheben, führen Sie einmalig in PowerShell <strong>als Administrator</strong> aus:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Dies ist eine sichere Einstellung, die es Ihnen erlaubt, Ihre eigenen Skripte und Skripte, die von einem vertrauenswürdigen Herausgeber signiert wurden, auszuführen.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Beispielskript <code>system_monitor.ps1</code></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Erstellen Sie eine Datei mit diesem Namen und fügen Sie den folgenden Code ein. Dieses Skript sammelt Systeminformationen und generiert Berichte.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell"># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Skript zur Erstellung eines Systemstatusberichts.
.DESCRIPTION
    Sammelt Informationen über Prozesse, Dienste und Speicherplatz und generiert Berichte.
.PARAMETER OutputPath
    Pfad zum Speichern der Berichte. Standardmäßig 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Block 1: Vorbereitung ---
Write-Host "Vorbereitung zur Berichterstellung..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Block 2: Datensammlung ---
Write-Host "Sammle Informationen..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Block 3: Funktionsaufruf für den Export (siehe nächster Abschnitt) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Berichte erfolgreich im Ordner $OutputPath" -ForegroundColor Magenta
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><em>Hinweis: Die Funktion <code>Export-Results</code> wird im nächsten Abschnitt als Beispiel für bewährte Methoden definiert.</em></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">5. Export von Ergebnissen</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Rohe Daten sind gut, aber oft müssen sie in einem für Menschen oder andere Programme geeigneten Format präsentiert werden. PowerShell bietet eine Vielzahl von Cmdlets für den Export.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table">
<table>
<thead>
<tr>
<th>Methode</th>
<th>Befehl</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Einfacher Text</strong></td>
<td><code>... | Out-File C:\Temp\data.txt</code></td>
<td>Leitet die Textdarstellung in eine Datei um.</td>
</tr>
<tr>
<td><strong>CSV (für Excel)</strong></td>
<td><code>... | Export-Csv C:\Temp\data.csv -NoTypeInfo</code></td>
<td>Exportiert Objekte in CSV. <code>-NoTypeInfo</code> entfernt die interne erste Zeile.</td>
</tr>
<tr>
<td><strong>HTML-Bericht</strong></td>
<td><code>... | ConvertTo-Html -Title "Bericht"</code></td>
<td>Erstellt HTML-Code aus Objekten.</td>
</tr>
<tr>
<td><strong>JSON (für API, Web)</strong></td>
<td><code>... | ConvertTo-Json</code></td>
<td>Konvertiert Objekte in das JSON-Format.</td>
</tr>
<tr>
<td><strong>XML (natives PowerShell-Format)</strong></td>
<td><code>... | Export-Clixml C:\Temp\data.xml</code></td>
<td>Speichert Objekte mit allen Datentypen. Sie können über <code>Import-Clixml</code> perfekt wiederhergestellt werden.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading">Ergänzung zum Skript: Exportfunktion</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Fügen wir unserem Skript <code>system_monitor.ps1</code> eine Funktion hinzu, die den Export übernimmt. Platzieren Sie diesen Code <strong>vor</strong> dem Aufruf von <code>Export-Results</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Export nach CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Erstellung eines schönen HTML-Berichts
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Top-10 Prozesse nach CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Dienststatistik&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;Systembericht&lt;/title&gt;" -Body "&lt;h1&gt;Systembericht vom $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Jetzt sammelt unser Skript nicht nur Daten, sondern speichert sie auch sauber in zwei Formaten: CSV für die Analyse und HTML für die schnelle Anzeige.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading">Fazit</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list"><!-- wp:list-item -->
<li><strong>Pipeline (<code>|</code>)</strong> — das Hauptwerkzeug zum Kombinieren von Befehlen und zur Objektverarbeitung.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>Get-Member</code></strong> — Objektanalyse, die zeigt, woraus Objekte bestehen.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Variablen (<code>$var</code>, <code>$_</code>)</strong> ermöglichen das Speichern von Daten und den Zugriff auf das aktuelle Objekt in der Pipeline.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong><code>.ps1</code>-Dateien</strong> verwandeln Befehle in wiederverwendbare Automatisierungswerkzeuge.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Export-Cmdlets</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) exportieren Daten im entsprechenden Format.</li>
<!-- /wp:list-item --></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>Im nächsten Teil werden wir dieses Wissen anwenden, um das Dateisystem zu navigieren und zu verwalten, indem wir die Objekte <code>System.IO.DirectoryInfo</code> und <code>System.IO.FileInfo</code> untersuchen.</strong></p>
<!-- /wp:paragraph -->[:it]<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" dir="rtl">פילוסופיית <span dir="ltr">PowerShell</span></h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" dir="rtl">חלק 2: <span dir="ltr">Pipeline</span> (צנרת), משתנים, <span dir="ltr">Get-Member</span>, קובץ <span dir="ltr">*.ps1*</span> וייצוא תוצאות</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl"><strong>❗ חשוב:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">אני כותב על <span dir="ltr">PS7 (PowerShell 7)</span>. הוא שונה מ-<span dir="ltr">PS5 (PowerShell 5)</span>. החל מהגרסה השביעית, <span dir="ltr">PowerShell</span> הפך חוצה פלטפורמות. עקב כך, השתנה אופן הפעולה של חלק מהפקודות.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">בחלק הראשון קבענו עקרון מפתח: <span dir="ltr">PowerShell</span> עובד עם <strong>אובייקטים</strong>, לא עם טקסט.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">פוסט זה מוקדש למספר כלים חשובים ב-<span dir="ltr">PowerShell</span>: נלמד להעביר אובייקטים דרך ה<strong>צנרת (<span dir="ltr">pipeline</span>)</strong>, לנתח אותם באמצעות <span dir="ltr"><strong><code>Get-Member</code></strong></span>, לשמור תוצאות ב<strong>משתנים</strong> ולאוטמט את כל זאת ב<strong>קבצי סקריפט (<span dir="ltr"><code>.ps1</code></span>)</strong> עם <strong>ייצוא</strong> התוצאות בפורמטים נוחים.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="rtl">1. מהי צנרת (<span dir="ltr"><code>|</code></span>)?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">צנרת ב-<span dir="ltr">PowerShell</span> היא מנגנון להעברת אובייקטי <span dir="ltr">.NET</span> מלאים (ולא רק טקסט) מפקודה אחת לאחרת, כאשר כל <span dir="ltr">cmdlet</span> הבא מקבל אובייקטים מובנים עם כל התכונות והמתודות שלהם.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">הסימן <span dir="ltr"><code>|</code></span> (קו אנכי) – הוא אופרטור הצנרת. משימתו היא לקחת את התוצאה (פלט) של הפקודה משמאלו, ולהעביר אותה כקלט לפקודה מימינו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><span dir="ltr">Command 1 (creates objects)</span> ← <span dir="ltr"><code>|</code></span> ← <span dir="ltr">Command 2 (receives and processes objects)</span> ← <span dir="ltr"><code>|</code></span> ← <span dir="ltr">Command 3 (receives processed objects)</span> ← <span dir="ltr"><code>|</code></span> ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">צנרת <span dir="ltr">UNIX</span> קלאסית: זרם טקסט</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">ב-<span dir="ltr"><code>bash</code></span>, הצנרת מעבירה <strong>זרם בתים</strong>, אשר בדרך כלל מתפרש כטקסט.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># Find all 'nginx' processes and count them
ps -ef | grep 'nginx' | wc -l
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="rtl">כאן <span dir="ltr"><code>ps</code></span> מוציא טקסט, <span dir="ltr"><code>grep</code></span> מסנן את הטקסט הזה, ו-<span dir="ltr"><code>wc</code></span> סופר שורות. כל כלי עזר אינו יודע דבר על "תהליכים", הוא עובד רק עם שורות.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">צנרת <span dir="ltr">PowerShell</span>: זרם אובייקטים</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl"><strong>דוגמה:</strong> בואו נקבל את כל התהליכים, נמיין אותם לפי שימוש במעבד ונבחר את 5 ה"זללנים" ביותר.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/1.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">כאן <span dir="ltr"><code>Get-Process</code></span> יוצר <strong>אובייקטים</strong> של תהליכים. <span dir="ltr"><code>Sort-Object</code></span> מקבל את ה<strong>אובייקטים</strong> האלה וממיין אותם לפי המאפיין <span dir="ltr"><code>CPU</code></span>. <span dir="ltr"><code>Select-Object</code></span> מקבל את ה<strong>אובייקטים</strong> הממוינים ובוחר את 5 הראשונים.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">בטח שמתם לב בפקודה למילים שמתחילות במקף (<span dir="ltr">-</span>): <span dir="ltr">-Property</span>, <span dir="ltr">-Descending</span>, <span dir="ltr">-First</span>. אלו הם פרמטרים.<br>פרמטרים – אלו הגדרות, מתגים והוראות ל-<span dir="ltr">cmdlet</span>. הם מאפשרים לשלוט ב<strong>איך</strong> הפקודה תבצע את עבודתה.<br>ללא פרמטרים, הפקודה פועלת במצב ברירת המחדל, ועם פרמטרים אתם נותנים לה הוראות ספציפיות.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">סוגי פרמטרים עיקריים:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li><strong>פרמטר עם ערך:</strong> דורש מידע נוסף.</li>
</ul>
<!-- /wp:list -->

<!-- wp:list -->
<ul dir="rtl">
<li><span dir="ltr"><code>-Property CPU</code></span>: אנחנו אומרים ל-<span dir="ltr"><code>Sort-Object</code></span> לפי איזה מאפיין למיין. <span dir="ltr"><code>CPU</code></span> הוא ערך הפרמטר.</li>
<li><span dir="ltr"><code>-First 5</code></span>: אנחנו אומרים ל-<span dir="ltr"><code>Select-Object</code></span> כמה אובייקטים לבחור. <span dir="ltr"><code>5</code></span> הוא ערך הפרמטר.</li>
</ul>
<!-- /wp:list -->

<!-- wp:list -->
<ul dir="rtl">
<li><strong>פרמטר-מתג (<span dir="ltr">flag</span>):</strong> אינו דורש ערך. עצם נוכחותו בפקודה מפעילה או מכבה התנהגות מסוימת.</li>
</ul>
<!-- /wp:list -->

<!-- wp:list -->
<ul dir="rtl">
<li><span dir="ltr"><code>-Descending</code></span>: הדגל הזה אומר ל-<span dir="ltr"><code>Sort-Object</code></span> לשנות את סדר המיון לסדר הפוך (מהגדול לקטן). הוא אינו זקוק לערך נוסף – הוא עצמו הוראה.</li>
</ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/2.png" alt="1"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">פקודה זו עונה על שאלה פשוטה מאוד:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><strong>"כמה תהליכים בדיוק בשם <span dir="ltr"><code>svchost.exe</code></span> פועלים כרגע במערכת שלי?"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">פירוק לשלבים</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl"><strong>שלב 1: <span dir="ltr"><code>Get-Process -Name 'svchost'</code></span></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">חלק זה של הפקודה פונה למערכת ההפעלה ומבקש למצוא <strong>את כל ללא יוצא מן הכלל</strong> התהליכים הפועלים, ששם קובץ ההפעלה שלהם הוא <span dir="ltr"><code>svchost.exe</code></span>.<br>בניגוד לתהליכים מסוג <span dir="ltr"><code>notepad</code></span> (שאחד או שניים מהם פועלים בדרך כלל), תהליכי <span dir="ltr"><code>svchost</code></span> תמיד <strong>רבים</strong> במערכת. הפקודה תחזיר <strong>מערך (אוסף) אובייקטים</strong>, כאשר כל אובייקט הוא תהליך <span dir="ltr"><code>svchost</code></span> נפרד ומלא עם ה-<span dir="ltr">ID</span> הייחודי שלו, שימוש בזיכרון וכו'.<br><span dir="ltr">PowerShell</span> מצא במערכת, לדוגמה, 90 תהליכי <span dir="ltr"><code>svchost</code></span> וכעת מחזיק בידיו אוסף של 90 אובייקטים.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl"><strong>שלב 2: <span dir="ltr"><code>|</code></span> (אופרטור צנרת)</strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">סימן זה לוקח את אוסף 90 אובייקטי ה-<span dir="ltr"><code>svchost</code></span>, שהתקבלו בשלב הראשון, ומתחיל להעביר אותם <strong>אחד אחד</strong> כקלט לפקודה הבאה.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl"><strong>שלב 3: <span dir="ltr"><code>Measure-Object</code></span></strong></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">מכיוון שקראנו ל-<span dir="ltr"><code>Measure-Object</code></span> ללא פרמטרים (כגון <span dir="ltr"><code>-Property</code></span>, <span dir="ltr"><code>-Sum</code></span> וכו'), הוא מבצע את פעולת ה<strong>ברירת מחדל</strong> שלו – פשוט סופר את מספר ה"פריטים" שהועברו אליו.<br>אחד, שניים, שלושה... לאחר שכל האובייקטים נספרו, <span dir="ltr"><code>Measure-Object</code></span> יוצר <strong>אובייקט-תוצאה משלו</strong>, ובו יש מאפיין <span dir="ltr"><code>Count</code></span>, השווה למספר הכולל.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li><strong><span dir="ltr"><code>Count: 90</code></span></strong> – זו התשובה לשאלתנו. 90 תהליכי <span dir="ltr"><code>svchost</code></span> פועלים.</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl">שאר השדות ריקים, כי לא ביקשנו מ-<span dir="ltr"><code>Measure-Object</code></span> לבצע חישובים מורכבים יותר.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">דוגמה עם <span dir="ltr"><code>svchost</code></span> ופרמטרים</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">בואו נשנה את המשימה שלנו. כעת איננו רוצים רק לספור את תהליכי ה-<span dir="ltr"><code>svchost</code></span>, אלא לדעת <strong>כמה סך הכל זיכרון <span dir="ltr">RAM</span> (במגה-בייטים) הם צורכים יחד</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">לשם כך נצטרך פרמטרים:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li><span dir="ltr"><code>-Property WorkingSet64</code></span>: הוראה זו אומרת ל-<span dir="ltr"><code>Measure-Object</code></span>: "מכל אובייקט <span dir="ltr"><code>svchost</code></span> שיגיע אליך, קח את הערך המספרי מהמאפיין <span dir="ltr"><code>WorkingSet64</code></span> (זהו שימוש בזיכרון בבתים)".</li>
<li><span dir="ltr"><code>-Sum</code></span>: הוראה-דגל זו אומרת: "סכום את כל הערכים האלה שלקחת מהמאפיין <span dir="ltr"><code>WorkingSet64</code></span>".</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl">הפקודה החדשה שלנו תיראה כך:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/3.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list" dir="rtl">
<li><span dir="ltr"><code>Get-Process</code></span> ימצא את כמות אובייקטי ה-<span dir="ltr"><code>svchost</code></span>.</li>
<li>הצנרת <span dir="ltr"><code>|</code></span> תעביר אותם ל-<span dir="ltr"><code>Measure-Object</code></span>.</li>
<li>אבל כעת <span dir="ltr"><code>Measure-Object</code></span> עובד באופן חדש:
<ul dir="rtl">
<li>הוא לוקח את אובייקט ה-<span dir="ltr"><code>svchost</code></span> הראשון, מסתכל על המאפיין <span dir="ltr"><code>.WorkingSet64</code></span> שלו (לדוגמה, <span dir="ltr"><code>25000000</code></span> בתים) וזוכר את המספר הזה.</li>
<li>לוקח את האובייקט השני, מסתכל על ה-<span dir="ltr"><code>.WorkingSet64</code></span> שלו (לדוגמה, <span dir="ltr"><code>15000000</code></span> בתים) ומוסיף לקודם.</li>
<li>...וכן הלאה עבור כל האובייקטים.</li>
</ul>
</li>
<li>בסופו של דבר, <span dir="ltr"><code>Measure-Object</code></span> יצור אובייקט-תוצאה, אך כעת הוא יהיה שונה.</li>
</ol>
<!-- /wp:list -->

<!-- wp:list -->
<ul dir="rtl">
<li><strong><span dir="ltr"><code>Count: 92</code></span></strong>: כמות האובייקטים.</li>
<li><strong><span dir="ltr"><code>Sum: 1661890560</code></span></strong>: זו הסכום הכולל של כל ערכי <span dir="ltr"><code>WorkingSet64</code></span> בבתים.</li>
<li><strong><span dir="ltr"><code>Property: WorkingSet64</code></span></strong>: שדה זה כעת גם מלא, הוא מיידע אותנו באיזה מאפיין בדיוק נעשה שימוש לחישובים.</li>
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="rtl">2. משתנים (רגילים ומיוחד <span dir="ltr"><code>$_</code></span>)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">משתנה הוא אחסון בעל שם בזיכרון, המכיל ערך כלשהו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">ערך זה יכול להיות כל דבר: טקסט, מספר, תאריך או, וזה הדבר החשוב ביותר עבור <span dir="ltr">PowerShell</span>, אובייקט שלם או אפילו אוסף אובייקטים. שם משתנה ב-<span dir="ltr">PowerShell</span> תמיד מתחיל בסימן דולר (<span dir="ltr">$</span>).<br>דוגמאות: <span dir="ltr">$name, $counter, $processList</span>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">משתנה מיוחד <span dir="ltr">$_</span>?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><span dir="ltr">$_</span> – הוא קיצור עבור "האובייקט הנוכחי" או "הדבר הזה".<br>תארו לעצמכם צנרת במפעל. לאורכה נעות חלקיקים שונים (אובייקטים).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><span dir="ltr">$_</span> – זהו בדיוק החלקיק שנמצא כעת מולכם (או מול הרובוט-מעבד).</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li>מקור (<span dir="ltr"><code>Get-Process</code></span>) – שופך על הצנרת קופסה שלמה של חלקים (כל התהליכים).</li>
<li>צנרת (<span dir="ltr"><code>|</code></span>) – גורמת לחלקיקים אלו לנוע על המסוע אחד אחד.</li>
<li>מעבד (<span dir="ltr"><code>Where-Object</code></span> או <span dir="ltr"><code>ForEach-Object</code></span>) – זהו רובוט שמסתכל על כל חלקיק.</li>
<li>המשתנה <span dir="ltr">$_</span> – זהו בדיוק החלקיק שנמצא כעת ב"ידיים" של הרובוט.</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl">כאשר הרובוט מסיים עם חלקיק אחד, הצנרת מזינה לו את הבא, ו-<span dir="ltr">$_</span> יצביע כעת עליו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">בואו נחשב כמה סך הכל זיכרון משתמשים תהליכי <span dir="ltr"><code>svchost</code></span>, ונציג את התוצאה על המסך.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># 1. Execute the command and save its complex result object into the $svchostMemory variable
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Now we can work with the saved object. Extract the Sum property from it.
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Display the result on the screen using the new variable
Write-Host "All svchost processes use $memoryInMB MB of memory."
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/4.png" alt="3"></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li><span dir="ltr"><code>Write-Host</code></span> – זהו <span dir="ltr">cmdlet</span> ייעודי, שמשימתו היחידה היא <strong>להציג טקסט ישירות למשתמש במסוף</strong>.</li>
<li>שורת טקסט במרכאות כפולות: <span dir="ltr"><code>"..."</code></span> - זוהי מחרוזת טקסט שאנו מעבירים ל-<span dir="ltr">cmdlet</span> <span dir="ltr"><code>Write-Host</code></span> כארגומנט. מדוע מרכאות כפולות ולא יחידות?
<p dir="rtl">ב-<span dir="ltr">PowerShell</span> קיימים שני סוגי מרכאות:</p>
<ul dir="rtl">
<li><strong>יחידות (<span dir="ltr"><code>'...'</code></span>):</strong> יוצרות <strong>מחרוזת מילולית</strong>. כל מה שבתוכן נתפס כטקסט רגיל, ללא יוצא מן הכלל.</li>
<li><strong>כפולות (<span dir="ltr"><code>"..."</code></span>):</strong> יוצרות <strong>מחרוזת ניתנת להרחבה (או להחלפה)</strong>. <span dir="ltr">PowerShell</span> "סורק" מחרוזת כזו בחיפוש אחר משתנים (המתחילים ב-<span dir="ltr">$</span>) ומחליף אותם בערכיהם.</li>
</ul>
</li>
<li><span dir="ltr"><code>$memoryInMB</code></span>. זהו משתנה, שבשלב הקודם של הסקריפט שלנו הכנסנו לתוכו את תוצאת החישובים. כאשר <span dir="ltr"><code>Write-Host</code></span> מקבל מחרוזת במרכאות כפולות, מתרחש תהליך הנקרא <strong>"הצבת משתנים" (<span dir="ltr">String Expansion</span>)</strong>:
<ol dir="rtl">
<li><span dir="ltr">PowerShell</span> רואה את הטקסט <span dir="ltr"><code>"All svchost processes use "</code></span>.</li>
<li>לאחר מכן הוא נתקל במבנה <span dir="ltr"><code>$memoryInMB</code></span>. הוא מבין שזה לא רק טקסט, אלא משתנה.</li>
<li>הוא מציץ בזיכרון, מוצא את הערך השמור ב-<span dir="ltr"><code>$memoryInMB</code></span> (לדוגמה, <span dir="ltr"><code>1585.52</code></span>).</li>
<li>הוא <strong>מציב את הערך הזה</strong> ישירות לתוך המחרוזת.</li>
<li>לאחר מכן הוא מוסיף את שאר הטקסט: <span dir="ltr"><code>" MB of memory."</code></span>.</li>
<li>בסופו של דבר, ל-<span dir="ltr"><code>Write-Host</code></span> מועברת כבר מחרוזת מוכנה, מורכבת: <span dir="ltr"><code>"All svchost processes use 1585.52 MB of memory."</code></span>.</li>
</ol>
</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl">הפעל את הפנקס:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list" dir="rtl">
<li>מוצאים את תהליך הפנקס ושומרים אותו למשתנה <span dir="ltr">$notepadProcess</span></li>
</ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">$notepadProcess = Get-Process -Name notepad
</code></pre>
<!-- /wp:code -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list" dir="rtl">
<li>פונים למאפיין '<span dir="ltr">Id</span>' של אובייקט זה באמצעות נקודה ומציגים אותו</li>
</ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Write-Host "ID of 'Notepad' process is: $($notepadProcess.Id)"
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/5.png" alt="5"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><strong>❗ חשוב:</strong><br><span dir="ltr">Write-Host</span> "שובר" את הצנרת. טקסט שהוצג באמצעותו אינו ניתן להעברה נוספת בצנרת לצורך עיבוד. הוא מיועד רק להצגה.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" dir="rtl">3. <span dir="ltr">Get-Member</span> (מפקח אובייקטים)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">אנחנו יודעים שאובייקטים "זורמים" דרך הצנרת. אבל איך לדעת ממה הם מורכבים? אילו תכונות יש להם ואילו פעולות (<span dir="ltr">methods</span>) ניתן לבצע איתם?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">ה-<span dir="ltr">cmdlet</span> <strong><span dir="ltr"><code>Get-Member</code></span></strong> (כינוי: <span dir="ltr"><code>gm</code></span>) הוא הכלי העיקרי למחקר. לפני שעובדים עם אובייקט, העבירו אותו דרך <span dir="ltr"><code>Get-Member</code></span> כדי לראות את כל יכולותיו.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">בואו ננתח את האובייקטים ש-<span dir="ltr"><code>Get-Process</code></span> יוצר:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/6.png" alt="6"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><em>ננתח כל חלק מפלט <span dir="ltr">Get-Member</span>.</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><span dir="ltr"><code>TypeName: System.Diagnostics.Process</code></span> - זהו "שם סוג" האובייקט המלא והרשמי מספריית <span dir="ltr">.NET</span>. זהו ה"דרכון" שלו.<br>שורה זו אומרת לכם שכל האובייקטים ש-<span dir="ltr">Get-Process</span> מחזיר, הם אובייקטים מסוג <span dir="ltr"><code>System.Diagnostics.Process</code></span>. זה מבטיח שלכולם תהיה אותה קבוצה של תכונות ומתודות.<br>אתם יכולים <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com" target="_blank" rel="noreferrer noopener"><span dir="ltr">לחפש בגוגל</span></a> "<span dir="ltr">System.Diagnostics.Process</span>" כדי למצוא את התיעוד הרשמי של <span dir="ltr">Microsoft</span> עם מידע מפורט יותר.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li>עמודה 1: <span dir="ltr"><code>Name</code></span></li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl">זהו פשוט **שם** קריא-אנושית של תכונה, מתודה או "חבר" אחר של האובייקט. זהו השם שתשתמשו בו בקוד שלכם כדי לגשת לנתונים או לבצע פעולות.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li>עמודה 2: <span dir="ltr"><code>MemberType</code></span> (סוג אובייקט)</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl">זוהי העמודה החשובה ביותר להבנה. היא מסווגת **מהו** כל אובייקט. זו ה"דרגה" שלו, שאומרת לכם **איך** להשתמש בו.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li><strong><span dir="ltr"><code>Property</code></span> (מאפיין):</strong> <strong>מאפיין</strong> או <strong>חלק נתונים</strong> השמור בתוך האובייקט. ניתן "לקרוא" את ערכו.
<ul dir="rtl">
<li><em>דוגמאות בצילום המסך:</em> <span dir="ltr"><code>BasePriority</code></span>, <span dir="ltr"><code>HandleCount</code></span>, <span dir="ltr"><code>ExitCode</code></span>. אלו הם פשוט נתונים שניתן לצפות בהם.</li>
</ul>
</li>
<li><strong><span dir="ltr"><code>Method</code></span> (מתודה):</strong> <strong>פעולה</strong> שניתן לבצע עם האובייקט. מתודות נקראות תמיד עם סוגריים עגולים <span dir="ltr"><code>()</code></span>.
<ul dir="rtl">
<li><em>דוגמאות בצילום המסך:</em> <span dir="ltr"><code>Kill</code></span>, <span dir="ltr"><code>Refresh</code></span>, <span dir="ltr"><code>WaitForExit</code></span>. הייתם כותבים <span dir="ltr"><code>$process.Kill()</code></span> או <span dir="ltr"><code>$process.Refresh()</code></span>.</li>
</ul>
</li>
<li><strong><span dir="ltr"><code>AliasProperty</code></span> (כינוי מאפיין):</strong> <strong>כינוי ידידותי</strong> למאפיין אחר, ארוך יותר. <span dir="ltr">PowerShell</span> מוסיף אותם לנוחות וקיצור.
<ul dir="rtl">
<li><em>דוגמאות בצילום המסך:</em> <span dir="ltr"><code>WS</code></span> – זהו כינוי קצר עבור <span dir="ltr"><code>WorkingSet64</code></span>. <span dir="ltr"><code>Name</code></span> – עבור <span dir="ltr"><code>ProcessName</code></span>. <span dir="ltr"><code>VM</code></span> – עבור <span dir="ltr"><code>VirtualMemorySize64</code></span>.</li>
</ul>
</li>
<li><strong><span dir="ltr"><code>Event</code></span> (אירוע):</strong> <strong>הודעה</strong> על כך שמשהו קרה, שאליה ניתן "להירשם".
<ul dir="rtl">
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>Exited</code></span>. הסקריפט שלכם יכול "להקשיב" לאירוע זה כדי לבצע פעולה כלשהי מיד לאחר שהתהליך מסתיים.</li>
</ul>
</li>
<li><strong><span dir="ltr"><code>CodeProperty</code></span> ו-<span dir="ltr"><code>NoteProperty</code></span>:</strong> סוגי מאפיינים מיוחדים, לרוב מתווספים על ידי <span dir="ltr">PowerShell</span> עצמו לנוחות. <span dir="ltr"><code>CodeProperty</code></span> מחשב את ערכו "בזמן אמת", ו-<span dir="ltr"><code>NoteProperty</code></span> – זהו מאפיין-הערה פשוט, שנוסף לאובייקט.</li>
</ul>
<!-- /wp:list -->

<!-- wp:list -->
<ul dir="rtl">
<li>עמודה 3: <span dir="ltr"><code>Definition</code></span> (הגדרה)</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl">זוהי **ההגדרה הטכנית** או ה"חתימה" של החבר. היא נותנת לכם פרטים מדויקים לשימוש בו. תוכנה תלוי ב-<span dir="ltr"><code>MemberType</code></span>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li><strong>עבור <span dir="ltr"><code>AliasProperty</code></span>:</strong> מראה, **למה שווה הכינוי**. זה שימושי להפליא!
<ul dir="rtl">
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>WS = WorkingSet64</code></span>. אתם מיד רואים ש-<span dir="ltr"><code>WS</code></span> הוא פשוט קיצור עבור <span dir="ltr"><code>WorkingSet64</code></span>.</li>
</ul>
</li>
<li><strong>עבור <span dir="ltr"><code>Property</code></span>:</strong> מראה **סוג הנתונים** השמור במאפיין (לדוגמה, <span dir="ltr"><code>int</code></span> למספר שלם, <span dir="ltr"><code>string</code></span> לטקסט, <span dir="ltr"><code>datetime</code></span> לתאריך ושעה), ומה ניתן לעשות איתו (<span dir="ltr"><code>{get;}</code></span> – רק לקרוא, <span dir="ltr"><code>{get;set;}</code></span> – לקרוא ולשנות).
<ul dir="rtl">
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>int BasePriority {get;}</code></span>. זהו מאפיין מסוג מספר שלם שניתן רק לקרוא.</li>
</ul>
</li>
<li><strong>עבור <span dir="ltr"><code>Method</code></span>:</strong> מראה מה המתודה מחזירה (לדוגמה, <span dir="ltr"><code>void</code></span> – כלום, <span dir="ltr"><code>bool</code></span> – אמת/שקר) ואילו **פרמטרים** (נתוני קלט) היא מקבלת בסוגריים.
<ul dir="rtl">
<li><em>דוגמה בצילום המסך:</em> <span dir="ltr"><code>void Kill()</code></span>. זה אומר שהמתודה <span dir="ltr"><code>Kill</code></span> לא מחזירה כלום וניתן לקרוא לה ללא פרמטרים. קיימת גם גרסה שנייה <span dir="ltr"><code>void Kill(bool entireProcessTree)</code></span>, המקבלת ערך בוליאני (<span dir="ltr">true/false</span>).</li>
</ul>
</li>
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">בצורת טבלה</h4>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table" dir="rtl">
<table>
<thead>
<tr>
<th dir="rtl">עמודה</th>
<th dir="rtl">מה זה?</th>
<th dir="rtl">דוגמה מצילום המסך</th>
<th dir="rtl">לשם מה?</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="rtl"><strong><span dir="ltr">Name</span></strong></td>
<td dir="rtl">השם שבו אתם משתמשים בקוד.</td>
<td dir="ltr"><code>Kill</code>, <code>WS</code>, <code>Name</code></td>
<td dir="rtl">לפנות למאפיין או למתודה (<span dir="ltr"><code>$process.WS</code></span>, <span dir="ltr"><code>$process.Kill()</code></span>).</td>
</tr>
<tr>
<td dir="rtl"><strong><span dir="ltr">MemberType</span></strong></td>
<td dir="rtl">סוג החבר (נתונים, פעולה וכו').</td>
<td dir="ltr"><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td>
<td dir="rtl"><strong>איך</strong> להשתמש בו (לקרוא ערך או לקרוא עם <span dir="ltr"><code>()</code></span>).</td>
</tr>
<tr>
<td dir="rtl"><strong><span dir="ltr">Definition</span></strong></td>
<td dir="rtl">פרטים טכניים.</td>
<td dir="ltr"><code>WS = WorkingSet64</code>, <code>void Kill()</code></td>
<td dir="rtl">מה מסתתר מאחורי הכינוי ואילו פרמטרים נחוצים למתודה.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">דוגמה: עבודה עם חלונות תהליכים</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">1. בעיה:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">"פתחתי הרבה חלונות פנקס רשימות. איך אני מכווץ את כולם באופן פרוגרמטי, מלבד הראשי, ואז סוגר רק את זה שיש בכותרתו את המילה '<span dir="ltr">Untitled</span>'?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">2. מחקר עם <span dir="ltr">Get-Member</span>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">עלינו למצוא תכונות הקשורות לחלון ולכותרתו.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name notepad | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="rtl"><strong>ניתוח תוצאת <span dir="ltr">Get-Member</span>:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li>בעת סקירת המאפיינים, אנו מוצאים את <span dir="ltr"><code>MainWindowTitle</code></span>. סוג <span dir="ltr"><code>string</code></span>. מצוין, זו כותרת החלון הראשי!</li>
<li>במתודות אנו רואים <span dir="ltr"><code>CloseMainWindow()</code></span>. זו דרך "רכה" יותר לסגור חלון מאשר <span dir="ltr"><code>Kill()</code></span>.</li>
<li>כמו כן, במתודות יש <span dir="ltr"><code>WaitForInputIdle()</code></span>. נשמע מעניין, ייתכן שזה יעזור להמתין עד שהתהליך יהיה מוכן לאינטראקציה.</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><img src="assets/02/7.png" alt="7"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><span dir="ltr">Get-Member</span> הראה לנו את המאפיין <span dir="ltr"><code>MainWindowTitle</code></span>, שהוא המפתח לפתרון הבעיה ומאפשר אינטראקציה עם תהליכים על בסיס מצב החלונות שלהם, ולא רק לפי שם.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">3. פתרון:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">כעת אנו יכולים לבנות לוגיקה המבוססת על כותרת החלון.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># 1. Find all Notepad processes
$notepads = Get-Process -Name notepad

# 2. Iterate through each and check the title
foreach ($pad in $notepads) {
    # For each process ($pad), check its MainWindowTitle property
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Found unsaved Notepad (ID: $($pad.Id)). Closing its window..."
        # $pad.CloseMainWindow() # Uncomment to actually close
        Write-Host "Window '$($pad.MainWindowTitle)' would have been closed." -ForegroundColor Yellow
    } else {
        Write-Host "Skipping Notepad with title: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/8.png" alt="8"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/9.png" alt="9"></p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator has-alpha-channel-opacity"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">דוגמה: מציאת תהליך אב</h4>
<!-- /wp:heading -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">1. בעיה:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">"לפעמים אני רואה במערכת הרבה תהליכי צאצא של <span dir="ltr"><code>chrome.exe</code></span>. איך אני מגלה איזה מהם הוא תהליך האב הראשי, שהפעיל את כולם?"</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">2. מחקר עם <span dir="ltr">Get-Member</span>:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">עלינו למצוא משהו שמקשר תהליך אחד לאחר.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/10.png" alt="10"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl"><strong>ניתוח תוצאת <span dir="ltr">Get-Member</span>:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul dir="rtl">
<li>בעת סקירת הרשימה בזהירות, אנו מוצאים מאפיין מסוג <span dir="ltr"><code>CodeProperty</code></span> בשם <span dir="ltr"><code>Parent</code></span>.</li>
<li>ההגדרה שלו (<span dir="ltr"><code>Definition</code></span>) – <span dir="ltr"><code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code></span>. זהו מאפיין מחושב, אשר בעת פנייה אליו מחזיר <strong>אובייקט תהליך האב</strong>.</li>
</ul>
<!-- /wp:list -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">3. פתרון:</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">כעת אנו יכולים לכתוב סקריפט, אשר עבור כל תהליך <span dir="ltr"><code>chrome</code></span> יציג מידע על התהליך עצמו ועל האב שלו.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># 1. Get all chrome processes
$chromeProcesses = Get-Process -Name chrome

# 2. For each of them, display information about it and its parent
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Get the parent process
    $parent = $_.Parent
    
    # Format the output nicely
    Write-Host "Process:" -ForegroundColor Green
    Write-Host "  - Name: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Its parent:" -ForegroundColor Yellow
    Write-Host "  - Name: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><img src="assets/02/11.png" alt="11"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><img src="assets/02/12.png" alt="12"></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p dir="rtl">אנו רואים מיד כי תהליכים עם <span dir="ltr">ID</span> 4756, 7936, 8268 ו-9752 הופעלו על ידי תהליך עם <span dir="ltr">ID</span> 14908. ניתן גם להבחין במקרה מעניין עם תהליך <span dir="ltr">ID</span>: 7252, שתהליך האב שלו לא הוגדר (ייתכן שתהליך האב כבר הסתיים עד למועד הבדיקה). שינוי הסקריפט עם בדיקת <span dir="ltr"><code>if ($parent)</code></span> מטפל במקרה זה בצורה חלקה, מבלי לגרום לשגיאה.<br><span dir="ltr">Get-Member</span> עזר לנו לגלות את המאפיין "הנסתר" <span dir="ltr">Parent</span>, המספק יכולות עוצמתיות לניתוח היררכיית התהליכים.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">4. קובץ <span dir="ltr">*.ps1*</span> (יצירת סקריפטים)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">כאשר שרשרת הפקודות שלכם הופכת לשימושית, תרצו לשמור אותה לשימוש חוזר. לשם כך נועדו **סקריפטים** – קבצי טקסט עם סיומת **<span dir="ltr"><code>.ps1</code></span>**.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">הרשאה להפעלת סקריפטים</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">כברירת מחדל, ב-<span dir="ltr">Windows</span> אסורה הפעלת סקריפטים מקומיים. כדי לתקן זאת **עבור המשתמש הנוכחי**, בצעו פעם אחת ב-<span dir="ltr">PowerShell</span> **כמנהל מערכת**:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="rtl">זוהי הגדרה בטוחה, המאפשרת להפעיל את הסקריפטים שלכם וסקריפטים חתומים על ידי מפרסם מהימן.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">דוגמת סקריפט <span dir="ltr">system_monitor.ps1</span></h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">צרו קובץ בשם זה והדביקו בו את הקוד למטה. סקריפט זה אוסף מידע על המערכת ומייצר דוחות.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr"># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    Script for creating a system status report.
.DESCRIPTION
    Collects information about processes, services, and disk space and generates reports.
.PARAMETER OutputPath
    Path to save reports. Default is 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Block 1: Preparation ---
Write-Host "Preparing to create report..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Block 2: Data Collection ---
Write-Host "Collecting information..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Block 3: Calling the export function (see next section) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Reports successfully saved in folder $OutputPath" -ForegroundColor Magenta
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="rtl"><em>הערה: הפונקציה <span dir="ltr"><code>Export-Results</code></span> תוגדר בסעיף הבא כדוגמה לפרקטיקה טובה.</em></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">5. ייצוא תוצאות</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">נתונים נקיים – זה טוב, אבל לעיתים קרובות יש צורך להציג אותם בצורה נוחה לבני אדם או לתוכנות אחרות. <span dir="ltr">PowerShell</span> מציע מגוון רחב של <span dir="ltr">cmdlets</span> לייצוא.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table" dir="rtl">
<table>
<thead>
<tr>
<th dir="rtl">שיטה</th>
<th dir="rtl">פקודה</th>
<th dir="rtl">תיאור</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="rtl"><strong>טקסט פשוט</strong></td>
<td dir="ltr"><code>... | Out-File C:\Temp\data.txt</code></td>
<td dir="rtl">מפנה ייצוג טקסטואלי לקובץ.</td>
</tr>
<tr>
<td dir="rtl"><strong><span dir="ltr">CSV</span> (עבור <span dir="ltr">Excel</span>)</strong></td>
<td dir="ltr"><code>... | Export-Csv C:\Temp\data.csv -NoTypeInfo</code></td>
<td dir="rtl">מייצא אובייקטים ל-<span dir="ltr">CSV</span>. <span dir="ltr"><code>-NoTypeInfo</code></span> מסיר את שורת השירות הראשונה.</td>
</tr>
<tr>
<td dir="rtl"><strong>דוח <span dir="ltr">HTML</span></strong></td>
<td dir="ltr"><code>... | ConvertTo-Html -Title "Report"</code></td>
<td dir="rtl">יוצר קוד <span dir="ltr">HTML</span> מאובייקטים.</td>
</tr>
<tr>
<td dir="rtl"><strong><span dir="ltr">JSON</span> (עבור <span dir="ltr">API</span>, אינטרנט)</strong></td>
<td dir="ltr"><code>... | ConvertTo-Json</code></td>
<td dir="rtl">ממיר אובייקטים לפורמט <span dir="ltr">JSON</span>.</td>
</tr>
<tr>
<td dir="rtl"><strong><span dir="ltr">XML</span> (פורמט מקורי של <span dir="ltr">PowerShell</span>)</strong></td>
<td dir="ltr"><code>... | Export-Clixml C:\Temp\data.xml</code></td>
<td dir="rtl">שומר אובייקטים עם כל סוגי הנתונים. ניתן לשחזר אותם באופן מושלם באמצעות <span dir="ltr"><code>Import-Clixml</code></span>.</td>
</tr>
</tbody>
</table>
</figure>
<!-- /wp:table -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" dir="rtl">השלמה לסקריפט: פונקציית ייצוא</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p dir="rtl">בואו נוסיף לסקריפט שלנו <span dir="ltr"><code>system_monitor.ps1</code></span> פונקציה שתעסוק בייצוא. מקמו את הקוד הזה **לפני** קריאה ל-<span dir="ltr"><code>Export-Results</code></span>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="line-numbers"><code class="language-powershell" dir="ltr">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Export to CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Create a nice HTML report
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>Top 10 processes by CPU</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>Services Statistics</h2>"

    ConvertTo-Html -Head "&lt;title&gt;System Report&lt;/title&gt;" -Body "&lt;h1&gt;System Report from $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p dir="rtl">כעת הסקריפט שלנו לא רק אוסף נתונים, אלא גם שומר אותם בקפידה בשני פורמטים: <span dir="ltr">CSV</span> לניתוח ו-<span dir="ltr">HTML</span> לצפייה מהירה.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" dir="rtl">סיכום</h4>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list" dir="rtl">
<li><strong>צנרת (<span dir="ltr"><code>|</code></span>)</strong> – הכלי העיקרי לשילוב פקודות ועיבוד אובייקטים.</li>
<li><strong><span dir="ltr"><code>Get-Member</code></span></strong> – ניתוח אובייקטים, המראה ממה הם מורכבים.</li>
<li><strong>משתנים (<span dir="ltr"><code>$var</code></span>, <span dir="ltr"><code>$_</code></span>)</strong> מאפשרים לשמור נתונים ולפנות לאובייקט הנוכחי בצנרת.</li>
<li><strong>קבצי <span dir="ltr"><code>.ps1</code></span></strong> הופכים פקודות לכלי אוטומציה הניתנים לשימוש חוזר.</li>
<li><strong><span dir="ltr">Cmdlets</span> ייצוא</strong> (<span dir="ltr"><code>Export-Csv</code></span>, <span dir="ltr"><code>ConvertTo-Html</code></span>) מייצאים נתונים בפורמט המתאים.</li>
</ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p dir="rtl"><strong>בחלק הבא ניישם ידע זה לניווט וניהול מערכת הקבצים, ונחקור את האובייקטים <span dir="ltr"><code>System.IO.DirectoryInfo</code></span> ו-<span dir="ltr"><code>System.IO.FileInfo</code></span>.</strong></p>
<!-- /wp:paragraph -->
[:]