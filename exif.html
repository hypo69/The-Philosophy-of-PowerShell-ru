<h2>Полное руководство по ExifTool и PowerShell</h2>
<p>Каждый раз, когда вы делаете фотографию, ваша камера записывает в файл не только само изображение, но и служебную информацию: модель камеры и объектива, дату и время съемки, выдержку, диафрагму,<br>
<code>ISO</code>, <code>GPS</code>-координаты. Эти данные называются **<code>EXIF</code> (<code>Exchangeable Image File Format</code>)**.</p>
<p>Хотя <code>PowerShell</code> имеет встроенные средства для чтения некоторых метаданных, они ограничены. Чтобы получить доступ ко **всей** информации, нужен специализированный инструмент.<br>
В этой статье я использую **<code>ExifTool</code>**.</p>
<p><strong><code>ExifTool</code></strong> — это бесплатная, кросс-платформенная утилита с открытым исходным кодом, написанная Филом Харви. Она является золотым стандартом для чтения, записи и редактирования метаданных в самых разных форматах файлов (изображения, аудио, видео, <code>PDF</code> и др.). <code>ExifTool</code> знает тысячи тегов от сотен производителей устройств, что делает его самым всеобъемлющим инструментом в своем классе.</p>
<h3>Скачивание и правильная настройка</h3>
<p>Прежде чем писать код, нужно подготовить саму утилиту.</p>
<ol>
<li>Зайдите на **официальный сайт <code>ExifTool</code>: <a href="https://exiftool.org/">https://exiftool.org/</a>**. На главной странице найдите и скачайте **"<code>Windows Executable</code>"**.</li>
<li>
<p><strong>Переименование (Критически важный шаг!):</strong> Скачанный файл будет называться <code>exiftool(-k).exe</code>. Это не случайность.</p>
<p>Переименуйте его в **<code>exiftool.exe</code>**, чтобы **отключить режим "паузы"**, который предназначен для пользователей, запускающих программу двойным щелчком мыши.</p>
</li>
<li>
<p><strong>Хранение:</strong> У вас есть два основных варианта, где хранить <code>exiftool.exe</code>.</p>
<ul>
<li><strong>Вариант 1 (Простой): В той же папке, что и ваш скрипт.</strong> Это самый легкий путь. Ваш скрипт <code>PowerShell</code> всегда сможет найти утилиту, так как она лежит рядом. Идеально для портативных скриптов, которые вы переносите с компьютера на компьютер.</li>
<li><strong>Вариант 2 (Рекомендуемый для частого использования): В папке из системной переменной <code>PATH</code>.</strong> Переменная <code>PATH</code> — это список директорий, где <code>Windows</code> и <code>PowerShell</code> автоматически ищут исполняемые файлы.<br>
Вы можете создать папку (например, <code>C:\Tools</code>), положить туда <code>exiftool.exe</code> и добавить <code>C:\Tools</code> в системную переменную <code>PATH</code>.<br>
После этого вы сможете вызывать <code>exiftool.exe</code> из любой папки в любой консоли.</li>
</ul>
</li>
</ol>
<p>Скрипты для добавления в <code>$PATH</code>:<br>
Добавление директории в <code>PATH</code> для ТЕКУЩЕГО ПОЛЬЗОВАТЕЛЯ<br>
Добавление директории в СИСТЕМНЫЙ <code>PATH</code> для ВСЕХ ПОЛЬЗОВАТЕЛЕЙ</p>
<hr>
<h2><code>PowerShell</code> и внешние программы</h2>
<p>Чтобы эффективно использовать <code>ExifTool</code>, нужно знать, как <code>PowerShell</code> запускает внешние <code>.exe</code> файлы.<br>
Правильный и самый надежный способ запуска внешних программ — это **оператор вызова <code>&amp;</code> (амперсанд)**.<br>
<code>PowerShell</code> выдаст ошибку в случае, если путь к программе содержит пробелы. Например, <code>C:\My Tools\exiftool.exe</code>.<br>
<code>&amp;</code> (амперсанд)** говорит <code>PowerShell</code>: "Текст, который следует за мной в кавычках, — это путь к исполняемому файлу. Запусти его, а всё, что идет дальше, — это его аргументы".</p>
<pre class="line-numbers"><code class="language-powershell"># Правильный синтаксис
&amp; "C:\Path With Spaces\program.exe" "аргумент 1" "аргумент 2"
</code></pre>
<p>Всегда используйте <code>&amp;</code>, когда работаете с путями к программам в переменных или путями, которые могут содержать пробелы.</p>
<hr>
<h2>Практические трюки: <code>ExifTool</code> + <code>PowerShell</code></h2>
<p>Теперь объединим наши знания.</p>
<h3>Пример №1: Базовое извлечение и интерактивный просмотр</h3>
<p>Самый простой способ получить все данные из фото и изучить их — это запросить их в формате <code>JSON</code> и передать в <code>Out-ConsoleGridView</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$photoPath = "D:\Photos\IMG_1234.JPG"

# 1. Запускаем exiftool с ключом -json для структурированного вывода
# 2. Преобразуем JSON-текст в объект PowerShell
#    Вызываем exiftool.exe напрямую, без переменной и оператора вызова &amp;.
$exifObject = exiftool.exe -json $photoPath | ConvertFrom-Json

# 3. Превращаем "широкий" объект в удобную таблицу "Параметр-Значение"
$reportData = $exifObject.psobject.Properties | Select-Object Name, Value

# 4. Выводим результат в интерактивное окно для анализа
$reportData | Out-ConsoleGridView -Title "Метаданные файла: $($photoPath | Split-Path -Leaf)"
</code></pre>
<p>Этот код откроет интерактивное окно, где вы сможете отсортировать данные по имени параметра или значению, а также отфильтровать их, просто начав вводить текст. Это невероятно удобно для быстрого поиска нужной информации.</p>
<h3>Пример №2: Создание чистого отчета и отправка на разные "устройства"</h3>
<p><code>Out-ConsoleGridView</code> — это только начало. Вы можете направить обработанные данные куда угодно, используя другие командлеты <code>Out-*</code>.</p>
<p>Предположим, у нас есть данные в переменной <code>$reportData</code> из предыдущего примера.</p>
<h4>**А) Отправка в <code>CSV</code>-файл для <code>Excel</code>**</h4>
<pre class="line-numbers"><code class="language-powershell">$reportData | Export-Csv -Path "C:\Reports\photo_exif.csv" -NoTypeInformation -Encoding UTF8
</code></pre>
<p>Команда <code>Export-Csv</code> создает идеально структурированный файл, который можно открыть в <code>Excel</code> или <code>Google</code> Таблицах.</p>
<h4>**Б) Отправка в текстовый файл**</h4>
<pre class="line-numbers"><code class="language-powershell"># Для красивого форматирования сначала используем Format-Table
$reportData | Format-Table -AutoSize | Out-File -FilePath "C:\Reports\photo_exif.txt"
</code></pre>
<p>Команда <code>Out-File</code> сохранит в файл точную текстовую копию того, что вы видите в консоли.</p>
<h4>**В) Отправка в буфер обмена**</h4>
<p>Хотите быстро вставить данные в письмо или чат? Используйте <code>Out-Clipboard</code>.</p>
<pre class="line-numbers"><code class="language-powershell">$reportData | Format-Table -AutoSize | Out-String | Out-Clipboard
</code></pre>
<p>Теперь вы можете нажать <code>Ctrl+V</code> в любом текстовом редакторе и вставить аккуратно отформатированную таблицу.</p>
<h3>Пример №3: Получение конкретных данных для использования в скрипте</h3>
<p>Часто вам не нужен весь отчет, а лишь одно или два значения. Поскольку <code>$exifObject</code> — это обычный объект <code>PowerShell</code>, вы можете легко обращаться к его свойствам.</p>
<pre class="line-numbers"><code class="language-powershell">
$photoPath = "D:\Photos\IMG_1234.JPG"

# Вызываем exiftool.exe напрямую по имени.
# PowerShell автоматически найдет его в одной из папок, перечисленных в PATH.
$exifObject = exiftool.exe -json $photoPath | ConvertFrom-Json

# 1. Создаем один PowerShell-объект с понятными именами свойств.
#    Это похоже на создание структурированной записи.
$reportObject = [PSCustomObject]@{ 
    "Камера"           = $exifObject.Model
    "Дата съемки"      = $exifObject.DateTimeOriginal
    "Чувствительность" = $exifObject.ISO
    "Имя файла"        = $exifObject.FileName # Добавим имя файла для контекста
}

# 2. Выводим этот объект в интерактивное окно.
#    Out-GridView автоматически создаст колонки из имен свойств.
$reportObject | Out-ConsoleGridView -Title "Метаданные файла: $(Split-Path $photoPath -Leaf)"
</code></pre>
<p>Этот подход является основой для любой серьезной автоматизации, такой как переименование файлов на основе даты съемки, сортировка фотографий по модели камеры или добавление водяных знаков с информацией о выдержке.</p>
<h3>Пример №4: Пакетное извлечение метаданных из папки</h3>
<p>Иногда нужно проанализировать не одно фото, а целую папку с изображениями.</p>
<pre class="line-numbers"><code class="language-powershell"># Указываем только папку с фотографиями.
$photoFolder = "D:\Photos"

# Вызываем exiftool.exe напрямую.
# Ключ -json обрабатывает все файлы в папке, если указан шаблон.
$allExif = exiftool.exe -json "$photoFolder\*.jpg" | ConvertFrom-Json

# Превращаем в удобный вид 
$report = foreach ($photo in $allExif) {
    [PSCustomObject]@{
        # --- Основные данные о файле и камере ---
        FileName       = $photo.FileName
        DateTime       = $photo.DateTimeOriginal
        CameraMake     = $photo.Make                 # Производитель (например, "Canon", "SONY")
        CameraModel    = $photo.Model                 # Модель камеры (например, "EOS R5")
        LensModel      = $photo.LensID                # Полное название модели объектива
        
        # --- Параметры съемки (экспозиция) ---
        ISO            = $photo.ISO
        ShutterSpeed   = $photo.ShutterSpeed
        Aperture       = $photo.Aperture
        FocalLength    = $photo.FocalLength           # Фокусное расстояние (например, "50.0 mm")
        ExposureMode   = $photo.ExposureProgram       # Режим съемки (например, "Manual", "Aperture Priority")
        Flash          = $photo.Flash                 # Информация о том, сработала ли вспышка
        
        # --- GPS и данные изображения ---
        GPSPosition    = $photo.GPSPosition           # Координаты GPS в виде одной строки (если есть)
        Dimensions     = "$($photo.ImageWidth)x$($photo.ImageHeight)" # Размеры изображения в пикселях
    }
}

# Выводим данные в интерактивную таблицу в КОНСОЛИ
$report | Out-ConsoleGridView -Title "Сводный отчет по папке: $photoFolder"
</code></pre>
<p>💡 Вы получаете аккуратную таблицу для всей папки сразу.</p>
<hr>
<h3>Пример №5: Рекурсивный поиск по подпапкам</h3>
<p><code>ExifTool</code> умеет сам искать файлы во всех подпапках при использовании ключа <code>-r</code>.</p>
<pre class="line-numbers"><code class="language-powershell">&amp; $exifToolPath -r -json "D:\Photos" | ConvertFrom-Json |
    Select-Object FileName, Model, DateTimeOriginal |
    Export-Csv "C:\Reports\all_photos_recursive.csv" -NoTypeInformation -Encoding UTF8
</code></pre>
<hr>
<h3>Пример №6: Переименование файлов по дате съемки</h3>
<p>Это один из самых популярных сценариев автоматизации — файлы получают имена по дате/времени съемки.</p>
<pre class="line-numbers"><code class="language-powershell">$exifToolPath = "C:\Tools\exiftool.exe"
$photoFolder = "D:\Photos"

# Переименуем в формат YYYY-MM-DD_HH-MM-SS.jpg
&amp; $exifToolPath -r -d "%Y-%m-%d_%H-%M-%S.%%e" "-FileName&lt;DateTimeOriginal" $photoFolder
</code></pre>
<p>💡 <em><code>ExifTool</code> подставит расширение исходного файла автоматически через <code>%%e</code>.</em></p>
<hr>
<h3>Пример №7: Извлечение только <code>GPS</code>-координат</h3>
<p>Полезно, если вы хотите построить карту по вашим фото.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Укажите путь к папке с вашими фотографиями
$photoFolder = "E:\DCIM\Camera"

# 2. Перечисляем теги, которые нам нужны: имя файла и три GPS-тега.
#    Это делает запрос намного быстрее, чем если бы мы забирали все теги.
$tagsToExtract = @(
    "-SourceFile", # SourceFile лучше, чем FileName, так как обычно содержит полный путь
    "-GPSLatitude",
    "-GPSLongitude",
    "-GPSAltitude"
)

# 3. Вызываем exiftool.exe напрямую (т.к. он в PATH).
#    Ключ -r ищет файлы во всех подпапках.
#    Результат сразу конвертируем из JSON.
$allExifData = exiftool.exe -r -json $tagsToExtract $photoFolder | ConvertFrom-Json

# 4. Фильтруем результаты: оставляем ТОЛЬКО те объекты, у которых есть широта и долгота.
$filesWithGps = $allExifData | Where-Object { $_.GPSLatitude -and $_.GPSLongitude }

# 5. Проверяем, нашлись ли вообще файлы с GPS-данными
if ($filesWithGps) {
    # 6. Создаем красивый отчет из отфильтрованных данных.
    #    Используем Select-Object для переименования колонок и форматирования.
    $report = $filesWithGps | Select-Object @{Name="Имя файла"; Expression={Split-Path $_.SourceFile -Leaf}},
                                             @{Name="Широта"; Expression={$_.GPSLatitude}},
                                             @{Name="Долгота"; Expression={$_.GPSLongitude}},
                                             @{Name="Высота"; Expression={if ($_.GPSAltitude) { "$($_.GPSAltitude) м" } else { "N/A" }}}
    
    # 7. Выводим итоговый отчет в интерактивную консольную таблицу.
    $report | Out-ConsoleGridView -Title "Файлы с GPS-данными в папке: $photoFolder"

} else {
    # Если ничего не найдено, вежливо сообщаем об этом.
    Write-Host "Файлы с GPS-данными в папке '$photoFolder' не найдены." -ForegroundColor Yellow
}
</code></pre>
<hr>
<h3>Пример №8: Массовое удаление всех <code>GPS</code>-данных (для приватности)</h3>
<pre class="line-numbers"><code class="language-powershell"># Удалим все GPS-теги из JPG и PNG
&amp; $exifToolPath -r -overwrite_original -gps:all= "D:\Photos"
</code></pre>
<p>💡 <em>Это действие необратимо, поэтому делайте бэкап перед выполнением.</em></p>
<hr>
<h3>Пример №9: Конвертация времени съемки в местное время</h3>
<p>Иногда фото сняты в другом часовом поясе. <code>ExifTool</code> может сместить дату.</p>
<pre class="line-numbers"><code class="language-powershell"># Смещаем время на +3 часа
&amp; $exifToolPath "-AllDates+=3:0:0" "D:\Photos\IMG_*.JPG"
</code></pre>
<hr>
<h3>Пример №10: Получение списка всех уникальных моделей камер в папке</h3>
<pre class="line-numbers"><code class="language-powershell">$models = &amp; $exifToolPath -r -Model -s3 "D:\Photos" | Sort-Object -Unique
$models | ForEach-Object { Write-Host "Модель: $_" }
</code></pre>
<hr>
<h3>Пример №11: Вывод только нужных тегов в табличном виде</h3>
<pre class="line-numbers"><code class="language-powershell">&amp; $exifToolPath -T -Model -DateTimeOriginal -ISO -Aperture -ShutterSpeed "D:\Photos\IMG_1234.JPG"
</code></pre>
<p><code>-T</code> делает вывод в табличном формате, разделённом табуляцией — удобно для дальнейшей обработки.</p>
<hr>
<h3>Пример №12: Проверка наличия <code>GPS</code> в большом массиве файлов</h3>
<pre class="line-numbers"><code class="language-powershell">$files = &amp; $exifToolPath -r -if "$gpslatitude" -p '$FileName' "D:\Photos"
Write-Host "Файлы с GPS:"
$files
</code></pre>
<hr>
<h3>Пример №13: Копирование метаданных с одного файла на другой</h3>
<pre class="line-numbers"><code class="language-powershell"># 1. Выбираем эталонный файл
$sourceFile = Get-ChildItem "D:\Photos" -Filter "*.jpg" | Out-ConsoleGridView -Title "Выберите ЭТАЛОННЫЙ файл"

# 2. Если эталон выбран, выбираем целевые файлы
if ($sourceFile) {
    $targetFiles = Get-ChildItem "D:\Photos\New" -Filter "*.jpg" | Out-ConsoleGridView -Title "Выберите ЦЕЛЕВЫЕ файлы для копирования метаданных" -OutputMode Multiple
    
    # 3. Если цели выбраны, выполняем копирование
    if ($targetFiles) {
        &amp; exiftool.exe -TagsFromFile $sourceFile.FullName ($targetFiles.FullName)
        Write-Host "Метаданные скопированы с $($sourceFile.Name) на $($targetFiles.Count) файлов."
    }
}
</code></pre>
<hr>
<h3>Пример №14: Сохранение исходных метаданных в отдельный <code>JSON</code> перед изменением</h3>
<pre class="line-numbers"><code class="language-powershell">$backupPath = "C:\Reports\metadata_backup.json"
&amp; $exifToolPath -r -json "D:\Photos" | Out-File -Encoding UTF8 $backupPath
</code></pre>
<hr>
<h3>Пример №15: Использование <code>PowerShell</code> для автоматической сортировки фото по дате</h3>
<pre class="line-numbers"><code class="language-powershell">$photos = Get-ChildItem "D:\Photos" -Filter *.jpg -Recurse
foreach ($photo in $photos) {
    $meta = &amp; $exifToolPath -json $photo.FullName | ConvertFrom-Json
    $date = Get-Date $meta.DateTimeOriginal -ErrorAction SilentlyContinue
    if ($date) {
        $targetFolder = "D:\Sorted\{0:yyyy}\{0:MM}" -f $date
        if (-not (Test-Path $targetFolder)) { New-Item -Path $targetFolder -ItemType Directory }
        Move-Item $photo.FullName -Destination $targetFolder
    }
}
</code></pre>
<hr>
<h3>Пример 16: Поиск всех уникальных моделей камер в коллекции</h3>
<p>Хотя это можно сделать одной строкой, вывод в <code>GridView</code> позволяет сразу скопировать нужное название модели.</p>
<pre class="line-numbers"><code class="language-powershell"># Ключ -s3 выводит только значения, -Model - название тега
$uniqueModels = &amp; exiftool.exe -r -Model -s3 "D:\Photos" | Sort-Object -Unique

# Выводим в GridView для удобного просмотра и копирования
$uniqueModels | Out-ConsoleGridView -Title "Уникальные модели камер в коллекции"
</code></pre>
