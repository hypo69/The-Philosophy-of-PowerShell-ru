[:fr]
# Philosophie PowerShell.

### **Partie 3 : Navigation et gestion du système de fichiers. Opérateurs logiques. Introduction aux fonctions.**

Dans la [partie précédente](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md), nous avons exploré les pipelines et les objets de processus abstraits.
Appliquons maintenant nos connaissances des pipelines et des objets à l'une des tâches fréquentes de l'utilisateur ou de l'administrateur : travailler avec le système de fichiers.
Dans PowerShell, ce travail est basé sur les mêmes principes : les commandes renvoient des objets qui peuvent être passés via le pipeline pour un traitement ultérieur.

***

### **1. Concept des PowerShell Drives (PSDrives)**

Avant de commencer à travailler avec des fichiers, il est important de comprendre le concept des **PowerShell-drives (PSDrives)**. Contrairement à `cmd.exe`, où les disques ne sont que des lettres `C:`, `D:`, et ainsi de suite, dans PowerShell, un "disque" est une abstraction pour accéder à tout stockage de données hiérarchique.

```powershell
Get-PSDrive
```
Le résultat affichera non seulement les disques physiques, mais aussi les pseudo-disques :

| Nom | Fournisseur | Racine | Description |
|---|---|---|---|
| Alias | Alias | Alias:\ | Alias de commandes |
| C | FileSystem | C:\ | Disque local C |
| Cert | Certificate | Cert:\ | Magasin de certificats |
| Env | Environment | Env:\ | Variables d'environnement |
| Function | Function | Function:\ | Fonctions chargées |
| HKCU | Registry | HKEY_CURRENT_USER | Branche du registre |
| HKLM | Registry | HKEY_LOCAL_MACHINE | Branche du registre |
| Variable | Variable | Variable:\ | Variables de session |
| WSMan | WSMan | WSMan:\ | Configuration WinRM |

Cette unification signifie que vous pouvez "entrer" dans le registre (`Set-Location HKLM:`) et obtenir une liste de ses clés avec la même commande `Get-ChildItem` que celle utilisée pour obtenir une liste de fichiers sur le disque C:. C'est un concept incroyablement puissant.

#### **Exemples d'utilisation avec différents fournisseurs**

*   **Magasin de certificats (Cert:)**
    Permet de travailler avec des certificats numériques comme s'il s'agissait de fichiers dans des dossiers.

    **Tâche :** Trouver tous les certificats SSL sur la machine locale dont la date d'expiration est inférieure à 30 jours.
    ```powershell
    # Accéder au magasin de certificats de l'ordinateur local
    Set-Location Cert:\LocalMachine\My

    # Trouver les certificats dont la date de fin est inférieure à aujourd'hui + 30 jours
    Get-ChildItem | Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) } | Select-Object Subject, NotAfter, Thumbprint
    ```

*   **Variables d'environnement (Env:)**
    Fournit un accès aux variables d'environnement Windows (`%PATH%`, `%windir%`, etc.) comme s'il s'agissait de fichiers.

    **Tâche :** Obtenir le chemin du dossier système de Windows et y ajouter le chemin de `System32`.
    ```powershell
    # Obtenir la valeur de la variable windir
    $windowsPath = (Get-Item Env:windir).Value
    # Ou plus simplement : $windowsPath = $env:windir

    # Construire le chemin complet en toute sécurité
    $system32Path = Join-Path -Path $windowsPath -ChildPath "System32"
    Write-Host $system32Path
    # Résultat : C:\WINDOWS\System32
    ```

*   **Registre Windows (HKCU: et HKLM:)**
    Imaginez que le registre est juste un autre système de fichiers. Les branches sont des dossiers, et les paramètres sont des propriétés de ces dossiers.

    **Tâche :** Connaître le nom complet de la version installée de Windows à partir du registre.
    ```powershell
    # Accéder à la branche de registre souhaitée
    Set-Location "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

    # Obtenir la propriété (paramètre de registre) nommée "ProductName"
    Get-ItemProperty -Path . -Name "ProductName"
    # Résultat : ProductName : Windows 11 Pro
    ```

*   **Fonctions chargées (Function:)**
    Affiche toutes les fonctions disponibles dans la session PowerShell actuelle, comme s'il s'agissait de fichiers.

    **Tâche :** Trouver toutes les fonctions chargées dont le nom contient le mot "Help", et afficher le code de l'une d'elles.
    ```powershell
    # Rechercher des fonctions par masque
    Get-ChildItem Function: | Where-Object { $_.Name -like "*Help*" }

    # Obtenir le code complet (définition) de la fonction Get-Help
    (Get-Item Function:Get-Help).Definition
    ```

*   **Variables de session (Variable:)**
    Permet de gérer toutes les variables (`$myVar`, `$PROFILE`, `$Error`, etc.) définies dans la session actuelle.

    **Tâche :** Trouver toutes les variables liées à la version de PowerShell (`$PSVersionTable`, `$PSHOME`, etc.).
    ```powershell
    # Trouver toutes les variables commençant par "PS"
    Get-ChildItem Variable:PS*

    # Obtenir la valeur d'une variable spécifique
    Get-Variable -Name "PSVersionTable"
    ```
---

### 2. **Navigation et analyse**

#### **Bases de la navigation**

```powershell
# Savoir où nous sommes (renvoie un objet PathInfo)
Get-Location          # Alias : gl, pwd

# Accéder à la racine du disque C:\
Set-Location C:\      # Alias : sl, cd

# Accéder au dossier personnel de l'utilisateur actuel
Set-Location ~

# Afficher le contenu du dossier actuel (renvoie une collection d'objets)
Get-ChildItem         # Alias : gci, ls, dir
```

```powershell
# **Recherche récursive**
# Trouver le fichier hosts dans le système, en ignorant les erreurs "Accès refusé"
Get-ChildItem C:\ -Filter "hosts" -Recurse -ErrorAction SilentlyContinue
```
**Clé `-Recurse` (Récursivement) :** Force le cmdlet à travailler non seulement avec l'élément spécifié, mais aussi avec tout son contenu.

**Clé `-ErrorAction SilentlyContinue` :** Instruction d'ignorer les erreurs et de continuer le travail silencieusement.

##### **Analyse de l'espace disque**
Un exemple classique de la puissance du pipeline : trouver, trier, formater et sélectionner.
```powershell
Get-ChildItem C:\Users -File -Recurse -ErrorAction SilentlyContinue |
    Sort-Object Length -Descending |
    Select-Object FullName, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} |
    Select-Object -First 20
```

###### **Astuce pour saisir de longues commandes.**
> PowerShell permet de les diviser en plusieurs lignes pour une meilleure lisibilité.
> 
> *   **Après l'opérateur de pipeline (`|`) :** C'est le moyen le plus courant et le plus pratique. Appuyez simplement sur `Entrée` après le symbole `|`. PowerShell verra que la commande n'est pas terminée et attendra la suite sur la ligne suivante.
> *   **N'importe où ailleurs :** Utilisez le caractère d'accent grave (backtick) `` ` `` à la fin de la ligne, puis appuyez sur `Entrée`. Ce caractère indique à PowerShell : "La commande continuera sur la ligne suivante".
> *   **Dans les éditeurs (ISE, VS Code) :** La combinaison de touches `Shift+Entrée` insère généralement automatiquement un saut de ligne sans exécuter la commande.

#### **Filtrage du contenu et opérateurs logiques**

```powershell
# Trouver tous les fichiers .exe. Le paramètre -Filter fonctionne très rapidement.
Get-ChildItem C:\Windows | Where-Object { $_.Extension -eq ".exe" }
```

`Get-ChildItem` renvoie une collection d'objets. Nous pouvons la passer via le pipeline à `Where-Object` pour un filtrage ultérieur.

```powershell
# Afficher uniquement les fichiers
Get-ChildItem C:\Windows | Where-Object { $_.PSIsContainer -eq $false }
```
Cette commande nous introduit à l'un des concepts fondamentaux des scripts PowerShell : les **opérateurs de comparaison**.

#### **Opérateurs de comparaison et logiques**

Ce sont des clés spéciales pour comparer des valeurs. Elles commencent toujours par un tiret (`-`) et sont la base pour filtrer les données dans `Where-Object` et construire la logique dans `if`.

| Opérateur | Description | Exemple dans le pipeline |
| :--- | :--- | :--- |
| `-eq` | Égal à (EQual) | `$_.Name -eq "svchost.exe"` |
| `-ne` | Non égal à (Not Equal) | `$_.Status -ne "Running"` |
| `-gt` | Plus grand que (Greater Than) | `$_.Length -gt 1MB` |
| `-ge` | Plus grand ou égal à (Greater or Equal) | `$_.Handles -ge 500` |
| `-lt` | Moins que (Less Than) | `$_.LastWriteTime -lt (Get-Date).AddDays(-30)`|
| `-le` | Moins ou égal à (Less or Equal) | `$_.Count -le 1` |
| `-like` | Similaire à (avec caractères génériques `*`, `?`)| `$_.Name -like "win*"` |
| `-notlike`| Non similaire à | `$_.Name -notlike "*.tmp"` |
| `-in` | La valeur est contenue dans la collection | `$_.Extension -in ".log", ".txt"` |
| `-and` | Logique ET (les deux conditions sont vraies) | |
| `-or` | Logique OU (au moins une condition est vraie) | |
| `-not` | Logique NON (inverse la condition) | |

Le sujet des opérateurs logiques est très vaste et je lui consacrerai une partie séparée (voire deux). En attendant, armés de ces opérateurs,
nous pouvons **filtrer, trier et sélectionner les fichiers et dossiers dont nous avons besoin**, en utilisant toute la puissance du pipeline d'objets.

#### **Exemples d'utilisation dans le système de fichiers**

**Trouver un fichier par nom exact (sensible à la casse) :**
```powershell
Get-ChildItem C:\Windows\System32 -Recurse | Where-Object { $_.Name -eq "kernel32.dll" }
```

**Trouver tous les fichiers commençant par "host", mais qui ne sont pas des dossiers :**
```powershell
Get-ChildItem C:\Windows\System32\drivers\etc | Where-Object { ($_.Name -like "host*") -and (-not $_.PSIsContainer) }
```

**Trouver tous les fichiers journaux (.log) dont la taille dépasse 50 mégaoctets :**
```powershell
Get-ChildItem C:\Windows\Logs -Filter "*.log" -Recurse | Where-Object { $_.Length -gt 50MB }
```

**Trouver tous les fichiers temporaires (.tmp) et les fichiers de sauvegarde (.bak) à nettoyer :**
L'opérateur `-in` est ici beaucoup plus élégant que plusieurs conditions avec `-or`.
```powershell
$extensionsToDelete = ".tmp", ".bak", ".old"
Get-ChildItem C:\Temp -Recurse | Where-Object { $_.Extension -in $extensionsToDelete }
```

**Trouver tous les fichiers Word (.docx) créés au cours de la dernière semaine :**
```powershell
$oneWeekAgo = (Get-Date).AddDays(-7)
Get-ChildItem C:\Users\MyUser\Documents -Filter "*.docx" -Recurse | Where-Object { $_.CreationTime -ge $oneWeekAgo }
```

**Trouver les fichiers vides (taille 0 octets) qui ne sont pas des dossiers :**
```powershell
Get-ChildItem C:\Downloads -Recurse | Where-Object { ($_.Length -eq 0) -and (-not $_.PSIsContainer) }
```

**Trouver tous les fichiers exécutables (.exe) qui ont été modifiés cette année, mais PAS ce mois-ci :**
Cet exemple complexe démontre la puissance de la combinaison d'opérateurs.
```powershell
Get-ChildItem "C:\Program Files" -Filter "*.exe" -Recurse | Where-Object {
    ($_.LastWriteTime.Year -eq (Get-Date).Year) -and ($_.LastWriteTime.Month -ne (Get-Date).Month)
}
```

*(Note : les parenthèses `()` autour de chaque condition sont utilisées pour le regroupement et l'amélioration de la lisibilité, en particulier dans les cas complexes).*

Soyez prudent avec la récursion :
Trop de fichiers/dossiers — `-Recurse` peut entrer récursivement dans des dizaines de milliers d'éléments.
Liens symboliques / liens cycliques — peuvent provoquer une récursion infinie.
Fichiers sans droits d'accès — peuvent bloquer l'exécution.

### 4. **Création, gestion et suppression sécurisée**

#### **Création, copie et déplacement**

```powershell
New-Item -Path "C:\Temp\MyFolder" -ItemType Directory
Add-Content -Path "C:\Temp\MyFolder\MyFile.txt" -Value "Première ligne"
Copy-Item -Path "C:\Temp\MyFolder" -Destination "C:\Temp\MyFolder_Copy" -Recurse
```

#### **Suppression sécurisée**
`Remove-Item` est un cmdlet potentiellement dangereux, c'est pourquoi PowerShell intègre des mécanismes de protection.
> **Clé `-WhatIf` (Et si ?) :** Votre meilleur ami. **n'exécute pas** le commande, mais affiche simplement dans la console un message sur **ce qui se passerait**.

```powershell
# VÉRIFICATION SÉCURISÉE avant suppression
Remove-Item C:\Temp\MyFolder -Recurse -Force -WhatIf
# Résultat : What if: Performing the operation "Remove Directory" on target "C:\Temp\MyFolder".

# Seulement après s'être assuré que tout est correct, on retire -WhatIf et on EXÉCUTE la commande
Remove-Item C:\Temp\MyFolder -Recurse -Force
```
---


### **Introduction aux fonctions**

Lorsqu'une ligne de code se transforme en un ensemble complexe de commandes que vous souhaitez utiliser encore et encore, il est temps de créer des **fonctions**.

#### **Comment utiliser et enregistrer des fonctions**

Il existe trois façons principales de rendre vos fonctions disponibles :

**Méthode 1 : Temporaire (pour les tests)**
Vous pouvez taper dans la console ou simplement copier et coller tout le code de la fonction dans la console de PowerShell. La fonction sera disponible jusqu'à la fermeture de cette fenêtre.

**Méthode 2 : Permanente, mais manuelle (via un fichier `.ps1`)**
C'est la méthode la plus courante pour organiser et partager des outils. Vous enregistrez la fonction dans un fichier `.ps1` et la chargez dans la session lorsque vous en avez besoin.
> **Dot Sourcing (`. .script.ps1`) :** Cette commande spéciale exécute le script dans le contexte *actuel*, rendant toutes ses fonctions et variables disponibles dans votre console.

**Méthode 3 : Automatique (via le profil PowerShell)**
C'est la méthode la plus puissante pour vos outils personnels, fréquemment utilisés.
> **Qu'est-ce qu'un profil PowerShell ?** C'est un script `.ps1` spécial que PowerShell exécute automatiquement à chaque démarrage. Tout ce que vous placez dans ce fichier — alias, variables et, bien sûr, fonctions — sera disponible dans chacune de vos sessions par défaut.

##### **Exemple 1 : Recherche de fichiers en double**

Passons en revue toutes les étapes avec l'exemple de la fonction `Find-DuplicateFiles`.

**Étape 1 : Définir le code de la fonction**
```powershell
$functionCode = @'
function Find-DuplicateFiles {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Path
    )

    Get-ChildItem $Path -File -Recurse -ErrorAction SilentlyContinue |
        Group-Object Name, Length |
        Where-Object { $_.Count -gt 1 } |
        ForEach-Object {
            # C'EST LA LIGNE CORRIGÉE :
            # À l'intérieur de l'opérateur $() les variables ne sont pas échappées.
            Write-Host "Doublons trouvés : $($_.Name)" -ForegroundColor Yellow
            $_.Group | Select-Object FullName, Length, LastWriteTime
        }
}
'@
```

**Étape 2 (Option A) : Enregistrer dans un fichier séparé pour un chargement manuel**
```powershell
# Enregistrer
Set-Content -Path ".\Find-DuplicateFiles.ps1" -Value $functionCode
# Charger
. .\Find-DuplicateFiles.ps1
```
> Dot Sourcing (. .\Find-DuplicateFiles.ps1) : Cette commande spéciale exécute le script dans le contexte actuel, rendant toutes ses fonctions et variables disponibles dans votre console.
```powershell
# Appeler
Find-DuplicateFiles -Path "C:\Users\$env:USERNAME\Downloads"
```

**Étape 2 (Option B) : Ajouter au profil pour un chargement automatique**
Rendons cette fonction toujours disponible.
> Qu'est-ce qu'un profil PowerShell ? C'est un script `.ps1` spécial que PowerShell exécute automatiquement à chaque démarrage. Tout ce que vous placez dans ce fichier — alias, variables et fonctions — sera disponible dans chacune de vos sessions par défaut.
1.  **Trouver le chemin du fichier de profil.** PowerShell le stocke dans la variable `$PROFILE`.
    ```powershell
    $PROFILE
    ```
2.  **Créer le fichier de profil s'il n'existe pas.**
    ```powershell
    if (-not (Test-Path $PROFILE)) {
        New-Item -Path $PROFILE -Type File -Force
    }
    ```
3.  **Ajouter le code de notre fonction à la fin du fichier de profil.**
    ```powershell
    Add-Content -Path $PROFILE -Value $functionCode
    ```
4.  **Redémarrez PowerShell** (ou exécutez `. $PROFILE`), et maintenant votre commande `Find-DuplicateFiles` sera toujours disponible, tout comme `Get-ChildItem`.

##### **Exemple 2 : Création d'une archive ZIP de sauvegarde**

**Code pour le fichier `Backup-FolderToZip.ps1` :**
```powershell
function Backup-FolderToZip {
    param([string]$SourcePath, [string]$DestinationPath)
    if (-not (Test-Path $SourcePath)) { Write-Error "Le dossier source n'a pas été trouvé."; return }
    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"
    $archiveFileName = "Backup_{0}_{1}.zip" -f (Split-Path $SourcePath -Leaf), $timestamp
    $fullArchivePath = Join-Path $DestinationPath $archiveFileName
    if (-not (Test-Path $DestinationPath)) { New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null }
    Compress-Archive -Path "$SourcePath\*" -DestinationPath $fullArchivePath -Force
    Write-Host "Sauvegarde terminée : $fullArchivePath" -ForegroundColor Green
}
```

Une analyse détaillée des fonctions sera faite dans les parties suivantes.

---


### **Référence des cmdlets pour travailler avec le système de fichiers**

#### **1. Cmdlets de base**
Cette liste comprend les 12 cmdlets les plus essentiels, qui couvrent 90 % des tâches quotidiennes.

| Cmdlet | Objectif principal | Exemple d'utilisation |
| :--- | :--- | :--- |
| `Get-ChildItem`| Obtenir la liste des fichiers et dossiers. | `Get-ChildItem C:\Windows` |
| `Set-Location` | Se déplacer vers un autre répertoire. | `Set-Location C:\Temp` |
| `Get-Location` | Afficher le répertoire actuel. | `Get-Location` |
| `New-Item` | Créer un nouveau fichier ou dossier. | `New-Item "report.docx" -Type File`|
| `Remove-Item` | Supprimer un fichier ou un dossier. | `Remove-Item "old_log.txt"` |
| `Copy-Item` | Copier un fichier ou un dossier. | `Copy-Item "file.txt" -Dest "D:\"` |
| `Move-Item` | Déplacer un fichier ou un dossier. | `Move-Item "report.docx" -Dest "C:\Archive"` |
| `Rename-Item` | Renommer un fichier ou un dossier. | `Rename-Item "old.txt" -NewName "new.txt"` |
| `Get-Content` | Lire le contenu d'un fichier. | `Get-Content "config.ini"` |
| `Set-Content` | Écrire/écraser le contenu d'un fichier. | `"data" | Set-Content "file.txt"`|
| `Add-Content` | Ajouter du contenu à la fin d'un fichier. | `Get-Date | Add-Content "log.txt"` |
| `Test-Path` | Vérifier si un fichier ou un dossier existe. | `Test-Path "C:\Temp"` |

Besoin de **lire le contenu** d'un fichier texte ? Utilisez `Get-Content`.
Besoin de **réécrire complètement un fichier** avec un nouveau contenu ? Utilisez `Set-Content`.
Besoin d'**ajouter une ligne à un fichier journal**, sans effacer les anciennes données ? Utilisez `Add-Content`.
Besoin de **vérifier si un fichier existe** avant d'écrire ? Utilisez `Test-Path`.

#### **2. Cmdlets spécialisés pour les tâches avancées**
Lorsque les cmdlets de base ne suffisent pas, PowerShell propose des outils plus spécialisés. Ils ne dupliquent pas les bases, mais étendent vos capacités.

*   **Travail avec les chemins (Path)**
    *   **`Join-Path`** : Joint les parties d'un chemin en toute sécurité, en insérant automatiquement `\`.
    *   **`Split-Path`** : Divise un chemin en parties (dossier, nom de fichier, extension).
    *   **`Resolve-Path`** : Convertit un chemin relatif (par exemple, `.` ou `..\files`) en un chemin complet et absolu.

*   **Travail avec les propriétés et le contenu (Item Properties and Content)**
    *   **`Get-ItemProperty`** : Obtient les propriétés d'un fichier spécifique (par exemple, `IsReadOnly`, `CreationTime`).
    *   **`Set-ItemProperty`** : Modifie les propriétés d'un fichier ou d'un dossier.
    *   **`Clear-Content`** : Supprime tout le contenu d'un fichier, mais laisse le fichier vide.

*   **Navigation avancée (Location Stack)**
    *   **`Push-Location`** : "Mémorise" le répertoire actuel et se déplace vers un nouveau.
    *   **`Pop-Location`** : Revient au répertoire "mémorisé" par `Push-Location`.

*   **Gestion des droits d'accès (ACL)**
    *   **`Get-Acl`** : Obtient la liste des droits d'accès (ACL) pour un fichier ou un dossier.
    *   **`Set-Acl`** : Définit les droits d'accès pour un fichier ou un dossier (opération complexe).

Besoin de **modifier un attribut de fichier**, par exemple, le rendre « lecture seule » ? Utilisez `Set-ItemProperty`.
Besoin de **vider complètement un fichier journal**, sans le supprimer ? Utilisez `Clear-Content`.
Besoin de **passer temporairement à un autre dossier** dans un script, puis de revenir en arrière de manière garantie ? Utilisez `Push-Location` et `Pop-Location`.
Besoin de **savoir qui a les droits** d'accès à un dossier ? Utilisez `Get-Acl`.

Dans la prochaine partie, nous apprendremos a trabajar con otros almacenes de datos, such as the Windows registry,
utilizando los mismos enfoques, profundizaremos en el concepto de funciones, examinaremos los operadores lógicos y aprenderemos a interactuar con el shell de forma interactiva.

Filosofía PowerShell en GitHub :
[Historia y primer cmdlet](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/01.md)

Parte 2 : [Pipeline, variables, Get-Member, archivo .ps1 y exportación de resultados.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/02.md)
Ejemplos para la segunda parte :
[system_monitor.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/02/system_monitor.ps1)

Parte 3 : [Navegación y gestión del sistema de archivos.](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/03.md)

Ejemplos para la tercera parte :
[Find-DuplicateFiles.ps1](https://github.com/hypo69/1001-python-ru/blob/master/articles/%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20PowerShell/code/03/Find-DuplicateFiles.ps1)
[Backup-FolderToZip]()
[:]