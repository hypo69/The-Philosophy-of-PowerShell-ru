### **А давайте встроим ИИ в PowerShell (Часть 2: Создаем интерактивный справочник химика)**

В первой части мы создали базовую функцию `Invoke-Gemini` и убедились, что можем отправлять простые запросы в ИИ прямо из PowerShell. Это было впечатляюще, но пока не очень полезно. Ответы были "сырыми", а сама функция — слишком простой.

В этой части мы сделаем огромный шаг вперед. Мы превратим нашу консоль в **интерактивный справочник по химическим элементам**. Мы напишем PowerShell-скрипт, который будет вести с нами диалог, используя Gemini как свою "базу знаний". Мы научимся формировать правильные, "умные" промпты и обрабатывать ответы, чтобы создать полноценное интерактивное приложение.

Для этого нам не потребуется ничего, кроме PowerShell и уже настроенного Gemini CLI.

#### **Шаг 1: Улучшаем наш `Invoke-Gemini`**

Наша первая версия функции была хороша для демонстрации, но для реальной работы ее нужно улучшить. Ответы от Gemini часто содержат лишнее форматирование (например, блоки кода ` ``` `) и "вступительные фразы" ("Конечно, вот ответ..."). Давайте напишем новую, улучшенную функцию, которая будет "чистить" вывод за нас.

**Улучшенная функция `Invoke-Gemini`:**
```powershell
function Invoke-Gemini {
    <#
    .SYNOPSIS
        Отправляет промпт в Gemini CLI и возвращает очищенный текстовый ответ.
    .DESCRIPTION
        Эта улучшенная функция отправляет промпт в неинтерактивном режиме,
        а затем обрабатывает результат, чтобы удалить стандартные блоки
        markdown-кода (```powershell, ```) и распространенные фразы-заполнители,
        возвращая только полезную информацию.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string]$Prompt
    )

    process {
        # Проверка наличия gemini (без изменений)
        try {
            $geminiCommand = Get-Command gemini -ErrorAction Stop
        }
        catch {
            Write-Error "Команда 'gemini' не найдена. Убедитесь, что Gemini CLI установлен."
            return
        }

        Write-Verbose "Отправка промпта в Gemini CLI..."
        
        # Запуск gemini (без изменений)
        $rawOutput = & $geminiCommand.Source -p $Prompt 2>&1

        if (-not $?) {
            Write-Warning "Команда gemini завершилась с ошибкой."
            $rawOutput | ForEach-Object { Write-Warning $_.ToString() }
            return
        }

        # --- НОВЫЙ БЛОК: Очистка вывода ---
        # Преобразуем массив строк в одну строку для удобства обработки
        $fullOutput = $rawOutput -join [Environment]::NewLine
        
        # Удаляем блоки кода и лишние пробелы по краям
        $cleanedOutput = $fullOutput -replace '(?s)```[a-zA-Z]*\r?\n(.*?)\r?\n```', '$1'
        $cleanedOutput = $cleanedOutput.Trim()
        
        # Возвращаем очищенный результат
        return $cleanedOutput
    }
}
```
**Что нового?**
*   **`$rawOutput -join [Environment]::NewLine`**: Мы объединяем все строки ответа в одну большую строку.
*   **`-replace '(?s)```...'`**: Эта сложная на вид команда (регулярное выражение) находит и удаляет обрамляющие блоки кода, оставляя только сам код.
*   **`.Trim()`**: Убирает лишние пустые строки в начале и в конце ответа.

Теперь наш `Invoke-Gemini` возвращает только суть.

#### **Шаг 2: Создаем "игровой цикл" на PowerShell**

Теперь напишем основной скрипт нашей "игры". Это будет интерактивный цикл, который будет общаться с нами, формировать умные промпты для `Invoke-Gemini` и показывать нам результаты.

Создайте файл `Start-ChemistryGame.ps1` и скопируйте в него этот код:

**`Start-ChemistryGame.ps1`**
```powershell
# Подключаем нашу улучшенную функцию (предполагается, что она в том же файле или в вашем профиле PowerShell)
function Invoke-Gemini {
    <#
    .SYNOPSIS
        Отправляет промпт в Gemini CLI и возвращает очищенный текстовый ответ.
    .DESCRIPTION
        Эта улучшенная функция отправляет промпт в неинтерактивном режиме,
        а затем обрабатывает результат, чтобы удалить стандартные блоки
        markdown-кода (```powershell, ```) и распространенные фразы-заполнители,
        возвращая только полезную информацию.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string]$Prompt
    )

    process {
        try {
            $geminiCommand = Get-Command gemini -ErrorAction Stop
        }
        catch {
            Write-Error "Команда 'gemini' не найдена. Убедитесь, что Gemini CLI установлен."
            return
        }
        Write-Verbose "Отправка промпта в Gemini CLI..."
        $rawOutput = & $geminiCommand.Source -p $Prompt 2>&1
        if (-not $?) {
            Write-Warning "Команда gemini завершилась с ошибкой."
            $rawOutput | ForEach-Object { Write-Warning $_.ToString() }
            return
        }
        $fullOutput = $rawOutput -join [Environment]::NewLine
        $cleanedOutput = $fullOutput -replace '(?s)```[a-zA-Z]*\r?\n(.*?)\r?\n```', '$1'
        return $cleanedOutput.Trim()
    }
}


# --- Основной цикл игры ---
Write-Host "Добро пожаловать в 'Исследователь химических элементов'!" -ForegroundColor Yellow

while ($true) {
    # 1. Запрашиваем ввод у пользователя
    $symbol = Read-Host "`nВведите химический символ (или 'выход' для завершения)"
    if ($symbol -eq 'выход' -or [string]::IsNullOrWhiteSpace($symbol)) {
        break
    }

    # 2. Формируем "умный" промпт для получения основной информации
    $prompt = "Предоставь основную информацию о химическом элементе с символом '$symbol'. Ответь кратко, только в формате: Название, Символ, Атомный номер, Атомная масса."
    Write-Host "`nЗапрашиваю информацию об элементе '$symbol' у Gemini..." -ForegroundColor Cyan
    $elementInfo = Invoke-Gemini -Prompt $prompt
    
    # Показываем результат
    Write-Host "`n--- Информация от Gemini ---"
    Write-Host $elementInfo -ForegroundColor Green

    # 3. Предлагаем дальнейшие действия, если элемент был найден
    if ($elementInfo -notlike "*не найден*" -and $elementInfo.Length -gt 0) {
        while ($true) {
            Write-Host "`nВыберите дополнительное действие:"
            $choice = Read-Host "1. Узнать интересные факты`n2. Спросить о валентности`n3. Ввести другой элемент"

            switch ($choice) {
                '1' {
                    $factsPrompt = "Расскажи 3 интересных факта об элементе с символом '$symbol'."
                    Write-Host "`nЗапрашиваю интересные факты у Gemini..." -ForegroundColor Cyan
                    $interestingFacts = Invoke-Gemini -Prompt $factsPrompt
                    Write-Host "`n--- Интересные факты ---"
                    Write-Host $interestingFacts -ForegroundColor Green
                }
                '2' {
                    $valencePrompt = "Какая основная валентность у элемента с символом '$symbol' и почему?"
                    Write-Host "`nЗапрашиваю информацию о валентности..." -ForegroundColor Cyan
                    $valenceInfo = Invoke-Gemini -Prompt $valencePrompt
                    Write-Host "`n--- Информация о валентности ---"
                    Write-Host $valenceInfo -ForegroundColor Green
                }
                '3' {
                    # Выходим из внутреннего цикла, чтобы запросить новый элемент
                    break
                }
                default {
                    Write-Warning "Неверный выбор. Пожалуйста, введите 1, 2 или 3."
                }
            }
        }
    }
}

Write-Host "`nСпасибо за игру!" -ForegroundColor Yellow
```

#### **Шаг 3: Играем!**

Теперь просто запустите скрипт из вашей консоли PowerShell:
```powershell
.\Start-ChemistryGame.ps1
```
Скрипт поприветствует вас и предложит ввести химический символ. Попробуйте ввести `Fe`, `O` или `Au`. Вы увидите, как скрипт:
1.  **Общается с вами:** Использует `Read-Host` для получения команд.
2.  **Формирует точные промпты:** Он не просто передает ваш ввод, а оборачивает его в конкретную инструкцию для ИИ ("*Предоставь информацию... только в формате...*"). Это заставляет Gemini давать более предсказуемые и чистые ответы.
3.  **Использует `Invoke-Gemini`:** Отправляет эти промпты в ИИ.
4.  **Предоставляет интерактивное меню:** Позволяет вам углубиться в изучение элемента, задавая новые, более конкретные вопросы.

---

**Поздравляю!** Вы только что создали полноценное интерактивное консольное приложение, полностью построенное на диалоге с ИИ. Вы научились не просто вызывать ИИ, а **управлять** им, формируя точные запросы для получения нужных данных.

**В следующей, третьей части,** мы поднимем планку еще выше. Мы научимся просить Gemini возвращать данные в **структурированном формате (JSON)**, а затем будем **превращать этот JSON в настоящие объекты PowerShell**. Это позволит нам не просто *показывать* информацию, а *работать* с ней: сортировать, фильтровать и передавать по конвейеру, полностью интегрировав мощь ИИ в философию PowerShell.