
# А давайте встроим ии в powershell

#### **Что такое Gemini CLI?**

Подробно о **Gemini CLI** я уже рассказывал в [Gemini CLI: Знакомство и первые шаги⁠⁠](https://pikabu.ru/series/geminicli_48168). Но если вы ее пропустили, вот краткое введение.

Если коротко, **Gemini CLI** — это командная строка для взаимодействия с моделями ИИ от Google. Вы запускаете его в своем терминале, и он превращается в чат, который, в отличие от веб-версий, имеет доступ к вашей файловой системе.

**Ключевые возможности:**
*   **Понимает код:** Он может анализировать ваши скрипты, находить в них ошибки и предлагать исправления.
*   **Генерирует код:** Вы можете попросить его написать PowerShell-скрипт для решения вашей задачи, и он это сделает.
*   **Работает с файлами:** Может читать файлы, создавать новые, вносить изменения в существующие.
*   **Запускает команды:** Может выполнять команды оболочки, такие как `git` или `npm`.

Для наших целей самое важное то, что Gemini CLI умеет работать в **неинтерактивном режиме**. То есть мы можем передать ему промпт как аргумент командной строки, и он просто вернет нам ответ, не запуская свой интерактивный чат. Именно эту возможность мы и будем использовать.

#### **Установка и настройка**

Чтобы начать, нам нужно подготовить наше окружение. Это делается один раз.

**Шаг 1: Установка Node.js**
Gemini CLI — это приложение, написанное на Node.js (популярная среда для JavaScript). Поэтому сначала нам нужно установить саму Node.js.
1.  Перейдите на официальный сайт: [https://nodejs.org/](https://nodejs.org/)
2.  Скачайте и установите **LTS** версию. Это самый стабильный и рекомендуемый вариант. Просто следуйте инструкциям установщика.
3.  После установки откройте новое окно PowerShell и проверьте, что все работает:
    ```powershell
    node -v
    npm -v
    ```
    Вы должны увидеть версии, например, `v20.12.2` и `10.5.0`.

**Шаг 2: Установка самого Gemini CLI**
Теперь, когда у нас есть `npm` (менеджер пакетов для Node.js), установка Gemini CLI сводится к одной команде. Выполните ее в PowerShell:
```powershell
npm install -g @google/gemini-cli
```
Флаг `-g` означает "глобальная установка", что сделает команду `gemini` доступной из любого места в вашей системе.

**Шаг 3: Аутентификация**
В первый раз, когда вы запустите Gemini CLI, он попросит вас войти в свой аккаунт Google. Это нужно, чтобы он мог использовать вашу бесплатную квоту.
1.  Просто введите в PowerShell команду:
    ```powershell
    gemini
    ```
2.  Он задаст вам вопрос о входе. Выберите "Sign in with Google".
3.  В вашем браузере откроется стандартное окно входа Google. Войдите в свой аккаунт и предоставьте необходимые разрешения.
4.  После этого в консоли вы увидите приветственное сообщение от Gemini. Поздравляю, вы готовы к работе! Можете ввести `/quit`, чтобы выйти из его чата.

#### **Философия PowerShell: ужасный `Invoke-Expression`**

Прежде чем мы соединим все вместе, познакомимся с одним из самых опасных командлетов в PowerShell — `Invoke-Expression`, или его коротким псевдонимом `iex`.

`Invoke-Expression` берет текстовую строку и выполняет ее так, как будто это была команда, напечатанная в консоли.

**Пример:**
```powershell
$commandString = "Get-Process -Name 'chrome'"
Invoke-Expression -InputObject $commandString
```
Эта команда сделает то же самое, что и простой вызов `Get-Process -Name 'chrome'`.

**Почему он опасный?** Потому что выполнение строки, которую вы не контролируете (например, полученной из интернета или от ИИ), — это огромная дыра в безопасности. Если ИИ по ошибке или со злым умыслом вернет команду `Remove-Item -Path C:\ -Recurse -Force`, `iex` без раздумий ее выполнит.

Для нашей задачи — создания управляемого и контролируемого моста между запросом на естественном языке и его выполнением — он подходит идеально. Мы будем использовать его с осторожностью, полностью осознавая риски.

#### **Соединяем всё вместе: командлет `Invoke-Gemini`**
Напишем простую PowerShell-функцию, которая позволит нам отправлять промпты одной командой.

Скопируйте этот код и вставьте его в свое окно PowerShell, чтобы он стал доступен в текущей сессии.

```powershell
function Invoke-Gemini {
    <#
    .SYNOPSIS
        Отправляет текстовый промпт в Gemini CLI и возвращает его ответ.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string]$Prompt
    )

    process {
        try {
            # Проверяем, доступна ли команда gemini
            $geminiCommand = Get-Command gemini -ErrorAction Stop
        }
        catch {
            Write-Error "Команда 'gemini' не найдена. Убедитесь, что Gemini CLI установлен."
            return
        }

        Write-Verbose "Отправка промпта в Gemini CLI..."
        
        # Запускаем gemini в неинтерактивном режиме с нашим промптом
        $output = & $geminiCommand.Source -p $Prompt 2>&1

        if (-not $?) {
            Write-Warning "Команда gemini завершилась с ошибкой."
            $output | ForEach-Object { Write-Warning $_.ToString() }
            return
        }

        # Возвращаем чистый вывод
        return $output
    }
}
```

#### **Пробуем магию!**


Давайте зададим ему вопрос на общую тему прямо из нашей PowerShell-консоли.

```powershell
Invoke-Gemini -Prompt "Расскажи о пяти последних трендах в области машинного обучения"
```


**Поздравляю!** Вы только что успешно встроили ИИ в PowerShell.

В следующей статье я расскажу, как использовать Gemini CLI для запуска скриптов и автоматизации задач. 