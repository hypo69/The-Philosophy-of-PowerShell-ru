<h2>Let's Embed AI in PowerShell. Part Two: The Specification Finder</h2>
<p>Last time, we saw how we can interact with the Gemini model through the command-line interface using PowerShell.
In this article, I will show you how to benefit from our knowledge.
We will turn our console into an interactive reference guide that takes a component identifier (brand, model, category, part number, etc.) as input and returns an interactive table with specifications obtained from the Gemini model.</p>
<p>Engineers, developers, and other specialists often need to find the exact parameters of, for example, a motherboard, a circuit breaker in an electrical panel, or a network switch. Our reference guide will always be at hand and, upon request, will gather information, clarify parameters on the internet, and return the desired table. In the table, you can select the necessary parameter(s) and, if needed, continue with a more in-depth search. Later, we will learn how to pass the result down the pipeline for further processing: exporting to an Excel or Google spreadsheet, storing in a database, or transferring to another program. In case of failure, the model will advise which parameters need to be clarified. But see for yourself:</p>
<p><a href="https://github.com/user-attachments/assets/0e6690c1-5d49-4c75-89fc-ede2c7642c5f">video</a></p>
<video width="600" controls>
  <source src="https://github.com/user-attachments/assets/0e6690c1-5d49-4c75-89fc-ede2c7642c5f" type="video/mp4">
  Your browser does not support the video tag.
</video>
<h2>How the AI-Powered Finder Works: From Launch to Result</h2>
<p>Let's trace the entire lifecycle of our scriptâ€”what happens from the moment it's launched until the results are obtained.</p>
<h2>Initialization: Preparing for Work</h2>
<p>The script accepts a <code>$Model</code> parameter with validationâ€”you can choose '<code>gemini-2.5-flash</code>' (the default, fast model) or '<code>gemini-2.5-pro</code>' (more powerful). Upon launch, the script first sets up the working environment. It sets the API key for access to Gemini AI, defines the current folder as the base directory, and creates a structure for storing files. For each session, a file with a timestamp is created, for example, <code>ai_session_2025-08-26_14-30-15.jsonl</code>. This is the dialogue history.</p>
<p>Next, the system checks that all necessary tools are installed. It looks for the Gemini CLI in the system and checks for configuration files in the <code>.gemini/</code> folder. The <code>GEMINI.md</code> file is particularly importantâ€”it contains the system prompt for the model and is automatically loaded by the Gemini CLI at startup. This is the standard location for system instructions. The <code>ShowHelp.md</code> file, which contains help information, is also checked. If anything critical is missing, the script warns the user or terminates.</p>
<h2>Starting Interactive Mode</h2>
<p>After successful initialization, the script displays a welcome message indicating the selected model ("AI Specification Finder. Model: '<code>gemini-2.5-flash</code>'."), the path to the session file, and instructions for commands. It then enters interactive modeâ€”it shows a prompt and waits for user input. The prompt looks like <code>ðŸ¤–AI :) > </code> and changes to <code>ðŸ¤–AI [Selection active] :) > </code> when the system has data for analysis.</p>
<h2>Processing User Input</h2>
<p>Every user input is first checked for service commands by the <code>Command-Handler</code> function. This function recognizes commands like <code>?</code> (help from the ShowHelp.md file), <code>history</code> (show session history), <code>clear</code> and <code>clear-history</code> (clear the history file), <code>gemini help</code> (CLI help), and <code>exit</code> and <code>quit</code> (exit). If it's a service command, it is executed immediately without contacting the AI, and the loop continues.</p>
<p>If it's a regular query, the system starts building the context to send to Gemini. It reads the entire history of the current session from the JSONL file (if it exists), adds a block with data from the previous selection (if there is an active selection), and combines all of this with the new user query into a structured prompt with sections "DIALOGUE HISTORY," "DATA FROM SELECTION," and "NEW TASK." After use, the selection data is cleared.</p>
<h2>Interacting with the Artificial Intelligence</h2>
<p>The formed prompt is sent to Gemini via the command line with the call <code>& gemini -m $Model -p $Prompt 2>&1</code>. The system captures all output (including errors via <code>2>&1</code>), checks the return code, and cleans the result of CLI service messages ("Data collection is disabled" and "Loaded cached credentials"). If an error occurs at this stage, the user receives a warning, but the script continues to run.</p>
<h2>Processing the AI's Response</h2>
<p>The system attempts to interpret the response received from the AI as JSON. First, it looks for a code block in the format <code>```json...```</code>, extracts the content, and tries to parse it. If there is no such block, it parses the entire response. If parsing is successful, the data is displayed in an interactive <code>Out-ConsoleGridView</code> table with the title "Select rows for the next query (OK) or close (Cancel)" and multiple selection enabled. If the JSON is not recognized (parsing error), the response is shown as plain text in blue.</p>
<h2>Working with Data Selection</h2>
<p>When the user selects rows in the table and clicks OK, the system performs several actions. First, the <code>Show-SelectionTable</code> function is called, which analyzes the structure of the selected data: if they are objects with properties, it identifies all unique fields and displays the data using <code>Format-Table</code> with auto-sizing and wrapping. If they are simple values, it displays them as a numbered list. It then outputs a counter of the selected items and the message "Selection saved. Add your next query (e.g., 'compare them')."</p>
<p>The selected data is converted to a compressed JSON with a nesting depth of 10 levels and saved in the <code>$selectionContextJson</code> variable for use in subsequent requests to the AI.</p>
<h2>Maintaining History</h2>
<p>Each "user query - AI response" pair is saved to the history file in JSONL format. This ensures the continuity of the dialogueâ€”the AI "remember" the entire previous conversation and can refer to previously discussed topics.</p>
<h2>The Cycle Continues</h2>
<p>After processing the request, the system returns to waiting for new input. If the user has an active selection, this is reflected in the command-line prompt. The cycle continues until the user enters an exit command.</p>
<h2>Practical Example of Operation</h2>
<p>Imagine a user runs the script and enters "RTX 4070 Ti Super":</p>
<ul>
<li><strong>Context Preparation:</strong> The system takes the system prompt from the file, adds the history (currently empty), and the new query.</li>
<li><strong>AI Request:</strong> The full prompt is sent to Gemini with a request to find the specifications of the video cards.</li>
<li><strong>Data Retrieval:</strong> The AI returns a JSON with an array of objects containing information about various RTX 4070 Ti Super models.</li>
<li><strong>Interactive Table:</strong> The user sees a table with manufacturers, specifications, and prices, and selects 2-3 models of interest.</li>
<li><strong>Displaying the Selection:</strong> A table with the selected models appears in the console, and the prompt changes to <code>[Selection active]</code>.</li>
<li><strong>Refining Query:</strong> The user types "compare their gaming performance."</li>
<li><strong>Contextual Analysis:</strong> The AI receives the initial query, the selected models, and the new question, providing a detailed comparison of those specific cards.</li>
</ul>
<h2>Termination</h2>
<p>When <code>exit</code> or <code>quit</code> is entered, the script terminates correctly, having saved the entire session history to a file. The user can return to this dialogue at any time by viewing the contents of the corresponding file in the <code>.chat_history</code> folder.</p>
<p>All this complex logic is hidden from the user behind a simple command-line interface. The person simply asks questions and receives structured answers, while the system takes care of all the work of maintaining context, parsing data, and managing the state of the dialogue.</p>
<hr>
<h2>Step 1: Setup</h2>
<pre class="line-numbers"><code class="language-powershell"># --- Step 1: Setup ---
$env:GEMINI_API_KEY = "AIzaSyCbq8bkt5Xr2hlE-73MIXFpdFYH-rLBd0k"
if (-not $env:GEMINI_API_KEY) { Write-Error "..."; return }

$scriptRoot = Get-Location
# --- CHANGE: Variable renamed ---
$HistoryDir = Join-Path $scriptRoot ".gemini/.chat_history"
# --- END CHANGE ---
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$historyFileName = "ai_session_$timestamp.jsonl"
$historyFilePath = Join-Path $HistoryDir $historyFileName
</code></pre>
<p><strong>Purpose of the lines:</strong></p>
<ul>
<li><code>$env:GEMINI_API_KEY = "..."</code> - sets the API key for accessing the Gemini AI.</li>
<li><code>if (-not $env:GEMINI_API_KEY)</code> - checks for the key and terminates the script if it's missing.</li>
<li><code>$scriptRoot = Get-Location</code> - gets the current working directory.</li>
<li><code>$HistoryDir = Join-Path...</code> - forms the path to the folder for storing dialogue history (<code>.gemini/.chat_history</code>).</li>
<li><code>$timestamp = Get-Date...</code> - creates a timestamp in the format <code>2025-08-26_14-30-15</code>.</li>
<li><code>$historyFileName = "ai_session_$timestamp.jsonl"</code> - generates a unique session filename.</li>
<li><code>$historyFilePath = Join-Path...</code> - creates the full path to the current session's history file.</li>
</ul>
<h2>Environment Check - What Should Be Installed</h2>
<pre class="line-numbers"><code class="language-powershell"># --- Step 2: Environment Check ---
try { Get-Command gemini -ErrorAction Stop | Out-Null } 
catch { Write-Error "Command 'gemini' not found..."; return }

if (-not (Test-Path (Join-Path $scriptRoot ".gemini/GEMINI.md"))) { 
    Write-Warning "System prompt file .gemini/GEMINI.md not found..." 
}
if (-not (Test-Path (Join-Path $scriptRoot ".gemini/ShowHelp.md"))) { 
    Write-Warning "Help file .gemini/ShowHelp.md not found..." 
}
</code></pre>
<p><strong>What is checked:</strong></p>
<ul>
<li>The presence of <strong>Gemini CLI</strong> in the system - the script won't work without it.</li>
<li>The <strong>GEMINI.md</strong> file - contains the system prompt (instructions for the AI).</li>
<li>The <strong>ShowHelp.md</strong> file - user help (the <code>?</code> command).</li>
</ul>
<h2>Main Function for Interacting with AI</h2>
<pre class="line-numbers"><code class="language-powershell">function Invoke-GeminiPrompt {
    param([string]$Prompt, [string]$Model)
    try {
        $output = & gemini -m $Model -p $Prompt 2>&1
        if (-not $?) { $output | ForEach-Object { Write-Warning $_.ToString() }; return $null }
        
        $outputString = ($output -join [Environment]::NewLine).Trim()
        $cleanedOutput = $outputString -replace "(?m)^Data collection is disabled\.`r?`n" , ""
        $cleanedOutput = $cleanedOutput -replace "(?m)^Loaded cached credentials\.`r?`n", ""
        
        return $cleanedOutput.Trim()
    }
    catch { Write-Error "Critical error when calling Gemini CLI: $_"; return $null }
}
</code></pre>
<p><strong>Function tasks:</strong></p>
<ul>
<li>Calls the Gemini CLI with the specified model and prompt.</li>
<li>Captures all output (including errors).</li>
<li>Cleans the result of CLI service messages.</li>
<li>Returns the clean AI response or <code>$null</code> on error.</li>
</ul>
<h2>History Management Functions</h2>
<pre class="line-numbers"><code class="language-powershell">function Add-History { 
    param([string]$UserPrompt, [string]$ModelResponse)
    if (-not (Test-Path $HistoryDir)) { New-Item -Path $HistoryDir -ItemType Directory | Out-Null }
    @{ user = $UserPrompt } | ConvertTo-Json -Compress | Add-Content -Path $historyFilePath
    @{ model = $ModelResponse } | ConvertTo-Json -Compress | Add-Content -Path $historyFilePath
}

function Show-History {
    if (-not (Test-Path $historyFilePath)) { Write-Host "Current session history is empty." -ForegroundColor Yellow; return }
    Write-Host "`n--- Current Session History ---" -ForegroundColor Cyan
    Get-Content -Path $historyFilePath
    Write-Host "------------------------------------`n" -ForegroundColor Cyan
}

function Clear-History {
    if (Test-Path $historyFilePath) {
        Remove-Item -Path $historyFilePath -Force -ErrorAction Stop
        Write-Host "Current session history ($historyFileName) has been deleted." -ForegroundColor Yellow
    }
}
</code></pre>
<p><strong>Purpose:</strong></p>
<ul>
<li><code>Add-History</code> - saves "question-answer" pairs in JSONL format.</li>
<li><code>Show-History</code> - displays the contents of the history file.</li>
<li><code>Clear-History</code> - deletes the current session's history file.</li>
</ul>
<h2>Function for Displaying Selected Data</h2>
<pre class="line-numbers"><code class="language-powershell">function Show-SelectionTable {
    param([array]$SelectedData)
    
    if ($null -eq $SelectedData -or $SelectedData.Count -eq 0) { return }
    
    Write-Host "`n--- SELECTED DATA ---" -ForegroundColor Yellow
    
    # Get all unique properties from the selected objects
    $allProperties = @()
    foreach ($item in $SelectedData) {
        if ($item -is [PSCustomObject]) {
            $properties = $item | Get-Member -MemberType Properties | Select-Object -ExpandProperty Name
            $allProperties = $allProperties + $properties | Sort-Object -Unique
        }
    }
    
    # Show a table or a list
    if ($allProperties.Count -gt 0) {
        $SelectedData | Format-Table -Property $allProperties -AutoSize -Wrap
    } else {
        for ($i = 0; $i -lt $SelectedData.Count; $i++) {
            Write-Host "[$($i + 1)] $($SelectedData[$i])" -ForegroundColor White
        }
    }
    
    Write-Host "-------------------------" -ForegroundColor Yellow
    Write-Host "Items selected: $($SelectedData.Count)" -ForegroundColor Magenta
}
</code></pre>
<p><strong>Function's task:</strong> After selecting items in <code>Out-ConsoleGridView</code>, it displays them in the console as a neat table, so the user can see exactly what was chosen.</p>
<h2>Main Working Loop</h2>
<pre class="line-numbers"><code class="language-powershell">while ($true) {
    # Display prompt with state indicator
    if ($selectionContextJson) {
        Write-Host -NoNewline -ForegroundColor Green "ðŸ¤–AI [Selection active] :) > "
    } else {
        Write-Host -NoNewline -ForegroundColor Green "ðŸ¤–AI :) > "
    }
    
    $UserPrompt = Read-Host
    
    # Handle service commands
    $commandResult = Command-Handler -Command $UserPrompt
    if ($commandResult -eq 'break') { break }
    if ($commandResult -eq 'continue') { continue }
    
    # Form the full prompt with context
    $fullPrompt = @"
### DIALOGUE HISTORY (CONTEXT)
$historyContent

### DATA FROM SELECTION (FOR ANALYSIS)
$selectionContextJson

### NEW TASK
$UserPrompt
"@
    
    # Call AI and process the response
    $ModelResponse = Invoke-GeminiPrompt -Prompt $fullPrompt -Model $Model
    
    # Try to parse JSON and show the interactive table
    try {
        $jsonObject = $jsonToParse | ConvertFrom-Json
        $gridSelection = $jsonObject | Out-ConsoleGridView -Title "Select rows..." -OutputMode Multiple
        
        if ($null -ne $gridSelection) {
            Show-SelectionTable -SelectedData $gridSelection
            $selectionContextJson = $gridSelection | ConvertTo-Json -Compress -Depth 10
        }
    }
    catch {
        Write-Host $ModelResponse -ForegroundColor Cyan
    }
    
    Add-History -UserPrompt $UserPrompt -ModelResponse $ModelResponse
}
</code></pre>
<p><strong>Key features:</strong></p>
<ul>
<li>The <code>[Selection active]</code> indicator shows that there is data for analysis.</li>
<li>Each query includes the entire dialogue history to maintain context.</li>
<li>The AI receives both the history and the user-selected data.</li>
<li>The result is attempted to be displayed as an interactive table.</li>
<li>If JSON parsing fails, plain text is shown.</li>
</ul>
<h2>Working Files Structure</h2>
<p>The script creates the following structure:</p>
<pre><code>â”œâ”€â”€ Find-Spec.ps1
â”œâ”€â”€ .gemini/
â”‚   â”œâ”€â”€ GEMINI.md              # System prompt for AI
â”‚   â”œâ”€â”€ ShowHelp.md            # User help
â”‚   â””â”€â”€ .chat_history/         # Folder with session history
â”‚       â”œâ”€â”€ ai_session_2025-08-26_10-15-30.jsonl
â”‚       â””â”€â”€ ai_session_2025-08-26_14-22-45.jsonl
</code></pre>
<p>The <code>GEMINI.md</code> file in the <code>.gemini/</code> folder is the standard location for the system prompt for the Gemini CLI. On each run, the model automatically loads instructions from this file, which defines its behavior and response format.</p>
<p>In the next part, we will look at the contents of the configuration files and practical usage examples.</p>