<h2>PowerShell Philosophy.</h2>
<h2>Part 0.</h2>
<p>What was before PowerShell?
In 1981, MS-DOS 1.0 was released with the <code>COMMAND.COM</code> command interpreter. For task automation, <strong>batch files (<code>.bat</code>)</strong> were used ‚Äî simple text files with a sequence of console commands. The astonishing asceticism of the command line against the backdrop of POSIX-compatible systems where the <strong>Bourne shell (<code>sh</code>)</strong> had existed since 1979.</p>

<h3>üìÖ State of the Shell Market at the Time of **MS-DOS 1.0** Release (August 1981)</h3>

<p>Here is a summary table of popular OSes of that time and their shell support (<code>sh</code>, <code>csh</code>, etc.):</p>

<table>
<thead>
<tr>
<th>Operating System</th>
<th>Shell Support (<code>sh</code>, <code>csh</code>, etc.)</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UNIX Version 7 (V7)</strong></td>
<td><code>sh</code></td>
<td>Last classic Bell Labs UNIX, widely distributed</td>
</tr>
<tr>
<td><strong>UNIX/32V</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>UNIX version for VAX architecture</td>
</tr>
<tr>
<td><strong>4BSD / 3BSD</strong></td>
<td><code>sh</code>, <code>csh</code></td>
<td>University branch of UNIX from Berkeley</td>
</tr>
<tr>
<td><strong>UNIX System III</strong></td>
<td><code>sh</code></td>
<td>First commercial version from AT&amp;T, predecessor to System V</td>
</tr>
<tr>
<td><strong>Xenix (from Microsoft)</strong></td>
<td><code>sh</code></td>
<td>Licensed UNIX version, sold by Microsoft since 1980</td>
</tr>
<tr>
<td><strong>IDRIS</strong></td>
<td><code>sh</code></td>
<td>UNIX-like OS for PDP-11 and Intel</td>
</tr>
<tr>
<td><strong>Coherent (Mark Williams)</strong></td>
<td><code>sh</code> (similar)</td>
<td>Inexpensive UNIX alternative for PCs</td>
</tr>
<tr>
<td><strong>CP/M (Digital Research)</strong></td>
<td>‚ùå (No <code>sh</code>, only simplest CLI)</td>
<td>Not UNIX, most popular OS for 8-bit PCs</td>
</tr>
<tr>
<td><strong>MS-DOS 1.0</strong></td>
<td>‚ùå (only <code>COMMAND.COM</code>)</td>
<td>Minimal command shell, no scripts or pipes</td>
</tr>
</tbody>
</table>

<hr />

<h3>üí° What are <code>sh</code>, <code>csh</code></h3>

<ul>
<li><code>sh</code> ‚Äî <strong>Bourne Shell</strong>, the primary UNIX scripting interpreter since 1977.</li>
<li><code>csh</code> ‚Äî <strong>C Shell</strong>, an improved shell with C-like syntax and conveniences for interactive work.</li>
<li>These shells <strong>supported redirects, pipes, variables, functions, and conditionals</strong> ‚Äî everything that made UNIX a powerful automation tool.</li>
</ul>

<hr />

<p>Microsoft focused on <strong>cheap 16-bit IBM PCs</strong>, which had <strong>little memory</strong> (usually 64‚Äì256 KB), lacked multitasking, and were intended for <strong>home and office use</strong>, not servers. UNIX was expensive, required complex architecture and expertise, while accountants and engineers, not system administrators, needed a fast and simple OS.</p>

<p>The DOS interface, instead of the complex <code>sh</code>, presented a single <code>command.com</code> file with a meager set of internal commands (<a href="/blog/dos-commands/" target="_blank">dir, copy, del, etc.</a>) without functions, loops, or modules.</p>

<p>There were also external commands ‚Äî separate executable files (.exe or .com). Examples: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
Execution scripts were written in a text file with the .bat (batch file) extension.</p>

<p>Examples of configuration files:</p>

<ul>
<li>AUTOEXEC.BAT</li>
</ul>

<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT ‚Äî Automatic configuration and launch of Windows 3.11
:: Author: hypo69
:: Year: approximately 1993
:: Purpose: Performs DOS environment initialization, loads network drivers, and launches Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: Command prompt setting
PROMPT $p$g

:: Environment variables setting
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: Loading drivers and utilities into upper memory
LH C:\DOS\SMARTDRV.EXE       :: Disk cache
LH C:\DOS\MOUSE.COM          :: Mouse driver

:: Loading network services (relevant for Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: Automatic Windows launch
WIN

</code></pre>

<ul>
<li>CONFIG.SYS</li>
</ul>

<pre class="line-numbers"><code class="language-bash">:: ------------------------------------------------------------------------------
:: CONFIG.SYS ‚Äî DOS memory and driver configuration for Windows 3.11
:: Author: hypo69
:: Year: approximately 1993
:: Purpose: Initializes memory drivers, configures system parameters
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE

</code></pre>

<p>In Microsoft, parallel to DOS, a fundamentally new kernel began to be developed almost immediately.</p>

<p>The <a href="https://www.wikiwand.com/ru/articles/Windows_NT" target="_blank"><strong>Windows NT</strong></a> (New Technology) kernel first appeared with the release of the operating system:</p>

<blockquote>
<p><strong>Windows NT 3.1 ‚Äî July 27, 1993</strong></p>
</blockquote>

<hr />

<ul>
<li><strong>Development began</strong>: in <strong>1988</strong> under the leadership of <strong>Dave Cutler</strong> (former DEC engineer, creator of VMS) with the goal of creating a completely new, secure, portable, and multitasking OS, not compatible with MS-DOS at the kernel level.</li>
<li><strong>NT 3.1</strong> ‚Äî was named to emphasize compatibility with <strong>Windows 3.1</strong> at the interface level, but had a <strong>completely new architecture</strong>.</li>
</ul>

<hr />

<h4>üß† What the NT kernel brought:</h4>

<table>
<thead>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>32-bit architecture</strong></td>
<td>Unlike MS-DOS and Windows 3.x, which were 16-bit.</td>
</tr>
<tr>
<td><strong>Multitasking</strong></td>
<td>True preemptive multitasking.</td>
</tr>
<tr>
<td><strong>Protected memory</strong></td>
<td>Programs could not corrupt each other's memory.</td>
</tr>
<tr>
<td><strong>Modularity</strong></td>
<td>Multi-layered kernel architecture: HAL, Executive, Kernel, drivers.</td>
</tr>
<tr>
<td><strong>Multi-platform support</strong></td>
<td>NT 3.1 ran on x86, MIPS, and Alpha.</td>
</tr>
<tr>
<td><strong>POSIX compatibility</strong></td>
<td>NT shipped with a <strong>POSIX subsystem</strong>, certified to POSIX.1.</td>
</tr>
</tbody>
</table>

<hr />

<h4>üìú NT Lineup:</h4>

<table>
<thead>
<tr>
<th>NT Version</th>
<th>Year</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>NT 3.1</td>
<td>1993</td>
<td>First NT release</td>
</tr>
<tr>
<td>NT 3.5 / 3.51</td>
<td>1994‚Äì1995</td>
<td>Improvements, optimization</td>
</tr>
<tr>
<td>NT 4.0</td>
<td>1996</td>
<td>Windows 95 interface, but NT kernel</td>
</tr>
<tr>
<td>Windows 2000</td>
<td>2000</td>
<td>NT 5.0</td>
</tr>
<tr>
<td>Windows XP</td>
<td>2001</td>
<td>NT 5.1</td>
</tr>
<tr>
<td>Windows Vista</td>
<td>2007</td>
<td>NT 6.0</td>
</tr>
<tr>
<td>Windows 10</td>
<td>2015</td>
<td>NT 10.0</td>
</tr>
<tr>
<td>Windows 11</td>
<td>2021</td>
<td>Also NT 10.0 (marketing üòä)</td>
</tr>
</tbody>
</table>

<hr />

<p>Difference in operating system capabilities:</p>

<table>
<thead>
<tr>
<th>Characteristic</th>
<th><strong>MS-DOS</strong> (1981)</th>
<th><strong>Windows NT</strong> (1993)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>System type</strong></td>
<td>Monolithic, single-tasking</td>
<td>Microkernel/hybrid, multitasking</td>
</tr>
<tr>
<td><strong>Bitness</strong></td>
<td>16-bit</td>
<td>32-bit (with 64-bit support from NT 5.2 / XP x64)</td>
</tr>
<tr>
<td><strong>Multitasking</strong></td>
<td>‚ùå Absent (one process at a time)</td>
<td>‚úÖ Preemptive multitasking</td>
</tr>
<tr>
<td><strong>Protected memory</strong></td>
<td>‚ùå No</td>
<td>‚úÖ Yes (each process in its own address space)</td>
</tr>
<tr>
<td><strong>Multi-user mode</strong></td>
<td>‚ùå No</td>
<td>‚úÖ Partially (in NT Workstation/Server)</td>
</tr>
<tr>
<td><strong>POSIX compatibility</strong></td>
<td>‚ùå No</td>
<td>‚úÖ Built-in POSIX subsystem in NT 3.1‚Äì5.2</td>
</tr>
<tr>
<td><strong>Kernel portability</strong></td>
<td>‚ùå x86 only</td>
<td>‚úÖ x86, MIPS, Alpha, PowerPC</td>
</tr>
<tr>
<td><strong>Drivers</strong></td>
<td>Direct hardware access</td>
<td>Via HAL and Kernel-mode Drivers</td>
</tr>
<tr>
<td><strong>Application access level</strong></td>
<td>Applications = system level</td>
<td>User / Kernel level separated</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>‚ùå Absent</td>
<td>‚úÖ Security model: SID, ACL, access tokens</td>
</tr>
<tr>
<td><strong>Stability</strong></td>
<td>‚ùå One program's dependency = OS crash</td>
<td>‚úÖ Process isolation, kernel protection</td>
</tr>
</tbody>
</table>

<hr />

<p>But there was one big BUT! Automation and administration tools were not given due attention until 2002.</p>

<hr />

<p>Microsoft used completely different approaches, strategies, and tools for administration. All of this was <strong>disjointed</strong>, often GUI-oriented, and not always automatable.</p>

<hr />

<h5>üìå List of some tools:</h5>

<table>
<thead>
<tr>
<th>Tool</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmd.exe</code></td>
<td>Improved command interpreter (replacement for <code>COMMAND.COM</code>)</td>
</tr>
<tr>
<td><code>.bat</code>, <code>.cmd</code></td>
<td>Command line scripts</td>
</tr>
<tr>
<td><strong>Windows Script Host (WSH)</strong></td>
<td>Support for VBScript and JScript for automation</td>
</tr>
<tr>
<td><code>reg.exe</code></td>
<td>Registry management from the command line</td>
</tr>
<tr>
<td><code>net.exe</code></td>
<td>Working with users, network, printers</td>
</tr>
<tr>
<td><code>sc.exe</code></td>
<td>Service management</td>
</tr>
<tr>
<td><code>tasklist</code>, <code>taskkill</code></td>
<td>Process management</td>
</tr>
<tr>
<td><code>gpedit.msc</code></td>
<td>Group Policy (local)</td>
</tr>
<tr>
<td><code>MMC</code></td>
<td>Console with snap-ins for management</td>
</tr>
<tr>
<td><code>WMI</code></td>
<td>Access to system information (via <code>wmic</code>, VBScript, or COM)</td>
</tr>
<tr>
<td><code>WbemTest.exe</code></td>
<td>GUI for testing WMI queries</td>
</tr>
<tr>
<td><code>eventvwr</code></td>
<td>Event log viewer</td>
</tr>
<tr>
<td><code>perfmon</code></td>
<td>Resource monitoring</td>
</tr>
</tbody>
</table>

<h5>üõ† Automation examples:</h5>

<ul>
<li>VBScript files (<code>*.vbs</code>) for administering users, networks, printers, and services.</li>
<li><code>WMIC</code> ‚Äî command-line interface to WMI (e.g., <code>wmic process list brief</code>).</li>
<li><code>.cmd</code> scripts with calls to <code>net</code>, <code>sc</code>, <code>reg</code>, <code>wmic</code>, etc.</li>
</ul>

<hr />

<h3>‚öôÔ∏è Windows Scripting Host (WSH)</h3>

<ul>
<li>First appeared in <strong>Windows 98</strong>, actively used in <strong>Windows 2000 and XP</strong>.</li>
<li>Allowed executing VBScript and JScript files from the command line:</li>
</ul>

<pre class="line-numbers"><code class="language-vbscript">Set objShell = WScript.CreateObject("WScript.Shell")
objShell.Run "notepad.exe"
</code></pre>

<hr />
<h2>Part 1.</h2>

<p>Only in 2002 did the company formulate the <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a> project, which later evolved into PowerShell:</p>

<p>Development began: approximately in 2002</p>

<p>Public announcement: 2003, as "Monad Shell"</p>

<p>First beta versions: appeared by 2005</p>

<p>Final release (PowerShell 1.0): November 2006</p>

<p>The author and chief architect of the Monad / PowerShell project is Jeffrey Snover
<a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (Jeffrey Snover)</a></p>

<p>Today PowerShell Core runs on
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a></p>

<p>In parallel, the .NET framework was being developed, and PowerShell was deeply integrated into it; in the following chapters, I will show examples.</p>

<p>And now ‚Äî the most important thing!</p>

<p>The main advantage of PowerShell compared to classic command shells is that it works with <em>objects</em>, not text. When you execute a command, it returns not just text, but a structured object (or a collection of objects) that has clearly defined properties and methods.</p>

<p>See how PowerShell surpasses classic shells thanks to <strong>working with objects</strong>.</p>

<h3>üìÅ How it was: <code>dir</code> and manual parsing</h3>

<p>In <strong>CMD</strong> (both in old <code>COMMAND.COM</code> and in <code>cmd.exe</code>), the <code>dir</code> command returns the result as plain text. Example output:</p>

<pre class="line-numbers"><code class="language-text">24.07.2025  21:15         1 428  my_script.js
25.07.2025  08:01         3 980  report.html
</code></pre>

<p>Suppose you want to extract the <strong>filename</strong> and <strong>size</strong> of each file. You will have to parse the lines manually:</p>

<pre class="line-numbers"><code class="language-cmd">for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
</code></pre>

<ul>
<li>This is terribly difficult to read, depends on locale, date format, font. And breaks with spaces in names.</li>
</ul>

<hr />

<h3>‚úÖ PowerShell: objects instead of text</h3>

<h4>‚úî Simple and readable example:</h4>

<pre class="line-numbers"><code class="language-powershell">Get-ChildItem | Select-Object Name, Length
</code></pre>

<p><strong>Result:</strong></p>

<pre class="line-numbers"><code class="language-text">Name          Length
----          ------
my_script.js   1428
report.html    3980
</code></pre>

<ul>
<li><code>Get-ChildItem</code> returns an <strong>array of file/folder objects</strong></li>
<li><code>Select-Object</code> allows you to easily get the necessary <strong>properties</strong></li>
</ul>

<hr />

<h3>üîç What does <code>Get-ChildItem</code> actually return?</h3>

<pre class="line-numbers"><code class="language-powershell">$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
</code></pre>

<p><strong>Result:</strong></p>

<pre class="line-numbers"><code class="language-text">TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
</code></pre>

<p>PowerShell returns <strong>objects of type <code>System.IO.FileInfo</code></strong>, which have:</p>

<ul>
<li>üß± Properties (<code>Name</code>, <code>Length</code>, <code>CreationTime</code>, <code>Extension</code>, ‚Ä¶)</li>
<li>üõ† Methods (<code>Delete()</code>, <code>CopyTo()</code>, <code>MoveTo()</code> etc.)</li>
</ul>

<p>You work <strong>with full-fledged objects</strong>, not strings.</p>

<hr />

<p>Syntax "Verb-Noun":</p>

<p>PowerShell uses a <strong>strict and logical command syntax</strong>:
<code>Verb-Noun</code></p>

<table>
<thead>
<tr>
<th>Verb</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Get-</code></td>
<td>Get</td>
</tr>
<tr>
<td><code>Set-</code></td>
<td>Set</td>
</tr>
<tr>
<td><code>New-</code></td>
<td>Create</td>
</tr>
<tr>
<td><code>Remove-</code></td>
<td>Remove</td>
</tr>
<tr>
<td><code>Start-</code></td>
<td>Start</td>
</tr>
<tr>
<td><code>Stop-</code></td>
<td>Stop</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Noun</th>
<th>What it works on</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Process</code></td>
<td>Process</td>
</tr>
<tr>
<td><code>Service</code></td>
<td>Service</td>
</tr>
<tr>
<td><code>Item</code></td>
<td>File/folder</td>
</tr>
<tr>
<td><code>EventLog</code></td>
<td>Event logs</td>
</tr>
<tr>
<td><code>Computer</code></td>
<td>Computer</td>
</tr>
</tbody>
</table>

<h4>üîÑ Examples:</h4>

<table>
<thead>
<tr>
<th>What needs to be done</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get processes</td>
<td><code>Get-Process</code></td>
</tr>
<tr>
<td>Stop service</td>
<td><code>Stop-Service</code></td>
</tr>
<tr>
<td>Create new file</td>
<td><code>New-Item</code></td>
</tr>
<tr>
<td>Get folder content</td>
<td><code>Get-ChildItem</code></td>
</tr>
<tr>
<td>Delete file</td>
<td><code>Remove-Item</code></td>
</tr>
</tbody>
</table>

<p>‚û° Even if you <strong>don't know the exact command</strong>, you can <strong>guess</strong> it by its meaning ‚Äî and almost always be right.</p>

<hr />

<p>The <code>Get-Help</code> cmdlet is your main assistant.</p>

<ol>
<li><strong>Get help about help itself:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Help
</code></pre>
</li>
<li><strong>Get basic help about the command for working with processes:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process
</code></pre>
</li>
<li><strong>See examples of using this command:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Examples
</code></pre>
<p>This is an incredibly useful parameter that often provides ready-made solutions for your tasks.</p>
</li>
<li><strong>Get the most detailed information about the command:</strong>
<pre class="line-numbers"><code class="language-powershell">Get-Help Get-Process -Full
</code></pre>
</li>
</ol>

<p>In the next part: pipeline or command chain (PipeLines)</p>