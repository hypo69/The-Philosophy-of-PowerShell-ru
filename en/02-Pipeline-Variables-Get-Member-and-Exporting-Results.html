<h1>PowerShell Philosophy.</h1>
<h2>Part 2: The Pipeline, Variables, Get-Member, *.ps1* Files, and Exporting Results</h2>
<p><strong>❗ Important:</strong>
I am writing about PS7 (PowerShell 7). It is different from PS5 (PowerShell 5). Starting with version 7, PS became cross-platform. Because of this, the behavior of some commands has changed.</p>
<p>In the first part, we established a key principle: PowerShell works with <strong>objects</strong>, not text. This post is dedicated to some important PowerShell tools: we will learn how to pass objects through the <strong>pipeline</strong>, analyze them with <strong><code>Get-Member</code></strong>, save results in <strong>variables</strong>, and automate all of this in <strong>script files (<code>.ps1</code>)</strong> with <strong>exporting</strong> results into convenient formats.</p>
<h3>1. What is the pipeline (<code>|</code>)?</h3>
<p>The pipeline in PowerShell is a mechanism for passing full-fledged .NET objects (not just text) from one command to another, where each subsequent cmdlet receives structured objects with all their properties and methods.</p>
<p>The <code>|</code> (pipe) symbol is the pipeline operator. Its job is to take the result (output) of the command to its left and pass it as input to the command on its right.</p>
<p><code>Command 1 (creates objects)</code> → <code>|</code> → <code>Command 2 (receives and processes objects)</code> → <code>|</code> → <code>Command 3 (receives processed objects)</code> → | ...</p>
<h4>The Classic UNIX Pipeline: A Stream of Text</h4>
<p>In <code>bash</code>, a <strong>stream of bytes</strong> is passed through the pipeline, which is usually interpreted as text.</p>
<pre class="line-numbers"><code class="language-bash"># Find all 'nginx' processes and count them
ps -ef | grep 'nginx' | wc -l
</code></pre>
<p>Here, <code>ps</code> outputs text, <code>grep</code> filters this text, and <code>wc</code> counts the lines. Each utility knows nothing about "processes"; it only works with strings.</p>
<h4>The PowerShell Pipeline: A Stream of Objects</h4>
<p><strong>Example:</strong> Let's get all processes, sort them by CPU usage, and select the 5 most "hungry" ones.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<p><img src="assets/02/1.png" alt="1"></p>
<p>Here, <code>Get-Process</code> creates process <strong>objects</strong>. <code>Sort-Object</code> receives these <strong>objects</strong> and sorts them by the <code>CPU</code> property. <code>Select-Object</code> receives the sorted <strong>objects</strong> and selects the first 5.</p>
<p>You probably noticed words in the command that start with a hyphen (-): -Property, -Descending, -First. These are parameters.
Parameters are settings, switches, and instructions for a cmdlet. They allow you to control <strong>HOW</strong> a command will do its job. Without parameters, a command works in its default mode, but with parameters, you give it specific instructions.</p>
<p>Main types of parameters:</p>
<ul>
<li>
<p>Parameter with a value: requires additional information.</p>
<p><code>-Property CPU</code>: We are telling Sort-Object which property to sort by. CPU is the value of the parameter.</p>
<p><code>-First 5</code>: We are telling Select-Object how many objects to select. 5 is the value of the parameter.</p>
</li>
<li>
<p>Switch parameter (flag): Does not require a value. Its mere presence in the command enables or disables a certain behavior.</p>
<p><code>-Descending</code>: This flag tells Sort-Object to reverse the sort order (from largest to smallest). It doesn't need an additional value—it is an instruction in itself.</p>
</li>
</ul>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<p><img src="assets/02/2.png" alt="1"></p>
<p>This command answers a very simple question:
<strong>"How many processes named <code>svchost.exe</code> are currently running on my system?"</strong></p>
<h4>Step-by-step breakdown</h4>
<h5><strong>Step 1: <code>Get-Process -Name 'svchost'</code></strong></h5>
<p>This part of the command queries the operating system and asks it to find <strong>all</strong> running processes whose executable file name is <code>svchost.exe</code>.
Unlike processes like <code>notepad</code> (of which there are usually one or two), there are always <strong>many</strong> <code>svchost</code> processes in the system. The command will return an <strong>array (collection) of objects</strong>, where each object is a separate, full-fledged <code>svchost</code> process with its own unique ID, memory usage, etc.
PowerShell has found, for example, 90 <code>svchost</code> processes in the system and now holds a collection of 90 objects.</p>
<h5><strong>Step 2: <code>|</code> (Pipeline Operator)</strong></h5>
<p>This symbol takes the collection of 90 <code>svchost</code> objects obtained in the first step and begins to pass them <strong>one by one</strong> to the input of the next command.</p>
<h5><strong>Step 3: <code>Measure-Object</code></strong></h5>
<p>Since we called <code>Measure-Object</code> without parameters (such as <code>-Property</code>, <code>-Sum</code>, etc.), it performs its <strong>default</strong> operation—it simply counts the number of "items" passed to it.
One, two, three ... After all the objects have been counted, <code>Measure-Object</code> creates its <strong>own result object</strong>, which has a <code>Count</code> property equal to the final number.</p>
<p><strong><code>Count: 90</code></strong> — this is the answer to our question. There are 90 <code>svchost</code> processes running.
The other fields are empty because we did not ask <code>Measure-Object</code> to perform more complex calculations.</p>
<h4>Example with <code>svchost</code> and parameters</h4>
<p>Let's change our task. Now we want to not just count the <code>svchost</code> processes, but to find out <strong>how much total RAM (in megabytes) they consume together</strong>.</p>
<p>To do this, we will need parameters:</p>
<ul>
<li><code>-Property WorkingSet64</code>: This instruction tells <code>Measure-Object</code>: "From each <code>svchost</code> object that comes to you, take the numeric value from the <code>WorkingSet64</code> property (this is memory usage in bytes)".</li>
<li><code>-Sum</code>: This flag instruction says: "Add up all these values that you took from the <code>WorkingSet64</code> property".</li>
</ul>
<p>Our new command will look like this:</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
</code></pre>
<p><img src="assets/02/3.png" alt="3"></p>
<ol>
<li><code>Get-Process</code> will find the number of <code>svchost</code> objects.</li>
<li>The pipeline <code>|</code> will pass them to <code>Measure-Object</code>.</li>
<li>But now <code>Measure-Object</code> works differently:
<ul>
<li>It takes the first <code>svchost</code> object, looks at its <code>.WorkingSet64</code> property (for example, <code>25000000</code> bytes) and remembers this number.</li>
<li>It takes the second object, looks at its <code>.WorkingSet64</code> (for example, <code>15000000</code> bytes) and adds it to the previous one.</li>
<li>...and so on for all objects.</li>
</ul>
</li>
<li>As a result, <code>Measure-Object</code> will create a result object, but now it will be different.</li>
</ol>
<ul>
<li><strong><code>Count: 92</code></strong>: The number of objects.</li>
<li><strong><code>Sum: 1661890560</code></strong>: This is the total sum of all <code>WorkingSet64</code> values in bytes.</li>
<li><strong><code>Property: WorkingSet64</code></strong>: This field is now also filled; it informs us which property was used for the calculations.</li>
</ul>
<h3>2. Variables (Regular and the special <code>$_</code>)</h3>
<p>A variable is a named storage in memory that contains some value.</p>
<p>This value can be anything: text, a number, a date, or, most importantly for PowerShell, a whole object or even a collection of objects. A variable name in PowerShell always starts with a dollar sign ($).
Examples: $name, $counter, $processList.</p>
<p>The special variable $_?</p>
<p>$_ is shorthand for "the current object" or "this thing here".
Imagine a conveyor belt in a factory. Different parts (objects) are moving along it.</p>
<p>$_ is the very part that is right in front of you (or in front of the processing robot).</p>
<p>The source (Get-Process) dumps a whole box of parts (all processes) onto the conveyor belt.</p>
<p>The pipeline (|) makes these parts move along the belt one by one.</p>
<p>The handler (Where-Object or ForEach-Object) is a robot that looks at each part.</p>
<p>The $_ variable is the very part that is currently in the robot's "hands".</p>
<p>When the robot is finished with one part, the conveyor belt feeds it the next one, and $_ will now point to it.</p>
<p>Let's calculate how much total memory the <code>svchost</code> processes use and display the result on the monitor.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Execute the command and save its complex result object to the $svchostMemory variable
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. Now we can work with the saved object. Let's get the Sum property from it
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. Display the result on the screen using the new variable
Write-Host "All svchost processes are using $memoryInMB MB of memory."
</code></pre>
<p><img src="assets/02/4.png" alt="3"></p>
<ul>
<li>
<p><code>Write-Host</code> is a specialized cmdlet whose sole purpose is to <strong>show text directly to the user in the console</strong>.</p>
</li>
<li>
<p>A string in double quotes: <code>"..."</code> is a text string that we pass to the <code>Write-Host</code> cmdlet as an argument. Why double quotes and not single quotes?</p>
<p>In PowerShell, there are two types of quotes:</p>
<ul>
<li><strong>Single (<code>'...'</code>):</strong> Create a <strong>literal string</strong>. Everything inside them is treated as plain text, without exception.</li>
<li><strong>Double (<code>"..."</code>):</strong> Create an <strong>expandable (or substitutable) string</strong>. PowerShell "scans" such a string for variables (starting with <code>$</code>) and substitutes their values in their place.</li>
</ul>
</li>
<li>
<p><code>$memoryInMB</code>. This is the variable in which we <strong>in the previous step</strong> of our script put the result of the calculations. When <code>Write-Host</code> receives a string in double quotes, a process called <strong>"String Expansion"</strong> occurs:</p>
<ol>
<li>PowerShell sees the text <code>"All svchost processes are using "</code>.</li>
<li>Then it encounters the construct <code>$memoryInMB</code>. It understands that this is not just text, but a variable.</li>
<li>It looks into memory, finds the value stored in <code>$memoryInMB</code> (for example, <code>1585.52</code>).</li>
<li>It <strong>substitutes this value</strong> directly into the string.</li>
<li>Then it adds the rest of the text: <code>" MB of memory."</code>.</li>
<li>As a result, the already assembled string is passed to <code>Write-Host</code>: <code>"All svchost processes are using 1585.52 MB of memory."</code>.</li>
</ol>
</li>
</ul>
<p>Start Notepad:</p>
<ol>
<li>Find the Notepad process and save it to the $notepadProcess variable</li>
</ol>
<pre class="line-numbers"><code class="language-powershell">$notepadProcess = Get-Process -Name notepad
</code></pre>
<ol start="2">
<li>Access the 'Id' property of this object through the dot and display it</li>
</ol>
<pre class="line-numbers"><code class="language-powershell">Write-Host "The ID of the 'Notepad' process is: $($notepadProcess.Id)"
</code></pre>
<p><img src="assets/02/5.png" alt="5"></p>
<p><strong>❗ Important:</strong>
    Write-Host "breaks" the pipeline. The text output by it cannot be passed further down the pipeline for processing. It is intended for display only.</p>
<h3>3. Get-Member (The Object Inspector)</h3>
<p>We know that objects "flow" through the pipeline. But how do we know what they are made of? What properties do they have and what actions (methods) can be performed on them?</p>
<p>The <strong><code>Get-Member</code></strong> cmdlet (alias: <code>gm</code>) is the main tool for investigation.
Before working with an object, pass it through <code>Get-Member</code> to see all its capabilities.</p>
<p>Let's analyze the objects that <code>Get-Process</code> creates:</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process | Get-Member
</code></pre>
<p><img src="assets/02/6.png" alt="6"></p>
<p><em>Let's break down each part of the Get-Member output.</em></p>
<p><code>TypeName: System.Diagnostics.Process</code> - This is the full, official "type name" of the object from the .NET library. This is its "passport".
This line tells you that all objects returned by Get-Process are objects of type System.Diagnostics.Process.
This guarantees that they will all have the same set of properties and methods.
You can <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">google</a> "System.Diagnostics.Process" to find the official Microsoft documentation with even more detailed information.</p>
<ul>
<li>
<p>Column 1: <code>Name</code></p>
<p>This is a simple, human-readable <strong>name</strong> of a property, method, or other "member" of an object. This is the name you will use in your code to access data or perform actions.</p>
</li>
<li>
<p>Column 2: <code>MemberType</code> (Type of object)</p>
<p>This is the most important column to understand. It classifies <strong>what</strong> each member is. This is its "job title" that tells you <strong>HOW</strong> to use it.</p>
<ul>
<li>
<p><strong><code>Property</code>:</strong> a <strong>characteristic</strong> or <strong>piece of data</strong> stored inside an object. You can "read" its value.</p>
<ul>
<li><em>Examples from the screenshot:</em> <code>BasePriority</code>, <code>HandleCount</code>, <code>ExitCode</code>. This is just data that can be viewed.</li>
</ul>
</li>
<li>
<p><strong><code>Method</code>:</strong> an <strong>ACTION</strong> that can be performed on an object. Methods are always called with parentheses <code>()</code>.</p>
<ul>
<li><em>Examples from the screenshot:</em> <code>Kill</code>, <code>Refresh</code>, <code>WaitForExit</code>. You would write <code>$process.Kill()</code> or <code>$process.Refresh()</code>.</li>
</ul>
</li>
<li>
<p><strong><code>AliasProperty</code>:</strong> a <strong>friendly alias</strong> for another, longer property. PowerShell adds them for convenience and brevity.</p>
<ul>
<li><em>Examples from the screenshot:</em> <code>WS</code> is a short alias for <code>WorkingSet64</code>. <code>Name</code> is for <code>ProcessName</code>. <code>VM</code> is for <code>VirtualMemorySize64</code>.</li>
</ul>
</li>
<li>
<p><strong><code>Event</code>:</strong> a <strong>NOTIFICATION</strong> that something has happened, to which you can "subscribe".</p>
<ul>
<li><em>Example from the screenshot:</em> <code>Exited</code>. Your script can "listen" for this event to perform some action immediately after the process terminates.</li>
</ul>
</li>
<li><strong><code>CodeProperty</code> and <code>NoteProperty</code>:</strong> special types of properties, often added by PowerShell itself for convenience. A <code>CodeProperty</code> calculates its value "on the fly", and a <code>NoteProperty</code> is a simple note property added to an object.</li>
</ul>
</li>
<li>
<p>Column 3: <code>Definition</code></p>
<p>This is the <strong>technical definition</strong> or "signature" of the member. It gives you the exact details for its use. Its content depends on the <code>MemberType</code>:</p>
<ul>
<li>
<p><strong>For <code>AliasProperty</code>:</strong> Shows <strong>what the alias is equal to</strong>. This is incredibly useful!</p>
<ul>
<li><em>Example from the screenshot:</em> <code>WS = WorkingSet64</code>. You can immediately see that <code>WS</code> is just a short notation for <code>WorkingSet64</code>.</li>
</ul>
</li>
<li>
<p><strong>For <code>Property</code>:</strong> Shows the <strong>data type</strong> stored in the property (e.g., <code>int</code> for an integer, <code>string</code> for text, <code>datetime</code> for a date and time), and what you can do with it (<code>{get;}</code> - read only, <code>{get;set;}</code> - read and write).</p>
<ul>
<li><em>Example from the screenshot:</em> <code>int BasePriority {get;}</code>. This is an integer property that can only be read.</li>
</ul>
</li>
<li>
<p><strong>For <code>Method</code>:</strong> Shows what the method returns (e.g., <code>void</code> - nothing, <code>bool</code> - true/false) and what <strong>parameters</strong> (input data) it accepts in parentheses.</p>
<ul>
<li><em>Example from the screenshot:</em> <code>void Kill()</code>. This means that the <code>Kill</code> method returns nothing and can be called without parameters. There is also a second version <code>void Kill(bool entireProcessTree)</code> that accepts a boolean value (true/false).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>In table form</h4>
<table>
<thead>
<tr>
<th>Column</th>
<th>What is it?</th>
<th>Example from screenshot</th>
<th>What for?</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td>The name you use in your code.</td>
<td><code>Kill</code>, <code>WS</code>, <code>Name</code></td>
<td>to access a property or method (<code>$process.WS</code>, <code>$process.Kill()</code>).</td>
</tr>
<tr>
<td><strong>MemberType</strong></td>
<td>The type of member (data, action, etc.).</td>
<td><code>Method</code>, <code>Property</code>, <code>AliasProperty</code></td>
<td><strong>how</strong> to use it (read a value or call with <code>()</code>).</td>
</tr>
<tr>
<td><strong>Definition</strong></td>
<td>Technical details.</td>
<td><code>WS = WorkingSet64</code>, <code>void Kill()</code></td>
<td>what is hidden behind an alias and what parameters a method needs.</td>
</tr>
</tbody>
</table>
<h4>Example: Working with process windows</h4>
<h5>1. The problem:</h5>
<p>"I have opened many Notepad windows. How can I programmatically minimize all but the main one, and then close only the one that has the word 'Untitled' in its title?"</p>
<h5>2. Investigation with <code>Get-Member</code>:</h5>
<p>We need to find properties related to the window and its title.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name notepad | Get-Member
</code></pre>
<p><strong>Analysis of the <code>Get-Member</code> result:</strong></p>
<ul>
<li>Scrolling through the properties, we find <code>MainWindowTitle</code>. The type is <code>string</code>. Great, this is the title of the main window!</li>
<li>In the methods, we see <code>CloseMainWindow()</code>. This is a "softer" way to close a window than <code>Kill()</code>.</li>
<li>Also in the methods, there is <code>WaitForInputIdle()</code>. This sounds interesting; perhaps it will help to wait until the process is ready for interaction.</li>
</ul>
<p><img src="assets/02/7.png" alt="7"></p>
<p><code>Get-Member</code> showed us the <code>MainWindowTitle</code> property, which is the key to solving the problem and allows us to interact with processes based on the state of their windows, and not just by name.</p>
<h5>3. The solution:</h5>
<p>Now we can build logic based on the window title.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Find all Notepad processes
$notepads = Get-Process -Name notepad

# 2. Go through each one and check the title
foreach ($pad in $notepads) {
    # For each process ($pad), check its MainWindowTitle property
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "Found an unsaved Notepad (ID: $($pad.Id)). Closing its window..."
        # $pad.CloseMainWindow() # Uncomment to actually close
        Write-Host "The window '$($pad.MainWindowTitle)' would have been closed." -ForegroundColor Yellow
    } else {
        Write-Host "Skipping Notepad with title: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<p><img src="assets/02/8.png" alt="8"></p>
<p><img src="assets/02/9.png" alt="9"></p>
<hr>
<h4>Example: Find the parent process</h4>
<h5>1. The problem:</h5>
<p>"Sometimes I see a lot of child <code>chrome.exe</code> processes in the system. How can I find out which one is the main, "parent" process that launched them all?"</p>
<h5>2. Investigation with <code>Get-Member</code>:</h5>
<p>We need to find something that links one process to another.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<p><img src="assets/02/10.png" alt="10"></p>
<p><strong>Analysis of the <code>Get-Member</code> result:</strong></p>
<ul>
<li>Carefully looking through the list, we find a property of type <code>CodeProperty</code> named <code>Parent</code>.</li>
<li>Its <code>Definition</code> is <code>System.Diagnostics.Process Parent{get=GetParentProcess;}</code>.
This is a calculated property that, when accessed, returns the <strong>parent process object</strong>.</li>
</ul>
<h5>3. The solution:</h5>
<p>Now we can write a script that, for each <code>chrome</code> process, will display information about its parent.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. Get all chrome processes
$chromeProcesses = Get-Process -Name chrome

# 2. For each of them, display information about it and its parent
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # Get the parent process
    $parent = $_.Parent
    
    # Format a nice output
    Write-Host "Process:" -ForegroundColor Green
    Write-Host "  - Name: $($_.ProcessName), ID: $($_.Id)"
    Write-Host "Its parent:" -ForegroundColor Yellow
    Write-Host "  - Name: $($parent.ProcessName), ID: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<p><img src="assets/02/11.png" alt="11"></p>
<p><img src="assets/02/12.png" alt="12"></p>
<p>We can immediately see that the processes with IDs 4756, 7936, 8268, and 9752 were launched by the process with ID 14908. We can also notice an interesting case with the process ID: 7252, whose parent process was not determined (perhaps the parent had already terminated by the time of the check). Modifying the script with an if ($parent) check neatly handles this case without causing an error.
Get-Member helped us discover the "hidden" Parent property, which provides powerful capabilities for analyzing the process hierarchy.</p>
<h4>4. The *.ps1* file (Creating scripts)</h4>
<p>When your command chain becomes useful, you will want to save it for repeated use. This is what <strong>scripts</strong> are for—text files with the <strong><code>.ps1</code></strong> extension.</p>
<h5>Permission to run scripts</h5>
<p>By default, Windows prohibits the execution of local scripts. To fix this <strong>for the current user</strong>, run the following once in PowerShell <strong>as an administrator</strong>:</p>
<pre class="line-numbers"><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
</code></pre>
<p>This is a safe setting that allows you to run your own scripts and scripts signed by a trusted publisher.</p>
<h5>Example script <code>system_monitor.ps1</code></h5>
<p>Create a file with this name and paste the code below into it. This script collects system information and generates reports.</p>
<pre class="line-numbers"><code class="language-powershell"># system_monitor.ps1
#requires -Version 5.1

&lt;#
.SYNOPSIS
    A script to create a system status report.
.DESCRIPTION
    Collects information about processes, services, and disk space and generates reports.
.PARAMETER OutputPath
    The path to save the reports. Defaults to 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#&gt;
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- Block 1: Preparation ---
Write-Host "Preparing to create the report..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- Block 2: Data collection ---
Write-Host "Collecting information..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- Block 3: Calling the export function (see next section) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "Reports successfully saved to the $OutputPath folder" -ForegroundColor Magenta
</code></pre>
<p><em>Note: The <code>Export-Results</code> function will be defined in the next section as an example of good practice.</em></p>
<h4>5. Exporting results</h4>
<p>Raw data is good, but often it needs to be presented in a form that is convenient for a person or another program. PowerShell offers many cmdlets for exporting.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Plain text</strong></td>
<td><code>... \| Out-File C:\Temp\data.txt</code></td>
<td>Redirects the text representation to a file.</td>
</tr>
<tr>
<td><strong>CSV (for Excel)</strong></td>
<td><code>... \| Export-Csv C:\Temp\data.csv -NoTypeInfo</code></td>
<td>Exports objects to CSV. <code>-NoTypeInfo</code> removes the service first line.</td>
</tr>
<tr>
<td><strong>HTML report</strong></td>
<td><code>... \| ConvertTo-Html -Title "Report"</code></td>
<td>Creates HTML code from objects.</td>
</tr>
<tr>
<td><strong>JSON (for API, web)</strong></td>
<td><code>... \| ConvertTo-Json</code></td>
<td>Converts objects to JSON format.</td>
</tr>
<tr>
<td><strong>XML (PowerShell's native format)</strong></td>
<td><code>... \| Export-Clixml C:\Temp\data.xml</code></td>
<td>Saves objects with all data types. They can be perfectly restored via <code>Import-Clixml</code>.</td>
</tr>
</tbody>
</table>
<h5>Addition to the script: export function</h5>
<p>Let's add a function to our <code>system_monitor.ps1</code> script that will handle exporting. Place this code <strong>before</strong> the <code>Export-Results</code> call.</p>
<pre class="line-numbers"><code class="language-powershell">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # Export to CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # Create a nice HTML report
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Top 10 processes by CPU&lt;/h2&gt;"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "&lt;h2&gt;Service statistics&lt;/h2&gt;"

    ConvertTo-Html -Head "&lt;title&gt;System Report&lt;/title&gt;" -Body "&lt;h1&gt;System report from $(Get-Date)&lt;/h1&gt; $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<p>Now our script not only collects data, but also neatly saves it in two formats: CSV for analysis and HTML for quick viewing.</p>
<h4>Conclusion</h4>
<ol>
<li><strong>The pipeline (<code>|</code>)</strong> is the main tool for combining commands and processing objects.</li>
<li><strong><code>Get-Member</code></strong> is an object analyzer that shows what they are made of.</li>
<li><strong>Variables (<code>$var</code>, <code>$_</code>)</strong> allow you to save data and refer to the current object in the pipeline.</li>
<li><strong><code>.ps1</code> files</strong> turn commands into reusable automation tools.</li>
<li><strong>Export cmdlets</strong> (<code>Export-Csv</code>, <code>ConvertTo-Html</code>) export data in the appropriate format.</li>
</ol>
<p><strong>In the next part, we will apply this knowledge to navigate and manage the file system, exploring the <code>System.IO.DirectoryInfo</code> and <code>System.IO.FileInfo</code> objects.</strong></p>