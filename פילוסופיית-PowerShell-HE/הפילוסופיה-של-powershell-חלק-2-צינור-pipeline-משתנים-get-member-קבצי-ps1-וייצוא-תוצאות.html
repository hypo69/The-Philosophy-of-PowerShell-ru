<h2 dir="rtl">הפילוסופיה של PowerShell.</h2>
<h3 dir="rtl">חלק 2: צינור (Pipeline), משתנים, Get-Member, קבצי ps1. וייצוא תוצאות</h3>
<p><strong>❗ חשוב:</strong>
אני כותב על PS7 (PowerShell 7). הוא שונה מ-PS5 (PowerShell 5). החל מגרסה 7, ps הפך לקרוס-פלטפורמה. בגלל זה, התנהגותן של כמה פקודות השתנתה.</p>
<p>בחלק הראשון, קבענו עיקרון מפתח: PowerShell עובד עם <strong>אובייקטים</strong>, לא עם טקסט.
פוסט זה מוקדש לכמה כלים חשובים של PowerShell:
נלמד כיצד להעביר אובייקטים דרך ה-<strong>pipeline</strong>, לנתח אותם עם <strong>`Get-Member`</strong>,
לשמור את התוצאות ב-<strong>משתנים</strong> ולבצע אוטומציה של כל זה ב-<strong>קבצי סקריפט (`.ps1`)</strong> עם <strong>ייצוא</strong>
של התוצאות לפורמטים נוחים.</p>
<h3 dir="rtl">1. מהו צינור (`|`)?</h3>
<p>הצינור ב-PowerShell הוא מנגנון להעברת אובייקטים מלאים של .NET (ולא רק טקסט) מפקודה אחת
 לאחרת, כאשר כל cmdlet עוקב מקבל אובייקטים מובנים עם כל המאפיינים והשיטות שלהם.</p>
<p>הסמל `|` (קו אנכי) הוא אופרטור הצינור. תפקידו לקחת את התוצאה (פלט) של הפקודה משמאלו ולהעביר אותה לקלט של הפקודה מימינו.</p>
<p>`פקודה 1 (יוצרת אובייקטים)` → `|` → `פקודה 2 (מקבלת ומעבדת אובייקטים)` → `|` → `פקודה 3 (מקבלת אובייקטים מעובדים)` → | ...</p>
<h4 dir="rtl">צינור UNIX קלאסי: זרם טקסט</h4>
<p>ב-`bash`, <strong>זרם של בתים</strong> מועבר דרך הצינور, אשר בדרך כלל מתפרש כטקסט.</p>
<pre class="line-numbers"><code class="language-bash"># מצא את כל תהליכי 'nginx' וספור אותם
ps -ef | grep 'nginx' | wc -l
</code></pre>
<p>כאן `ps` מוציא טקסט, `grep` מסנן את הטקסט הזה, ו-`wc` סופר את השורות. כל כלי עזר לא יודע כלום על "תהליכים", הוא עובד רק עם מחרוזות.</p>
<h4 dir="rtl">צינור PowerShell: זרם אובייקטים</h4>
<p><strong>דוגמה:</strong> בואו נקבל את כל התהליכים, נמיין אותם לפי שימוש במעבד, ונבחר את 5 ה"זללנים" ביותר.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
</code></pre>
<p><img src="assets/02/1.png" alt="1"></p>
<p>כאן `Get-Process` יוצר <strong>אובייקטים</strong> של תהליכים. `Sort-Object` מקבל את ה<strong>אובייקטים</strong> האלה וממיין אותם לפי המאפיין `CPU`. `Select-Object` מקבל את ה<strong>אובייקטים</strong> הממוינים ובוחר את 5 הראשונים.</p>
<p>בטח שמתם לב למילים בפקודה שמתחילות במקף (-): -Property, -Descending, -First. אלו פרמטרים.
פרמטרים הם הגדרות, מתגים והוראות עבור cmdlet. הם מאפשרים לך לשלוט ב<strong>איך</strong> הפקודה תבצע את עבודתה.
ללא פרמטרים, הפקודה פועלת במצב ברירת מחדל, ועם פרמטרים אתה נותן לה הוראות ספציפיות.</p>
<p>סוגי פרמטרים עיקריים:</p>
<ul>
<li>
<p>פרמטר עם ערך: דורש מידע נוסף.</p>
<p>`-Property CPU`: אנחנו אומרים ל-Sort-Object לפי איזה מאפיין למיין. CPU הוא ערך הפרמטר.</p>
<p>`-First 5`: אנחנו אומרים ל-Select-Object כמה אובייקטים לבחור. 5 הוא ערך הפרמטר.</p>
</li>
<li>
<p>פרמטר מתג (דגל): אינו דורש ערך. עצם נוכחותו בפקודה מפעילה או משביתה התנהגות מסוימת.</p>
<p>`-Descending`: דגל זה אומר ל-Sort-Object להפוך את סדר המיון (מהגדול לקטן). הוא אינו זקוק לערך נוסף — הוא הוראה בפני עצמה.</p>
</li>
</ul>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name 'svchost' | Measure-Object
</code></pre>
<p><img src="assets/02/2.png" alt="1"></p>
<p>פקודה זו עונה על שאלה פשוטה מאוד:
<strong>"כמה תהליכים בשם `svchost.exe` פועלים כעת במערכת שלי?"</strong></p>
<h4 dir="rtl">פירוט שלב אחר שלב</h4>
<h5 dir="rtl"><strong>שלב 1: `Get-Process -Name 'svchost'`</strong></h5>
<p>חלק זה של הפקודה ניגש למערכת ההפעלה ומבקש למצוא את <strong>כל</strong> התהליכים הפועלים ששם קובץ ההפעלה שלהם הוא `svchost.exe`.
בניגוד לתהליכים כמו `notepad` (שבדרך כלל יש אחד או שניים מהם), תמיד יש <strong>הרבה</strong> תהליכי `svchost` במערכת. הפקודה תחזיר <strong>מערך (אוסף) של אובייקטים</strong>,
כאשר כל אובייקט הוא תהליך `svchost` נפרד ומלא עם מזהה ייחודי משלו, שימוש בזיכרון וכו'.
PowerShell מצא, למשל, 90 תהליכי `svchost` במערכת ומחזיק כעת אוסף של 90 אובייקטים.</p>
<h5 dir="rtl"><strong>שלב 2: `|` (אופרטור צינור)</strong></h5>
<p>סמל זה לוקח את אוסף 90 אובייקטי `svchost` שהתקבלו בשלב הראשון ומתחיל להעביר אותם <strong>אחד אחד</strong> לקלט של הפקודה הבאה.</p>
<h5 dir="rtl"><strong>שלב 3: `Measure-Object`</strong></h5>
<p>מכיוון שקראנו ל-`Measure-Object` ללא פרמטרים (כגון `-Property`, `-Sum` וכו'), הוא מבצע את פעולת ה<strong>ברירת מחדל</strong> שלו — הוא פשוט סופר את מספר ה"פריטים" שהועברו אליו.
אחד, שניים, שלושה ... לאחר שכל האובייקטים נספרו, `Measure-Object` יוצר <strong>אובייקט תוצאה משלו</strong>, שיש לו מאפיין `Count` השווה למספר הסופי.</p>
<p><strong>`Count: 90`</strong> — זו התשובה לשאלתנו. 90 תהליכי `svchost` פועלים.
שאר השדות ריקים מכיוון שלא ביקשנו מ-`Measure-Object` לבצע חישובים מורכבים יותר.</p>
<h4 dir="rtl">דוגמה עם `svchost` ופרמטרים</h4>
<p>בואו נשנה את המשימה שלנו. עכשיו אנחנו לא רוצים רק לספור את תהליכי `svchost`,
אלא לגלות <strong>כמה זיכרון RAM כולל (במגה-בייט) הם צורכים יחד</strong>.</p>
<p>לשם כך, נצטרך פרמטרים:
*   `-Property WorkingSet64`: הוראה זו אומרת ל-`Measure-Object`: "מכל אובייקט `svchost` שמגיע אליך, קח את הערך המספרי מהמאפיין `WorkingSet64` (זהו שימוש בזיכרון בבתים)".
*   `-Sum`: הוראת דגל זו אומרת: "סכם את כל הערכים האלה שלקחת מהמאפיין `WorkingSet64`".</p>
<p>הפקודה החדשה שלנו תיראה כך:
```powershell
Get-Process -Name 'svchost' | Measure-Object -Property WorkingSet64 -Sum
```
<img src="assets/02/3.png" alt="3"></p>
<ol>
<li>`Get-Process` ימצא את מספר אובייקטי `svchost`.</li>
<li>הצינור `|` יעביר אותם ל-`Measure-Object`.</li>
<li>אבל עכשיו `Measure-Object` עובד בדרך חדשה:
<ul>
<li>הוא לוקח את אובייקט `svchost` הראשון, מסתכל על מאפיין `.WorkingSet64` שלו (לדוגמה, `25000000` בתים) וזוכר את המספר הזה.</li>
<li>הוא לוקח את האובייקט השני, מסתכל על `.WorkingSet64` שלו (לדוגמה, `15000000` בתים) ומוסיף אותו לקודם.</li>
<li>...וכן הלאה עבור כל האובייקטים.</li>
</ul>
</li>
<li>כתוצאה מכך, `Measure-Object` ייצור אובייקט תוצאה, אבל עכשיו הוא יהיה שונה.</li>
</ol>
<ul>
<li><strong>`Count: 92`</strong>: מספר האובייקטים.</li>
<li><strong>`Sum: 1661890560`</strong>: זהו הסכום הכולל של כל ערכי `WorkingSet64` בבתים.</li>
<li><strong>`Property: WorkingSet64`</strong>: שדה זה כעת מלא גם הוא, הוא מודיע לנו באיזה מאפיין נעשה שימוש לחישובים.</li>
</ul>
<h3 dir="rtl">2. משתנים (רגילים ומיוחדים `$_`)</h3>
<p>משתנה הוא אחסון בעל שם בזיכרון המכיל ערך כלשהו.</p>
<p>ערך זה יכול להיות כל דבר: טקסט, מספר, תאריך, או, והכי חשוב עבור PowerShell,
אובייקט שלם או אפילו אוסף של אובייקטים. שם משתנה ב-PowerShell תמיד מתחיל בסימן דולר ($).
דוגמאות: $name, $counter, $processList.</p>
<p>משתנה מיוחד $_?</p>
<p>$_ הוא קיצור של "האובייקט הנוכחי" או "הדבר הזה כאן".
דמיינו מסוע במפעל. חלקים שונים (אובייקטים) נעים עליו.</p>
<p>$_ הוא החלק שנמצא ממש מולך (או מול הרובוט המעבד).</p>
<p>המקור (Get-Process) שופך קופסה שלמה של חלקים (כל התהליכים) על המסוע.</p>
<p>הצינור (|) גורם לחלקים אלה לנוע לאורך הסרט אחד אחד.</p>
<p>המטפל (Where-Object או ForEach-Object) הוא רובוט שמסתכל על כל חלק.</p>
<p>המשתנה $_ הוא החלק שנמצא כעת ב"ידיים" של הרובוט.</p>
<p>כאשר הרובוט מסיים עם חלק אחד, המסוע מזין לו את הבא, ו-$_ יצביע כעת עליו.</p>
<p>בואו נחשב כמה זיכרון כולל משתמשים תהליכי `svchost` ונציג את התוצאה על הצג.
```powershell
# 1. בצע את הפקודה ושמור את אובייקט התוצאה המורכב שלה במשתנה $svchostMemory
$svchostMemory = Get-Process -Name svchost | Measure-Object -Property WorkingSet64 -Sum

# 2. עכשיו אנחנו יכולים לעבוד עם האובייקט השמור. אנחנו מקבלים ממנו את המאפיין Sum
$memoryInMB = $svchostMemory.Sum / 1MB

# 3. הצג את התוצאה על המסך, באמצעות המשתנה החדש
Write-Host "כל תהליכי svchost משתמשים ב-$memoryInMB MB של זיכרון."
```
<img src="assets/02/4.png" alt="3"></p>
<ul>
<li>
<p>`Write-Host` הוא cmdlet מיוחד שתפקידו היחיד הוא <strong>להציג טקסט ישירות למשתמש בקונסולה</strong>.</p>
</li>
<li>
<p>המחרוזת במרכאות כפולות: `"..."` היא מחרוזת הטקסט שאנו מעבירים ל-cmdlet `Write-Host` כארגומנט. למה מרכאות כפולות ולא מרכאות בודדות?</p>
<p>ב-PowerShell, ישנם שני סוגים של מרכאות:</p>
<ul>
<li><strong>בודדות (`'...'`) :</strong> יוצרות <strong>מחרוזת מילולית</strong>. כל מה שבתוכן נתפס כטקסט רגיל, ללא יוצא מן הכלל.</li>
<li><strong>כפולות (`"..."`) :</strong> יוצרות <strong>מחרוזת ניתנת להרחבה (או החלפה)</strong>. PowerShell "סורק" מחרוזת כזו לאיתור משתנים (המתחילים ב-`$`) ומחליף את ערכיהם במקומם.</li>
</ul>
</li>
<li>
<p>`$memoryInMB`. זהו המשתנה שבו שמנו את תוצאת החישובים <strong>בשלב הקודם</strong> של הסקריפט שלנו. כאשר `Write-Host` מקבל מחרוזת במרכאות כפולות,
מתרחש תהליך שנקרא <strong>"הרחבת מחרוזת"</strong>:
1.  PowerShell רואה את הטקסט `"כל תהליכי svchost משתמשים ב- "`.
2.  ואז הוא נתקל במבנה `$memoryInMB`. הוא מבין שזה לא רק טקסט, אלא משתנה.
3.  הוא מסתכל בזיכרון, מוצא את הערך המאוחסן ב-`$memoryInMB` (לדוגמה, `1585.52`).
4.  הוא <strong>מחליף את הערך הזה</strong> ישירות במחרוזת.
5.  ואז הוא מוסיף את שאר הטקסט: `" MB של זיכרון."`.
6.  כתוצאה מכך, המחרוזת שכבר הורכבה מועברת ל-`Write-Host`: `"כל תהליכי svchost משתמשים ב-1585.52 MB של זיכרון."`.</li>
</ul>
<p>הפעל את פנקס הרשימות:
1. מצא את תהליך פנקס הרשימות ושמור אותו במשתנה $notepadProcess
```powershell
$notepadProcess = Get-Process -Name notepad
```</p>
<ol start="2">
<li>אנו ניגשים למאפיין 'Id' של אובייקט זה דרך נקודה ומציגים אותו
```powershell
Write-Host "מזהה התהליך 'פנקס רשימות' הוא: $($notepadProcess.Id)"
```
<img src="assets/02/5.png" alt="5"></li>
</ol>
<p><strong>❗ חשוב:</strong>
    Write-Host "שובר" את הצינור. לא ניתן להעביר את הטקסט שהוא פולט הלאה בצינור לעיבוד. הוא מיועד לתצוגה בלבד.</p>
<h3 dir="rtl">3. Get-Member (מפקח אובייקטים)</h3>
<p>אנו יודעים שאובייקטים "זורמים" דרך הצינור. אבל איך נדע ממה הם מורכבים? אילו מאפיינים יש להם ואילו פעולות (שיטות) ניתן לבצע איתם?</p>
<p>ה-cmdlet **`Get-Member`** (כינוי: `gm`) הוא הכלי העיקרי למחקר.
לפני העבודה עם אובייקט, העבירו אותו דרך `Get-Member` כדי לראות את כל יכולותיו.</p>
<p>בואו ננתח את האובייקטים ש-`Get-Process` יוצר:
```powershell
Get-Process | Get-Member
```
<img src="assets/02/6.png" alt="6"></p>
<p><em>בואו נפרט כל חלק בפלט של Get-Member.</em></p>
<p>`TypeName: System.Diagnostics.Process` - זהו "שם הטיפוס" המלא והרשמי של האובייקט מספריית .NET. זהו ה"דרכון" שלו.
שורה זו אומרת לכם שכל האובייקטים המוחזרים על ידי Get-Process הם אובייקטים מסוג System.Diagnostics.Process.
זה מבטיח שלכולם יהיה אותו סט של מאפיינים ושיטות.
תוכלו <a href="https://www.google.com/search?q=System.Diagnostics.Process+site%3Amicrosoft.com">לחפש בגוגל</a> "System.Diagnostics.Process" כדי למצוא את התיעוד הרשמי של מיקרוסופט עם מידע מפורט עוד יותר.</p>
<ul>
<li>עמודה 1: `Name`</li>
</ul>
<p>זהו <strong>שם</strong> פשוט וקריא לאדם של מאפיין, שיטה או "חבר" אחר של אובייקט. זהו השם שתשתמשו בו בקוד שלכם כדי לגשת לנתונים או לבצע פעולות.</p>
<ul>
<li>עמודה 2: `MemberType` (סוג אובייקט)</li>
</ul>
<p>זוהי העמודה החשובה ביותר להבנה. היא מסווגת <strong>מה</strong> כל אובייקט. זוהי ה"משרה" שלו, שאומרת לכם <strong>כיצד</strong> להשתמש בו.</p>
<ul>
<li>
<p><strong>`Property` (מאפיין):** <strong>מאפיין</strong> או <strong>פיסת נתונים</strong> המאוחסנת בתוך אובייקט. ניתן "לקרוא" את ערכו.
*   <em>דוגמאות בצילום המסך:</em> `BasePriority`, `HandleCount`, `ExitCode`. אלו פשוט נתונים שניתן להציג.</p>
</li>
<li>
<p><strong>`Method` (שיטה):** <strong>פעולה</strong> שניתן לבצע עם אובייקט. שיטות תמיד נקראות עם סוגריים `()`.
*   <em>דוגמאות בצילום המסך:</em> `Kill`, `Refresh`, `WaitForExit`. הייתם כותבים `$process.Kill()` או `$process.Refresh()`.</p>
</li>
<li>
<p><strong>`AliasProperty` (מאפיין כינוי):** <strong>כינוי ידידותי</strong> למאפיין אחר, ארוך יותר. PowerShell מוסיף אותם לנוחות וקיצור.
*   <em>דוגמאות בצילום המסך:</em> `WS` הוא כינוי קצר ל-`WorkingSet64`. `Name` הוא ל-`ProcessName`. `VM` הוא ל-`VirtualMemorySize64`.</p>
</li>
<li>
<p><strong>`Event` (אירוע):** <strong>הודעה</strong> על כך שמשהו קרה, שניתן "להירשם" אליה.
*   <em>דוגמה בצילום המסך:</em> `Exited`. הסקריפט שלכם יכול "להאזין" לאירוע זה כדי לבצע פעולה כלשהי מיד לאחר סיום התהליך.</p>
</li>
<li>
<p><strong>`CodeProperty` ו-`NoteProperty`:** סוגים מיוחדים של מאפיינים, שלעיתים קרובות מתווספים על ידי PowerShell עצמו לנוחות. `CodeProperty` מחשב את ערכו "על הדרך", ו-`NoteProperty` הוא מאפיין הערה פשוט שנוסף לאובייקט.</p>
</li>
<li>
<p>עמודה 3: `Definition` (הגדרה)</p>
</li>
</ul>
<p>זוהי ה<strong>הגדרה הטכנית</strong> או ה"חתימה" של החבר. היא נותנת לכם את הפרטים המדויקים לשימוש בו. תוכנה תלוי ב-`MemberType`:</p>
<ul>
<li>
<p><strong>עבור `AliasProperty`:** מראה <strong>למה שווה הכינוי</strong>. זה שימושי להפליא!
*   <em>דוגמה בצילום המסך:</em> `WS = WorkingSet64`. ניתן לראות מיד ש-`WS` הוא פשוט סימון קצר ל-`WorkingSet64`.</p>
</li>
<li>
<p><strong>עבור `Property`:** מראה את <strong>סוג הנתונים</strong> המאוחסן במאפיין (לדוגמה, `int` למספר שלם, `string` לטקסט, `datetime` לתאריך ושעה), ומה ניתן לעשות איתו (`{get;}` — קריאה בלבד, `{get;set;}` — קריאה ושינוי).
*   <em>דוגמה בצילום המסך:</em> `int BasePriority {get;}`. זהו מאפיין של מספר שלם שניתן לקרוא בלבד.</p>
</li>
<li>
<p><strong>עבור `Method`:** מראה מה השיטה מחזירה (לדוגמה, `void` — כלום, `bool` — אמת/שקר) ואילו <strong>פרמטרים</strong> (נתוני קלט) היא מקבלת בסוגריים.
*   <em>דוגמה בצילום המסך:</em> `void Kill()`. זה אומר שהשיטה `Kill` אינה מחזירה דבר וניתן לקרוא לה ללא פרמטרים. יש גם גרסה שנייה `void Kill(bool entireProcessTree)`, המקבלת ערך בוליאני (אמת/שקר).</p>
</li>
</ul>
<h4 dir="rtl">בצורת טבלה</h4>
<table>
<thead>
<tr>
<th dir="rtl">עמודה</th>
<th dir="rtl">מה זה?</th>
<th dir="rtl">דוגמה מצילום המסך</th>
<th dir="rtl">לשם מה?</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="rtl"><strong>Name</strong></td>
<td dir="rtl">השם שבו אתה משתמש בקוד.</td>
<td dir="rtl">`Kill`, `WS`, `Name`</td>
<td dir="rtl">כדי לגשת למאפיין או שיטה (`$process.WS`, `$process.Kill()`).</td>
</tr>
<tr>
<td dir="rtl"><strong>MemberType</strong></td>
<td dir="rtl">סוג החבר (נתונים, פעולה וכו').</td>
<td dir="rtl">`Method`, `Property`, `AliasProperty`</td>
<td dir="rtl"><strong>כיצד</strong> להשתמש בו (לקרוא ערך או לקרוא עם `()`).</td>
</tr>
<tr>
<td dir="rtl"><strong>Definition</strong></td>
<td dir="rtl">פרטים טכניים.</td>
<td dir="rtl">`WS = WorkingSet64`, `void Kill()`</td>
<td dir="rtl">מה מסתתר מאחורי הכינוי ואילו פרמטרים השיטה צריכה.</td>
</tr>
</tbody>
</table>
<h4 dir="rtl">דוגמה: עבודה עם חלונות תהליכים</h4>
<h5 dir="rtl">1. בעיה:</h5>
<p>"פתחתי הרבה חלונות של פנקס רשימות. כיצד אוכל למזער באופן תכנותי את כולם מלבד הראשי, ואז לסגור רק את זה שיש לו את המילה 'ללא כותרת' בכותרת שלו?"</p>
<h5 dir="rtl">2. מחקר עם `Get-Member`:</h5>
<p>עלינו למצוא מאפיינים הקשורים לחלון ולכותרת שלו.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name notepad | Get-Member
</code></pre>
<p><strong>ניתוח תוצאת `Get-Member`:</strong>
*   בגלילה בין המאפיינים, אנו מוצאים את `MainWindowTitle`. סוג `string`. נהדר, זו כותרת החלון הראשי!
*   בשיטות, אנו רואים את `CloseMainWindow()`. זוהי דרך "רכה" יותר לסגור חלון מאשר `Kill()`.
*   כמו כן, בשיטות יש את `WaitForInputIdle()`. נשמע מעניין, אולי זה יעזור לחכות עד שהתהליך יהיה מוכן לאינטראקציה.</p>
<p><img src="assets/02/7.png" alt="7"></p>
<p>`Get-Member` הראה לנו את המאפיין `MainWindowTitle`, שהוא המפתח לפתרון הבעיה ומאפשר לנו לתקשר עם תהליכים על סמך מצב החלונות שלהם, ולא רק לפי שם.</p>
<h5 dir="rtl">3. פתרון:</h5>
<p>כעת אנו יכולים לבנות לוגיקה המבוססת על כותרת החלון.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. מצא את כל תהליכי פנקס הרשימות
$notepads = Get-Process -Name notepad

# 2. עבור על כל אחד ובדוק את הכותרת
foreach ($pad in $notepads) {
    # עבור כל תהליך ($pad), בדוק את מאפיין MainWindowTitle שלו
    if ($pad.MainWindowTitle -like '*Untitled*') {
        Write-Host "נמצא פנקס רשימות שלא נשמר (מזהה: $($pad.Id)). סוגר את חלונו..."
        # $pad.CloseMainWindow() # בטל את ההערה כדי לסגור בפועל
        Write-Host "החלון '$($pad.MainWindowTitle)' היה נסגר." -ForegroundColor Yellow
    } else {
        Write-Host "מדלג על פנקס רשימות עם כותרת: $($pad.MainWindowTitle)"
    }
}
</code></pre>
<p><img src="assets/02/8.png" alt="8"></p>
<p><img src="assets/02/9.png" alt="9"></p>
<hr>
<h4 dir="rtl">דוגמה: מצא את תהליך האב</h4>
<h5 dir="rtl">1. בעיה:</h5>
<p>"לפעמים אני רואה הרבה תהליכי `chrome.exe` ילדים במערכת. איך אני יודע איזה מהם הוא התהליך הראשי, תהליך ה"אב" שהפעיל את כולם?"</p>
<h5 dir="rtl">2. מחקר עם `Get-Member`:</h5>
<p>עלינו למצוא משהו שמחבר תהליך אחד למשנהו.</p>
<pre class="line-numbers"><code class="language-powershell">Get-Process -Name chrome | Select-Object -First 1 | Get-Member
</code></pre>
<p><img src="assets/02/10.png" alt="10"></p>
<p><strong>ניתוח תוצאת `Get-Member`:</strong>
*   בבחינה מדוקדקת של הרשימה, אנו מוצאים מאפיין מסוג `CodeProperty` בשם `Parent`.
*   הגדרתו (`Definition`) היא `System.Diagnostics.Process Parent{get=GetParentProcess;}`.
זהו מאפיין מחושב שכאשר ניגשים אליו, הוא מחזיר את <strong>אובייקט תהליך האב</strong>.</p>
<h5 dir="rtl">3. פתרון:</h5>
<p>כעת אנו יכולים לכתוב סקריפט שיציג מידע על האב שלו עבור כל תהליך `chrome`.</p>
<pre class="line-numbers"><code class="language-powershell"># 1. קבל את כל תהליכי chrome
$chromeProcesses = Get-Process -Name chrome

# 2. עבור כל אחד מהם, הצג מידע עליו ועל האב שלו
$chromeProcesses | Select-Object -First 5 | ForEach-Object {
    # קבל את תהליך האב
    $parent = $_.Parent
    
    # עצב פלט יפה
    Write-Host "תהליך:" -ForegroundColor Green
    Write-Host "  - שם: $($_.ProcessName), מזהה: $($_.Id)"
    Write-Host "האב שלו:" -ForegroundColor Yellow
    Write-Host "  - שם: $($parent.ProcessName), מזהה: $($parent.Id)"
    Write-Host "-----------------------------"
}
</code></pre>
<p><img src="assets/02/11.png" alt="11"></p>
<p><img src="assets/02/12.png" alt="12"></p>
<p>אנו יכולים לראות מיד שהתהליכים עם המזהים 4756, 7936, 8268 ו-9752 הופעלו על ידי התהליך עם המזהה 14908. ניתן גם להבחין במקרה מעניין עם מזהה התהליך: 7252, שתהליך האב שלו לא זוהה (אולי האב כבר הספיק להסתיים בזמן הבדיקה). שינוי הסקריפט עם הבדיקה `if ($parent)` מטפל במקרה זה בצורה מסודרת מבלי לגרום לשגיאה.
Get-Member עזר לנו לגלות את המאפיין ה"נסתר" Parent, המספק יכולות חזקות לניתוח היררכיית התהליכים.</p>
<h4 dir="rtl">4. קובץ *.ps1* (יצירת סקריפטים)</h4>
<p>כאשר שרשרת הפקודות שלכם הופכת לשימושית, תרצו לשמור אותה לשימוש חוזר. לשם כך נועדו <strong>סקריפטים</strong> — קבצי טקסט עם סיומת <strong>`.ps1`</strong>.</p>
<h5 dir="rtl">הרשאה להרצת סקריפטים</h5>
<p>כברירת מחדל, Windows אוסר על הפעלת סקריפטים מקומיים. כדי לתקן זאת <strong>עבור המשתמש הנוכחי</strong>, הפעילו פעם אחת ב-PowerShell <strong>כמנהל</strong>:
```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
```
זוהי הגדרה בטוחה המאפשרת לכם להריץ סקריפטים משלכם וסקריפטים חתומים על ידי מפרסם מהימן.</p>
<h5 dir="rtl">דוגמה לסקריפט `system_monitor.ps1`</h5>
<p>צרו קובץ בשם זה והדביקו בו את הקוד שלהלן. סקריפט זה אוסף מידע מערכת ומייצר דוחות.</p>
<pre class="line-numbers"><code class="language-powershell"># system_monitor.ps1
#requires -Version 5.1

<#
.SYNOPSIS
    סקריפט ליצירת דוח מצב מערכת.
.DESCRIPTION
    אוסף מידע על תהליכים, שירותים ושטח דיסק ומייצר דוחות.
.PARAMETER OutputPath
    הנתיב לשמירת הדוחות. ברירת המחדל היא 'C:\Temp'.
.EXAMPLE
    .\system_monitor.ps1 -OutputPath "C:\Reports"
#>
param(
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp"
)

# --- בלוק 1: הכנה ---
Write-Host "מתכונן ליצירת דוח..." -ForegroundColor Cyan
if (!(Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# --- בלוק 2: איסוף נתונים ---
Write-Host "אוסף מידע..." -ForegroundColor Green
$processes = Get-Process | Sort-Object CPU -Descending
$services = Get-Service | Group-Object Status | Select-Object Name, Count

# --- בלוק 3: קריאה לפונקציית הייצוא (ראה סעיף הבא) ---
Export-Results -Processes $processes -Services $services -OutputPath $OutputPath

Write-Host "הדוחות נשמרו בהצלחה בתיקייה $OutputPath" -ForegroundColor Magenta
</code></pre>
<p><em>הערה: הפונקציה `Export-Results` תוגדר בסעיף הבא כדוגמה לפרקטיקה טובה.</em></p>
<h4 dir="rtl">5. ייצוא תוצאות</h4>
<p>נתונים גולמיים זה טוב, אבל לעתים קרובות צריך להציג אותם בצורה נוחה לאדם או לתוכנה אחרת. PowerShell מציע הרבה cmdlets לייצוא.</p>
<table>
<thead>
<tr>
<th dir="rtl">שיטה</th>
<th dir="rtl">פקודה</th>
<th dir="rtl">תיאור</th>
</tr>
</thead>
<tbody>
<tr>
<td dir="rtl"><strong>טקסט רגיל</strong></td>
<td dir="rtl">`... \| Out-File C:\Temp\data.txt`</td>
<td dir="rtl">מפנה את ייצוג הטקסט לקובץ.</td>
</tr>
<tr>
<td dir="rtl"><strong>CSV (עבור Excel)</strong></td>
<td dir="rtl">`... \| Export-Csv C:\Temp\data.csv -NoTypeInfo`</td>
<td dir="rtl">מייצא אובייקטים ל-CSV. `-NoTypeInfo` מסיר את שורת השירות הראשונה.</td>
</tr>
<tr>
<td dir="rtl"><strong>דוח HTML</strong></td>
<td dir="rtl">`... \| ConvertTo-Html -Title "דוח"`</td>
<td dir="rtl">יוצר קוד HTML מאובייקטים.</td>
</tr>
<tr>
<td dir="rtl"><strong>JSON (עבור API, אינטרנט)</strong></td>
<td dir="rtl">`... \| ConvertTo-Json`</td>
<td dir="rtl">ממיר אובייקטים לפורמט JSON.</td>
</tr>
<tr>
<td dir="rtl"><strong>XML (פורמט PowerShell מקורי)</strong></td>
<td dir="rtl">`... \| Export-Clixml C:\Temp\data.xml`</td>
<td dir="rtl">שומר אובייקטים עם כל סוגי הנתונים. ניתן לשחזר אותם בצורה מושלמת באמצעות `Import-Clixml`.</td>
</tr>
</tbody>
</table>
<h5 dir="rtl">תוספת לסקריפט: פונקציית ייצוא</h5>
<p>בואו נוסיף פונקציה לסקריפט `system_monitor.ps1` שלנו שתטפל בייצוא. מקם את הקוד הזה <strong>לפני</strong> הקריאה ל-`Export-Results`.</p>
<pre class="line-numbers"><code class="language-powershell">function Export-Results {
    param(
        $Processes,
        $Services,
        $OutputPath
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm"

    # ייצוא ל-CSV
    $Processes | Select-Object -First 20 | Export-Csv (Join-Path $OutputPath "processes_$timestamp.csv") -NoTypeInformation
    $Services | Export-Csv (Join-Path $OutputPath "services_$timestamp.csv") -NoTypeInformation

    # יצירת דוח HTML יפה
    $htmlReportPath = Join-Path $OutputPath "report_$timestamp.html"
    $processesHtml = $Processes | Select-Object -First 10 Name, Id, CPU | ConvertTo-Html -Fragment -PreContent "<h2>10 התהליכים המובילים לפי מעבד</h2>"
    $servicesHtml = $Services | ConvertTo-Html -Fragment -PreContent "<h2>סטטיסטיקות שירות</h2>"

    ConvertTo-Html -Head "<title>דוח מערכת</title>" -Body "<h1>דוח מערכת מתאריך $(Get-Date)</h1> $($processesHtml) $($servicesHtml)" | Out-File $htmlReportPath
}
</code></pre>
<p>כעת הסקריפט שלנו לא רק אוסף נתונים, אלא גם שומר אותם בצורה מסודרת בשני פורמטים: CSV לניתוח ו-HTML לצפייה מהירה.</p>
<h4 dir="rtl">סיכום</h4>
<ol>
<li dir="rtl"><strong>צינור (`|`)</strong> — הכלי העיקרי לשילוב פקודות ועיבוד אובייקטים.</li>
<li dir="rtl"><strong>`Get-Member`</strong> — ניתוח של אובייקטים המראה ממה הם מורכבים.</li>
<li dir="rtl"><strong>משתנים (`$var`, `$_`)</strong> מאפשרים לכם לשמור נתונים ולגשת לאובייקט הנוכחי בצינור.</li>
<li dir="rtl"><strong>קבצי `.ps1`</strong> הופכים פקודות לכלי אוטומציה לשימוש חוזר.</li>
<li dir="rtl"><strong>cmdlets לייצוא</strong> (`Export-Csv`, `ConvertTo-Html`) מייצאים נתונים בפורמט המתאים.</li>
</ol>
<p><strong>בחלק הבא, ניישם את הידע הזה כדי לנווט ולנהל את מערכת הקבצים, ונחקור את האובייקטים `System.IO.DirectoryInfo` ו-`System.IO.FileInfo`.</strong></p>
