# הפילוסופיה של PowerShell.
## חלק 0.
מה היה לפני PowerShell?
בשנת 1981, יצאה MS-DOS 1.0 עם מפרש הפקודות `COMMAND.COM`. לאוטומציה של משימות, נעשה שימוש ב**קבצי אצווה (`.bat`)** — קבצי טקסט פשוטים עם רצף של פקודות קונסולה. זו הייתה סגפנות מפתיעה בשורת הפקודה בהשוואה למערכות תואמות POSIX, שבהן ה-**Bourne shell (`sh`)** היה קיים מאז 1979.

### 📅 מצב שוק המעטפות בזמן יציאת MS-DOS 1.0 (אוגוסט 1981)

הנה טבלת סיכום של מערכות הפעלה פופולריות באותה תקופה ותמיכתן במעטפות (`sh`, `csh` וכו'):

| מערכת הפעלה | תמיכה במעטפות (`sh`, `csh` וכו') | הערה |
|---|---|---|
| **UNIX Version 7 (V7)** | `sh` | ה-UNIX הקלאסי האחרון של מעבדות בל, נפוץ מאוד |
| **UNIX/32V** | `sh`, `csh` | גרסת UNIX לארכיטקטורת VAX |
| **4BSD / 3BSD** | `sh`, `csh` | ענף אוניברסיטאי של UNIX מברקלי |
| **UNIX System III** | `sh` | הגרסה המסחרית הראשונה של AT&T, קודמו של System V |
| **Xenix (של מיקרוסופט)** | `sh` | גרסה מורשית של UNIX, שנמכרה על ידי מיקרוסופט מאז 1980 |
| **IDRIS** | `sh` | מערכת הפעלה דמוית UNIX עבור PDP-11 ואינטל |
| **Coherent (Mark Williams)** | `sh` (דומה) | חלופה זולה ל-UNIX למחשבים אישיים |
| **CP/M (Digital Research)** | ❌ (אין `sh`, רק CLI בסיסי מאוד) | לא UNIX, מערכת ההפעלה הפופולרית ביותר למחשבים אישיים של 8 סיביות |
| **MS-DOS 1.0** | ❌ (רק `COMMAND.COM`) | מעטפת פקודות מינימלית, ללא סקריפטים או צינורות |

---

### 💡 מהם `sh`, `csh`

* `sh` — **Bourne Shell**, מפרש הסקריפטים העיקרי של UNIX מאז 1977.
* `csh` — **C Shell**, מעטפת משופרת עם תחביר דמוי C ונוחות לעבודה אינטראקטיבית.
* מעטפות אלו **תמכו בהפניות, צינורות, משתנים, פונקציות ותנאים** — כל מה שהפך את UNIX לכלי אוטומציה רב עוצמה.

---

מיקרוסופט כיוונה ל**מחשבי IBM PC זולים של 16 סיביות**, שהיה להם **מעט זיכרון** (בדרך כלל 64–256 KB), ללא ריבוי משימות, ונועדו ל**שימוש ביתי ומשרדי**, לא לשרתים. UNIX הייתה יקרה, דרשה ארכיטקטורה מורכבת ומומחיות, בעוד שרואי חשבון ומהנדסים, לא מנהלי מערכות, היו זקוקים למערכת הפעלה מהירה ופשוטה.

במקום ה-`sh` המורכב, ממשק ה-DOS סיפק קובץ יחיד, command.com, עם סט דל של פקודות פנימיות [ (dir, copy, del וכו')](https://www.techgeekbuzz.com/blog/dos-commands/){:target="_blank"} ללא פונקציות, לולאות או מודולים.

היו גם פקודות חיצוניות — קבצי הפעלה נפרדים (.exe או .com). דוגמאות: FORMAT.COM, XCOPY.EXE, CHKDSK.EXE, EDIT.COM.
סקריפטים של ביצוע נכתבו בקובץ טקסט עם סיומת .bat (קובץ אצווה).

דוגמאות לקובצי תצורה:

- AUTOEXEC.BAT

```bash
:: ------------------------------------------------------------------------------
:: AUTOEXEC.BAT — תצורה והפעלה אוטומטית של Windows 3.11
:: מחבר: hypo69
:: שנה: בערך 1993
:: מטרה: מאתחל את סביבת ה-DOS, טוען מנהלי התקנים של רשת ומפעיל את Windows 3.11
:: ------------------------------------------------------------------------------
@ECHO OFF

:: הגדרת שורת הפקודה
PROMPT $p$g

:: הגדרת משתני סביבה
SET TEMP=C:\TEMP
PATH=C:\DOS;C:\WINDOWS

:: טעינת מנהלי התקנים וכלי עזר לזיכרון העליון
LH C:\DOS\SMARTDRV.EXE       :: מטמון דיסק
LH C:\DOS\MOUSE.COM          :: מנהל התקן של עכבר

:: טעינת שירותי רשת (רלוונטי עבור Windows for Workgroups 3.11)
IF EXIST C:\NET\NET.EXE LH C:\NET\NET START

:: הפעלה אוטומטית של Windows
WIN
```
- CONFIG.SYS
```bash
:: ------------------------------------------------------------------------------
:: CONFIG.SYS — תצורת זיכרון ומנהלי התקנים של DOS עבור Windows 3.11
:: מחבר: hypo69
:: שנה: בערך 1993
:: מטרה: מאתחל מנהלי התקנים של זיכרון, מגדיר פרמטרים של המערכת
:: ------------------------------------------------------------------------------
DEVICE=C:\DOS\HIMEM.SYS
DEVICE=C:\DOS\EMM386.EXE NOEMS
DOS=HIGH,UMB
FILES=40
BUFFERS=30
DEVICEHIGH=C:\DOS\SETVER.EXE
```

במקביל ל-DOS, מיקרוסופט החלה כמעט מיד לפתח ליבה חדשה ביסודה.

ליבת [**Windows NT**](https://www.wikiwand.com/ru/articles/Windows_NT){:target="_blank"} (טכנולוגיה חדשה) הופיעה לראשונה עם יציאת מערכת ההפעלה:

> **Windows NT 3.1 — 27 ביולי 1993**

---

* **הפיתוח החל**: בשנת **1988** בהנהגתו של **דייב קאטלר** (מהנדס DEC לשעבר ויוצר VMS) במטרה ליצור מערכת הפעלה חדשה לחלוטין, מאובטחת, ניידת ורב-משימתית, שאינה תואמת ל-MS-DOS ברמת הליבה.
* **NT 3.1** — נקראה כך כדי להדגיש תאימות עם **Windows 3.1** ברמת הממשק, אך זו הייתה **ארכיטקטורה חדשה לחלוטין**.

---

#### 🧠 מה הביאה ליבת ה-NT:

| תכונה | תיאור |
|---|---|
| **ארכיטקטורת 32 סיביות** | בניגוד ל-MS-DOS ו-Windows 3.x, שהיו 16 סיביות. |
| **ריבוי משימות** | ריבוי משימות מקדים אמיתי. |
| **זיכרון מוגן** | תוכניות לא יכלו להשחית זו את הזיכרון של זו. |
| **מודולריות** | ארכיטקטורת ליבה רב-שכבתית: HAL, Executive, Kernel, מנהלי התקנים. |
| **תמיכה בריבוי פלטפורמות** | NT 3.1 רץ על x86, MIPS ו-Alpha. |
| **תאימות POSIX** | NT הגיע עם **תת-מערכת POSIX**, שאושרה ל-POSIX.1. |

---

#### 📜 שושלת ה-NT:

| גרסת NT | שנה | הערה |
|---|---|---|
| NT 3.1 | 1993 | מהדורת NT ראשונה |
| NT 3.5 / 3.51 | 1994–1995 | שיפורים, אופטימיזציה |
| NT 4.0 | 1996 | ממשק Windows 95, אבל ליבת NT |
| Windows 2000 | 2000 | NT 5.0 |
| Windows XP | 2001 | NT 5.1 |
| Windows Vista | 2007 | NT 6.0 |
| Windows 10 | 2015 | NT 10.0 |
| Windows 11 | 2021 | גם NT 10.0 (שיווק 😊) |

---

הבדל ביכולות מערכת ההפעלה:

| מאפיין | **MS-DOS** (1981) | **Windows NT** (1993) |
|---|---|---|
| **סוג מערכת** | מונוליטית, חד-משימתית | מיקרו-ליבה/היברידית, רב-משימתית |
| **סיביות** | 16 סיביות | 32 סיביות (עם תמיכה ב-64 סיביות מאז NT 5.2 / XP x64) |
| **ריבוי משימות** | ❌ נעדר (תהליך אחד בכל פעם) | ✅ ריבוי משימות מקדים |
| **זיכרון מוגן** | ❌ לא | ✅ כן (כל תהליך במרחב הכתובות שלו) |
| **מצב ריבוי משתמשים** | ❌ לא | ✅ חלקית (ב-NT Workstation/Server) |
| **תאימות POSIX** | ❌ לא | ✅ תת-מערכת POSIX מובנית ב-NT 3.1–5.2 |
| **ניידות ליבה** | ❌ x86 בלבד | ✅ x86, MIPS, Alpha, PowerPC |
| **מנהלי התקנים** | גישה ישירה לחומרה | דרך HAL ומנהלי התקנים במצב ליבה |
| **רמת גישה ליישומים** | יישומים = רמת מערכת | רמות משתמש/ליבה מופרדות |
| **אבטחה** | ❌ נעדרת | ✅ מודל אבטחה: SID, ACL, אסימוני גישה |
| **יציבות** | ❌ תלות של תוכנית אחת = קריסת מערכת ההפעלה | ✅ בידוד תהליכים, הגנה על הליבה |

---

אבל היה אבל גדול אחד! כלי אוטומציה וניהול לא קיבלו תשומת לב ראויה עד 2002.

---
 
מיקרוסופט השתמשה בגישות, אסטרטגיות וכלים שונים לחלוטין לניהול. כל זה היה **מפוזר**, לעתים קרובות מוכוון GUI, ולא תמיד ניתן לאוטומציה.

---

##### 📌 רשימה של כמה כלים:

| כלי | מטרה |
|---|---|
| `cmd.exe` | מפרש פקודות משופר (תחליף ל-`COMMAND.COM`) |
| `.bat`, `.cmd` | סקריפטים של שורת הפקודה |
| **Windows Script Host (WSH)** | תמיכה ב-VBScript ו-JScript לאוטומציה |
| `reg.exe` | ניהול הרישום משורת הפקודה |
| `net.exe` | עבודה עם משתמשים, רשת, מדפסות |
| `sc.exe` | ניהול שירותים |
| `tasklist`, `taskkill` | ניהול תהליכים |
| `gpedit.msc` | מדיניות קבוצתית (מקומית) |
| `MMC` | קונסולה עם יישומונים לניהול |
| `WMI` | גישה למידע מערכת (באמצעות `wmic`, VBScript או COM) |
| `WbemTest.exe` | GUI לבדיקת שאילתות WMI |
| `eventvwr` | הצגת יומני אירועים |
| `perfmon` | ניטור משאבים |

##### 🛠 דוגמאות לאוטומציה:

* קבצי VBScript (`*.vbs`) לניהול משתמשים, רשתות, מדפסות ושירותים.
* `WMIC` — ממשק שורת פקודה ל-WMI (לדוגמה: `wmic process list brief`).
* סקריפטים של `.cmd` עם קריאות ל-`net`, `sc`, `reg`, `wmic` וכו'.

---

### ⚙️ Windows Scripting Host (WSH)

* הופיע לראשונה ב-**Windows 98**, היה בשימוש פעיל ב-**Windows 2000 ו-XP**.
* אפשר להריץ קבצי VBScript ו-JScript משורת הפקודה:

  ```vbscript
  Set objShell = WScript.CreateObject("WScript.Shell")
  objShell.Run "notepad.exe"
  ```

---
## חלק 1.

רק בשנת 2002 החברה ניסחה את פרויקט <a href="https://learn.microsoft.com/en-us/powershell/scripting/developer/monad-manifesto?view=powershell-7.5" target="_blank">Monad</a>, שלימים התפתח ל-PowerShell:

תחילת הפיתוח: בערך בשנת 2002

הכרזה פומבית: 2003, בשם "Monad Shell"

גרסאות בטא ראשונות: הופיעו עד 2005

מהדורה סופית (PowerShell 1.0): נובמבר 2006

 המחבר והארכיטקט הראשי של פרויקט Monad / PowerShell הוא ג'פרי סנובר
 <a href="https://www.wikiwand.com/en/articles/Jeffrey_Snover" target="_blank"> (ג'פרי סנובר)</a>
 
כיום PowerShell Core פועל על
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/windows-core.md" target="_blank">Windows</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/macos.md" target="_blank">macOS</a>
<a href="https://github.com/PowerShell/PowerShell/blob/master/docs/building/linux.md" target="_blank">Linux</a>

 
במקביל, פותחה מסגרת ה-.NET, ו-PowerShell שולבה בה לעומק. בפרקים הבאים אציג דוגמאות.

ועכשיו — הדבר החשוב ביותר!

היתרון העיקרי של PowerShell בהשוואה למעטפות פקודה קלאסיות הוא שהוא עובד עם *אובייקטים*, לא עם טקסט. כאשר אתה מבצע פקודה, היא מחזירה לך לא רק טקסט, אלא אובייקט מובנה (או אוסף של אובייקטים) שיש לו מאפיינים ושיטות מוגדרים היטב.

ראו כיצד PowerShell עולה על מעטפות קלאסיות בזכות **עבודה עם אובייקטים**

### 📁 הדרך הישנה: `dir` וניתוח ידני

ב-**CMD** (הן ב-`COMMAND.COM` הישן והן ב-`cmd.exe`), הפקודה `dir` מחזירה את התוצאה כטקסט רגיל. פלט לדוגמה:

```
24.07.2025  21:15         1,428  my_script.js
25.07.2025  08:01         3,980  report.html
```

נניח שברצונך לחלץ את **שם הקובץ** ואת **גודל** כל קובץ. תצטרך לנתח את המחרוזות באופן ידני:
```cmd
for /f "tokens=5,6" %a in ('dir ^| findstr /R "[0-9][0-9].[0-9][0-9].[0-9][0-9][0-9][0-9]"') do @echo %a %b
```

* זה נורא קשה לקריאה, תלוי באזור, בפורמט התאריך ובגופן. וזה נשבר עם רווחים בשמות.

---

### ✅ PowerShell: אובייקטים במקום טקסט

#### ✔ דוגמה פשוטה וקריאה:

```powershell
Get-ChildItem | Select-Object Name, Length
```

**תוצאה:**

```
Name          Length
----          ------
my_script.js   1428
report.html    3980
```

* `Get-ChildItem` מחזירה **מערך של אובייקטים של קבצים/תיקיות**
* `Select-Object` מאפשר לך לקבל בקלות את ה**מאפיינים** הנדרשים

---

### 🔍 מה באמת מחזירה `Get-ChildItem`?

```powershell
$item = Get-ChildItem -Path .\my_script.js
$item | Get-Member
```

**תוצאה:**

```
TypeName: System.IO.FileInfo

Name         MemberType     Definition
----         ---------      ----------
Length       Property       long Length {get;}
Name         Property       string Name {get;}
CreationTime Property       datetime CreationTime {get;set;}
Delete       Method         void Delete()
...
```

PowerShell מחזירה **אובייקטים מסוג `System.IO.FileInfo`**, שיש להם:

* 🧱 מאפיינים (`Name`, `Length`, `CreationTime`, `Extension`, …)
* 🛠 שיטות (`Delete()`, `CopyTo()`, `MoveTo()` וכו')

אתה עובד **עם אובייקטים מלאים**, לא עם מחרוזות.

---

### תחביר "פועל-שם עצם":

PowerShell משתמש ב**תחביר פקודות קפדני והגיוני**:
`פועל-שם עצם` (Verb-Noun)

| פועל | מה הוא עושה |
|---|---|
| `Get-` | קבל |
| `Set-` | הגדר |
| `New-` | צור |
| `Remove-` | הסר |
| `Start-` | התחל |
| `Stop-` | עצור |

| שם עצם | על מה הוא עובד |
|---|---|
| `Process` | תהליך |
| `Service` | שירות |
| `Item` | קובץ/תיקיה |
| `EventLog` | יומני אירועים |
| `Computer` | מחשב |

#### 🔄 דוגמאות:

| מה לעשות | פקודה |
|---|---|
| קבל תהליכים | `Get-Process` |
| עצור שירות | `Stop-Service` |
| צור קובץ חדש | `New-Item` |
| קבל תוכן תיקיה | `Get-ChildItem` |
| הסר קובץ | `Remove-Item` |

➡ גם אם **אינך יודע את הפקודה המדויקת**, אתה יכול **לנחש** אותה לפי המשמעות — וכמעט תמיד תצדק.

---

ה-cmdlet `Get-Help` הוא העוזר העיקרי שלך.

1.  **קבל עזרה על העזרה עצמה:**
    ```powershell
    Get-Help Get-Help
    ```
2.  **קבל עזרה בסיסית על הפקודה לעבודה עם תהליכים:**
    ```powershell
    Get-Help Get-Process
    ```
3.  **ראה דוגמאות לשימוש בפקודה זו:**
    ```powershell
    Get-Help Get-Process -Examples
    ```
    זהו פרמטר שימושי להפליא שלעתים קרובות נותן פתרונות מוכנים למשימות שלך.
4.  **קבל את המידע המפורט ביותר על הפקודה:**
    ```powershell
    Get-Help Get-Process -Full
    ```
בחלק הבא: הצינור או שרשרת הפקודות (PipeLines)
